<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>World Builder</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        /* Phase screens */
        .phase { display: none; height: 100vh; }
        .phase.active { display: flex; }

        /* LOAD PHASE */
        #loadPhase {
            justify-content: center;
            align-items: center;
            background: #000;
        }

        .load-box {
            text-align: center;
            padding: 40px 50px;
            background: #000;
            border: 4px solid #fff;
        }

        .load-box h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 20px;
            color: #fff;
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .load-box p {
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            color: #888;
            margin-bottom: 20px;
        }

        .retro-btn {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            padding: 12px 20px;
            margin: 8px;
            background: #000;
            color: #fff;
            border: 2px solid #fff;
            cursor: pointer;
        }

        .retro-btn:hover {
            background: #fff;
            color: #000;
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }
        .blink { animation: blink 1s step-end infinite; }

        /* COLLISION PHASE */
        #collisionPhase {
            flex-direction: column;
        }

        .collision-header {
            background: #2a2a4e;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #4af;
        }

        .collision-header h2 { color: #4af; }

        .collision-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .collision-sidebar {
            width: 280px;
            background: #2a2a4e;
            padding: 15px;
            overflow-y: auto;
        }

        .collision-main {
            flex: 1;
            overflow: auto;
            padding: 20px;
            background: #111;
        }

        #collisionTilesetCanvas {
            cursor: crosshair;
            image-rendering: pixelated;
            border: 2px solid #555;
        }

        .tool-buttons {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .tool-buttons button.active {
            background: #4af;
            color: #000;
        }

        /* Retro Button Styles */
        .retro-btn {
            min-height: 28px;
            min-width: 32px;
            padding: 4px 8px;
            font-size: 11px;
            font-weight: bold;
            border: 2px solid;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.1s ease;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            box-shadow: 0 3px 0 rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        .retro-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 0 rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        .retro-btn:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        .retro-cyan { background: #3a8; border-color: #2a6; color: #fff; }
        .retro-cyan.active { background: #5fc; border-color: #3da; color: #000; box-shadow: 0 0 12px #5fc, 0 3px 0 rgba(0,0,0,0.3); }
        .retro-purple { background: #86c; border-color: #64a; color: #fff; }
        .retro-purple.active { background: #a8f; border-color: #86c; color: #000; box-shadow: 0 0 12px #a8f, 0 3px 0 rgba(0,0,0,0.3); }
        .retro-orange { background: #d84; border-color: #b62; color: #fff; }
        .retro-orange.active { background: #fa6; border-color: #d84; color: #000; box-shadow: 0 0 12px #fa6, 0 3px 0 rgba(0,0,0,0.3); }
        .retro-pink { background: #c6a; border-color: #a48; color: #fff; }
        .retro-pink.active { background: #f8c; border-color: #c6a; color: #000; box-shadow: 0 0 12px #f8c, 0 3px 0 rgba(0,0,0,0.3); }
        /* Flip - cyan/magenta shift */
        .retro-blue { background: #38a; border-color: #268; color: #fff; }
        .retro-blue.active { background: #f0f; border-color: #c0c; color: #fff; box-shadow: 0 0 20px #f0f, 0 0 40px #f0f, 0 3px 0 rgba(0,0,0,0.3); animation: flipPulse 0.5s infinite alternate; }
        /* Erase - red/yellow danger flash */
        .retro-red { background: #833; border-color: #611; color: #fff; }
        .retro-red.active { background: #f00; border-color: #ff0; color: #ff0; box-shadow: 0 0 20px #f00, 0 0 40px #ff0, 0 3px 0 rgba(0,0,0,0.3); animation: erasePulse 0.3s infinite alternate; }

        @keyframes flipPulse {
            from { background: #f0f; box-shadow: 0 0 15px #f0f, 0 3px 0 rgba(0,0,0,0.3); }
            to { background: #0ff; box-shadow: 0 0 25px #0ff, 0 3px 0 rgba(0,0,0,0.3); }
        }
        @keyframes erasePulse {
            from { background: #f00; border-color: #ff0; }
            to { background: #ff0; border-color: #f00; color: #f00; }
        }

        /* Tileset Picker Styles */
        .tileset-picker {
            position: relative;
            flex: 1;
        }
        .tileset-picker-btn {
            width: 100%;
            padding: 8px 12px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            text-align: left;
        }
        .tileset-picker-btn:hover {
            background: #444;
            border-color: #666;
        }
        .tileset-picker-btn .thumb {
            width: 32px;
            height: 32px;
            border: 1px solid #555;
            border-radius: 3px;
            image-rendering: pixelated;
            background: #222;
            object-fit: cover;
        }
        .tileset-picker-btn .name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .tileset-picker-btn .arrow {
            font-size: 10px;
            color: #888;
        }
        .tileset-picker-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 4px;
            margin-top: 4px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .tileset-picker-dropdown.open {
            display: block;
        }
        .tileset-picker-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #3a3a3a;
        }
        .tileset-picker-item:last-child {
            border-bottom: none;
        }
        .tileset-picker-item:hover {
            background: #3a3a3a;
        }
        .tileset-picker-item.selected {
            background: #2a4a6a;
        }
        .tileset-picker-item .thumb {
            width: 48px;
            height: 48px;
            border: 1px solid #555;
            border-radius: 3px;
            image-rendering: pixelated;
            background: #222;
            object-fit: cover;
        }
        .tileset-picker-item .info {
            flex: 1;
            min-width: 0;
        }
        .tileset-picker-item .name {
            font-weight: bold;
            color: #fff;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .tileset-picker-item .size {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }

        /* BUILD PHASE */
        #buildPhase {
            flex-direction: row;
        }

        .panel {
            background: #1a1a1a;
            padding: 15px;
            overflow-y: scroll;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            border-right: 2px solid #333;
        }

        .left-panel {
            width: 320px;
            min-width: 100px;
            max-width: 600px;
        }

        .map-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .toolbar {
            padding: 8px 12px;
            display: flex;
            gap: 8px;
            align-items: center;
            background: #0a0a0a;
            border-bottom: 2px solid #333;
            flex-wrap: wrap;
        }

        .toolbar-modes {
            display: flex;
            gap: 3px;
        }

        .toolbar-modes button {
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            padding: 14px 12px;
            background: #1a1a1a;
            color: #555;
            border: 1px solid #333;
            border-radius: 0;
            transition: all 0.15s;
        }

        .toolbar-modes button:hover {
            color: #fff;
            border-color: #666;
            background: #222;
        }

        /* Toolbar mode colors */
        #tileMode2:hover, #tileMode2.active { border-color: #4a7; color: #4a7; background: #0a1a0a; }
        #npcMode2:hover, #npcMode2.active { border-color: #f93; color: #f93; background: #1a0f0a; }
        #animPropMode2:hover, #animPropMode2.active { border-color: #a6f; color: #a6f; background: #120a1a; }
        #soundMode2:hover, #soundMode2.active { border-color: #fd0; color: #fd0; background: #1a1a0a; }
        #lightingMode2:hover, #lightingMode2.active { border-color: #0ff; color: #0ff; background: #0a1a1a; }
        #triggerMode2:hover, #triggerMode2.active { border-color: #f55; color: #f55; background: #1a0a0a; }
        #cameraMode2:hover, #cameraMode2.active { border-color: #58f; color: #58f; background: #0a0a1a; }
        #dialogMode2:hover, #dialogMode2.active { border-color: #f6a; color: #f6a; background: #1a0a12; }

        .toolbar-separator {
            width: 1px;
            height: 24px;
            background: #333;
            margin: 0 5px;
        }

        .toolbar-spacer {
            flex: 1;
        }

        .tools-dropdown {
            position: relative;
        }

        .tools-toggle {
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            padding: 14px 12px;
            background: #1a1a1a;
            color: #888;
            border: 1px solid #444;
        }

        .tools-toggle:hover {
            background: #222;
            color: #fff;
        }

        .tools-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #1a1a1a;
            border: 1px solid #444;
            padding: 8px;
            z-index: 1000;
            min-width: 150px;
            margin-top: 4px;
        }

        .tools-menu.open {
            display: block;
        }

        .tools-menu button {
            display: block;
            width: 100%;
            text-align: left;
            margin: 2px 0;
            font-size: 10px;
            padding: 8px 10px;
        }

        .tools-menu-separator {
            height: 1px;
            background: #333;
            margin: 8px 0;
        }

        .tools-menu-zoom {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
            color: #888;
            font-size: 10px;
        }

        .tools-menu-zoom button {
            width: auto;
            padding: 5px 10px;
            margin: 0;
        }

        .coop-status-menu {
            padding: 8px 10px;
            margin-bottom: 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            text-align: center;
            border: 1px solid;
            border-radius: 0;
        }

        .coop-status-menu.connected {
            background: #0a1a0a;
            color: #0f0;
            border-color: #0f0;
        }

        .coop-status-menu.disconnected {
            background: #1a0a0a;
            color: #f55;
            border-color: #f55;
        }

        .tools-menu-theme {
            padding: 5px;
            color: #888;
            font-size: 10px;
        }

        .theme-swatches {
            display: flex;
            gap: 4px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .theme-swatch {
            width: 24px;
            height: 24px;
            border: 2px solid #444;
            padding: 0;
            cursor: pointer;
            transition: all 0.15s;
        }

        .theme-swatch:hover {
            border-color: #fff;
            transform: scale(1.1);
        }

        .theme-swatch.active {
            border-color: #4af;
            box-shadow: 0 0 8px #4af;
        }

        .toolbar-grab {
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            padding: 14px 12px;
            background: #1a1a1a;
            color: #888;
            border: 1px solid #444;
        }

        .toolbar-grab:hover {
            background: #222;
            color: #fff;
            border-color: #666;
        }

        .toolbar-grab.active {
            background: #0a1a2a;
            color: #4af;
            border-color: #4af;
        }

        .spawn-btn {
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            padding: 8px 12px;
            background: #0a1a0a;
            color: #4a4;
            border: 2px solid #4a4;
        }

        .spawn-btn:hover {
            background: #4a4;
            color: #000;
        }

        .spawn-btn.active {
            background: #4a4;
            color: #000;
            animation: spawn-pulse 1s infinite;
        }

        @keyframes spawn-pulse {
            0%, 100% { box-shadow: 0 0 5px #4a4; }
            50% { box-shadow: 0 0 15px #4a4; }
        }

        .test-map-btn {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            padding: 10px 20px;
            background: #1a0a0a;
            color: #f44;
            border: 2px solid #f44;
            animation: pulse-glow 2s infinite;
        }

        .test-map-btn:hover {
            background: #f44;
            color: #000;
            box-shadow: 0 0 20px #f44;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 5px #f44; }
            50% { box-shadow: 0 0 15px #f44; }
        }

        @keyframes glow-blink {
            0%, 100% { opacity: 1; text-shadow: 0 0 10px #0ff, 0 0 20px #0ff; }
            50% { opacity: 0.5; text-shadow: 0 0 5px #0ff; }
        }

        .toolbar-hint {
            color: #444;
            font-size: 9px;
            font-family: monospace;
        }

        .map-viewport {
            flex: 1;
            overflow: scroll;
            -webkit-overflow-scrolling: touch;
            background: #111;
            padding: 40px;
            position: relative;
        }

        #mapCanvas {
            border: 2px solid #555;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        #mapCanvas.grabbing {
            cursor: grab;
        }

        #mapCanvas.grabbing:active {
            cursor: grabbing;
        }

        /* Expand buttons */
        .expand-btn {
            position: absolute;
            background: #4a7c59;
            color: white;
            border: none;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.6;
            z-index: 10;
            padding: 0;
        }

        .expand-btn:hover {
            opacity: 1;
            background: #5a9c69;
        }

        .expand-top {
            top: 10px;
            width: 60px;
            height: 25px;
        }

        .expand-bottom {
            width: 60px;
            height: 25px;
        }

        .expand-left {
            left: 10px;
            width: 25px;
            height: 60px;
        }

        .expand-right {
            width: 25px;
            height: 60px;
        }

        /* Common */
        button {
            background: #222;
            color: #aaa;
            border: 1px solid #444;
            padding: 8px 14px;
            border-radius: 0;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.15s;
        }
        button:hover { background: #333; color: #fff; border-color: #666; }
        button.danger { background: #311; color: #f66; border-color: #a55; }
        button.danger:hover { background: #422; color: #f88; }
        button.primary { background: #124; color: #4af; border-color: #4af; }
        button.primary:hover { background: #236; }

        h2 {
            color: #888;
            font-size: 11px;
            margin: 15px 0 8px;
            font-family: 'Press Start 2P', monospace;
            letter-spacing: 1px;
        }
        h3 {
            color: #666;
            font-size: 10px;
            margin: 10px 0 5px;
        }

        input[type="file"] { display: none; }

        select, input[type="text"] {
            padding: 6px;
            background: #111;
            border: 1px solid #444;
            color: #ccc;
            border-radius: 0;
            font-size: 12px;
        }

        .info {
            color: #666;
            font-size: 10px;
            padding: 10px;
            background: #111;
            border: 1px solid #333;
            border-radius: 0;
            margin: 10px 0;
        }

        .tileset-container {
            background: #000;
            padding: 5px;
            border: 1px solid #333;
            border-radius: 0;
            overflow: scroll;
            -webkit-overflow-scrolling: touch;
            max-height: 300px;
        }

        #paintTilesetCanvas {
            cursor: crosshair;
            image-rendering: pixelated;
            border: 1px solid #444;
        }

        .selected-preview {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            margin: 10px 0;
            min-height: 68px;
            max-height: 68px;
            overflow: hidden;
        }

        .selected-preview canvas {
            border: 2px solid #0f0;
            image-rendering: pixelated;
            max-width: 48px;
            max-height: 48px;
            flex-shrink: 0;
        }

        .mode-tabs {
            display: none; /* Hidden - now in toolbar */
            gap: 4px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .mode-tabs button {
            flex: 1;
            min-width: 70px;
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            padding: 8px 4px;
            background: #000;
            color: #666;
            border: 1px solid #444;
            border-radius: 0;
            transition: all 0.15s;
        }

        .mode-tabs button:hover {
            color: #fff;
            border-color: #888;
        }

        /* Each tab gets its own color theme */
        #tileMode:hover, #tileMode.active { border-color: #4a7; color: #4a7; background: #0a1a0a; }
        #npcMode:hover, #npcMode.active { border-color: #f93; color: #f93; background: #1a0f0a; }
        #animPropMode:hover, #animPropMode.active { border-color: #a6f; color: #a6f; background: #120a1a; }
        #soundMode:hover, #soundMode.active { border-color: #fd0; color: #fd0; background: #1a1a0a; }
        #lightingMode:hover, #lightingMode.active { border-color: #0ff; color: #0ff; background: #0a1a1a; }
        #triggerMode:hover, #triggerMode.active { border-color: #f55; color: #f55; background: #1a0a0a; }
        #cameraMode:hover, #cameraMode.active { border-color: #58f; color: #58f; background: #0a0a1a; }
        #dialogMode:hover, #dialogMode.active { border-color: #f6a; color: #f6a; background: #1a0a12; }

        .prop-item {
            background: #333;
            padding: 8px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 11px;
        }

        .prop-item .name { color: #4af; font-weight: bold; }

        .state-picker {
            position: fixed;
            background: #2a2a4e;
            border: 2px solid #4af;
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            display: none;
        }

        .state-picker.visible { display: block; }

        .state-option {
            padding: 8px 12px;
            margin: 3px 0;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
        }

        .state-option:hover { background: #444; }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .zoom-controls button { padding: 4px 10px; }
        .zoom-controls span { color: #888; font-size: 12px; min-width: 30px; text-align: center; }

        .toolbar span { color: #888; font-size: 11px; }

        /* Animated Prop Editor Modal */
        .anim-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
        }
        .anim-modal.visible { display: flex; }

        .anim-modal-content {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .anim-sidebar {
            width: 280px;
            background: #2a2a4e;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #4af;
        }

        .anim-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1a1a2e;
            overflow: hidden;
            min-width: 0;
        }

        .anim-header {
            padding: 15px 20px;
            background: #2a2a4e;
            border-bottom: 2px solid #4af;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .anim-header h2 { color: #4af; margin: 0; }

        .anim-canvas-area {
            flex: 1;
            overflow: auto;
            padding: 20px;
            display: block;
            min-height: 0;
        }

        .anim-canvas-area canvas {
            border: 2px solid #555;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .anim-frames-bar {
            background: #2a2a4e;
            padding: 15px 20px;
            border-top: 2px solid #4af;
        }

        .anim-frames-list {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            min-height: 50px;
            background: #111;
            padding: 10px;
            border-radius: 5px;
        }

        .anim-frame-thumb {
            border: 2px solid #4af;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .anim-frame-thumb:hover { border-color: #fff; }

        /* Dialog page button styles */
        .dialog-page {
            padding: 8px 12px;
            background: #333;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #aaa;
        }
        .dialog-page:hover { border-color: #888; }
        .dialog-page.active {
            background: #484;
            border-color: #6a6;
            color: #fff;
        }

        .anim-frame-thumb .frame-num {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0,0,0,0.8);
            color: #4af;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 2px;
        }

        /* NPC System Styles */
        .npc-item {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            cursor: pointer;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .npc-item:hover { background: #444; }
        .npc-item.selected { border-color: #4af; background: #3a3a5e; }
        .npc-item .npc-preview {
            width: 32px;
            height: 32px;
            background: #222;
            border-radius: 4px;
            image-rendering: pixelated;
        }
        .npc-item .npc-info { flex: 1; }
        .npc-item .npc-name { color: #4af; font-weight: bold; font-size: 12px; }
        .npc-item .npc-type { color: #888; font-size: 10px; }
        .npc-item .npc-actions { display: flex; gap: 5px; }
        .npc-item .npc-actions button { padding: 3px 8px; font-size: 10px; }

        .npc-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
        }
        .npc-modal.visible { display: flex; justify-content: center; align-items: center; }

        .npc-modal-content {
            background: #2a2a4e;
            border: 2px solid #4af;
            border-radius: 10px;
            padding: 25px;
            width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .npc-modal h2 { color: #4af; margin-bottom: 20px; }
        .npc-modal label { display: block; color: #aaa; font-size: 12px; margin: 10px 0 5px; }
        .npc-modal input[type="text"], .npc-modal textarea, .npc-modal select {
            width: 100%;
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }
        .npc-modal textarea { min-height: 80px; resize: vertical; }

        .npc-sprite-preview {
            background: #111;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }
        .npc-sprite-preview canvas {
            image-rendering: pixelated;
            border: 1px solid #444;
        }

        .npc-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .placed-npc-item {
            background: #2a2a3e;
            padding: 6px 10px;
            border-radius: 4px;
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .placed-npc-item button { padding: 2px 8px; font-size: 10px; background: #a55; }

        /* Hamburger menu and resize handle */
        .mode-tabs-header {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #2a2a3e;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .hamburger-btn {
            background: #444;
            border: none;
            color: #fff;
            font-size: 20px;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
        }
        .hamburger-btn:hover { background: #555; }
        #currentModeLabel {
            font-weight: bold;
            font-size: 14px;
        }
        .mode-tabs.collapsed {
            display: none;
        }
        .resize-handle {
            position: relative;
            width: 24px;
            height: 100%;
            min-height: 200px;
            background: #333;
            border-left: 2px solid #555;
            border-right: 2px solid #555;
            cursor: ew-resize;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .resize-handle::before {
            content: '‹›';
            color: #888;
            font-size: 24px;
            font-weight: bold;
        }
        .resize-handle:hover, .resize-handle.active {
            background: #4af;
            border-color: #4af;
        }
        .resize-handle:hover::before, .resize-handle.active::before {
            color: #000;
        }

        /* Mobile/Touch friendly styles */
        @media (max-width: 1024px), (pointer: coarse) {
            .toolbar button, .tool-buttons button, .zoom-controls button {
                min-height: 44px;
                min-width: 44px;
                font-size: 14px;
                padding: 8px 12px;
            }
            .sidebar { width: 280px; }
            .mode-buttons button { padding: 10px 15px; font-size: 13px; }
            #mapCanvas { touch-action: none; }
            #paintTilesetCanvas { touch-action: manipulation; }
            .tileset-container { touch-action: pan-x pan-y; }
            .map-viewport { touch-action: pan-x pan-y; }
            .panel { touch-action: pan-y; }
            .mode-tabs-header { display: flex; }
            .mode-tabs { display: none; }
            .mode-tabs.expanded { display: flex; }
        }

        /* Test Game Console - visible log panel */
        #testConsole {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 320px;
            max-height: 300px;
            background: rgba(0,0,0,0.95);
            border: 2px solid #4af;
            border-radius: 8px;
            font-family: monospace;
            font-size: 11px;
            z-index: 9999;
            display: none;
            flex-direction: column;
        }
        #testConsole.visible { display: flex; }
        #testConsoleHeader {
            background: #234;
            padding: 8px 12px;
            border-radius: 6px 6px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #4af;
            font-weight: bold;
            font-size: 12px;
        }
        #testConsoleHeader button {
            background: #633;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        #testConsoleHeader button:hover { background: #944; }
        #testConsoleLogs {
            flex: 1;
            max-height: 240px;
            overflow-y: auto;
            padding: 8px;
            color: #0f0;
        }
        #testConsoleLogs div {
            margin: 3px 0;
            padding: 2px 0;
            border-bottom: 1px solid #222;
        }
        #testConsoleLogs .error { color: #f66; }
        #testConsoleLogs .warn { color: #fa0; }
        #testConsoleLogs .info { color: #4af; }
        #testConsoleLogs .stream { color: #8f8; }
        #testConsoleLogs .time { color: #666; margin-right: 6px; }
    </style>
</head>
<body>
    <!-- Cursor Mode Indicator -->
    <div id="cursorIndicator" style="display:none; position:fixed; pointer-events:none; z-index:99999; font-size:18px; text-shadow: 0 0 4px #000, 0 0 2px #000;"></div>

    <!-- Test Game Console (auto-opens on test start) -->
    <div id="testConsole">
        <div id="testConsoleHeader">
            <span>Test Game Console</span>
            <button onclick="document.getElementById('testConsole').classList.remove('visible')">✕</button>
        </div>
        <div id="testConsoleLogs"></div>
    </div>
    <!-- PHASE 1: LOAD -->
    <div id="loadPhase" class="phase active">
        <div class="load-box" id="mainMenu">
            <h1>ADVENTURE<br>CRAFTER</h1>
            <p>- WORLD BUILDER -</p>
            <div style="margin-top:20px;">
                <button class="retro-btn" onclick="document.getElementById('fileInput').click()">
                    > NEW GAME
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="showSaveChoice()">
                    > LOAD SAVE
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="showDirectJoinPrompt()" style="background:#226;">
                    > JOIN ROOM
                </button>
            </div>
            <p class="blink" style="margin-top:20px; font-size:8px; color:#fff;">
                SELECT OPTION
            </p>
        </div>
        <div class="load-box" id="saveChoice" style="display:none;">
            <h1>LOAD<br>SAVE</h1>
            <p>- SELECT SOURCE -</p>
            <div style="margin-top:20px;">
                <button class="retro-btn" onclick="playButtonSound(); document.getElementById('projectFileInputWelcome').click(); document.getElementById('saveChoice').style.display='none'; document.getElementById('mainMenu').style.display='block';">
                    > YOUR SAVE
                </button>
            </div>
            <div style="margin-top:10px;">
                <button class="retro-btn" onclick="playButtonSound(); document.getElementById('saveChoice').style.display='none'; document.getElementById('mainMenu').style.display='block';" style="font-size:10px;">
                    > BACK
                </button>
            </div>
        </div>
        <div class="load-box" id="modeSelect" style="display:none;">
            <h1>WHO ARE<br>YOU?</h1>
            <div style="margin-top:20px;">
                <button class="retro-btn" onclick="playButtonSound(); startBuilder()">
                    > ADVENTURER
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="playButtonSound(); startBuilder()">
                    > CRAFTER
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="playButtonSound(); startBuilder()">
                    > BOTH
                </button>
            </div>
        </div>
        <div class="load-box" id="craftMultiplayerPrompt" style="display:none;">
            <h1>BUILD MODE</h1>
            <p style="font-size:7px; color:#888;">CHOOSE HOW TO BUILD</p>
            <div style="margin-top:20px;">
                <button class="retro-btn" onclick="playActionSound(); startCraftSolo()" style="width:200px;">
                    > SOLO
                </button>
                <p style="font-size:6px; color:#666; margin:5px 0 15px 0;">BUILD ALONE</p>
            </div>
            <div>
                <button class="retro-btn" onclick="showHostPrompt()" style="width:200px;">
                    > HOST ROOM
                </button>
                <p style="font-size:6px; color:#666; margin:5px 0 15px 0;">OTHERS JOIN YOU</p>
            </div>
            <div>
                <button class="retro-btn" onclick="showJoinPrompt()" style="width:200px;">
                    > JOIN ROOM
                </button>
                <p style="font-size:6px; color:#666; margin:5px 0 15px 0;">JOIN SOMEONE ELSE</p>
            </div>
            <div style="margin-top:10px;">
                <button class="retro-btn" onclick="hideCraftMultiplayerPrompt()" style="font-size:8px;">
                    > BACK
                </button>
            </div>
        </div>
        <!-- HOST ROOM PROMPT -->
        <div class="load-box" id="hostRoomPrompt" style="display:none;">
            <h1>HOST ROOM</h1>
            <div style="margin-top:15px;">
                <input type="text" id="hostPlayerName" placeholder="YOUR NAME" maxlength="12"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;">
            </div>
            <div style="margin-top:10px;">
                <input type="text" id="hostRoomCode" placeholder="ROOM CODE" maxlength="12"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;">
            </div>
            <p style="font-size:7px; color:#0ff; margin-top:8px; text-shadow:0 0 10px #0ff, 0 0 20px #0ff; animation:glow-blink 1s ease-in-out infinite;">SHARE THIS CODE WITH FRIENDS</p>
            <div style="margin-top:15px;">
                <button class="retro-btn" onclick="playActionSound(); startCraftHost()">
                    > CREATE
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="hideHostPrompt()" style="font-size:8px;">
                    > BACK
                </button>
            </div>
        </div>
        <!-- JOIN ROOM PROMPT -->
        <div class="load-box" id="joinRoomPrompt" style="display:none;">
            <h1>JOIN ROOM</h1>
            <p style="font-size:7px; color:#888;">LOAD SAME SAVE AS HOST</p>
            <div style="margin-top:15px;">
                <button class="retro-btn" onclick="document.getElementById('joinSaveFileInput').click()" style="font-size:8px; background:#2a7;">
                    > LOAD SAVE FILE
                </button>
                <input type="file" id="joinSaveFileInput" accept=".json" style="display:none;" onchange="handleJoinSaveFile(event)">
                <p id="joinSaveStatus" style="font-size:6px; color:#888; margin-top:5px;">No file loaded</p>
            </div>
            <div style="margin-top:10px;">
                <input type="text" id="joinPlayerName" placeholder="YOUR NAME" maxlength="12"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;">
            </div>
            <div style="margin-top:10px;">
                <input type="text" id="joinRoomCode" placeholder="ROOM CODE" maxlength="12"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;">
            </div>
            <p style="font-size:6px; color:#666; margin-top:5px;">ENTER HOST'S ROOM CODE</p>
            <div style="margin-top:15px;">
                <button class="retro-btn" onclick="playActionSound(); startCraftJoin()">
                    > JOIN
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="hideJoinPrompt()" style="font-size:8px;">
                    > BACK
                </button>
            </div>
        </div>
        <div class="load-box" id="multiplayerPrompt" style="display:none;">
            <h1>MULTIPLAYER</h1>
            <p>- OPTIONAL -</p>
            <div style="margin-top:15px;">
                <input type="text" id="mpPlayerName" placeholder="YOUR NAME" maxlength="12"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;">
            </div>
            <div style="margin-top:10px;">
                <input type="text" id="mpRoomCode" placeholder="ROOM CODE" maxlength="12"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;">
            </div>
            <p style="font-size:6px; color:#666; margin-top:8px;">LEAVE BLANK FOR SOLO</p>
            <div style="margin-top:15px;">
                <button class="retro-btn" onclick="playActionSound(); startAdventure()">
                    > START
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="hideMultiplayerPrompt()" style="font-size:8px;">
                    > BACK
                </button>
            </div>
        </div>
        <input type="file" id="fileInput" accept="image/*" onchange="loadTileset(event)" style="display:none;">
        <input type="file" id="projectFileInputWelcome" accept=".json" style="display:none;" onchange="loadSaveWithModeSelect(event)">
    </div>

    <!-- PHASE 2: COLLISION SETUP -->
    <div id="collisionPhase" class="phase">
        <div class="collision-header">
            <div>
                <h2>Step 1: Define Collision</h2>
                <span style="color:#888; font-size:12px;">Paint collision on tiles with brush</span>
            </div>
            <div>
                <label style="color:#aaa; margin-right:10px;">Tile Size:</label>
                <select id="gridSize" onchange="rebuildCollisionView()">
                    <option value="16" selected>16x16</option>
                    <option value="32">32x32</option>
                </select>
                <button onclick="finishCollisionSetup()" class="primary" style="margin-left:20px; padding:10px 25px;">
                    Done - Start Building →
                </button>
            </div>
        </div>
        <div class="collision-body">
            <div class="collision-sidebar">
                <div class="info">
                    <strong>Simple Tile Collision:</strong><br>
                    Left-click: Add collision<br>
                    Right-click: Remove collision<br>
                    Drag to paint multiple tiles
                </div>

                <h3>Tool</h3>
                <div class="tool-buttons">
                    <button id="collisionToolPaint" class="active" onclick="setCollisionTool('paint')">Add Collision</button>
                    <button id="collisionToolErase" onclick="setCollisionTool('erase')">Remove</button>
                    <button id="collisionToolSplit" onclick="setCollisionTool('split')" style="background:#0aa;">Depth Split</button>
                </div>

                <div id="splitControls" style="display:none; margin:10px 0; padding:10px; background:#1a3a3e; border-radius:5px;">
                    <div style="font-size:11px; color:#0ff; margin-bottom:5px;">Draw split line on tiles (drag to draw)</div>
                    <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                        <label style="font-size:11px; display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="checkbox" id="flatLineToggle" checked onchange="toggleFlatLineMode()">
                            <span>Flat Line</span>
                        </label>
                        <span style="font-size:11px;">Y:</span>
                        <input type="number" id="splitYInput" value="8" min="0" max="16" style="width:50px; padding:3px;">
                        <button onclick="setSplitLineY()" style="padding:3px 8px; font-size:10px; background:#0aa;">Set Y</button>
                        <button onclick="clearSelectedSplit()" style="padding:3px 8px; font-size:10px; background:#a55;">Clear</button>
                    </div>
                    <div style="font-size:10px; color:#888; margin-top:5px;">C = Canopy (top) | T = Trunk (bottom, Y-sorted with player)</div>
                </div>

                <h3>Brush Size (pixels)</h3>
                <div class="tool-buttons">
                    <button id="brush2" onclick="setBrushSize(2)">2</button>
                    <button id="brush4" class="active" onclick="setBrushSize(4)">4</button>
                    <button id="brush8" onclick="setBrushSize(8)">8</button>
                    <button id="brush16" onclick="setBrushSize(16)">16</button>
                </div>

                <h3>Brush Shape</h3>
                <div class="tool-buttons">
                    <button id="brushShapeSquare" class="active" onclick="setBrushShape('square')">■ Square</button>
                    <button id="brushShapeCircle" onclick="setBrushShape('circle')">● Circle</button>
                    <button id="brushShapeRect" onclick="setBrushShape('rect')">▬ Rect</button>
                </div>
                <div id="brushRectControls" style="display:none; margin-top:8px;">
                    <div style="display:flex; gap:10px; align-items:center;">
                        <label style="font-size:10px; color:#aaa;">W: <input type="number" id="brushRectW" value="8" min="1" max="32" style="width:40px;" onchange="updateBrushRect()"></label>
                        <label style="font-size:10px; color:#aaa;">H: <input type="number" id="brushRectH" value="4" min="1" max="32" style="width:40px;" onchange="updateBrushRect()"></label>
                    </div>
                </div>

                <h3>Zoom (Q/E or +/-)</h3>
                <div class="tool-buttons">
                    <button onclick="setCollisionZoom(2)">2x</button>
                    <button onclick="setCollisionZoom(4)">4x</button>
                    <button id="collisionZoom8" class="active" onclick="setCollisionZoom(6)">6x</button>
                    <button onclick="setCollisionZoom(8)">8x</button>
                </div>
                <div style="font-size:10px; color:#666; margin-top:5px;">Middle-click drag or Shift+drag to pan</div>

                <h3>Quick Actions</h3>
                <div class="tool-buttons">
                    <button onclick="selectAllCollision()">All Solid</button>
                    <button onclick="clearAllCollision()" class="danger">Clear All</button>
                </div>

                <h3 style="margin-top:20px;">Stats</h3>
                <div id="collisionStats" style="background:#111; padding:10px; border-radius:5px; font-size:12px; color:#888;">
                    0 tiles with collision
                </div>
            </div>

            <div class="collision-main">
                <canvas id="collisionTilesetCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- PHASE 3: BUILD -->
    <div id="buildPhase" class="phase">
        <div class="panel left-panel" id="leftPanel">
            <div class="mode-tabs-header">
                <button id="menuToggle" class="hamburger-btn" onclick="toggleModeMenu()">☰</button>
                <span id="currentModeLabel">Tools</span>
            </div>
            <div class="mode-tabs" id="modeTabs">
                <button id="tileMode" class="active" onclick="setMode('tile')">Tiles</button>
                <button id="playerMode" onclick="setMode('player')">Player</button>
                <button id="npcMode" onclick="setMode('npc')">NPCs</button>
                <button id="animPropMode" onclick="setMode('animProp')">Animated</button>
                <button id="soundMode" onclick="setMode('sound')">Sounds</button>
                <button id="lightingMode" onclick="setMode('lighting')">Lights</button>
                <button id="triggerMode" onclick="setMode('trigger')">Triggers</button>
                <button id="cameraMode" onclick="setMode('camera')">Camera</button>
                <button id="dialogMode" onclick="setMode('dialog')">Dialogs</button>
                <button id="itemMode" onclick="setMode('item')">Items</button>
            </div>

            <!-- TILE MODE -->
            <div id="tileModeContent">
                <!-- Hide during door animation mode -->
                <div id="tileNormalUI">
                    <h3>Transform</h3>
                    <div class="tool-buttons" style="margin-bottom:8px;">
                        <button id="rot0" class="retro-btn retro-cyan active" onclick="setRotation(0)">0°</button>
                        <button id="rot90" class="retro-btn retro-purple" onclick="setRotation(90)">90°</button>
                        <button id="rot180" class="retro-btn retro-orange" onclick="setRotation(180)">180°</button>
                        <button id="rot270" class="retro-btn retro-pink" onclick="setRotation(270)">270°</button>
                    </div>
                    <div class="tool-buttons" style="gap:8px;">
                        <button id="flipBtn" class="retro-btn retro-blue" onclick="toggleFlipH()" style="flex:1;">Flip H</button>
                        <button id="eraseBtn" class="retro-btn retro-red" onclick="toggleEraseMode()" style="flex:1;">Erase</button>
                    </div>
                </div>

                <h3>Tileset</h3>
                <div style="display:flex; gap:5px; margin-bottom:5px; align-items:center;">
                    <div class="tileset-picker" id="tilesetPicker">
                        <div class="tileset-picker-btn" onclick="toggleTilesetPicker()">
                            <img class="thumb" id="tilesetPickerThumb" src="">
                            <span class="name" id="tilesetPickerName">No tileset</span>
                            <span class="arrow">▼</span>
                        </div>
                        <div class="tileset-picker-dropdown" id="tilesetPickerDropdown"></div>
                    </div>
                    <input type="file" id="addTilesetInput" accept="image/*" onchange="addTileset(event)" style="display:none;">
                    <button onclick="document.getElementById('addTilesetInput').click()" style="padding:5px 10px;" title="Add tileset">+</button>
                    <button onclick="deleteTileset()" style="padding:5px 10px; background:#a55;" title="Delete tileset">×</button>
                </div>
                <!-- Hide during door animation mode -->
                <div id="tileExtraButtons">
                    <div style="display:flex; gap:5px; margin-bottom:5px;">
                        <button id="tileSelectModeBtn" onclick="toggleTileSelectMode()" style="flex:1; background:#555;">Select Tiles</button>
                    </div>
                </div>
                <div class="tileset-container">
                    <canvas id="paintTilesetCanvas"></canvas>
                </div>

                <!-- Hide during door animation mode -->
                <div id="tileCopyCollision">
                    <div style="margin-top:10px;">
                        <button id="copyFromMapBtn" onclick="startCopyFromMap()" style="background:#666;">Copy from Map</button>
                        <span id="copyModeInfo" style="display:none; font-size:11px; color:#4af; margin-left:8px;">Click & drag on map to select area</span>
                    </div>

                    <button onclick="goBackToCollision()" style="margin-top:15px; background:#555;">Edit Tile Collisions</button>
                </div>

                <h3 style="margin-top:15px;">Layers</h3>
                <div id="layerList"></div>
                <!-- Hide during door animation mode -->
                <div id="tileLayerAdd">
                    <button onclick="addLayer()" style="margin-top:5px;">+ Add Layer</button>
                </div>
            </div>

            <!-- PLAYER MODE -->
            <div id="playerModeContent" style="display:none;">
                <h3>Player Characters</h3>

                <div id="playerListContainer">
                    <div id="playerCharacterList" style="margin-bottom:10px;"></div>
                    <button onclick="openPlayerEditor()" style="width:100%;">+ Create Character</button>
                </div>

                <p style="font-size:10px; color:#666; margin-top:10px;">Create player sprite sheets with walk animations. Active character is used in test game.</p>

                <div style="margin-top:15px; padding:10px; background:#1a2a1a; border-radius:5px;">
                    <div style="display:flex; align-items:center; gap:10px;">
                        <canvas id="activePlayerPreview" width="64" height="64" style="border:2px solid #4f8; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                        <div>
                            <div style="font-size:11px; color:#8a8;">Active:</div>
                            <div id="activePlayerName" style="color:#4f8; font-size:13px; font-weight:bold;">Default Sprite</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- NPC MODE -->
            <div id="npcModeContent" style="display:none;">
                <h3>NPCs</h3>

                <div id="npcListContainer">
                    <div id="npcList" style="margin-bottom:10px;"></div>
                    <button onclick="openNpcEditor()" style="width:100%;">+ Create NPC</button>
                </div>

                <p style="font-size:10px; color:#666; margin-top:10px;">Select NPC from list, then click map to place.</p>

                <h3 style="margin-top:15px;">Placed NPCs</h3>
                <div id="placedNpcList" style="max-height:120px; overflow-y:auto; font-size:11px; color:#888;">
                    No NPCs placed
                </div>

                <!-- Path Editor Panel (shown when NPC selected) -->
                <div id="npcPathPanel" style="display:none; margin-top:15px; padding:10px; background:#1a1a2e; border-radius:5px;">
                    <h3 style="margin-top:0;">Path for: <span id="npcPathName">NPC</span></h3>

                    <!-- Collapsible Settings Header -->
                    <div onclick="toggleNpcSettingsPanel()" style="cursor:pointer; background:#252540; border:2px solid #444; border-radius:4px; padding:8px; margin-bottom:8px; display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-size:12px; color:#8af; font-weight:bold;">NPC Settings</span>
                        <span id="npcSettingsToggle" style="font-size:14px; color:#8af;">+</span>
                    </div>

                    <!-- Collapsible Settings Content -->
                    <div id="npcSettingsContent" style="display:none; border:1px solid #333; border-radius:4px; padding:8px; margin-bottom:10px; background:#151525;">
                        <div style="margin-bottom:10px;">
                            <div style="display:flex; gap:5px; margin-bottom:5px;">
                                <button id="npcDrawPathBtn" onclick="toggleNpcPathDrawing()" style="flex:1; background:#4a4;">Draw Path</button>
                                <button id="npcEditPathBtn" onclick="toggleNpcPathEditing()" style="flex:1; background:#47a;">Edit Path</button>
                            </div>
                            <p id="npcPathInfo" style="font-size:10px; color:#666; margin-top:5px;">Click tiles to add waypoints</p>
                        </div>

                        <div style="margin-bottom:10px;">
                            <label style="font-size:11px;">Trigger:</label>
                            <select id="npcTriggerType" onchange="updateNpcTrigger()" style="width:100%; margin-top:3px;">
                                <option value="loop">Loop (always walking)</option>
                                <option value="interact">On Interact (attack)</option>
                                <option value="timeDay">Time: Day only</option>
                                <option value="timeNight">Time: Night only</option>
                            </select>
                        </div>

                        <div style="margin-bottom:8px;">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <label style="font-size:11px;">Walk Speed:</label>
                                <span id="npcSpeedValue" style="font-size:10px; color:#4af;">3</span>
                            </div>
                            <input type="range" id="npcWalkSpeed" min="1" max="10" value="3" onchange="updateNpcSpeed()" style="width:100%;">
                        </div>
                        <div style="margin-bottom:10px;">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <label style="font-size:11px;">Anim Speed:</label>
                                <span id="npcAnimSpeedValue" style="font-size:10px; color:#4af;">8 fps</span>
                            </div>
                            <input type="range" id="npcAnimSpeed" min="1" max="24" value="8" onchange="updateNpcAnimSpeed()" style="width:100%;">
                        </div>

                        <!-- Enemy AI Settings -->
                        <div id="npcEnemySection" style="margin:10px 0; padding:8px; background:#2a1a1a; border:1px solid #a44; border-radius:4px;">
                            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                <input type="checkbox" id="npcIsEnemy" onchange="updateNpcEnemy()">
                                <label for="npcIsEnemy" style="font-size:11px; color:#f88; cursor:pointer;">Enemy AI</label>
                            </div>
                            <div id="npcEnemyOptions" style="display:none;">
                                <!-- Vision Radius -->
                                <div style="margin-bottom:6px;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <label style="font-size:10px; color:#aaa;">Vision Radius:</label>
                                        <span id="npcVisionValue" style="font-size:10px; color:#f88;">5 tiles</span>
                                    </div>
                                    <input type="range" id="npcVisionRadius" min="1" max="15" value="5" onchange="updateNpcEnemy()" style="width:100%;">
                                </div>
                                <!-- Chase Speed -->
                                <div style="margin-bottom:6px;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <label style="font-size:10px; color:#aaa;">Chase Speed:</label>
                                        <span id="npcChaseSpeedValue" style="font-size:10px; color:#f88;">4</span>
                                    </div>
                                    <input type="range" id="npcChaseSpeed" min="1" max="10" value="4" onchange="updateNpcEnemy()" style="width:100%;">
                                </div>
                                <!-- Attack Mode -->
                                <div style="margin-bottom:6px;">
                                    <label style="font-size:10px; color:#aaa;">Attack Mode:</label>
                                    <select id="npcAttackMode" onchange="updateNpcEnemy()" style="width:100%; margin-top:2px; background:#1a1a2e; color:#fff; border:1px solid #555; padding:3px;">
                                        <option value="touch">Touch (contact damage)</option>
                                        <option value="lunge">Lunge (dash attack)</option>
                                    </select>
                                </div>
                                <!-- Damage Amount -->
                                <div style="margin-bottom:6px;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <label style="font-size:10px; color:#aaa;">Damage:</label>
                                        <span id="npcDamageValue" style="font-size:10px; color:#f88;">10</span>
                                    </div>
                                    <input type="range" id="npcDamage" min="5" max="50" value="10" step="5" onchange="updateNpcEnemy()" style="width:100%;">
                                </div>
                                <!-- Damage Cooldown -->
                                <div style="margin-bottom:6px;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <label style="font-size:10px; color:#aaa;">Attack Cooldown:</label>
                                        <span id="npcCooldownValue" style="font-size:10px; color:#f88;">1.0s</span>
                                    </div>
                                    <input type="range" id="npcAttackCooldown" min="0.5" max="3" value="1" step="0.25" onchange="updateNpcEnemy()" style="width:100%;">
                                </div>
                                <!-- Lunge Options (only shown for lunge mode) -->
                                <div id="npcLungeOptions" style="display:none; padding:6px; background:#1a1a2e; border-radius:4px; margin-bottom:6px;">
                                    <div style="margin-bottom:6px;">
                                        <div style="display:flex; justify-content:space-between; align-items:center;">
                                            <label style="font-size:10px; color:#aaa;">Lunge Range:</label>
                                            <span id="npcLungeRangeValue" style="font-size:10px; color:#f88;">2 tiles</span>
                                        </div>
                                        <input type="range" id="npcAttackRange" min="1" max="5" value="2" onchange="updateNpcEnemy()" style="width:100%;">
                                    </div>
                                    <div style="margin-bottom:4px;">
                                        <div style="display:flex; justify-content:space-between; align-items:center;">
                                            <label style="font-size:10px; color:#aaa;">Lunge Speed:</label>
                                            <span id="npcLungeSpeedValue" style="font-size:10px; color:#f88;">8</span>
                                        </div>
                                        <input type="range" id="npcLungeSpeed" min="4" max="16" value="8" onchange="updateNpcEnemy()" style="width:100%;">
                                    </div>
                                </div>
                                <!-- Post-Attack Slowdown -->
                                <div style="padding:6px; background:#2a1a2a; border-radius:4px; margin-bottom:6px;">
                                    <div style="font-size:10px; color:#aaa; margin-bottom:4px;">-- Post-Attack Slowdown --</div>
                                    <div style="margin-bottom:6px;">
                                        <div style="display:flex; justify-content:space-between; align-items:center;">
                                            <label style="font-size:10px; color:#aaa;">Slowdown %:</label>
                                            <span id="npcSlowdownValue" style="font-size:10px; color:#f88;">50%</span>
                                        </div>
                                        <input type="range" id="npcSlowdownPercent" min="0" max="100" value="50" step="10" onchange="updateNpcEnemy()" style="width:100%;">
                                    </div>
                                    <div style="margin-bottom:4px;">
                                        <div style="display:flex; justify-content:space-between; align-items:center;">
                                            <label style="font-size:10px; color:#aaa;">Slowdown Duration:</label>
                                            <span id="npcSlowdownDurationValue" style="font-size:10px; color:#f88;">0.5s</span>
                                        </div>
                                        <input type="range" id="npcSlowdownDuration" min="0" max="2" value="0.5" step="0.25" onchange="updateNpcEnemy()" style="width:100%;">
                                    </div>
                                </div>
                                <div style="font-size:9px; color:#888; margin-top:5px;">
                                    <span id="npcAttackModeDesc">Touch: deals damage on contact. Lunge: dashes at player when in range.</span>
                                </div>
                            </div>
                        </div>

                        <!-- NPC Scale -->
                        <div style="margin-bottom:8px; padding:6px; background:#1a2a1a; border:1px solid #4a4; border-radius:4px;">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <label style="font-size:10px; color:#aaa;">NPC Scale:</label>
                                <span id="npcScaleValue" style="font-size:10px; color:#4f4;">1.0x</span>
                            </div>
                            <input type="range" id="npcScale" min="0.5" max="3" value="1" step="0.1" onchange="updateNpcScale()" style="width:100%;">
                        </div>

                        <div style="display:flex; gap:5px; margin-bottom:8px;">
                            <button id="npcPreviewPathBtn" onclick="toggleNpcPathPreview()" style="flex:1; background:#47a;">Preview</button>
                            <button onclick="clearNpcPath()" style="flex:1; background:#a55;">Clear Path</button>
                        </div>

                        <div id="npcWaypointList" style="margin-top:10px; font-size:10px; color:#888; max-height:150px; overflow-y:auto;">
                            No waypoints
                        </div>
                    </div>

                    <button onclick="deleteSelectedPlacedNpc()" style="width:100%; background:#a33;">Delete NPC</button>
                </div>
            </div>

            <!-- ANIMATED PROPS MODE -->
            <div id="animPropModeContent" style="display:none;">
                <h3>Animated Props</h3>

                <!-- Animated Prop List -->
                <div id="animPropListContainer">
                    <div id="animPropList" style="margin-bottom:10px;"></div>
                    <button onclick="openAnimPropEditor()" style="width:100%;">+ Create Animated Prop</button>
                </div>

                <!-- Scale Slider -->
                <div style="margin-top:10px; padding:8px; background:#1a2a35; border-radius:4px;">
                    <div style="display:flex; align-items:center; justify-content:space-between;">
                        <span style="font-size:11px; color:#aaa;">Scale:</span>
                        <span id="animPropScaleValue" style="font-size:10px; color:#4f4;">1.0x</span>
                    </div>
                    <input type="range" id="animPropScale" min="0.5" max="3" value="1" step="0.25" onchange="updateAnimPropScale()" oninput="updateAnimPropScale()" style="width:100%;">
                </div>

                <p style="font-size:10px; color:#666; margin-top:10px;">Select prop from list, then click map to place. Right-click to remove.</p>

                <h3 style="margin-top:15px;">Layers</h3>
                <div id="animPropLayerList"></div>
                <button onclick="addLayer()" style="margin-top:5px;">+ Add Layer</button>
            </div>

            <!-- SOUND MODE -->
            <div id="soundModeContent" style="display:none;">
                <h3>Sounds</h3>

                <!-- Sound Library -->
                <div style="margin-bottom:15px;">
                    <div style="display:flex; gap:5px; align-items:center; margin-bottom:8px;">
                        <select id="soundSelect" onchange="switchSound()" style="flex:1;"></select>
                        <input type="file" id="soundInput" accept="audio/*" onchange="loadSound(event)" style="display:none;">
                        <button onclick="document.getElementById('soundInput').click()" style="padding:5px 10px;" title="Add Sound">+</button>
                    </div>
                    <div id="soundControls" style="display:none;">
                        <div style="display:flex; gap:5px; margin-bottom:8px;">
                            <button onclick="previewSound()" style="flex:1;">▶ Preview</button>
                            <button onclick="stopPreview()" style="flex:1;">■ Stop</button>
                        </div>
                        <div id="currentSoundInfo" style="font-size:10px; color:#888;"></div>
                    </div>
                    <div id="noSoundMessage" style="color:#888; font-size:11px; padding:10px; text-align:center;">
                        Click + to add sounds
                    </div>
                </div>

                <!-- Attach Mode -->
                <h4 style="margin:15px 0 8px 0; color:#4af;">Attach To:</h4>
                <div style="display:flex; gap:5px; margin-bottom:10px;">
                    <button id="soundAttachTile" class="active" onclick="setSoundAttachMode('tile')" style="flex:1;">Tile Position</button>
                    <button id="soundAttachPlayer" onclick="setSoundAttachMode('player')" style="flex:1;">Player Action</button>
                </div>

                <!-- Tile Mode Options -->
                <div id="tileSoundOptions">
                    <!-- Selection indicator -->
                    <div id="soundEditMode" style="background:#2a4a3a; padding:8px; border-radius:4px; margin-bottom:10px; display:none;">
                        <span style="color:#4f8;">Editing: <span id="editingSoundKey"></span></span>
                        <button onclick="deselectTileSound()" style="float:right; padding:2px 8px; font-size:10px;">Cancel</button>
                    </div>

                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Radius: <span id="soundRadiusVal">3</span> tiles
                        </label>
                        <input type="range" id="soundRadius" min="1" max="50" value="3" oninput="document.getElementById('soundRadiusVal').textContent=this.value" style="width:100%;">
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="soundLoop" checked> Loop continuously
                        </label>
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Volume: <span id="soundVolumeVal">50</span>%
                        </label>
                        <input type="range" id="soundVolume" min="0" max="100" value="50" oninput="document.getElementById('soundVolumeVal').textContent=this.value" style="width:100%;">
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Fade Distance: <span id="soundFadeVal">50</span>%
                        </label>
                        <input type="range" id="soundFade" min="0" max="100" value="50" oninput="document.getElementById('soundFadeVal').textContent=this.value" style="width:100%;">
                        <p style="font-size:9px; color:#555; margin-top:2px;">How much of radius is fade zone (0=abrupt, 100=full fade)</p>
                    </div>

                    <!-- Action buttons -->
                    <div style="display:flex; gap:5px; margin:10px 0;">
                        <button id="soundSaveBtn" onclick="saveSelectedSound()" style="flex:1; padding:8px; background:#4a7c59;">Save Changes</button>
                        <button onclick="deselectTileSound()" style="flex:1; padding:8px; background:#555;">New Sound</button>
                    </div>
                    <p style="font-size:10px; color:#666;">Click map to place new or select existing. Right-click to remove.</p>

                    <h4 style="margin:15px 0 8px 0; color:#4af;">Placed Sounds:</h4>
                    <div id="placedSoundsList" style="max-height:150px; overflow-y:auto; font-size:11px;"></div>
                </div>

                <!-- Player Mode Options -->
                <div id="playerSoundOptions" style="display:none;">
                    <div style="margin-bottom:10px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">Action:</label>
                        <select id="playerActionSelect" onchange="updatePlayerSoundUI()" style="width:100%;">
                            <option value="walk">Walk</option>
                            <option value="attack">Attack</option>
                        </select>
                    </div>
                    <div id="walkSoundSettings">
                        <div style="margin-bottom:8px;">
                            <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                                Step Interval: <span id="walkIntervalVal">200</span>ms
                            </label>
                            <input type="range" id="walkInterval" min="100" max="400" value="200" oninput="document.getElementById('walkIntervalVal').textContent=this.value" style="width:100%;">
                        </div>
                        <div style="margin-bottom:8px;">
                            <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                                Pitch Variation: <span id="walkPitchVal">10</span>%
                            </label>
                            <input type="range" id="walkPitch" min="0" max="30" value="10" oninput="document.getElementById('walkPitchVal').textContent=this.value" style="width:100%;">
                        </div>
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Volume: <span id="playerSoundVolumeVal">50</span>%
                        </label>
                        <input type="range" id="playerSoundVolume" min="0" max="100" value="50" oninput="document.getElementById('playerSoundVolumeVal').textContent=this.value" style="width:100%;">
                    </div>
                    <button onclick="assignPlayerSound()" style="width:100%; margin-top:5px;">Assign Selected Sound</button>

                    <h4 style="margin:15px 0 8px 0; color:#4af;">Current Assignments:</h4>
                    <div id="playerSoundAssignments" style="font-size:11px; color:#aaa;">
                        <div>Walk: <span id="walkSoundName">None</span></div>
                        <div>Attack: <span id="attackSoundName">None</span></div>
                    </div>
                </div>
            </div>

            <!-- LIGHTING MODE -->
            <div id="lightingModeContent" style="display:none;">
                <h3>Lighting</h3>

                <!-- Preview Toggle -->
                <button id="lightingPreviewBtn" onclick="toggleLightingPreview()" style="width:100%; padding:10px; margin-bottom:15px; background:#2a5a8a; font-weight:bold;">
                    👁️ Preview Lighting: OFF
                </button>

                <!-- Global Settings -->
                <div style="margin-bottom:15px; padding:10px; background:#1a2a1a; border-radius:4px;">
                    <h4 style="margin:0 0 10px 0; color:#4af;">Global Settings</h4>
                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="ambientEnabled" onchange="updateLightingSettings()"> Enable Ambient Lighting
                        </label>
                    </div>
                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="blobShadows" checked onchange="updateLightingSettings()"> Blob Shadows (under sprites)
                        </label>
                    </div>
                </div>

                <!-- Time of Day -->
                <div style="margin-bottom:15px; padding:10px; background:#1a1a2a; border-radius:4px;">
                    <h4 style="margin:0 0 10px 0; color:#4af;">Time of Day</h4>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px;">
                        <button id="todDawn" onclick="setTimeOfDay('dawn')" style="padding:8px; background:#4a3520;">🌅 Dawn</button>
                        <button id="todDay" onclick="setTimeOfDay('day')" class="active" style="padding:8px; background:#2a4a2a;">☀️ Day</button>
                        <button id="todDusk" onclick="setTimeOfDay('dusk')" style="padding:8px; background:#4a2520;">🌇 Dusk</button>
                        <button id="todNight" onclick="setTimeOfDay('night')" style="padding:8px; background:#1a1a3a;">🌙 Night</button>
                    </div>
                    <p style="font-size:9px; color:#555; margin-top:8px; text-align:center;">Affects ambient overlay color and darkness</p>
                </div>

                <!-- Player Light -->
                <div style="margin-bottom:15px; padding:10px; background:#2a2a1a; border-radius:4px;">
                    <h4 style="margin:0 0 10px 0; color:#4af;">Player Torch</h4>
                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="playerLight" onchange="updateLightingSettings()"> Player carries light
                        </label>
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Light Radius: <span id="playerLightRadiusVal">4</span> tiles
                        </label>
                        <input type="range" id="playerLightRadius" min="1" max="10" value="4" oninput="document.getElementById('playerLightRadiusVal').textContent=this.value; updateLightingSettings();" style="width:100%;">
                    </div>
                </div>

                <!-- Point Lights -->
                <div style="margin-bottom:15px; padding:10px; background:#2a1a2a; border-radius:4px;">
                    <h4 style="margin:0 0 10px 0; color:#4af;">Point Lights</h4>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Light Radius: <span id="pointLightRadiusVal">3</span> tiles
                        </label>
                        <input type="range" id="pointLightRadius" min="1" max="10" value="3" oninput="document.getElementById('pointLightRadiusVal').textContent=this.value" style="width:100%;">
                    </div>
                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="pointLightFlicker"> Flicker effect
                        </label>
                    </div>
                    <p style="font-size:10px; color:#666;">Click map to place lights. Right-click to remove.</p>

                    <h4 style="margin:15px 0 8px 0; color:#4af;">Placed Lights:</h4>
                    <div id="placedLightsList" style="max-height:150px; overflow-y:auto; font-size:11px;"></div>
                </div>
            </div>

            <!-- TRIGGER MODE -->
            <div id="triggerModeContent" style="display:none;">
                <h3>Map Triggers</h3>

                <!-- Current Map Selector -->
                <div style="background:#1a2a3a; padding:10px; border-radius:4px; margin-bottom:15px;">
                    <label style="font-size:11px; color:#aaa; display:block; margin-bottom:5px;">Current Map:</label>
                    <select id="currentMapSelect" style="width:100%; padding:6px; margin-bottom:8px;" onchange="switchToMap(this.value)">
                        <option value="main">main</option>
                    </select>
                    <div style="display:flex; gap:5px;">
                        <button onclick="promptNewMap()" style="flex:1; padding:6px;">+ New</button>
                        <button onclick="promptRenameMap()" style="flex:1; padding:6px; background:#668;">Rename</button>
                        <button onclick="promptDeleteMap()" style="flex:1; padding:6px; background:#a33;">Delete</button>
                    </div>
                </div>

                <!-- Trigger List -->
                <div style="background:#222; padding:10px; border-radius:4px; margin-bottom:15px;">
                    <h4 style="margin:0 0 8px 0; color:#f4f;">Triggers on this map:</h4>
                    <div id="triggerList" style="max-height:150px; overflow-y:auto; font-size:11px;">
                        <div style="color:#666; text-align:center; padding:10px;">No triggers placed</div>
                    </div>
                </div>

                <!-- Help text -->
                <div style="background:#1a1a2e; padding:12px; border-radius:4px; margin-bottom:15px;">
                    <p style="font-size:12px; color:#aaa; text-align:center; line-height:1.5; margin:0;">
                        <b style="color:#4af;">Click & drag</b> on map to place door<br>
                        <b style="color:#f4f;">Right-click</b> to remove<br>
                        <b style="color:#0f0;">Drag green boxes</b> to move spawns
                    </p>
                </div>
            </div>

            <!-- CAMERA MODE -->
            <div id="cameraModeContent" style="display:none;">
                <h3>Camera Settings</h3>

                <!-- Current Map -->
                <div style="background:#1a2a3a; padding:10px; border-radius:4px; margin-bottom:15px;">
                    <label style="font-size:11px; color:#aaa; display:block; margin-bottom:5px;">Current Map:</label>
                    <select id="cameraMapSelect" style="width:100%; padding:6px;" onchange="switchToMap(this.value)">
                        <option value="main">main</option>
                    </select>
                </div>

                <!-- Explanation -->
                <div style="background:#1a1a2e; padding:12px; border-radius:4px; margin-bottom:15px;">
                    <p style="font-size:12px; color:#ccc; line-height:1.6; margin:0 0 10px 0;">
                        <b>Camera Bounds</b> restrict where the camera can move during gameplay.
                        The camera will stay within the bounds you set, preventing players from seeing outside the play area.
                    </p>
                    <p style="font-size:11px; color:#aaa; line-height:1.5; margin:0;">
                        Each map can have its own camera bounds. If no bounds are set, the camera freely follows the player.
                    </p>
                </div>

                <!-- Camera Bounds Tool -->
                <div style="background:#2a2a2a; padding:12px; border-radius:4px; margin-bottom:15px;">
                    <h4 style="margin:0 0 10px 0; color:#fa0;">Bounds Area</h4>
                    <div id="cameraBoundsInfo" style="font-size:12px; color:#aaa; margin-bottom:10px; padding:8px; background:#1a1a1a; border-radius:4px;">
                        No bounds (camera follows player)
                    </div>
                    <div style="display:flex; gap:8px;">
                        <button id="setCameraBoundsBtn" onclick="toggleCameraBoundsMode()" style="flex:1; padding:8px; background:#484; font-size:13px;">Set Bounds</button>
                        <button onclick="clearCameraBounds()" style="padding:8px 12px; background:#644; font-size:13px;">Clear</button>
                    </div>
                </div>

                <!-- Instructions -->
                <div style="background:#222; padding:12px; border-radius:4px;">
                    <h4 style="margin:0 0 8px 0; color:#888;">How to use:</h4>
                    <ol style="margin:0; padding-left:20px; font-size:11px; color:#aaa; line-height:1.8;">
                        <li>Click <b style="color:#8f8;">Set Bounds</b></li>
                        <li>Drag on the map to select an area</li>
                        <li>Drag again to expand the bounds</li>
                        <li>Click <b style="color:#8f8;">Done</b> when finished</li>
                    </ol>
                </div>
            </div>

            <!-- DIALOG MODE -->
            <div id="dialogModeContent" style="display:none;">
                <h3>Dialog System</h3>

                <!-- Dialog List -->
                <div style="background:#1a2a3a; padding:10px; border-radius:4px; margin-bottom:15px;">
                    <label style="font-size:11px; color:#aaa; display:block; margin-bottom:8px;">Your Dialogs:</label>
                    <div id="dialogList" style="max-height:150px; overflow-y:auto; margin-bottom:10px;">
                        <div style="color:#666; font-size:12px; text-align:center; padding:20px;">No dialogs created yet</div>
                    </div>
                    <button onclick="openDialogEditor(-1)" style="width:100%; padding:8px; background:#484;">+ New Dialog</button>
                </div>

                <!-- Quick Instructions -->
                <div style="background:#222; padding:12px; border-radius:4px; margin-bottom:15px;">
                    <p style="font-size:11px; color:#aaa; line-height:1.6; margin:0;">
                        Create dialogs here, then attach them to <b style="color:#88f;">NPCs</b> or <b style="color:#fa0;">Triggers</b> to use them in your game.
                    </p>
                </div>

                <!-- Click to Place Instructions -->
                <div style="background:#222; padding:12px; border-radius:4px; margin-bottom:15px;">
                    <p style="font-size:11px; color:#aaa; line-height:1.6; margin:0;">
                        <b style="color:#8f8;">1.</b> Click a dialog above to select it<br>
                        <b style="color:#8f8;">2.</b> Click on <b style="color:#88f;">NPC</b> to attach dialog<br>
                        <b style="color:#8f8;">3.</b> Or click <b style="color:#fa0;">tile</b> to place a sign<br>
                        <b style="color:#f88;">Right-click</b> to remove/detach
                    </p>
                </div>

                <!-- NPC Dialog Trigger Type -->
                <div style="background:#1a1a2e; padding:10px; border-radius:4px; margin-bottom:15px;">
                    <label style="font-size:10px; color:#888;">NPC Dialog Trigger:</label>
                    <select id="dialogNpcTrigger" style="width:100%; padding:6px; margin-top:4px;">
                        <option value="interact">Press A to talk</option>
                        <option value="auto">Auto (walk near)</option>
                    </select>
                </div>

                <!-- Placed Dialog Tiles List -->
                <div style="background:#2a1a1a; padding:10px; border-radius:4px;">
                    <h4 style="margin:0 0 8px 0; font-size:11px; color:#fa0;">Placed Signs</h4>
                    <div id="placedDialogTilesList" style="max-height:100px; overflow-y:auto;">
                        <div style="color:#666; font-size:11px; text-align:center; padding:10px;">No dialog tiles placed</div>
                    </div>
                </div>
            </div>

            <!-- ITEMS MODE -->
            <div id="itemModeContent" style="display:none;">
                <h3>Items</h3>

                <!-- Item List -->
                <div id="itemListContainer">
                    <div id="itemList" style="margin-bottom:10px;"></div>
                    <button onclick="openItemEditor()" style="width:100%;">+ Create Item</button>
                </div>

                <p style="font-size:10px; color:#666; margin-top:10px;">Select item from list, then click map to place. Right-click to remove.</p>
                <p style="font-size:10px; color:#4af; margin-top:5px;">Items idle until player presses A to interact.</p>

                <!-- Placed Items List -->
                <div style="background:#1a2a1a; padding:10px; border-radius:4px; margin-top:15px;">
                    <h4 style="margin:0 0 8px 0; font-size:11px; color:#4f8;">Placed Items</h4>
                    <div id="placedItemsList" style="max-height:150px; overflow-y:auto;">
                        <div style="color:#666; font-size:11px; text-align:center; padding:10px;">No items placed</div>
                    </div>
                </div>

                <h3 style="margin-top:15px;">Layers</h3>
                <div id="itemLayerList"></div>
                <button onclick="addLayer()" style="margin-top:5px;">+ Add Layer</button>
            </div>
        </div>

        <div class="resize-handle" id="sidebarResize"></div>

        <div class="map-panel">
            <div class="toolbar" id="mainToolbar">
                <!-- Mode Tabs in Toolbar -->
                <div class="toolbar-modes">
                    <button id="tileMode2" class="toolbar-mode active" onclick="setMode('tile')">Tiles</button>
                    <button id="playerMode2" onclick="setMode('player')">Player</button>
                    <button id="npcMode2" onclick="setMode('npc')">NPCs</button>
                    <button id="animPropMode2" onclick="setMode('animProp')">Anim</button>
                    <button id="soundMode2" onclick="setMode('sound')">Sound</button>
                    <button id="lightingMode2" onclick="setMode('lighting')">Light</button>
                    <button id="triggerMode2" onclick="setMode('trigger')">Trig</button>
                    <button id="cameraMode2" onclick="setMode('camera')">Cam</button>
                    <button id="dialogMode2" onclick="setMode('dialog')">Dialog</button>
                    <button id="itemMode2" onclick="setMode('item')">Items</button>
                </div>

                <div class="toolbar-separator"></div>

                <!-- Tools Dropdown -->
                <div class="tools-dropdown">
                    <button class="tools-toggle" onclick="toggleToolsMenu()">⚙ Tools ▼</button>
                    <div class="tools-menu" id="toolsMenu">
                        <div id="coopStatusInMenu" class="coop-status-menu" style="display:none;"></div>
                        <button onclick="clearMap()">Clear Map</button>
                        <button onclick="downloadProject()">Save</button>
                        <button onclick="document.getElementById('projectFileInput').click()">Load</button>
                        <button onclick="exportConfig()">Export</button>
                        <button onclick="showStorageInfo()">Storage</button>
                        <button onclick="showRoomInfo()">Room Info</button>
                        <div class="tools-menu-separator"></div>
                        <div class="tools-menu-zoom">
                            <span>Zoom:</span>
                            <button onclick="zoomOut()">-</button>
                            <span id="zoomLevel">2x</span>
                            <button onclick="zoomIn()">+</button>
                        </div>
                        <div class="tools-menu-separator"></div>
                        <div class="tools-menu-theme">
                            <span>UI Theme:</span>
                            <div class="theme-swatches">
                                <button class="theme-swatch" style="background:#1a1a1a;" onclick="setUITheme('#1a1a1a')" title="Dark Grey"></button>
                                <button class="theme-swatch" style="background:#0a0a0a;" onclick="setUITheme('#0a0a0a')" title="Black"></button>
                                <button class="theme-swatch" style="background:#1a1a2e;" onclick="setUITheme('#1a1a2e')" title="Purple"></button>
                                <button class="theme-swatch" style="background:#1a2a1a;" onclick="setUITheme('#1a2a1a')" title="Green"></button>
                                <button class="theme-swatch" style="background:#2a1a1a;" onclick="setUITheme('#2a1a1a')" title="Red"></button>
                                <button class="theme-swatch" style="background:#1a2a2a;" onclick="setUITheme('#1a2a2a')" title="Cyan"></button>
                                <button class="theme-swatch" style="background:#2a2a1a;" onclick="setUITheme('#2a2a1a')" title="Yellow"></button>
                                <button class="theme-swatch" style="background:#2a1a2a;" onclick="setUITheme('#2a1a2a')" title="Magenta"></button>
                            </div>
                            <input type="color" id="customThemeColor" value="#1a1a1a" onchange="setUITheme(this.value)" title="Custom color" style="width:100%;height:24px;margin-top:5px;cursor:pointer;border:1px solid #444;">
                        </div>
                    </div>
                </div>
                <input type="file" id="projectFileInput" accept=".json" style="display:none;" onchange="uploadProject(event)">

                <button id="grabToolBtn" onclick="toggleGrabTool()" class="toolbar-grab">Grab</button>

                <div class="toolbar-spacer"></div>

                <!-- Spawn Point Button -->
                <button id="setSpawnBtn" onclick="toggleSetSpawnMode()" class="spawn-btn">SPAWN</button>

                <!-- Test Map - Special Button -->
                <button onclick="testMap()" class="test-map-btn">▶ PLAY</button>

                <span id="toolHint" class="toolbar-hint">R:rotate | I:flip | E:erase</span>
            </div>
            <!-- Door Animation Panel (in toolbar area) -->
            <div id="doorAnimPanel" style="display:none; background:#1a1a2e; padding:12px 20px; border-bottom:2px solid #f90;">
                <div id="doorAnimSelectMode" style="display:none;">
                    <span style="color:#f90; font-weight:bold; margin-right:15px;">DOOR ANIM: Select tiles to swap</span>
                    <span style="color:#aaa; margin-right:15px;">Click tiles that change when door opens</span>
                    <button onclick="finishTileSelection()" style="background:#4a4; padding:8px 20px; font-weight:bold;">DONE - Paint Replacements</button>
                </div>
                <div id="doorAnimPaintMode" style="display:none;">
                    <span style="color:#4af; font-weight:bold; margin-right:15px;">DOOR ANIM: Paint replacement tiles</span>
                    <span style="color:#aaa; margin-right:15px;">Use palette to paint (or leave empty to remove)</span>
                    <button onclick="finishAnimPainting()" style="background:#4a4; padding:8px 20px; font-weight:bold;">DONE - Save Animation</button>
                </div>
            </div>
            <div class="map-viewport" id="mapViewport">
                <!-- Expand buttons -->
                <button class="expand-btn expand-top" onclick="expandMap('top')" title="Expand up">+</button>
                <button class="expand-btn expand-bottom" onclick="expandMap('bottom')" title="Expand down">+</button>
                <button class="expand-btn expand-left" onclick="expandMap('left')" title="Expand left">+</button>
                <button class="expand-btn expand-right" onclick="expandMap('right')" title="Expand right">+</button>
                <canvas id="mapCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- State picker popup -->
    <div class="state-picker" id="statePicker">
        <h3 style="margin-bottom:10px;">Select State</h3>
        <div id="stateOptions"></div>
    </div>

    <!-- NPC Editor Modal -->
    <div class="anim-modal" id="npcModal">
        <div class="anim-modal-content">
            <!-- Sidebar -->
            <div class="anim-sidebar">
                <h2 style="margin-top:0;">NPC</h2>

                <!-- Step 1: Load Sprite Sheet -->
                <div style="margin-bottom:15px;">
                    <h3>1. Sprite Sheet</h3>
                    <input type="file" id="npcFileInput" accept="image/*" onchange="npcLoadSheet(event)" style="display:none;">
                    <button onclick="document.getElementById('npcFileInput').click()" style="width:100%;">Load Image</button>
                    <div id="npcFileName" style="font-size:11px; color:#4af; margin-top:5px;"></div>
                </div>

                <!-- Step 2: Frame Size -->
                <div id="npcFrameSection" style="margin-bottom:15px; display:none;">
                    <h3>2. Frame Size</h3>
                    <div style="display:flex; gap:5px; flex-wrap:wrap; margin-bottom:8px;">
                        <button onclick="npcSetFrameSize(16,16)" style="padding:4px 8px; font-size:11px;">16x16</button>
                        <button onclick="npcSetFrameSize(16,32)" style="padding:4px 8px; font-size:11px;">16x32</button>
                        <button onclick="npcSetFrameSize(32,32)" style="padding:4px 8px; font-size:11px;">32x32</button>
                        <button onclick="npcSetFrameSize(32,64)" style="padding:4px 8px; font-size:11px;">32x64</button>
                        <button onclick="npcSetFrameSize(48,48)" style="padding:4px 8px; font-size:11px;">48x48</button>
                        <button onclick="npcResetGrid()" style="padding:4px 8px; font-size:11px; background:#a55;">Reset</button>
                    </div>
                    <div style="font-size:11px; color:#888;" id="npcGridInfo"></div>
                </div>

                <!-- Step 3: Animation Selection -->
                <div id="npcAnimSection" style="margin-bottom:15px; display:none;">
                    <h3>3. Select Animation</h3>
                    <div id="npcAnimButtons" style="display:flex; flex-direction:column; gap:5px;">
                        <div style="display:flex; gap:4px;">
                            <button id="npcAnimDown" onclick="npcSelectAnim('walkDown')" class="active" style="flex:1; padding:6px; font-size:11px;">↓ Walk</button>
                            <button id="npcAnimUp" onclick="npcSelectAnim('walkUp')" style="flex:1; padding:6px; font-size:11px;">↑ Walk</button>
                            <button id="npcAnimLeft" onclick="npcSelectAnim('walkLeft')" style="flex:1; padding:6px; font-size:11px;">← Walk</button>
                            <button id="npcAnimRight" onclick="npcSelectAnim('walkRight')" style="flex:1; padding:6px; font-size:11px;">→ Walk</button>
                        </div>
                        <button id="npcAnimIdle" onclick="npcSelectAnim('idle')" style="padding:6px; font-size:11px;">Idle</button>
                        <div style="border-top:1px solid #555; margin:5px 0; padding-top:5px;">
                            <div style="font-size:10px; color:#f88; margin-bottom:5px;">-- Attack Animations (Enemy NPCs) --</div>
                            <div style="display:flex; gap:4px;">
                                <button id="npcAnimAttackDown" onclick="npcSelectAnim('attackDown')" style="flex:1; padding:6px; font-size:11px; background:#744;">↓ Atk</button>
                                <button id="npcAnimAttackUp" onclick="npcSelectAnim('attackUp')" style="flex:1; padding:6px; font-size:11px; background:#744;">↑ Atk</button>
                                <button id="npcAnimAttackLeft" onclick="npcSelectAnim('attackLeft')" style="flex:1; padding:6px; font-size:11px; background:#744;">← Atk</button>
                                <button id="npcAnimAttackRight" onclick="npcSelectAnim('attackRight')" style="flex:1; padding:6px; font-size:11px; background:#744;">→ Atk</button>
                            </div>
                        </div>
                    </div>
                    <!-- Custom animations list -->
                    <div id="npcCustomAnimList" style="margin-top:8px;"></div>
                    <!-- Add custom animation -->
                    <div style="display:flex; gap:5px; margin-top:8px;">
                        <input type="text" id="npcCustomAnimName" placeholder="e.g. swing, dance" style="flex:1; padding:4px; font-size:11px;">
                        <button onclick="npcAddCustomAnim()" style="padding:4px 8px; font-size:11px; background:#4a4;">+ Add</button>
                    </div>
                    <p style="font-size:10px; color:#666; margin-top:8px;">Select animation type, then click frames on sprite sheet</p>
                </div>

                <!-- Step 4: Name -->
                <div id="npcNameSection" style="margin-bottom:15px; display:none;">
                    <h3>4. Name</h3>
                    <input type="text" id="npcNameInput" placeholder="e.g. villager, guard" style="width:100%;">
                </div>

                <!-- Step 5: Collision & Depth -->
                <div id="npcCollisionSection" style="margin-bottom:15px; display:none;">
                    <h3>5. Collision & Depth</h3>
                    <div style="display:flex; gap:5px; flex-wrap:wrap; margin-bottom:10px;">
                        <button id="npcToolNone" class="active" onclick="setNpcTool('none')" style="padding:5px 8px; font-size:11px;">Select</button>
                        <button id="npcToolCollision" onclick="setNpcTool('collision')" style="padding:5px 8px; font-size:11px; background:#a55;">Collision</button>
                        <button id="npcToolErase" onclick="setNpcTool('erase')" style="padding:5px 8px; font-size:11px;">Erase</button>
                        <button id="npcToolSplit" onclick="setNpcTool('split')" style="padding:5px 8px; font-size:11px; background:#0aa;">Split</button>
                    </div>
                    <!-- Brush Controls for Collision -->
                    <div id="npcBrushSection" style="display:none; margin-bottom:10px; background:#1a1a2a; padding:8px; border-radius:4px;">
                        <div style="display:flex; gap:3px; margin-bottom:6px;">
                            <button id="npcShapeSquare" class="active" onclick="setNpcBrushShape('square')" style="padding:3px 6px; font-size:9px;" title="Square">◼</button>
                            <button id="npcShapeCircle" onclick="setNpcBrushShape('circle')" style="padding:3px 6px; font-size:9px;" title="Circle">●</button>
                            <button id="npcShapeRect" onclick="setNpcBrushShape('rect')" style="padding:3px 6px; font-size:9px;" title="Rectangle">▬</button>
                        </div>
                        <div style="margin-bottom:4px;">
                            <label style="font-size:9px; color:#888;">Size: <span id="npcBrushSizeVal">4</span>px</label>
                            <input type="range" id="npcBrushSizeSlider" min="1" max="32" value="4" oninput="setNpcBrushSize(this.value)" style="width:100%;">
                        </div>
                        <div id="npcRectControls" style="display:none;">
                            <div style="display:flex; gap:8px;">
                                <div style="flex:1;">
                                    <label style="font-size:8px; color:#888;">W: <span id="npcBrushRectWVal">8</span></label>
                                    <input type="range" id="npcBrushRectWSlider" min="2" max="32" value="8" oninput="setNpcBrushRectW(this.value)" style="width:100%;">
                                </div>
                                <div style="flex:1;">
                                    <label style="font-size:8px; color:#888;">H: <span id="npcBrushRectHVal">4</span></label>
                                    <input type="range" id="npcBrushRectHSlider" min="2" max="32" value="4" oninput="setNpcBrushRectH(this.value)" style="width:100%;">
                                </div>
                            </div>
                        </div>
                    </div>
                    <p style="font-size:9px; color:#555;">Draw collision on sprite. Split line = depth sorting.</p>
                </div>

                <!-- Actions -->
                <div style="margin-top:auto;">
                    <button onclick="npcSave()" style="width:100%; background:#4af; color:#000; margin-bottom:10px;">Save NPC</button>
                    <button onclick="npcCancel()" style="width:100%; background:#a55;">Cancel</button>
                </div>
            </div>

            <!-- Main Area -->
            <div class="anim-main">
                <div class="anim-header">
                    <h2>Sprite Sheet</h2>
                    <span style="color:#888; font-size:12px;">Click frames to add to current animation</span>
                    <div style="display:flex; align-items:center; gap:5px; margin-left:auto;">
                        <span style="color:#888; font-size:11px;">Zoom:</span>
                        <button onclick="npcZoomOut()" style="padding:2px 8px; font-size:14px;">-</button>
                        <span id="npcZoomLevel" style="color:#4af; font-size:11px; min-width:35px; text-align:center;">3x</span>
                        <button onclick="npcZoomIn()" style="padding:2px 8px; font-size:14px;">+</button>
                    </div>
                </div>

                <div class="anim-canvas-area">
                    <canvas id="npcEditorCanvas"></canvas>
                </div>

                <!-- Bottom Bar: Animation Frames -->
                <div class="anim-frames-bar">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span><strong id="npcCurrentAnimName" style="color:#4af;">Walk Down</strong>: <span id="npcFrameCount">0</span> frames</span>
                        <div style="display:flex; align-items:center; gap:15px;">
                            <!-- Live Preview (larger) -->
                            <div style="display:flex; align-items:center; gap:10px;">
                                <canvas id="npcLivePreview" width="96" height="96" style="border:2px solid #4af; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                                <div style="font-size:11px;">
                                    <div style="display:flex; align-items:center; gap:5px;">
                                        <span style="color:#888;">Speed:</span>
                                        <input type="range" id="npcSpeedSlider" min="1" max="24" value="8" style="width:80px;" oninput="npcUpdateSpeed()">
                                        <span id="npcSpeedLabel" style="color:#4af; min-width:35px;">8 fps</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:5px; margin-top:5px;">
                                        <label style="color:#888; cursor:pointer;"><input type="checkbox" id="npcPingPong" onchange="npcUpdatePingPong()"> Ping-Pong</label>
                                    </div>
                                </div>
                            </div>
                            <button id="npcMirrorBtn" onclick="npcToggleMirror()" style="background:#555; padding:5px 10px; font-size:11px; border:1px solid #888;">Mirror</button>
                            <button onclick="npcClearCurrentAnim()" style="background:#a55; padding:5px 10px; font-size:11px;">Clear</button>
                        </div>
                    </div>
                    <div class="anim-frames-list" id="npcFramesList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pratt Warning Modal -->
    <div id="prattModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.9); z-index:10000; justify-content:center; align-items:center;">
        <div class="pratt-box">
            <div class="pratt-border"></div>
            <div class="pratt-content">
                <div class="pratt-icon">!</div>
                <h2 class="pratt-title">HEY <span style="color:#f84;">P</span><span style="color:#ff0;">R</span><span style="color:#4f8;">A</span><span style="color:#4ff;">T</span><span style="color:#f4f;">T</span>!</h2>
                <div class="pratt-subtitle">It's not broken!</div>
                <div class="pratt-message">Your tiles are rotated <span id="prattDegrees" class="pratt-highlight">90°</span> AND <span class="pratt-highlight">flipped</span>.</div>
                <div class="pratt-warning">This combo can look... interesting</div>
                <div class="pratt-buttons">
                    <button onclick="prattConfirm(true)" class="pratt-btn pratt-btn-yes">PLACE IT!</button>
                    <button onclick="prattConfirm(false)" class="pratt-btn pratt-btn-no">NAH</button>
                </div>
                <div class="pratt-footer">won't bug you again until you change it</div>
            </div>
        </div>
    </div>
    <style>
        .pratt-box {
            position: relative;
            animation: prattSlide 0.3s ease-out;
        }
        .pratt-border {
            position: absolute;
            inset: -4px;
            background: linear-gradient(45deg, #f84, #ff0, #4f8, #4ff, #f4f, #f84);
            background-size: 400% 400%;
            animation: prattRainbow 3s linear infinite;
            border-radius: 12px;
        }
        .pratt-content {
            position: relative;
            background: #111;
            padding: 25px 35px;
            border-radius: 8px;
            text-align: center;
            min-width: 320px;
        }
        .pratt-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        .pratt-title {
            font-size: 24px;
            font-weight: bold;
            margin: 0 0 12px 0;
            letter-spacing: 4px;
        }
        .pratt-subtitle {
            color: #4f8;
            font-size: 16px;
            margin-bottom: 15px;
        }
        .pratt-message {
            color: #ccc;
            font-size: 14px;
            margin-bottom: 8px;
        }
        .pratt-highlight {
            color: #f4f;
            font-weight: bold;
        }
        .pratt-warning {
            color: #fa0;
            font-size: 13px;
            margin-bottom: 20px;
        }
        .pratt-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        .pratt-btn {
            padding: 10px 30px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .pratt-btn:hover {
            transform: scale(1.05);
        }
        .pratt-btn:active {
            transform: scale(0.95);
        }
        .pratt-btn-yes {
            background: linear-gradient(180deg, #4a4 0%, #282 100%);
            color: #fff;
            box-shadow: 0 4px 0 #151, 0 0 20px #4f84;
        }
        .pratt-btn-no {
            background: linear-gradient(180deg, #555 0%, #333 100%);
            color: #aaa;
            box-shadow: 0 4px 0 #222;
        }
        .pratt-footer {
            color: #555;
            font-size: 10px;
            margin-top: 15px;
            font-style: italic;
        }
        @keyframes prattSlide {
            0% { transform: translateY(-30px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        @keyframes prattRainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 400% 50%; }
        }

        /* Player Animation Buttons - Retro Style */
        .player-anim-btn {
            border: 2px solid #333;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s ease;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            position: relative;
        }
        .player-anim-btn:hover {
            transform: translateY(-1px);
            filter: brightness(1.2);
        }
        .player-anim-btn:active {
            transform: translateY(1px);
        }
        .player-anim-btn.has-frames::after {
            content: '';
            position: absolute;
            top: -3px;
            right: -3px;
            background: #4f8;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 2px solid #111;
        }

        /* Walk buttons - Green */
        .player-anim-btn.walk-btn {
            background: linear-gradient(180deg, #3a5 0%, #283 100%);
            border-color: #4c7;
            color: #cfc;
        }
        .player-anim-btn.walk-btn.active {
            background: linear-gradient(180deg, #5f8 0%, #3a5 100%);
            border-color: #8fc;
            box-shadow: 0 0 10px #4f8, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Idle buttons - Cyan */
        .player-anim-btn.idle-btn {
            background: linear-gradient(180deg, #357 0%, #235 100%);
            border-color: #58a;
            color: #adf;
        }
        .player-anim-btn.idle-btn.active {
            background: linear-gradient(180deg, #5af 0%, #38d 100%);
            border-color: #8df;
            box-shadow: 0 0 10px #4af, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Attack buttons - Red */
        .player-anim-btn.attack-btn {
            background: linear-gradient(180deg, #744 0%, #522 100%);
            border-color: #966;
            color: #fcc;
        }
        .player-anim-btn.attack-btn.active {
            background: linear-gradient(180deg, #f66 0%, #a44 100%);
            border-color: #f99;
            box-shadow: 0 0 10px #f44, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Interact buttons - Purple */
        .player-anim-btn.interact-btn {
            background: linear-gradient(180deg, #458 0%, #336 100%);
            border-color: #68a;
            color: #cdf;
        }
        .player-anim-btn.interact-btn.active {
            background: linear-gradient(180deg, #8af 0%, #58c 100%);
            border-color: #adf;
            box-shadow: 0 0 10px #8af, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Death buttons - Dark Red */
        .player-anim-btn.death-btn {
            background: linear-gradient(180deg, #633 0%, #411 100%);
            border-color: #855;
            color: #faa;
        }
        .player-anim-btn.death-btn.active {
            background: linear-gradient(180deg, #c44 0%, #833 100%);
            border-color: #f66;
            box-shadow: 0 0 10px #f44, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Special buttons - Gold */
        .player-anim-btn.special-btn {
            background: linear-gradient(180deg, #754 0%, #532 100%);
            border-color: #a86;
            color: #fda;
        }
        .player-anim-btn.special-btn.active {
            background: linear-gradient(180deg, #fa4 0%, #c84 100%);
            border-color: #fc8;
            box-shadow: 0 0 10px #fa4, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Category headers */
        .player-anim-category {
            font-size: 10px;
            font-weight: bold;
            padding: 4px 8px;
            margin: 8px 0 4px 0;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .player-anim-category.walk { background: #283; color: #8fc; }
        .player-anim-category.idle { background: #235; color: #8df; }
        .player-anim-category.attack { background: #522; color: #faa; }
        .player-anim-category.interact { background: #336; color: #adf; }
        .player-anim-category.death { background: #411; color: #f88; }
        .player-anim-category.special { background: #532; color: #fd8; }
    </style>

    <!-- Player Editor Modal -->
    <div class="anim-modal" id="playerModal">
        <div class="anim-modal-content">
            <!-- Sidebar -->
            <div class="anim-sidebar">
                <h2 style="margin-top:0;">Player Character</h2>

                <!-- Step 1: Load Sprite Sheet -->
                <div style="margin-bottom:15px;">
                    <h3>1. Sprite Sheets</h3>
                    <input type="file" id="playerFileInput" accept="image/*" onchange="playerLoadSheet(event)" style="display:none;">
                    <button onclick="document.getElementById('playerFileInput').click()" style="width:100%; background:#3a5;">+ Add Sheet</button>
                    <div id="playerSheetTabs" style="margin-top:8px; display:flex; flex-direction:column; gap:4px;"></div>
                    <div id="playerFileName" style="font-size:11px; color:#4f8; margin-top:5px;"></div>
                </div>

                <!-- Step 2: Frame Size -->
                <div id="playerFrameSection" style="margin-bottom:15px; display:none;">
                    <h3>2. Frame Size</h3>
                    <div style="display:flex; gap:5px; flex-wrap:wrap; margin-bottom:8px;">
                        <button onclick="playerSetFrameSize(16,16)" style="padding:4px 8px; font-size:11px;">16x16</button>
                        <button onclick="playerSetFrameSize(16,32)" style="padding:4px 8px; font-size:11px;">16x32</button>
                        <button onclick="playerSetFrameSize(32,32)" style="padding:4px 8px; font-size:11px;">32x32</button>
                        <button onclick="playerSetFrameSize(32,64)" style="padding:4px 8px; font-size:11px;">32x64</button>
                        <button onclick="playerSetFrameSize(64,64)" style="padding:4px 8px; font-size:11px;">64x64</button>
                        <button onclick="playerResetGrid()" style="padding:4px 8px; font-size:11px; background:#a55;">Reset</button>
                    </div>
                    <div style="font-size:11px; color:#888;" id="playerGridInfo"></div>
                </div>

                <!-- Step 3: Animation Selection -->
                <div id="playerAnimSection" style="margin-bottom:15px; display:none;">
                    <h3>3. Select Animation</h3>
                    <div id="playerAnimButtons" style="display:flex; flex-direction:column; gap:5px;">
                        <div class="player-anim-category walk">Walk</div>
                        <div style="display:flex; gap:4px;">
                            <button id="playerAnimDown" onclick="playerSelectAnim('walkDown')" class="player-anim-btn walk-btn active" style="flex:1; padding:6px; font-size:11px;">↓ Walk</button>
                            <button id="playerAnimUp" onclick="playerSelectAnim('walkUp')" class="player-anim-btn walk-btn" style="flex:1; padding:6px; font-size:11px;">↑ Walk</button>
                            <button id="playerAnimLeft" onclick="playerSelectAnim('walkLeft')" class="player-anim-btn walk-btn" style="flex:1; padding:6px; font-size:11px;">← Walk</button>
                            <button id="playerAnimRight" onclick="playerSelectAnim('walkRight')" class="player-anim-btn walk-btn" style="flex:1; padding:6px; font-size:11px;">→ Walk</button>
                        </div>
                        <div class="player-anim-category idle">Idle</div>
                        <button id="playerAnimIdle" onclick="playerSelectAnim('idle')" class="player-anim-btn idle-btn" style="padding:6px; font-size:11px;" title="Single idle for all directions">Idle (All)</button>
                        <div style="font-size:10px; color:#888; margin:3px 0;">or directional:</div>
                        <div style="display:flex; gap:4px;">
                            <button id="playerAnimIdleDown" onclick="playerSelectAnim('idleDown')" class="player-anim-btn idle-btn" style="flex:1; padding:5px; font-size:10px;">↓</button>
                            <button id="playerAnimIdleUp" onclick="playerSelectAnim('idleUp')" class="player-anim-btn idle-btn" style="flex:1; padding:5px; font-size:10px;">↑</button>
                            <button id="playerAnimIdleLeft" onclick="playerSelectAnim('idleLeft')" class="player-anim-btn idle-btn" style="flex:1; padding:5px; font-size:10px;">←</button>
                            <button id="playerAnimIdleRight" onclick="playerSelectAnim('idleRight')" class="player-anim-btn idle-btn" style="flex:1; padding:5px; font-size:10px;">→</button>
                        </div>
                        <div class="player-anim-category attack">Attack</div>
                        <div style="display:flex; gap:4px;">
                            <button id="playerAnimAttackDown" onclick="playerSelectAnim('attackDown')" class="player-anim-btn attack-btn" style="flex:1; padding:6px; font-size:11px;">↓ Atk</button>
                            <button id="playerAnimAttackUp" onclick="playerSelectAnim('attackUp')" class="player-anim-btn attack-btn" style="flex:1; padding:6px; font-size:11px;">↑ Atk</button>
                            <button id="playerAnimAttackLeft" onclick="playerSelectAnim('attackLeft')" class="player-anim-btn attack-btn" style="flex:1; padding:6px; font-size:11px;">← Atk</button>
                            <button id="playerAnimAttackRight" onclick="playerSelectAnim('attackRight')" class="player-anim-btn attack-btn" style="flex:1; padding:6px; font-size:11px;">→ Atk</button>
                        </div>
                        <div style="margin-top:5px; font-size:10px;">
                            <label style="color:#888;">Movement: </label>
                            <select id="playerAttackMovement" style="font-size:10px; padding:2px; background:#333; color:#fff; border:1px solid #555;">
                                <option value="stop">Stop</option>
                                <option value="slide">Slide then stop</option>
                                <option value="move">Keep moving</option>
                            </select>
                        </div>
                        <div id="playerHitboxSection" style="margin-top:5px; display:none; padding:8px; background:#2a1a2a; border:1px solid #606; border-radius:4px;">
                            <div style="font-size:10px; color:#c8f; font-weight:bold; margin-bottom:6px;">Attack Hitbox (Per Direction)</div>
                            <div style="display:flex; gap:3px; margin-bottom:6px;">
                                <button id="phbDirUp" onclick="setPlayerHitboxDir('up')" style="flex:1; padding:3px; font-size:9px;">↑</button>
                                <button id="phbDirDown" onclick="setPlayerHitboxDir('down')" class="active" style="flex:1; padding:3px; font-size:9px; background:#606;">↓</button>
                                <button id="phbDirLeft" onclick="setPlayerHitboxDir('left')" style="flex:1; padding:3px; font-size:9px;">←</button>
                                <button id="phbDirRight" onclick="setPlayerHitboxDir('right')" style="flex:1; padding:3px; font-size:9px;">→</button>
                            </div>
                            <div style="margin-bottom:4px;">
                                <label style="font-size:9px; color:#888;">Range: <span id="playerHitboxRangeVal">40</span>px</label>
                                <input type="range" id="playerHitboxRange" min="10" max="120" value="40" oninput="updatePlayerHitboxShape()" style="width:100%;">
                            </div>
                            <div style="margin-bottom:4px;">
                                <label style="font-size:9px; color:#888;">Width: <span id="playerHitboxWidthVal">60</span>°</label>
                                <input type="range" id="playerHitboxWidth" min="20" max="180" value="60" oninput="updatePlayerHitboxShape()" style="width:100%;">
                            </div>
                            <div style="margin-bottom:4px;">
                                <label style="font-size:9px; color:#888;">Offset X: <span id="playerHitboxOffsetXVal">0</span>px</label>
                                <input type="range" id="playerHitboxOffsetX" min="-50" max="50" value="0" oninput="updatePlayerHitboxShape()" style="width:100%;">
                            </div>
                            <div style="margin-bottom:4px;">
                                <label style="font-size:9px; color:#888;">Offset Y: <span id="playerHitboxOffsetYVal">0</span>px</label>
                                <input type="range" id="playerHitboxOffsetY" min="-50" max="50" value="0" oninput="updatePlayerHitboxShape()" style="width:100%;">
                            </div>
                            <button onclick="copyPlayerHitboxToAll()" style="width:100%; padding:3px; font-size:9px; background:#464; margin-top:4px;">Copy to All Directions</button>
                            <p style="font-size:8px; color:#888; margin:4px 0 0 0;">Adjust hitbox per direction. Test with C key.</p>
                        </div>
                        <div class="player-anim-category interact">Interact</div>
                        <button id="playerAnimInteract" onclick="playerSelectAnim('interact')" class="player-anim-btn interact-btn" style="padding:6px; font-size:11px;">Interact</button>
                        <div class="player-anim-category death">Death</div>
                        <button id="playerAnimDeath" onclick="playerSelectAnim('death')" class="player-anim-btn death-btn" style="padding:6px; font-size:11px;">Death</button>
                        <!-- Game Over Sound Selection -->
                        <div style="margin:8px 0; padding:6px; background:#2a1a2a; border:1px solid #644; border-radius:4px;">
                            <label style="font-size:10px; color:#f88;">Game Over Sound:</label>
                            <select id="playerGameOverSound" onchange="playerUpdateGameOverSound()" style="width:100%; margin-top:4px; background:#1a1a2e; color:#fff; border:1px solid #555; padding:4px; font-size:11px;">
                                <option value="-1">None</option>
                            </select>
                            <button onclick="playerPreviewGameOverSound()" style="width:100%; margin-top:4px; padding:4px; font-size:10px; background:#644;">Preview Sound</button>
                        </div>
                        <div class="player-anim-category special">Special</div>
                        <button id="playerAnimReceivedItem" onclick="playerSelectAnim('receivedItem')" class="player-anim-btn special-btn" style="padding:6px; font-size:11px;">Received Item</button>
                    </div>
                    <!-- Custom animations list -->
                    <div id="playerCustomAnimList" style="margin-top:8px;"></div>
                    <!-- Add custom animation -->
                    <div style="display:flex; gap:5px; margin-top:8px;">
                        <input type="text" id="playerCustomAnimName" placeholder="e.g. roll, cast" style="flex:1; padding:4px; font-size:11px;">
                        <button onclick="playerAddCustomAnim()" style="padding:4px 8px; font-size:11px; background:#4a4;">+ Add</button>
                    </div>
                    <p style="font-size:10px; color:#666; margin-top:8px;">Drag on sprite sheet to select multi-tile frames</p>
                </div>

                <!-- Step 4: Name -->
                <div id="playerNameSection" style="margin-bottom:15px; display:none;">
                    <h3>4. Name</h3>
                    <input type="text" id="playerNameInput" placeholder="e.g. hero, knight" style="width:100%;">
                </div>

                <!-- Actions -->
                <div style="margin-top:auto;">
                    <button onclick="playerSave()" style="width:100%; background:#4f8; color:#000; margin-bottom:10px;">Save Character</button>
                    <button onclick="playerCancel()" style="width:100%; background:#a55;">Cancel</button>
                </div>
            </div>

            <!-- Main Area -->
            <div class="anim-main">
                <div class="anim-header">
                    <h2>Sprite Sheet</h2>
                    <span style="color:#888; font-size:12px;">Click frames to add to current animation</span>
                    <div style="display:flex; align-items:center; gap:5px; margin-left:auto;">
                        <span style="color:#888; font-size:11px;">Zoom:</span>
                        <button onclick="playerZoomOut()" style="padding:2px 8px; font-size:14px;">-</button>
                        <span id="playerZoomLevel" style="color:#4f8; font-size:11px; min-width:35px; text-align:center;">3x</span>
                        <button onclick="playerZoomIn()" style="padding:2px 8px; font-size:14px;">+</button>
                    </div>
                </div>

                <div class="anim-canvas-area">
                    <canvas id="playerEditorCanvas"></canvas>
                </div>

                <!-- Bottom Bar: Animation Frames -->
                <div class="anim-frames-bar">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span><strong id="playerCurrentAnimName" style="color:#4f8;">Walk Down</strong>: <span id="playerFrameCount">0</span> frames</span>
                        <div style="display:flex; align-items:center; gap:15px;">
                            <!-- Live Preview -->
                            <div style="display:flex; align-items:center; gap:10px;">
                                <canvas id="playerLivePreview" width="96" height="96" style="border:2px solid #4f8; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                                <div style="font-size:11px;">
                                    <div style="display:flex; align-items:center; gap:5px;">
                                        <span style="color:#888;">Speed:</span>
                                        <input type="range" id="playerSpeedSlider" min="1" max="24" value="8" style="width:80px;" oninput="playerUpdateSpeed()">
                                        <span id="playerSpeedLabel" style="color:#4f8; min-width:35px;">8 fps</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:5px; margin-top:5px;">
                                        <label style="color:#888; cursor:pointer;"><input type="checkbox" id="playerPingPong" onchange="playerUpdatePingPong()"> Ping-Pong</label>
                                    </div>
                                </div>
                            </div>
                            <button id="playerMirrorBtn" onclick="playerToggleMirror()" style="background:#555; padding:5px 10px; font-size:11px; border:1px solid #888;">Mirror</button>
                            <button onclick="playerClearCurrentAnim()" style="background:#a55; padding:5px 10px; font-size:11px;">Clear</button>
                        </div>
                    </div>
                    <div class="anim-frames-list" id="playerFramesList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Dialog Editor Modal -->
    <div class="anim-modal" id="dialogModal">
        <div class="anim-modal-content" style="width:700px; max-width:95vw;">
            <div style="display:flex; gap:20px; height:100%;">
                <!-- Left: Controls -->
                <div style="flex:0 0 280px; background:#1a1a2e; padding:15px; border-radius:8px; overflow-y:auto;">
                    <h2 style="margin-top:0; color:#88f;">Dialog Editor</h2>

                    <!-- Dialog Name -->
                    <div style="margin-bottom:15px;">
                        <label style="font-size:11px; color:#aaa; display:block; margin-bottom:5px;">Dialog Name:</label>
                        <input type="text" id="dialogNameInput" placeholder="e.g. villager_greeting" style="width:100%; padding:8px;">
                    </div>

                    <!-- Style Selection -->
                    <div style="margin-bottom:15px;">
                        <label style="font-size:11px; color:#aaa; display:block; margin-bottom:5px;">Style:</label>
                        <select id="dialogStyleSelect" style="width:100%; padding:8px;" onchange="updateDialogPreview()">
                            <option value="1">Classic NES</option>
                            <option value="2">Final Fantasy</option>
                            <option value="3">Pokemon</option>
                            <option value="4">Earthbound</option>
                            <option value="5">Chrono Trigger</option>
                            <option value="6">Modern Pixel</option>
                        </select>
                    </div>

                    <!-- Colors -->
                    <div style="margin-bottom:15px;">
                        <label style="font-size:11px; color:#aaa; display:block; margin-bottom:5px;">Colors:</label>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                            <div>
                                <label style="font-size:10px; color:#666;">Background</label>
                                <input type="color" id="dialogBgColor" value="#000000" style="width:100%; height:30px;" onchange="updateDialogPreview()">
                            </div>
                            <div>
                                <label style="font-size:10px; color:#666;">Border</label>
                                <input type="color" id="dialogBorderColor" value="#ffffff" style="width:100%; height:30px;" onchange="updateDialogPreview()">
                            </div>
                            <div>
                                <label style="font-size:10px; color:#666;">Text</label>
                                <input type="color" id="dialogTextColor" value="#ffffff" style="width:100%; height:30px;" onchange="updateDialogPreview()">
                            </div>
                            <div>
                                <label style="font-size:10px; color:#666;">Accent</label>
                                <input type="color" id="dialogAccentColor" value="#ffffff" style="width:100%; height:30px;" onchange="updateDialogPreview()">
                            </div>
                        </div>
                    </div>

                    <!-- Size -->
                    <div style="margin-bottom:15px;">
                        <label style="font-size:11px; color:#aaa; display:block; margin-bottom:5px;">Size:</label>
                        <div style="display:flex; gap:8px;">
                            <div style="flex:1;">
                                <label style="font-size:10px; color:#666;">Width</label>
                                <input type="number" id="dialogWidth" value="280" min="100" max="500" style="width:100%; padding:4px;" onchange="updateDialogPreview()">
                            </div>
                            <div style="flex:1;">
                                <label style="font-size:10px; color:#666;">Height</label>
                                <input type="number" id="dialogHeight" value="80" min="50" max="200" style="width:100%; padding:4px;" onchange="updateDialogPreview()">
                            </div>
                        </div>
                    </div>

                    <!-- Buttons -->
                    <div style="display:flex; gap:8px; margin-top:20px;">
                        <button onclick="saveDialog()" style="flex:1; padding:10px; background:#484; font-size:13px;">Save</button>
                        <button onclick="closeDialogEditor()" style="flex:1; padding:10px; background:#644; font-size:13px;">Cancel</button>
                    </div>
                </div>

                <!-- Right: Pages and Preview -->
                <div style="flex:1; display:flex; flex-direction:column; gap:15px;">
                    <!-- Pages List -->
                    <div style="background:#1a1a2e; padding:15px; border-radius:8px;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                            <h3 style="margin:0; color:#fa0;">Pages</h3>
                            <button onclick="addDialogPage()" style="padding:5px 10px; background:#484; font-size:12px;">+ Add Page</button>
                        </div>
                        <div id="dialogPagesList" style="display:flex; gap:8px; flex-wrap:wrap; max-height:60px; overflow-y:auto;">
                            <div class="dialog-page active" onclick="selectDialogPageEditor(0)">1</div>
                        </div>
                    </div>

                    <!-- Current Page Editor -->
                    <div style="background:#1a1a2e; padding:15px; border-radius:8px; flex:1;">
                        <div style="margin-bottom:10px;">
                            <label style="font-size:11px; color:#aaa; display:block; margin-bottom:5px;">Speaker Name:</label>
                            <input type="text" id="dialogSpeaker" placeholder="NPC name or leave empty" style="width:100%; padding:8px;" onkeyup="updateDialogPreview()">
                        </div>
                        <div>
                            <label style="font-size:11px; color:#aaa; display:block; margin-bottom:5px;">Text:</label>
                            <textarea id="dialogTextInput" rows="4" placeholder="Enter dialog text..." style="width:100%; padding:8px; resize:vertical;" onkeyup="updateDialogPreview()"></textarea>
                        </div>
                        <button onclick="removeCurrentDialogPage()" style="margin-top:8px; padding:5px 10px; background:#644; font-size:11px;">Delete Page</button>
                    </div>

                    <!-- Preview -->
                    <div style="background:#222; padding:15px; border-radius:8px; text-align:center;">
                        <label style="font-size:11px; color:#888; display:block; margin-bottom:10px;">Preview:</label>
                        <canvas id="dialogPreviewCanvas" width="280" height="80" style="image-rendering:pixelated; transform:scale(1.5);"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Animated Prop Editor Modal -->
    <div class="anim-modal" id="animPropModal">
        <div class="anim-modal-content">
            <!-- Sidebar -->
            <div class="anim-sidebar">
                <h2 style="margin-top:0;">Animated Prop</h2>

                <!-- Step 1: Load Sprite Sheet -->
                <div style="margin-bottom:20px;">
                    <h3>1. Sprite Sheet</h3>
                    <input type="file" id="animPropFileInput" accept="image/*" onchange="animPropLoadSheet(event)">
                    <button onclick="document.getElementById('animPropFileInput').click()" style="width:100%;">Load Image</button>
                    <div id="animPropFileName" style="font-size:11px; color:#4af; margin-top:5px;"></div>
                </div>

                <!-- Step 2: Frame Size -->
                <div id="animPropFrameSection" style="margin-bottom:20px; display:none;">
                    <h3>2. Frame Size</h3>
                    <div style="display:flex; gap:10px; margin-bottom:10px;">
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Width:</label>
                            <input type="number" id="animPropFrameW" value="16" min="8" max="256" onchange="animPropUpdateGrid()" style="width:100%;">
                        </div>
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Height:</label>
                            <input type="number" id="animPropFrameH" value="16" min="8" max="256" onchange="animPropUpdateGrid()" style="width:100%;">
                        </div>
                    </div>
                    <div style="font-size:11px; color:#888;" id="animPropGridInfo"></div>
                </div>

                <!-- Step 3: Animation Type -->
                <div id="animPropTypeSection" style="margin-bottom:20px; display:none;">
                    <h3>3. Animation Type</h3>
                    <select id="animPropType" style="width:100%;" onchange="animPropTypeChanged()">
                        <option value="loop">Loop (continuous)</option>
                        <option value="interactive">Interactive (on trigger)</option>
                    </select>
                    <p style="font-size:10px; color:#666; margin-top:5px;">Adjust speed with slider in preview below</p>

                    <!-- Interact options (shown when type is 'interactive') -->
                    <div id="animPropInteractOptions" style="display:none; margin-top:10px; padding:10px; background:#1a2a35; border-radius:5px;">
                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                            <input type="checkbox" id="animPropGiveItem" onchange="animPropGiveItemChanged()">
                            <span style="font-size:12px;">Give Item on Interact</span>
                        </label>
                        <div id="animPropItemSection" style="display:none;">
                            <label style="font-size:10px; color:#888;">Select Item:</label>
                            <select id="animPropItemSelect" style="width:100%; margin-top:4px;">
                                <option value="-1">-- No items defined --</option>
                            </select>
                            <p style="font-size:9px; color:#666; margin-top:4px;">Player receives this item when interacting (A key)</p>
                        </div>
                    </div>
                </div>

                <!-- Step 4: Collision & Depth -->
                <div id="animPropCollisionSection" style="margin-bottom:20px; display:none;">
                    <h3>4. Collision & Depth</h3>
                    <div style="display:flex; gap:5px; flex-wrap:wrap; margin-bottom:10px;">
                        <button id="animPropToolNone" class="active" onclick="setAnimPropTool('none')" style="padding:5px 8px; font-size:11px;">Select</button>
                        <button id="animPropToolCollision" onclick="setAnimPropTool('collision')" style="padding:5px 8px; font-size:11px; background:#a55;">Collision</button>
                        <button id="animPropToolErase" onclick="setAnimPropTool('erase')" style="padding:5px 8px; font-size:11px;">Erase</button>
                        <button id="animPropToolSplit" onclick="setAnimPropTool('split')" style="padding:5px 8px; font-size:11px; background:#0aa;">Split</button>
                    </div>

                    <!-- Brush Size for Collision -->
                    <div id="animPropBrushSection" style="display:none; margin-bottom:10px;">
                        <span style="font-size:10px; color:#aaa;">Brush:</span>
                        <button id="animPropBrush1" onclick="setAnimPropBrush(1)" style="padding:3px 6px; font-size:10px;">1</button>
                        <button id="animPropBrush2" onclick="setAnimPropBrush(2)" style="padding:3px 6px; font-size:10px;">2</button>
                        <button id="animPropBrush4" class="active" onclick="setAnimPropBrush(4)" style="padding:3px 6px; font-size:10px;">4</button>
                        <button id="animPropBrush8" onclick="setAnimPropBrush(8)" style="padding:3px 6px; font-size:10px;">8</button>
                    </div>

                    <!-- Split Controls -->
                    <div id="animPropSplitControls" style="display:none; margin-bottom:10px; padding:8px; background:#1a3a3e; border-radius:5px;">
                        <div style="font-size:10px; color:#0ff; margin-bottom:5px;">Draw split line on tiles (drag to draw)</div>
                        <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                            <label style="font-size:10px; display:flex; align-items:center; gap:4px; cursor:pointer;">
                                <input type="checkbox" id="animPropFlatLine" checked>
                                <span>Flat Line</span>
                            </label>
                            <span style="font-size:10px;">Y:</span>
                            <input type="number" id="animPropSplitY" value="8" min="0" max="16" style="width:40px; padding:2px; font-size:10px;">
                            <button onclick="setAnimPropSplitY()" style="padding:2px 6px; font-size:9px; background:#0aa;">Set Y</button>
                            <button onclick="clearAnimPropSplit()" style="padding:2px 6px; font-size:9px; background:#a55;">Clear</button>
                        </div>
                        <div style="font-size:9px; color:#888; margin-top:4px;">C = Canopy (top) | T = Trunk (Y-sorted)</div>
                    </div>

                    <p style="font-size:10px; color:#666;">Paint on any frame. Collision/split data applies to all frames.</p>
                </div>

                <!-- Step 5: Name -->
                <div id="animPropNameSection" style="margin-bottom:20px; display:none;">
                    <h3>5. Name</h3>
                    <input type="text" id="animPropNameInput" placeholder="e.g. torch, chest, door" style="width:100%;">
                </div>

                <!-- Actions -->
                <div style="margin-top:auto;">
                    <button onclick="animPropSave()" style="width:100%; background:#4af; color:#000; margin-bottom:10px;">Save Prop</button>
                    <button onclick="animPropCancel()" style="width:100%; background:#a55;">Cancel</button>
                </div>
            </div>

            <!-- Main Area -->
            <div class="anim-main">
                <div class="anim-header">
                    <h2>Sprite Sheet</h2>
                    <span style="color:#888; font-size:12px;">Click or drag to select frames (multi-tile supported)</span>
                    <div style="display:flex; align-items:center; gap:5px; margin-left:auto;">
                        <span style="color:#888; font-size:11px;">Zoom:</span>
                        <button onclick="animPropZoomOut()" style="padding:2px 8px; font-size:14px;">-</button>
                        <span id="animPropZoomLevel" style="color:#4af; font-size:11px; min-width:35px; text-align:center;">3x</span>
                        <button onclick="animPropZoomIn()" style="padding:2px 8px; font-size:14px;">+</button>
                    </div>
                </div>

                <div class="anim-canvas-area">
                    <canvas id="animPropEditorCanvas"></canvas>
                </div>

                <!-- Bottom Bar: Animation Frames -->
                <div class="anim-frames-bar">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span>Animation Frames: <strong id="animPropFrameCount" style="color:#4af;">0</strong></span>
                        <div style="display:flex; align-items:center; gap:15px;">
                            <!-- Live Preview -->
                            <div style="display:flex; align-items:center; gap:8px;">
                                <canvas id="animPropLivePreview" width="48" height="48" style="border:2px solid #4af; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                                <div style="font-size:11px;">
                                    <div style="display:flex; align-items:center; gap:5px;">
                                        <span style="color:#888;">Speed:</span>
                                        <input type="range" id="animPropSpeedSlider" min="1" max="24" value="8" style="width:80px;" oninput="animPropUpdateSpeed()">
                                        <span id="animPropSpeedLabel" style="color:#4af; min-width:35px;">8 fps</span>
                                    </div>
                                </div>
                            </div>
                            <button onclick="animPropClearFrames()" style="background:#a55; padding:5px 10px; font-size:11px;">Clear</button>
                        </div>
                    </div>
                    <div class="anim-frames-list" id="animPropFramesList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Item Editor Modal -->
    <div class="anim-modal" id="itemModal">
        <div class="anim-modal-content">
            <!-- Sidebar -->
            <div class="anim-sidebar">
                <h2 style="margin-top:0;">Interactive Item</h2>

                <!-- Step 1: Load Sprite Sheet -->
                <div style="margin-bottom:20px;">
                    <h3>1. Sprite Sheet</h3>
                    <input type="file" id="itemFileInput" accept="image/*" onchange="itemLoadSheet(event)" style="display:none;">
                    <button onclick="document.getElementById('itemFileInput').click()" style="width:100%;">Load Image</button>
                    <div id="itemFileName" style="font-size:11px; color:#4f8; margin-top:5px;"></div>
                </div>

                <!-- Step 2: Frame Size -->
                <div id="itemFrameSection" style="margin-bottom:20px; display:none;">
                    <h3>2. Frame Size</h3>
                    <div style="display:flex; gap:10px; margin-bottom:10px;">
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Width:</label>
                            <input type="number" id="itemFrameW" value="16" min="8" max="256" onchange="itemUpdateGrid()" style="width:100%;">
                        </div>
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Height:</label>
                            <input type="number" id="itemFrameH" value="16" min="8" max="256" onchange="itemUpdateGrid()" style="width:100%;">
                        </div>
                    </div>
                    <div style="font-size:11px; color:#888;" id="itemGridInfo"></div>
                </div>

                <!-- Step 3: Idle Frame -->
                <div id="itemIdleSection" style="margin-bottom:20px; display:none;">
                    <h3>3. Idle Frame</h3>
                    <p style="font-size:10px; color:#666; margin-bottom:8px;">Which frame shows before player interacts</p>
                    <select id="itemIdleFrame" style="width:100%;">
                        <option value="0">Frame 1 (first)</option>
                    </select>
                </div>

                <!-- Step 4: Name -->
                <div id="itemNameSection" style="margin-bottom:20px; display:none;">
                    <h3>4. Name</h3>
                    <input type="text" id="itemNameInput" placeholder="e.g. chest, pot, crate" style="width:100%;">
                </div>

                <!-- Actions -->
                <div style="margin-top:auto;">
                    <button onclick="itemSave()" style="width:100%; background:#4f8; color:#000; margin-bottom:10px;">Save Item</button>
                    <button onclick="itemCancel()" style="width:100%; background:#a55;">Cancel</button>
                </div>
            </div>

            <!-- Main Area -->
            <div class="anim-main">
                <div class="anim-header">
                    <h2>Sprite Sheet</h2>
                    <span style="color:#888; font-size:12px;">Click frames in order: idle first, then animation sequence</span>
                    <div style="display:flex; align-items:center; gap:5px; margin-left:auto;">
                        <span style="color:#888; font-size:11px;">Zoom:</span>
                        <button onclick="itemZoomOut()" style="padding:2px 8px; font-size:14px;">-</button>
                        <span id="itemZoomLevel" style="color:#4f8; font-size:11px; min-width:35px; text-align:center;">3x</span>
                        <button onclick="itemZoomIn()" style="padding:2px 8px; font-size:14px;">+</button>
                    </div>
                </div>

                <div class="anim-canvas-area">
                    <canvas id="itemEditorCanvas"></canvas>
                </div>

                <!-- Bottom Bar: Animation Frames -->
                <div class="anim-frames-bar">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span>Animation Frames: <strong id="itemFrameCount" style="color:#4f8;">0</strong></span>
                        <div style="display:flex; align-items:center; gap:15px;">
                            <!-- Live Preview -->
                            <div style="display:flex; align-items:center; gap:8px;">
                                <canvas id="itemLivePreview" width="48" height="48" style="border:2px solid #4f8; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                                <div style="font-size:11px;">
                                    <div style="display:flex; align-items:center; gap:5px;">
                                        <span style="color:#888;">Speed:</span>
                                        <input type="range" id="itemSpeedSlider" min="1" max="24" value="8" style="width:80px;" oninput="itemUpdateSpeed()">
                                        <span id="itemSpeedLabel" style="color:#4f8; min-width:35px;">8 fps</span>
                                    </div>
                                </div>
                            </div>
                            <button onclick="itemClearFrames()" style="background:#a55; padding:5px 10px; font-size:11px;">Clear</button>
                        </div>
                    </div>
                    <div class="anim-frames-list" id="itemFramesList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Door Target Map Modal -->
    <div id="doorMapModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:10000; justify-content:center; align-items:center;">
        <div style="background:#2a2a2a; padding:20px; border-radius:8px; min-width:300px; border:2px solid #4af;">
            <h3 style="margin:0 0 15px 0; color:#4af;">Door <span id="doorModalNumber">1</span></h3>

            <div id="doorMapSelectDiv">
                <div style="margin-bottom:15px;">
                    <label style="display:block; margin-bottom:5px; color:#aaa;">Target map:</label>
                    <select id="doorMapSelect" style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555;">
                    </select>
                </div>

                <div style="margin-bottom:15px;">
                    <label style="display:block; margin-bottom:5px; color:#aaa;">Or create new map:</label>
                    <input type="text" id="doorNewMapName" placeholder="Enter new map name..." style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555; box-sizing:border-box;">
                </div>
            </div>

            <div style="margin-bottom:15px; padding-top:15px; border-top:1px solid #444;">
                <label style="display:block; margin-bottom:5px; color:#aaa;">Door Type:</label>
                <select id="doorModalType" onchange="updateDoorModalOptions()" style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555;">
                    <option value="walkover">Walk Over (auto)</option>
                    <option value="interact">Interact (press button)</option>
                    <option value="external">External Link (to another HTML)</option>
                </select>
            </div>

            <!-- External options (shown only for external type) -->
            <div id="externalOptions" style="display:none; margin-bottom:15px; background:#1a2a3a; padding:10px; border-radius:4px;">
                <label style="display:block; margin-bottom:8px; color:#0ff; font-weight:bold;">Destination:</label>
                <select id="externalDestination" style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555;">
                    <option value="tavern/test-3d-tavern.html">Tavern (3D)</option>
                </select>
                <p style="margin:8px 0 0 0; font-size:11px; color:#888;">Player will be transported to this location</p>
            </div>

            <!-- Walkover options (shown only for walkover type) -->
            <div id="walkoverOptions" style="margin-bottom:15px; background:#222; padding:10px; border-radius:4px;">
                <label style="display:block; margin-bottom:8px; color:#4af; font-weight:bold;">Walk-Out Settings:</label>

                <div style="margin-bottom:10px;">
                    <label style="display:flex; align-items:center; gap:8px; color:#fff; cursor:pointer;">
                        <input type="checkbox" id="useWalkOutPoint" onchange="toggleWalkOutMode()" style="width:18px; height:18px;">
                        <span>Set walk-out destination (click on map)</span>
                    </label>
                    <p style="margin:5px 0 0 26px; font-size:11px; color:#888;">Player auto-walks to this point before fade</p>
                </div>

                <div id="walkDirectionOptions">
                    <label style="display:block; margin-bottom:5px; color:#aaa;">Or walk direction:</label>
                    <div style="display:flex; gap:5px; margin-bottom:10px;">
                        <button type="button" onclick="setWalkDirection('up')" id="walkDirUp" style="flex:1; padding:8px; background:#444; border:2px solid #555; color:#fff; cursor:pointer;">↑</button>
                        <button type="button" onclick="setWalkDirection('down')" id="walkDirDown" style="flex:1; padding:8px; background:#444; border:2px solid #555; color:#fff; cursor:pointer;">↓</button>
                        <button type="button" onclick="setWalkDirection('left')" id="walkDirLeft" style="flex:1; padding:8px; background:#444; border:2px solid #555; color:#fff; cursor:pointer;">←</button>
                        <button type="button" onclick="setWalkDirection('right')" id="walkDirRight" style="flex:1; padding:8px; background:#444; border:2px solid #555; color:#fff; cursor:pointer;">→</button>
                    </div>
                    <label style="display:block; margin-bottom:5px; color:#aaa;">Walk Duration (seconds):</label>
                    <input type="number" id="doorWalkDuration" value="0.5" min="0.1" max="5" step="0.1" style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555; box-sizing:border-box;">
                </div>
            </div>

            <!-- Interact options (shown only for interact type) -->
            <div id="interactOptions" style="display:none; margin-bottom:15px; background:#222; padding:10px; border-radius:4px;">
                <label style="display:block; margin-bottom:8px; color:#f84; font-weight:bold;">Door Animation:</label>
                <div style="margin-bottom:10px;">
                    <label style="display:flex; align-items:center; gap:8px; color:#fff; cursor:pointer;">
                        <input type="checkbox" id="useDoorAnimation" style="width:18px; height:18px;">
                        <span>Animate door tiles (paint after placing)</span>
                    </label>
                    <p style="margin:5px 0 0 26px; font-size:11px; color:#888;">Selected tiles will disappear when door opens</p>
                </div>
            </div>

            <div style="margin-bottom:15px;">
                <label style="display:block; margin-bottom:5px; color:#aaa;">Fade Duration (seconds, 0 = instant):</label>
                <input type="number" id="doorFadeDuration" value="0.5" min="0" max="3" step="0.1" style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555; box-sizing:border-box;">
            </div>

            <div style="display:flex; gap:10px; justify-content:flex-end;">
                <button onclick="closeDoorMapModal()" style="padding:8px 16px; background:#555; color:#fff;">Cancel</button>
                <button id="doorModalConfirmBtn" onclick="confirmDoorMapModal()" style="padding:8px 16px; background:#4af; color:#000; font-weight:bold;">Set Spawn →</button>
            </div>
        </div>
    </div>

    <script>
        // ===== GLOBALS =====
        let currentPhase = 'load'; // 'load', 'collision', 'build'
        let gridSize = 16;
        let zoom = 2;
        let mapCols = 40;
        let mapRows = 30;

        let tilesetImg = null;
        let tilesets = []; // Array of { name, img, data } for multiple tilesets
        let currentTilesetIndex = 0;
        let tileCollisions = {}; // "tilesetIndex:x,y" -> [{x,y}, ...]
        let selectedTileData = null;
        let selectionStart = null; // For multi-tile selection
        let selectedTiles = []; // Array of {x, y} for multi-tile selection
        let hoverMapPos = null; // Current hover position on map for preview
        let tileRotation = 0; // 0, 90, 180, 270 degrees
        let tileFlippedH = false; // Flip tile horizontally
        let prattWarningShown = false; // Track if flip+rotation warning was shown
        let eraseMode = false; // Erase tiles instead of painting

        // Layers
        let layers = []; // Array of layer data, each layer is a 2D array like map
        let currentLayer = 0;
        let layerVisibility = []; // Which layers are visible
        let layerNames = []; // Custom names for layers

        // Player layer (for visualization - uneditable, undeletable)
        let playerLayerIndex = 1; // Which layer position the player appears at
        let playerPreviewPos = { x: 5, y: 5 }; // Position on map for player preview
        let spawnMapName = 'main'; // Which map the initial spawn is on
        let playerPreviewVisible = true;
        let setSpawnMode = false; // For setting player spawn position

        // Brush settings
        let brushPainting = false;
        let brushErasing = false;
        let collisionZoom = 6;
        let collisionTool = 'paint'; // 'paint' or 'erase'
        let brushSize = 4; // Brush size in pixels
        let brushShape = 'square'; // 'square', 'circle', 'rect'
        let brushRectW = 8;
        let brushRectH = 4;
        let brushPreviewPos = null; // { x, y } for cyan preview
        let modifiedCollisionKeys = new Set(); // Track modified tiles for sync

        // Pixel collision masks per tile
        let collisionMasks = {}; // "x,y" -> 2D array of booleans

        // Depth split lines for Y-sorting (trunk vs canopy)
        let tileSplitLines = {}; // "tilesetIndex:x,y" -> array of Y values per column (freeform line)
        let selectedSplitTile = null; // {x, y, tilesetIndex} - currently selected tile for splitting
        let draggingSplitLine = false; // true when dragging the split line
        let flatLineMode = true; // when true, split lines are always horizontal
        let modifiedSplitKey = null; // Track current split line being modified for sync

        // Panning
        let collisionPanX = 0;
        let collisionPanY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;

        let mode = 'tile';
        let currentMapName = 'main'; // Current map name (for multi-map support)
        let maps = {}; // All maps data: { 'main': {layers, tileCollisions, ...}, 'dungeon1': {...} }
        let placedTriggers = []; // Map transition triggers: { x, y, mapName, targetMap, targetX, targetY, type, ... }
        let settingSpawnPoint = false; // True when clicking to set trigger spawn point
        let spawnSourceMap = null; // Map we came from when setting spawn
        let draggingSpawnTrigger = null; // Trigger being dragged (to move spawn point)
        let pendingTriggerForSpawn = null; // Trigger we're setting spawn for (green box follows mouse)
        let triggerDragStart = null; // Start position for drag-to-create trigger {x, y}
        let triggerDragEnd = null; // End position for drag-to-create trigger {x, y}
        let pendingTriggerWidth = 1; // Width of trigger being created
        let pendingTriggerHeight = 1; // Height of trigger being created

        // Player sprite (embedded as base64)
        let playerSpriteData = null; // Base64 data URL of player sprite
        let playerSpriteImg = null; // Image object for preview

        // Load default player sprite
        (function loadDefaultPlayerSprite() {
            const defaultSprite = new Image();
            defaultSprite.onload = () => {
                if (!playerSpriteImg) {
                    playerSpriteImg = defaultSprite;
                    console.log('Default player sprite loaded');
                }
            };
            defaultSprite.onerror = () => {
                console.log('Failed to load default sprite, trying relative path...');
                defaultSprite.src = 'assets/player_sprite.png';
            };
            // Use absolute URL to work in all contexts
            defaultSprite.src = window.location.origin + '/assets/player_sprite.png';
        })();

        // Player character system (multiple characters with animations)
        let playerCharacters = []; // Array of { name, spriteData, frameWidth, frameHeight, animations, fps }
        let activePlayerIndex = -1; // Which character is active (-1 = use default sprite)

        // Player editor state
        let playerEditorSheets = []; // Array of { image, data, name }
        let playerCurrentSheetIndex = 0;
        let playerEditorFrameW = 64;
        let playerEditorFrameH = 64;
        let playerEditorZoom = 3;
        let playerEditorEditingIndex = -1; // -1 = new, >= 0 = editing existing
        let playerAnimations = { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], idleDown: [], idleUp: [], idleLeft: [], idleRight: [], attackDown: [], attackUp: [], attackLeft: [], attackRight: [], interact: [], death: [], receivedItem: [] };
        let playerCurrentAnim = 'walkDown';
        let playerPreviewPlaying = false;
        let playerPreviewInterval = null;
        let playerPreviewFrame = 0;
        let playerAnimFpsList = {}; // Per-animation FPS: { walkDown: 8, death: 1, ... }
        let playerPingPong = false;
        let playerPreviewDirection = 1; // 1 = forward, -1 = backward for ping-pong
        let playerAnimMirrors = {}; // { walkLeft: true } - animations to render flipped horizontally
        let playerAttackMovement = 'stop'; // 'stop', 'slide', 'move' - player movement during attack
        // Shape-based attack hitbox per direction (triangle/cone)
        let playerHitboxRange = { up: 20, down: 20, left: 20, right: 20 };
        let playerHitboxWidth = { up: 90, down: 90, left: 90, right: 90 };
        let playerHitboxOffsetY = { up: 5, down: 0, left: 0, right: 0 };
        let playerHitboxOffsetX = { up: 0, down: 0, left: 5, right: -10 }; // Horizontal offset
        let playerGameOverSoundIndex = -1; // Index of game over sound (-1 = none, 0+ = builtin, 100+ = project sounds)

        // Built-in game over sounds
        const builtinGameOverSounds = [
            { name: 'Game Over 1', file: 'game-over-417465.mp3' },
            { name: 'Game Over 2 (Arcade)', file: 'game-over-arcade-6435.mp3' }
        ];
        let builtinGameOverAudios = [null, null]; // Lazy-loaded audio elements
        // Player drag-selection for multi-tile frames
        let playerFrameDragging = false;
        let playerFrameDragStart = null;
        let playerFrameDragEnd = null;

        // Copy from map mode
        let copyMode = false;
        let copyStart = null;
        let copyEnd = null;
        let copiedTiles = null; // 2D array of copied tile data

        // Multiple props system - array of prop images like tilesets
        let props = []; // Array of { name, img, data, collisionMasks }
        let currentPropIndex = -1;
        let propImage = null; // Current prop image (shortcut)
        let propImageData = null; // Current prop data (shortcut)
        let propSelection = null; // {x, y, width, height}
        let propCollisionMasks = {}; // Current prop's collision masks
        let propTool = 'select'; // 'select', 'collision', 'erase'
        let propBrushSize = 4;
        let propPainting = false;

        // Animated Props System
        let animatedProps = []; // Array of animated prop definitions { name, spriteData, frameWidth, frameHeight, frames: [{x,y,w,h},...], type: 'loop'|'interactive', fps }
        let currentAnimPropIndex = -1;
        let currentAnimPropScale = 1; // Scale for placing animated props
        let animPropSpriteSheet = null; // Current sprite sheet Image
        let animPropSpriteData = null; // Current sprite data URL
        let animPropFrames = []; // Frames being edited
        let animPropPreviewPlaying = false;
        let animPropPreviewFrame = 0;
        let animPropPreviewInterval = null;
        let placedAnimProps = []; // Animated props placed on map: { propIndex, x, y, layer } (grid coords like tiles)
        // Drag selection for multi-tile frames
        let animPropDragStart = null; // {gridX, gridY}
        let animPropDragEnd = null; // {gridX, gridY}
        let animPropIsDragging = false;
        // Animation state for placed props in editor
        let placedAnimPropFrames = {}; // key: "x,y,layer" -> { frame: 0, timer: 0 }
        let editorAnimInterval = null;

        // Items System (interactive props like chests)
        let items = []; // Array of item definitions { name, spriteData, frameWidth, frameHeight, frames: [{x,y,w,h},...], fps, idleFrame }
        let currentItemIndex = -1;
        let itemSpriteSheet = null; // Current sprite sheet Image
        let itemSpriteData = null; // Current sprite data URL
        let itemFrames = []; // Frames being edited
        let itemPreviewPlaying = false;
        let itemPreviewFrame = 0;
        let itemPreviewInterval = null;
        let placedItems = []; // Items placed on map: { itemIndex, x, y, layer, mapName, used: false }
        // Drag selection for multi-tile frames
        let itemDragStart = null;
        let itemDragEnd = null;
        let itemIsDragging = false;
        // Animation state for placed items in editor
        let placedItemFrames = {}; // key: "x,y,layer,map" -> { frame: 0, timer: 0, playing: false }

        // NPC System
        let npcs = []; // Array of NPC definitions { name, spriteData, frameWidth, frameHeight, animations: {...}, fps }
        let currentNpcIndex = -1;
        let placedNpcs = []; // NPCs placed on map: { npcIndex, x, y, path: [{x,y},...], trigger, speed }
        let selectedPlacedNpcIndex = -1; // Currently selected placed NPC for editing
        let npcPathDrawing = false; // Currently drawing a path
        let npcPathEditing = false; // Currently editing/moving waypoints
        let npcDraggingWaypoint = -1; // Index of waypoint being dragged (-1 = none)
        let npcEditorImage = null;

        // NPC Path Preview
        let npcPathPreviewActive = false;
        let npcPreviewAnimId = null;
        let npcPreviewState = null; // { x, y, waypointIndex, direction, frame, frameTimer }
        let npcEditorData = null;
        let npcEditorFrameW = 16;
        let npcEditorFrameH = 16;
        let npcEditorEditingIndex = -1;
        let npcEditorZoom = 3; // Zoom level for sprite sheet display
        let npcTool = 'none'; // 'none', 'collision', 'erase', 'split'
        let npcBrushSize = 4;
        let npcBrushShape = 'square'; // 'square', 'circle', 'rect'
        let npcBrushRectW = 8; // Width for rectangle brush
        let npcBrushRectH = 4; // Height for rectangle brush
        let npcBrushPreviewPos = null; // {x, y} for cursor preview
        let npcCollisionMask = null; // 2D array for collision pixels
        let npcSplitLine = null; // Y value for depth split
        let npcPainting = false;
        let npcFrames = []; // Frames being edited

        // NPC frame drag selection (for multi-tile frames)
        let npcFrameDragStart = null;   // {gridX, gridY}
        let npcFrameDragEnd = null;     // {gridX, gridY}
        let npcFrameDragging = false;
        let npcPreviewPlaying = false;
        let npcPreviewFrame = 0;
        let npcPreviewInterval = null;
        let npcPingPong = false;
        let npcPreviewDirection = 1; // 1 = forward, -1 = backward for ping-pong

        // Dialog System
        let dialogs = []; // Array of dialog configurations { name, style, colors, pages: [{speaker, text}], ... }
        let placedDialogTiles = []; // Dialog tiles (signs): { x, y, mapName, dialogIndex }
        let currentDialogIndex = -1;
        let currentDialogTileIndex = -1; // Selected dialog for tile placement
        let dialogEditorOpen = false;

        // Sound System
        let sounds = []; // Array of { name, data, duration, type: 'ambient'|'action' }
        let currentSoundIndex = -1;
        let soundAttachMode = 'tile'; // 'tile' or 'player'
        let tileSounds = {}; // "x,y" -> { soundIndex, radius, loop, volume, fadePercent }
        let playerSounds = {
            walk: { soundIndex: -1, interval: 200, volume: 0.5, pitchVariation: 0.1 },
            attack: { soundIndex: -1, volume: 0.7 }
        };
        let previewAudio = null; // For sound preview playback
        let selectedTileSoundKey = null; // Currently selected tile sound for editing

        // Lighting System (Classic 2D - no WebGL)
        let lightingSettings = {
            blobShadows: true,
            ambientEnabled: false,
            timeOfDay: 'day',  // 'dawn', 'day', 'dusk', 'night'
            playerLight: false,
            playerLightRadius: 4
        };
        const TIME_PRESETS = {
            dawn:  { r: 0, g: 0, b: 20, a: 0.45 },   // Light darkness
            day:   { r: 0, g: 0, b: 0, a: 0 },        // No overlay
            dusk:  { r: 0, g: 0, b: 20, a: 0.55 },   // Medium darkness
            night: { r: 0, g: 0, b: 20, a: 0.95 }    // Full darkness (100%)
        };
        let pointLights = {};  // "mapName:x,y" -> { radius, flicker }

        let map = [];

        // Canvas refs
        const collisionTilesetCanvas = document.getElementById('collisionTilesetCanvas');
        const collisionTilesetCtx = collisionTilesetCanvas.getContext('2d');
        const paintTilesetCanvas = document.getElementById('paintTilesetCanvas');
        const paintTilesetCtx = paintTilesetCanvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        const propTilesetCanvas = document.getElementById('propTilesetCanvas');
        const propTilesetCtx = propTilesetCanvas ? propTilesetCanvas.getContext('2d') : null;

        // ===== PROP TOOLS =====
        function setPropTool(tool) {
            propTool = tool;
            document.getElementById('propToolSelect').classList.remove('active');
            document.getElementById('propToolCollision').classList.remove('active');
            document.getElementById('propToolErase').classList.remove('active');
            document.getElementById('propTool' + tool.charAt(0).toUpperCase() + tool.slice(1)).classList.add('active');

            // Show/hide brush controls
            document.getElementById('propBrushControls').style.display =
                (tool === 'collision' || tool === 'erase') ? 'block' : 'none';

            // Update cursor
            if (propTilesetCanvas) propTilesetCanvas.style.cursor = (tool === 'select') ? 'crosshair' : 'cell';

            drawPropTileset();
        }

        function setPropBrushSize(size) {
            propBrushSize = size;
            document.querySelectorAll('[id^="propBrush"]').forEach(b => b.classList.remove('active'));
            document.getElementById('propBrush' + size).classList.add('active');
        }

        // ===== PHASE MANAGEMENT =====
        let keepLoadPhaseVisible = false; // Flag to keep loading screen visible during adventure mode
        function setPhase(phase) {
            currentPhase = phase;
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('active'));
            document.getElementById(phase + 'Phase').classList.add('active');
            // Keep loadPhase visible if flag is set (adventure mode loading)
            if (keepLoadPhaseVisible) {
                document.getElementById('loadPhase').classList.add('active');
            }

            // Start/stop editor animation loop based on phase
            if (phase === 'build') {
                startEditorAnimLoop();
            } else {
                stopEditorAnimLoop();
            }
        }

        // Animation loop for animated props in the editor
        function startEditorAnimLoop() {
            if (editorAnimInterval) return;
            editorAnimInterval = setInterval(() => {
                let needsRender = false;

                // Scan all layers for animTile cells
                for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {
                    const layer = layers[layerIdx];
                    if (!layer) continue;

                    for (let y = 0; y < layer.length; y++) {
                        if (!layer[y]) continue;
                        for (let x = 0; x < layer[y].length; x++) {
                            const cell = layer[y][x];
                            if (!cell || cell.type !== 'animTile') continue;

                            const prop = animatedProps[cell.propIndex];
                            if (!prop || !prop.frames || prop.frames.length <= 1) continue;
                            if (prop.type !== 'loop') continue;

                            const key = x + ',' + y + ',' + layerIdx;
                            if (!placedAnimPropFrames[key]) {
                                placedAnimPropFrames[key] = { frame: 0, timer: 0 };
                            }
                            placedAnimPropFrames[key].timer++;

                            const fps = prop.fps || 8;
                            const frameDelay = Math.round(60 / fps);

                            if (placedAnimPropFrames[key].timer >= frameDelay) {
                                placedAnimPropFrames[key].timer = 0;
                                placedAnimPropFrames[key].frame++;
                                needsRender = true;
                            }
                        }
                    }
                }

                if (needsRender) renderMap();
            }, 1000 / 60); // 60fps update
        }

        function stopEditorAnimLoop() {
            if (editorAnimInterval) {
                clearInterval(editorAnimInterval);
                editorAnimInterval = null;
            }
        }

        // ===== LOAD PHASE =====
        function loadTileset(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Add as first tileset
                    tilesets = [{ name: file.name, img: img, data: e.target.result }];
                    currentTilesetIndex = 0;
                    tilesetImg = img;
                    updateTilesetDropdown();
                    setPhase('collision');
                    rebuildCollisionView();
                    // Broadcast to other builders
                    broadcastEdit({ editType: 'addTileset', name: file.name, data: e.target.result });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function addTileset(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    tilesets.push({ name: file.name, img: img, data: e.target.result });
                    currentTilesetIndex = tilesets.length - 1;
                    tilesetImg = img;
                    updateTilesetDropdown();
                    drawPaintTileset();
                    drawPropTileset();
                    // Broadcast to other builders
                    broadcastEdit({ editType: 'addTileset', name: file.name, data: e.target.result });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = ''; // Reset input so same file can be selected again
        }

        function switchTileset() {
            // Legacy function - now handled by selectTilesetFromPicker
            if (tilesets[currentTilesetIndex]) {
                tilesetImg = tilesets[currentTilesetIndex].img;
            }
            selectedTileData = null;
            selectedTiles = [];
            drawPaintTileset();
            drawPropTileset();
            renderMap();
        }

        function updateTilesetDropdown() {
            // Update the picker button with current tileset
            const thumb = document.getElementById('tilesetPickerThumb');
            const name = document.getElementById('tilesetPickerName');
            const dropdown = document.getElementById('tilesetPickerDropdown');

            if (!thumb || !name || !dropdown) return;

            if (tilesets.length > 0 && tilesets[currentTilesetIndex]) {
                const ts = tilesets[currentTilesetIndex];
                thumb.src = ts.data || '';
                thumb.style.display = ts.data ? 'block' : 'none';
                name.textContent = ts.name || 'Untitled';
            } else {
                thumb.src = '';
                thumb.style.display = 'none';
                name.textContent = 'No tileset';
            }

            // Build dropdown items
            dropdown.innerHTML = '';
            tilesets.forEach((ts, i) => {
                const item = document.createElement('div');
                item.className = 'tileset-picker-item' + (i === currentTilesetIndex ? ' selected' : '');
                item.onclick = () => selectTilesetFromPicker(i);

                const itemThumb = document.createElement('img');
                itemThumb.className = 'thumb';
                itemThumb.src = ts.data || '';

                const info = document.createElement('div');
                info.className = 'info';

                const itemName = document.createElement('div');
                itemName.className = 'name';
                itemName.textContent = ts.name || 'Untitled';

                const size = document.createElement('div');
                size.className = 'size';
                if (ts.img) {
                    size.textContent = ts.img.width + ' x ' + ts.img.height + ' px';
                }

                info.appendChild(itemName);
                info.appendChild(size);
                item.appendChild(itemThumb);
                item.appendChild(info);
                dropdown.appendChild(item);
            });
        }

        function toggleTilesetPicker() {
            const dropdown = document.getElementById('tilesetPickerDropdown');
            if (dropdown) {
                dropdown.classList.toggle('open');
            }
        }

        function selectTilesetFromPicker(index) {
            currentTilesetIndex = index;
            tilesetImg = tilesets[currentTilesetIndex].img;
            selectedTileData = null;
            selectedTiles = [];

            // Close dropdown
            const dropdown = document.getElementById('tilesetPickerDropdown');
            if (dropdown) dropdown.classList.remove('open');

            // Update UI
            updateTilesetDropdown();
            drawPaintTileset();
            drawPropTileset();
            renderMap();
        }

        // Close tileset picker when clicking outside
        document.addEventListener('click', function(e) {
            const picker = document.getElementById('tilesetPicker');
            const dropdown = document.getElementById('tilesetPickerDropdown');
            if (picker && dropdown && !picker.contains(e.target)) {
                dropdown.classList.remove('open');
            }
        });

        function deleteTileset() {
            if (tilesets.length === 0) {
                alert('No tileset to delete');
                return;
            }
            if (tilesets.length === 1) {
                alert('Cannot delete the only tileset. Add another one first.');
                return;
            }

            const tileset = tilesets[currentTilesetIndex];
            if (!confirm('Delete tileset "' + tileset.name + '"?\n\nTiles from this tileset on the map will become empty.')) return;

            // Remove tiles from map that use this tileset
            layers.forEach(layer => {
                for (let y = 0; y < layer.length; y++) {
                    for (let x = 0; x < layer[y].length; x++) {
                        const tile = layer[y][x];
                        if (tile && tile.tilesetIndex === currentTilesetIndex) {
                            layer[y][x] = null;
                        } else if (tile && tile.tilesetIndex > currentTilesetIndex) {
                            // Adjust indices for tilesets after the deleted one
                            tile.tilesetIndex--;
                        }
                    }
                }
            });

            // Remove collision data for this tileset
            const keysToDelete = [];
            for (const key in tileCollisions) {
                const [tsIdx] = key.split(':');
                if (parseInt(tsIdx) === currentTilesetIndex) {
                    keysToDelete.push(key);
                }
            }
            keysToDelete.forEach(key => delete tileCollisions[key]);

            // Update collision keys for tilesets after deleted one
            const updatedCollisions = {};
            for (const key in tileCollisions) {
                const [tsIdx, coords] = key.split(':');
                const idx = parseInt(tsIdx);
                if (idx > currentTilesetIndex) {
                    updatedCollisions[(idx - 1) + ':' + coords] = tileCollisions[key];
                } else {
                    updatedCollisions[key] = tileCollisions[key];
                }
            }
            tileCollisions = updatedCollisions;

            // Remove the tileset
            tilesets.splice(currentTilesetIndex, 1);

            // Update current index
            if (currentTilesetIndex >= tilesets.length) {
                currentTilesetIndex = tilesets.length - 1;
            }
            tilesetImg = tilesets[currentTilesetIndex].img;

            // Update UI
            updateTilesetDropdown();
            selectedTileData = null;
            selectedTiles = [];
            drawPaintTileset();
            renderMap();
        }

        // ===== PLAYER SPRITE =====
        function loadPlayerSprite(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                playerSpriteData = e.target.result;
                playerSpriteImg = new Image();
                playerSpriteImg.onload = () => {
                    // Update preview
                    const preview = document.getElementById('playerSpritePreview');
                    const ctx = preview.getContext('2d');
                    ctx.clearRect(0, 0, 48, 48);
                    ctx.imageSmoothingEnabled = false;
                    // Draw first frame (assuming 64x64 frames, top-left)
                    ctx.drawImage(playerSpriteImg, 0, 0, 64, 64, 0, 0, 48, 48);
                    document.getElementById('playerSpriteInfo').textContent =
                        file.name + ' (' + playerSpriteImg.naturalWidth + 'x' + playerSpriteImg.naturalHeight + ')';
                };
                playerSpriteImg.src = playerSpriteData;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function updatePlayerSpritePreview() {
            const preview = document.getElementById('playerSpritePreview');
            if (!preview) return;
            const ctx = preview.getContext('2d');
            ctx.clearRect(0, 0, 48, 48);

            if (playerSpriteImg && playerSpriteImg.complete && playerSpriteImg.naturalWidth > 0) {
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(playerSpriteImg, 0, 0, 64, 64, 0, 0, 48, 48);
            }
        }

        // ===== COLLISION PHASE =====
        function rebuildCollisionView() {
            gridSize = parseInt(document.getElementById('gridSize').value);
            drawCollisionTileset();
            updateCollisionStats();
        }

        function drawCollisionTileset() {
            if (!tilesetImg) return;

            collisionTilesetCanvas.width = tilesetImg.naturalWidth * collisionZoom;
            collisionTilesetCanvas.height = tilesetImg.naturalHeight * collisionZoom;

            collisionTilesetCtx.imageSmoothingEnabled = false;
            collisionTilesetCtx.drawImage(tilesetImg, 0, 0, collisionTilesetCanvas.width, collisionTilesetCanvas.height);

            // Grid
            collisionTilesetCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            const cols = Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = Math.floor(tilesetImg.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(x * gridSize * collisionZoom, 0);
                collisionTilesetCtx.lineTo(x * gridSize * collisionZoom, collisionTilesetCanvas.height);
                collisionTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(0, y * gridSize * collisionZoom);
                collisionTilesetCtx.lineTo(collisionTilesetCanvas.width, y * gridSize * collisionZoom);
                collisionTilesetCtx.stroke();
            }

            // Draw pixel collision masks (only for current tileset)
            collisionTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            const keyPrefix = currentTilesetIndex + ':';
            for (let key in collisionMasks) {
                // Only show collisions for current tileset
                if (!key.startsWith(keyPrefix)) continue;

                const mask = collisionMasks[key];
                if (!mask) continue;

                // Parse key format: "tilesetIndex:x,y"
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                for (let py = 0; py < gridSize; py++) {
                    for (let px = 0; px < gridSize; px++) {
                        if (mask[py] && mask[py][px]) {
                            collisionTilesetCtx.fillRect(
                                (tx + px) * collisionZoom,
                                (ty + py) * collisionZoom,
                                collisionZoom,
                                collisionZoom
                            );
                        }
                    }
                }
            }

            // Draw depth split lines (cyan freeform lines)
            collisionTilesetCtx.strokeStyle = '#0ff';
            collisionTilesetCtx.lineWidth = 2;
            for (let key in tileSplitLines) {
                if (!key.startsWith(keyPrefix)) continue;

                const splitYArray = tileSplitLines[key];
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                // Draw freeform line connecting all column Y values
                collisionTilesetCtx.beginPath();
                for (let col = 0; col < gridSize; col++) {
                    const splitY = Array.isArray(splitYArray) ? splitYArray[col] : splitYArray;
                    const lineX = (tx + col + 0.5) * collisionZoom;
                    const lineY = (ty + splitY) * collisionZoom;
                    if (col === 0) {
                        collisionTilesetCtx.moveTo(lineX, lineY);
                    } else {
                        collisionTilesetCtx.lineTo(lineX, lineY);
                    }
                }
                collisionTilesetCtx.stroke();

                // Fill canopy region with semi-transparent cyan
                collisionTilesetCtx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(tx * collisionZoom, ty * collisionZoom);
                for (let col = 0; col < gridSize; col++) {
                    const splitY = Array.isArray(splitYArray) ? splitYArray[col] : splitYArray;
                    const lineX = (tx + col + 0.5) * collisionZoom;
                    const lineY = (ty + splitY) * collisionZoom;
                    collisionTilesetCtx.lineTo(lineX, lineY);
                }
                collisionTilesetCtx.lineTo((tx + gridSize) * collisionZoom, ty * collisionZoom);
                collisionTilesetCtx.closePath();
                collisionTilesetCtx.fill();

                // Draw "C" for canopy and "T" for trunk
                const avgSplitY = Array.isArray(splitYArray)
                    ? splitYArray.reduce((a, b) => a + b, 0) / splitYArray.length
                    : splitYArray;
                collisionTilesetCtx.fillStyle = '#0ff';
                collisionTilesetCtx.font = (collisionZoom * 2) + 'px sans-serif';
                collisionTilesetCtx.textAlign = 'center';
                collisionTilesetCtx.fillText('C', tx * collisionZoom + gridSize * collisionZoom / 2, (ty + avgSplitY / 2) * collisionZoom);
                collisionTilesetCtx.fillText('T', tx * collisionZoom + gridSize * collisionZoom / 2, (ty + avgSplitY + (gridSize - avgSplitY) / 2) * collisionZoom);
            }

            // Highlight selected split tile
            if (selectedSplitTile && collisionTool === 'split') {
                collisionTilesetCtx.strokeStyle = '#ff0';
                collisionTilesetCtx.lineWidth = 3;
                collisionTilesetCtx.strokeRect(
                    selectedSplitTile.x * collisionZoom,
                    selectedSplitTile.y * collisionZoom,
                    gridSize * collisionZoom,
                    gridSize * collisionZoom
                );
            }

            // Draw cyan brush preview
            if (brushPreviewPos && (collisionTool === 'paint' || collisionTool === 'erase')) {
                const bx = brushPreviewPos.x;
                const by = brushPreviewPos.y;
                collisionTilesetCtx.strokeStyle = collisionTool === 'erase' ? '#ff0' : '#0ff';
                collisionTilesetCtx.lineWidth = 2;
                collisionTilesetCtx.setLineDash([4, 4]);

                if (brushShape === 'square') {
                    const half = Math.floor(brushSize / 2);
                    collisionTilesetCtx.strokeRect(
                        (bx - half) * collisionZoom,
                        (by - half) * collisionZoom,
                        brushSize * collisionZoom,
                        brushSize * collisionZoom
                    );
                } else if (brushShape === 'circle') {
                    const radius = (brushSize / 2) * collisionZoom;
                    collisionTilesetCtx.beginPath();
                    collisionTilesetCtx.arc(bx * collisionZoom, by * collisionZoom, radius, 0, Math.PI * 2);
                    collisionTilesetCtx.stroke();
                } else if (brushShape === 'rect') {
                    const halfW = Math.floor(brushRectW / 2);
                    const halfH = Math.floor(brushRectH / 2);
                    collisionTilesetCtx.strokeRect(
                        (bx - halfW) * collisionZoom,
                        (by - halfH) * collisionZoom,
                        brushRectW * collisionZoom,
                        brushRectH * collisionZoom
                    );
                }

                collisionTilesetCtx.setLineDash([]);
            }
        }

        function setCollisionZoom(z) {
            collisionZoom = z;
            document.querySelectorAll('[id^="collisionZoom"]').forEach(b => b.classList.remove('active'));
            const btn = document.querySelector(`[onclick="setCollisionZoom(${z})"]`);
            if (btn) btn.classList.add('active');
            drawCollisionTileset();
        }

        function setCollisionTool(tool) {
            collisionTool = tool;
            document.getElementById('collisionToolPaint').classList.toggle('active', tool === 'paint');
            document.getElementById('collisionToolErase').classList.toggle('active', tool === 'erase');
            document.getElementById('collisionToolSplit').classList.toggle('active', tool === 'split');

            // Show/hide split controls
            document.getElementById('splitControls').style.display = tool === 'split' ? 'block' : 'none';

            // Update cursor based on tool
            if (tool === 'split') {
                collisionTilesetCanvas.style.cursor = 'pointer';
            } else if (tool === 'erase') {
                collisionTilesetCanvas.style.cursor = 'not-allowed';
            } else {
                collisionTilesetCanvas.style.cursor = 'crosshair';
            }

            // Clear split selection when switching away
            if (tool !== 'split') {
                selectedSplitTile = null;
            }

            drawCollisionTileset();
        }

        function setBrushSize(size) {
            brushSize = size;
            document.querySelectorAll('[id^="brush"]').forEach(b => b.classList.remove('active'));
            document.getElementById('brush' + size).classList.add('active');
            drawCollisionTileset();
        }

        function setBrushShape(shape) {
            brushShape = shape;
            document.getElementById('brushShapeSquare').classList.remove('active');
            document.getElementById('brushShapeCircle').classList.remove('active');
            document.getElementById('brushShapeRect').classList.remove('active');
            document.getElementById('brushShape' + shape.charAt(0).toUpperCase() + shape.slice(1)).classList.add('active');
            document.getElementById('brushRectControls').style.display = shape === 'rect' ? 'block' : 'none';
            drawCollisionTileset();
        }

        function updateBrushRect() {
            brushRectW = parseInt(document.getElementById('brushRectW').value) || 8;
            brushRectH = parseInt(document.getElementById('brushRectH').value) || 4;
            drawCollisionTileset();
        }

        function updateCollisionStats() {
            // Only count collisions for current tileset
            const keyPrefix = currentTilesetIndex + ':';
            const count = Object.keys(tileCollisions).filter(k => k.startsWith(keyPrefix) && tileCollisions[k]).length;
            document.getElementById('collisionStats').textContent = count + ' tiles with collision (tileset ' + currentTilesetIndex + ')';
        }

        function selectAllCollision(fromNetwork = false) {
            if (!tilesetImg && !fromNetwork) return;
            const cols = fromNetwork ? 100 : Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = fromNetwork ? 100 : Math.floor(tilesetImg.naturalHeight / gridSize);
            const tilesetIdx = fromNetwork ? arguments[1] : currentTilesetIndex;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const tileX = col * gridSize;
                    const tileY = row * gridSize;
                    const key = tilesetIdx + ':' + tileX + ',' + tileY;
                    tileCollisions[key] = true;
                }
            }

            if (!fromNetwork) {
                broadcastEdit({ editType: 'selectAllCollision', tilesetIndex: currentTilesetIndex });
            }
            drawCollisionTileset();
            updateCollisionStats();
        }

        function clearAllCollision(fromNetwork = false, tilesetIdx = null) {
            if (!fromNetwork && !confirm('Clear all collision for current tileset?')) return;
            const keyPrefix = (fromNetwork ? tilesetIdx : currentTilesetIndex) + ':';
            for (let key in tileCollisions) {
                if (key.startsWith(keyPrefix)) {
                    delete tileCollisions[key];
                }
            }
            for (let key in collisionMasks) {
                if (key.startsWith(keyPrefix)) {
                    delete collisionMasks[key];
                }
            }
            if (!fromNetwork) {
                broadcastEdit({ editType: 'clearAllCollision', tilesetIndex: currentTilesetIndex });
            }
            drawCollisionTileset();
            updateCollisionStats();
        }

        // Collision canvas mouse events - pixel brush painting + pan
        collisionTilesetCanvas.addEventListener('mousedown', (e) => {
            e.preventDefault();

            // Middle mouse or shift+left = pan
            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                isPanning = true;
                panStartX = e.clientX + collisionPanX;
                panStartY = e.clientY + collisionPanY;
                collisionTilesetCanvas.style.cursor = 'grabbing';
                return;
            }

            // Handle split tool mode
            if (collisionTool === 'split' && e.button === 0) {
                handleSplitClick(e);
                return;
            }

            if (e.button === 0) {
                brushPainting = true;
                paintCollisionAt(e, collisionTool === 'paint');
            } else if (e.button === 2) {
                brushErasing = true;
                paintCollisionAt(e, false);
            }
        });

        collisionTilesetCanvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                collisionPanX = panStartX - e.clientX;
                collisionPanY = panStartY - e.clientY;
                updateCollisionScroll();
                return;
            }

            // Handle dragging split line
            if (draggingSplitLine && selectedSplitTile) {
                handleSplitDrag(e);
                return;
            }

            if (brushPainting) paintCollisionAt(e, collisionTool === 'paint');
            if (brushErasing) paintCollisionAt(e, false);

            // Update brush preview position
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);
            brushPreviewPos = { x: px, y: py };
            if (!brushPainting && !brushErasing && collisionTool !== 'split') {
                drawCollisionTileset();
            }
        });

        collisionTilesetCanvas.addEventListener('mouseleave', () => {
            brushPreviewPos = null;
            drawCollisionTileset();
        });

        collisionTilesetCanvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                collisionTilesetCanvas.style.cursor = collisionTool === 'split' ? 'pointer' : 'crosshair';
            }
            // Sync split line on drag end
            if (draggingSplitLine && modifiedSplitKey && tileSplitLines[modifiedSplitKey]) {
                console.log('[SYNC] Broadcasting splitLine:', modifiedSplitKey, 'line:', tileSplitLines[modifiedSplitKey]);
                broadcastEdit({ editType: 'splitLine', key: modifiedSplitKey, mask: tileSplitLines[modifiedSplitKey] });
                modifiedSplitKey = null;
            }
            draggingSplitLine = false;
            // Sync modified collision data
            if ((brushPainting || brushErasing) && modifiedCollisionKeys.size > 0) {
                syncModifiedCollisions();
            }
            brushPainting = false;
            brushErasing = false;
        });

        collisionTilesetCanvas.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                collisionTilesetCanvas.style.cursor = 'crosshair';
            }
            // Sync modified collision data
            if ((brushPainting || brushErasing) && modifiedCollisionKeys.size > 0) {
                syncModifiedCollisions();
            }
            brushPainting = false;
            brushErasing = false;
        });

        function syncModifiedCollisions() {
            // Send collision updates to other builders
            modifiedCollisionKeys.forEach(key => {
                if (tileCollisions[key]) {
                    broadcastEdit({ editType: 'collision', key: key, value: true });
                    if (collisionMasks[key]) {
                        broadcastEdit({ editType: 'collisionMask', key: key, mask: collisionMasks[key] });
                    }
                } else {
                    broadcastEdit({ editType: 'collision', key: key, value: false });
                }
            });
            modifiedCollisionKeys.clear();
        }

        collisionTilesetCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Touch support for collision canvas (mobile/iPad)
        collisionTilesetCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling while drawing
            const touch = e.touches[0];

            // Handle split tool mode
            if (collisionTool === 'split') {
                handleSplitClickTouch(touch);
                return;
            }

            // Start painting collision
            brushPainting = true;
            paintCollisionAtTouch(touch, collisionTool === 'paint');
        }, { passive: false });

        collisionTilesetCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling while drawing
            const touch = e.touches[0];

            // Handle dragging split line
            if (draggingSplitLine && selectedSplitTile) {
                handleSplitDragTouch(touch);
                return;
            }

            if (brushPainting) paintCollisionAtTouch(touch, collisionTool === 'paint');
        }, { passive: false });

        collisionTilesetCanvas.addEventListener('touchend', () => {
            // Sync split line on drag end
            if (draggingSplitLine && modifiedSplitKey && tileSplitLines[modifiedSplitKey]) {
                console.log('[SYNC] Broadcasting splitLine:', modifiedSplitKey, 'line:', tileSplitLines[modifiedSplitKey]);
                broadcastEdit({ editType: 'splitLine', key: modifiedSplitKey, mask: tileSplitLines[modifiedSplitKey] });
                modifiedSplitKey = null;
            }
            draggingSplitLine = false;
            if ((brushPainting || brushErasing) && modifiedCollisionKeys.size > 0) {
                syncModifiedCollisions();
            }
            brushPainting = false;
            brushErasing = false;
        });

        collisionTilesetCanvas.addEventListener('touchcancel', () => {
            // Sync split line on drag end
            if (draggingSplitLine && modifiedSplitKey && tileSplitLines[modifiedSplitKey]) {
                console.log('[SYNC] Broadcasting splitLine:', modifiedSplitKey, 'line:', tileSplitLines[modifiedSplitKey]);
                broadcastEdit({ editType: 'splitLine', key: modifiedSplitKey, mask: tileSplitLines[modifiedSplitKey] });
                modifiedSplitKey = null;
            }
            draggingSplitLine = false;
            if ((brushPainting || brushErasing) && modifiedCollisionKeys.size > 0) {
                syncModifiedCollisions();
            }
            brushPainting = false;
            brushErasing = false;
        });

        // Touch versions of paint/split functions
        function paintCollisionAtTouch(touch, addCollision) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((touch.clientX - rect.left) / collisionZoom);
            const py = Math.floor((touch.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;
            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;

            if (!collisionMasks[key]) {
                collisionMasks[key] = Array(gridSize).fill(null).map(() => Array(gridSize).fill(false));
            }

            const localX = px - tileX;
            const localY = py - tileY;
            const halfBrush = Math.floor(brushSize / 2);

            for (let by = -halfBrush; by <= halfBrush; by++) {
                for (let bx = -halfBrush; bx <= halfBrush; bx++) {
                    const targetX = localX + bx;
                    const targetY = localY + by;
                    if (targetX >= 0 && targetX < gridSize && targetY >= 0 && targetY < gridSize) {
                        collisionMasks[key][targetY][targetX] = addCollision;
                    }
                }
            }

            // Update tileCollisions
            let hasCollision = false;
            for (let y = 0; y < gridSize && !hasCollision; y++) {
                for (let x = 0; x < gridSize && !hasCollision; x++) {
                    if (collisionMasks[key][y][x]) hasCollision = true;
                }
            }
            if (hasCollision) {
                tileCollisions[key] = true;
            } else {
                delete tileCollisions[key];
                delete collisionMasks[key];
            }

            // Track for sync
            modifiedCollisionKeys.add(key);

            drawCollisionTileset();
            updateCollisionStats();
        }

        function handleSplitClickTouch(touch) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((touch.clientX - rect.left) / collisionZoom);
            const py = Math.floor((touch.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;

            selectedSplitTile = { x: tileX, y: tileY, tilesetIndex: currentTilesetIndex };
            draggingSplitLine = true;

            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;
            modifiedSplitKey = key; // Track for sync
            const localY = py - tileY;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            if (flatLineMode) {
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                document.getElementById('splitYInput').value = clampedY;
            } else {
                if (!tileSplitLines[key]) {
                    const defaultY = parseInt(document.getElementById('splitYInput').value) || Math.floor(gridSize / 2);
                    tileSplitLines[key] = new Array(gridSize).fill(defaultY);
                }
                const localX = px - tileX;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            document.getElementById('splitYInput').max = gridSize;
            drawCollisionTileset();
        }

        function handleSplitDragTouch(touch) {
            if (!selectedSplitTile || !draggingSplitLine) return;

            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((touch.clientX - rect.left) / collisionZoom);
            const py = Math.floor((touch.clientY - rect.top) / collisionZoom);

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            if (!tileSplitLines[key]) return;

            const localY = py - selectedSplitTile.y;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            if (flatLineMode) {
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                document.getElementById('splitYInput').value = clampedY;
            } else {
                const localX = px - selectedSplitTile.x;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            // Update modifiedSplitKey to ensure it stays in sync
            modifiedSplitKey = key;

            drawCollisionTileset();
        }

        // Paint collision pixels with brush
        function paintCollisionAt(e, addCollision) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            // Find which tile this pixel is in
            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;
            // Include tileset index in key so each tileset has separate collisions
            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;

            // Get or create mask for this tile
            if (!collisionMasks[key]) {
                collisionMasks[key] = [];
                for (let y = 0; y < gridSize; y++) {
                    collisionMasks[key][y] = new Array(gridSize).fill(false);
                }
            }
            const mask = collisionMasks[key];

            // Paint pixels with brush based on shape
            const half = Math.floor(brushSize / 2);
            const localX = px - tileX;
            const localY = py - tileY;

            if (brushShape === 'square') {
                for (let dy = -half; dy < half; dy++) {
                    for (let dx = -half; dx < half; dx++) {
                        const mx = localX + dx;
                        const my = localY + dy;
                        if (mx >= 0 && mx < gridSize && my >= 0 && my < gridSize) {
                            mask[my][mx] = addCollision;
                        }
                    }
                }
            } else if (brushShape === 'circle') {
                const radius = brushSize / 2;
                const radiusSq = radius * radius;
                for (let dy = -Math.ceil(radius); dy <= Math.ceil(radius); dy++) {
                    for (let dx = -Math.ceil(radius); dx <= Math.ceil(radius); dx++) {
                        if (dx * dx + dy * dy <= radiusSq) {
                            const mx = localX + dx;
                            const my = localY + dy;
                            if (mx >= 0 && mx < gridSize && my >= 0 && my < gridSize) {
                                mask[my][mx] = addCollision;
                            }
                        }
                    }
                }
            } else if (brushShape === 'rect') {
                const halfW = Math.floor(brushRectW / 2);
                const halfH = Math.floor(brushRectH / 2);
                for (let dy = -halfH; dy < halfH; dy++) {
                    for (let dx = -halfW; dx < halfW; dx++) {
                        const mx = localX + dx;
                        const my = localY + dy;
                        if (mx >= 0 && mx < gridSize && my >= 0 && my < gridSize) {
                            mask[my][mx] = addCollision;
                        }
                    }
                }
            }

            // Update tileCollisions (true if any pixel is set)
            let hasCollision = false;
            for (let y = 0; y < gridSize && !hasCollision; y++) {
                for (let x = 0; x < gridSize && !hasCollision; x++) {
                    if (mask[y][x]) hasCollision = true;
                }
            }
            if (hasCollision) {
                tileCollisions[key] = true;
            } else {
                delete tileCollisions[key];
                delete collisionMasks[key];
            }

            // Track for sync on mouseup
            modifiedCollisionKeys.add(key);

            drawCollisionTileset();
            updateCollisionStats();
        }

        // ===== DEPTH SPLIT FUNCTIONS =====
        // tileSplitLines stores an array of Y values per column for freeform lines
        // Format: "tilesetIndex:x,y" -> [y0, y1, y2, ..., y15] (one Y per column)

        function toggleFlatLineMode() {
            flatLineMode = document.getElementById('flatLineToggle').checked;
        }

        function handleSplitClick(e) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            // Find which tile was clicked
            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;

            // Select this tile for splitting
            selectedSplitTile = { x: tileX, y: tileY, tilesetIndex: currentTilesetIndex };
            draggingSplitLine = true;

            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;
            modifiedSplitKey = key; // Track for sync

            // Calculate local Y position within the tile
            const localY = py - tileY;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            // Initialize or set split line
            if (flatLineMode) {
                // Flat line mode: set entire line to clicked Y
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                // Update the Y input to show current value
                document.getElementById('splitYInput').value = clampedY;
            } else {
                // Freeform mode: initialize if doesn't exist, then set clicked column
                if (!tileSplitLines[key]) {
                    const defaultY = parseInt(document.getElementById('splitYInput').value) || Math.floor(gridSize / 2);
                    tileSplitLines[key] = new Array(gridSize).fill(defaultY);
                }
                const localX = px - tileX;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            // Update UI
            document.getElementById('splitYInput').max = gridSize;

            drawCollisionTileset();
        }

        function handleSplitDrag(e) {
            if (!selectedSplitTile || !draggingSplitLine) return;

            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            if (!tileSplitLines[key]) return;

            // Calculate local position within the tile
            const localY = py - selectedSplitTile.y;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            if (flatLineMode) {
                // Flat line mode: set entire line to current Y
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                document.getElementById('splitYInput').value = clampedY;
            } else {
                // Freeform mode: set only this column
                const localX = px - selectedSplitTile.x;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            // Update modifiedSplitKey to ensure it stays in sync
            modifiedSplitKey = key;

            drawCollisionTileset();
        }

        function setSplitLineY() {
            // Set a flat horizontal line at the specified Y
            if (!selectedSplitTile) {
                alert('Click a tile first to select it');
                return;
            }

            const splitY = parseInt(document.getElementById('splitYInput').value) || Math.floor(gridSize / 2);
            const clampedY = Math.max(0, Math.min(gridSize, splitY));

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            tileSplitLines[key] = new Array(gridSize).fill(clampedY);

            drawCollisionTileset();
        }

        function clearSelectedSplit() {
            if (!selectedSplitTile) return;

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            delete tileSplitLines[key];
            broadcastEdit({ editType: 'clearSplitLine', key: key });
            selectedSplitTile = null;

            drawCollisionTileset();
        }

        // Keyboard controls for build phase
        document.addEventListener('keydown', (e) => {
            if (currentPhase === 'build') {
                if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    rotateNext();
                }
                if (e.key === 'i' || e.key === 'I') {
                    e.preventDefault();
                    toggleFlipH();
                }
                if (e.key === 'e' || e.key === 'E') {
                    e.preventDefault();
                    toggleEraseMode();
                }
            }
        });

        // Keyboard controls for collision painter
        document.addEventListener('keydown', (e) => {
            if (currentPhase !== 'collision') return;

            // Zoom with Q/E or +/-
            if (e.key === 'e' || e.key === 'E' || e.key === '=' || e.key === '+') {
                e.preventDefault();
                if (collisionZoom < 12) setCollisionZoom(collisionZoom + 1);
                return;
            }
            if (e.key === 'q' || e.key === 'Q' || e.key === '-' || e.key === '_') {
                e.preventDefault();
                if (collisionZoom > 1) setCollisionZoom(collisionZoom - 1);
                return;
            }

            // Arrow keys to pan
            const panSpeed = 50;
            let moved = false;

            if (e.key === 'ArrowLeft') { collisionPanX -= panSpeed; moved = true; }
            if (e.key === 'ArrowRight') { collisionPanX += panSpeed; moved = true; }
            if (e.key === 'ArrowUp') { collisionPanY -= panSpeed; moved = true; }
            if (e.key === 'ArrowDown') { collisionPanY += panSpeed; moved = true; }

            if (moved) {
                e.preventDefault();
                updateCollisionScroll();
            }
        });

        function updateCollisionScroll() {
            const container = document.querySelector('.collision-main');
            // Clamp pan values
            const maxX = Math.max(0, collisionTilesetCanvas.width - container.clientWidth);
            const maxY = Math.max(0, collisionTilesetCanvas.height - container.clientHeight);
            collisionPanX = Math.max(0, Math.min(maxX, collisionPanX));
            collisionPanY = Math.max(0, Math.min(maxY, collisionPanY));

            container.scrollLeft = collisionPanX;
            container.scrollTop = collisionPanY;
        }

        let mapInitialized = false;

        function finishCollisionSetup() {
            // Only initialize map if it hasn't been created yet
            if (!mapInitialized) {
                initMap();
                mapInitialized = true;
            }
            setPhase('build');
            drawPaintTileset();
            renderMap();
            updateAnimPropListDisplay();
        }

        function goBackToCollision() {
            setPhase('collision');
            rebuildCollisionView();
        }

        // ===== BUILD PHASE =====
        function initMap() {
            // Initialize with one layer
            layers = [createEmptyLayer()];
            layerVisibility = [true];
            layerNames = [''];
            currentLayer = 0;
            map = layers[0]; // map points to current layer for compatibility
            renderLayerList();
        }

        function createEmptyLayer() {
            const layer = [];
            for (let y = 0; y < mapRows; y++) {
                layer[y] = [];
                for (let x = 0; x < mapCols; x++) {
                    layer[y][x] = null;
                }
            }
            return layer;
        }

        function addLayer(fromNetwork = false) {
            layers.push(createEmptyLayer());
            layerVisibility.push(true);
            layerNames.push('');
            currentLayer = layers.length - 1;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();

            // Broadcast to other builders
            if (!fromNetwork) {
                broadcastEdit({ editType: 'addLayer', mapName: currentMapName });
            }
        }

        function selectLayer(index) {
            currentLayer = index;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function toggleLayerVisibility(index) {
            layerVisibility[index] = !layerVisibility[index];
            renderLayerList();
            renderMap();
        }

        function deleteLayer(index, fromNetwork = false) {
            if (layers.length <= 1) return alert('Need at least one layer');
            if (!fromNetwork) {
                const layerLabel = layerNames[index] ? `"${layerNames[index]}"` : `Layer ${index}`;
                if (!confirm('Delete ' + layerLabel + '?')) return;
            }
            layers.splice(index, 1);
            layerVisibility.splice(index, 1);
            layerNames.splice(index, 1);
            if (currentLayer >= layers.length) currentLayer = layers.length - 1;
            map = layers[currentLayer];
            if (!fromNetwork) {
                broadcastEdit({ editType: 'deleteLayer', index: index, mapName: currentMapName });
            }
            renderLayerList();
            renderMap();
        }

        function moveLayerUp(index, fromNetwork = false) {
            if (index <= 0) return;
            [layers[index], layers[index-1]] = [layers[index-1], layers[index]];
            [layerVisibility[index], layerVisibility[index-1]] = [layerVisibility[index-1], layerVisibility[index]];
            [layerNames[index], layerNames[index-1]] = [layerNames[index-1], layerNames[index]];
            if (currentLayer === index) currentLayer--;
            else if (currentLayer === index - 1) currentLayer++;
            map = layers[currentLayer];
            if (!fromNetwork) {
                broadcastEdit({ editType: 'moveLayerUp', index: index, mapName: currentMapName });
            }
            renderLayerList();
            renderMap();
        }

        function moveLayerDown(index, fromNetwork = false) {
            if (index >= layers.length - 1) return;
            [layers[index], layers[index+1]] = [layers[index+1], layers[index]];
            [layerVisibility[index], layerVisibility[index+1]] = [layerVisibility[index+1], layerVisibility[index]];
            [layerNames[index], layerNames[index+1]] = [layerNames[index+1], layerNames[index]];
            if (currentLayer === index) currentLayer++;
            else if (currentLayer === index + 1) currentLayer--;
            map = layers[currentLayer];
            if (!fromNetwork) {
                broadcastEdit({ editType: 'moveLayerDown', index: index, mapName: currentMapName });
            }
            renderLayerList();
            renderMap();
        }

        function renderLayerList() {
            // Render to both layer lists (tileset mode and animProp mode)
            const lists = [
                document.getElementById('layerList'),
                document.getElementById('animPropLayerList')
            ];

            for (const list of lists) {
                if (!list) continue;
                list.innerHTML = '';

                // Insert player layer row at the right position
                // Player layer is rendered BETWEEN layers[playerLayerIndex-1] and layers[playerLayerIndex]
                // So we need to show it after displaying layer playerLayerIndex-1

                for (let i = 0; i < layers.length; i++) {
                    // If this is where the player layer should appear, show it first
                    if (i === playerLayerIndex) {
                        list.appendChild(createPlayerLayerRow());
                    }

                    const div = document.createElement('div');
                    div.style.cssText = 'display:flex; align-items:center; gap:5px; padding:5px; margin:3px 0; background:' + (i === currentLayer ? '#4af' : '#333') + '; border-radius:4px; font-size:11px;';

                    const layerLabel = layerNames[i] ? `Layer ${i} (${layerNames[i]})` : `Layer ${i}`;

                    div.innerHTML = `
                        <input type="checkbox" ${layerVisibility[i] ? 'checked' : ''} onclick="toggleLayerVisibility(${i})" title="Visibility">
                        <span style="flex:1; cursor:pointer; color:${i === currentLayer ? '#000' : '#fff'};" onclick="selectLayer(${i})">${layerLabel}</span>
                        <button onclick="renameLayer(${i})" style="padding:2px 5px; font-size:10px;" title="Rename">✎</button>
                        <button onclick="moveLayerUp(${i})" style="padding:2px 5px; font-size:10px;">↑</button>
                        <button onclick="moveLayerDown(${i})" style="padding:2px 5px; font-size:10px;">↓</button>
                        <button onclick="deleteLayer(${i})" style="padding:2px 5px; font-size:10px; background:#a55;">X</button>
                    `;
                    list.appendChild(div);
                }

                // If player layer is at the end (beyond all layers)
                if (playerLayerIndex >= layers.length) {
                    list.appendChild(createPlayerLayerRow());
                }
            }
        }

        function createPlayerLayerRow() {
            const div = document.createElement('div');
            div.style.cssText = 'display:flex; align-items:center; gap:5px; padding:5px; margin:3px 0; background:#f0a; border-radius:4px; font-size:11px;';

            div.innerHTML = `
                <input type="checkbox" ${playerPreviewVisible ? 'checked' : ''} onclick="togglePlayerPreview()" title="Visibility">
                <span style="flex:1; color:#000;">🧍 PLAYER</span>
                <span style="color:#000; font-size:9px; opacity:0.7;">locked</span>
                <button onclick="movePlayerLayerUp()" style="padding:2px 5px; font-size:10px;">↑</button>
                <button onclick="movePlayerLayerDown()" style="padding:2px 5px; font-size:10px;">↓</button>
            `;
            return div;
        }

        function togglePlayerPreview() {
            playerPreviewVisible = !playerPreviewVisible;
            renderLayerList();
            renderMap();
        }

        function toggleSetSpawnMode() {
            setSpawnMode = !setSpawnMode;
            const btn = document.getElementById('setSpawnBtn');
            const canvas = document.getElementById('mapCanvas');

            if (setSpawnMode) {
                btn.classList.add('active');
                btn.textContent = 'CLICK MAP';
                canvas.style.cursor = 'crosshair';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'SPAWN';
                canvas.style.cursor = grabToolActive ? 'grab' : 'crosshair';
            }
        }

        function movePlayerLayerUp() {
            if (playerLayerIndex > 0) {
                playerLayerIndex--;
                renderLayerList();
                renderMap();
            }
        }

        function movePlayerLayerDown() {
            if (playerLayerIndex < layers.length) {
                playerLayerIndex++;
                renderLayerList();
                renderMap();
            }
        }

        function renameLayer(index, newName = null, fromNetwork = false) {
            if (!fromNetwork) {
                const currentName = layerNames[index] || '';
                newName = prompt('Enter nickname for Layer ' + index + ':', currentName);
            }
            if (newName !== null) {
                layerNames[index] = newName.trim ? newName.trim() : newName;
                if (!fromNetwork) {
                    broadcastEdit({ editType: 'renameLayer', index: index, name: layerNames[index], mapName: currentMapName });
                }
                renderLayerList();
            }
        }

        function setMode(m) {
            mode = m;
            // Sidebar tabs
            document.getElementById('tileMode').classList.toggle('active', m === 'tile');
            document.getElementById('playerMode').classList.toggle('active', m === 'player');
            document.getElementById('npcMode').classList.toggle('active', m === 'npc');
            document.getElementById('animPropMode').classList.toggle('active', m === 'animProp');
            document.getElementById('soundMode').classList.toggle('active', m === 'sound');
            document.getElementById('lightingMode').classList.toggle('active', m === 'lighting');
            document.getElementById('triggerMode').classList.toggle('active', m === 'trigger');
            document.getElementById('cameraMode').classList.toggle('active', m === 'camera');
            document.getElementById('dialogMode').classList.toggle('active', m === 'dialog');
            document.getElementById('itemMode').classList.toggle('active', m === 'item');
            // Toolbar tabs
            document.getElementById('tileMode2').classList.toggle('active', m === 'tile');
            if (document.getElementById('playerMode2')) document.getElementById('playerMode2').classList.toggle('active', m === 'player');
            document.getElementById('npcMode2').classList.toggle('active', m === 'npc');
            document.getElementById('animPropMode2').classList.toggle('active', m === 'animProp');
            document.getElementById('soundMode2').classList.toggle('active', m === 'sound');
            document.getElementById('lightingMode2').classList.toggle('active', m === 'lighting');
            document.getElementById('triggerMode2').classList.toggle('active', m === 'trigger');
            document.getElementById('cameraMode2').classList.toggle('active', m === 'camera');
            document.getElementById('dialogMode2').classList.toggle('active', m === 'dialog');
            document.getElementById('itemMode2').classList.toggle('active', m === 'item');
            document.getElementById('tileModeContent').style.display = m === 'tile' ? 'block' : 'none';
            document.getElementById('playerModeContent').style.display = m === 'player' ? 'block' : 'none';
            document.getElementById('npcModeContent').style.display = m === 'npc' ? 'block' : 'none';
            document.getElementById('animPropModeContent').style.display = m === 'animProp' ? 'block' : 'none';
            document.getElementById('soundModeContent').style.display = m === 'sound' ? 'block' : 'none';
            document.getElementById('lightingModeContent').style.display = m === 'lighting' ? 'block' : 'none';
            document.getElementById('triggerModeContent').style.display = m === 'trigger' ? 'block' : 'none';
            document.getElementById('cameraModeContent').style.display = m === 'camera' ? 'block' : 'none';
            document.getElementById('dialogModeContent').style.display = m === 'dialog' ? 'block' : 'none';
            document.getElementById('itemModeContent').style.display = m === 'item' ? 'block' : 'none';

            // Update mode label for mobile
            const labels = { tile: 'Tiles', player: 'Player', npc: 'NPCs', animProp: 'Animated', sound: 'Sounds', lighting: 'Lights', trigger: 'Triggers', camera: 'Camera', dialog: 'Dialogs', item: 'Items' };
            document.getElementById('currentModeLabel').textContent = labels[m] || m;

            // Collapse menu on mobile after selection
            document.getElementById('modeTabs').classList.remove('expanded');

            // Update lists when switching modes
            if (m === 'player') updatePlayerList();
            if (m === 'npc') updateNpcList();
            if (m === 'trigger') {
                updateMapDropdowns();
                updateTriggerList();
            }
            if (m === 'camera') {
                updateMapDropdowns();
                updateCameraBoundsInfo();
            }
            if (m === 'dialog') {
                updateDialogList();
                updateDialogNpcDropdown();
            }
            if (m === 'item') {
                updateItemList();
            }

            // Redraw map to show appropriate overlays
            renderMap();
        }

        function toggleModeMenu() {
            document.getElementById('modeTabs').classList.toggle('expanded');
        }

        // Sidebar resize functionality
        (function() {
            const panel = document.getElementById('leftPanel');
            const handle = document.getElementById('sidebarResize');
            if (!panel || !handle) return;

            let isResizing = false;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                handle.classList.add('active');
                document.body.style.cursor = 'ew-resize';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const newWidth = e.clientX;
                if (newWidth >= 100 && newWidth <= 600) {
                    panel.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                isResizing = false;
                handle.classList.remove('active');
                document.body.style.cursor = '';
            });

            // Touch support for resize
            handle.addEventListener('touchstart', (e) => {
                isResizing = true;
                handle.classList.add('active');
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!isResizing) return;
                const touch = e.touches[0];
                const newWidth = touch.clientX;
                if (newWidth >= 100 && newWidth <= 600) {
                    panel.style.width = newWidth + 'px';
                }
            }, { passive: false });

            document.addEventListener('touchend', () => {
                isResizing = false;
                handle.classList.remove('active');
            });
        })();

        // ===== SOUND MANAGEMENT =====
        function loadSound(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const audio = new Audio(e.target.result);
                audio.addEventListener('loadedmetadata', function() {
                    sounds.push({
                        name: file.name,
                        data: e.target.result,
                        duration: audio.duration || 0,
                        type: 'ambient'
                    });
                    updateSoundDropdown();
                    currentSoundIndex = sounds.length - 1;
                    const selectEl = document.getElementById('soundSelect');
                    const controlsEl = document.getElementById('soundControls');
                    if (selectEl) selectEl.value = currentSoundIndex;
                    if (controlsEl) controlsEl.style.display = 'block';
                });
                audio.addEventListener('error', function() {
                    console.error('Failed to load audio metadata');
                    // Still add the sound even if metadata fails
                    sounds.push({
                        name: file.name,
                        data: e.target.result,
                        duration: 0,
                        type: 'ambient'
                    });
                    updateSoundDropdown();
                    currentSoundIndex = sounds.length - 1;
                    const selectEl = document.getElementById('soundSelect');
                    const controlsEl = document.getElementById('soundControls');
                    if (selectEl) selectEl.value = currentSoundIndex;
                    if (controlsEl) controlsEl.style.display = 'block';
                });
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function switchSound() {
            const selectEl = document.getElementById('soundSelect');
            const controlsEl = document.getElementById('soundControls');
            currentSoundIndex = selectEl ? parseInt(selectEl.value) : -1;
            if (controlsEl) controlsEl.style.display = currentSoundIndex >= 0 ? 'block' : 'none';
            stopPreview();
        }

        function updateSoundDropdown() {
            const select = document.getElementById('soundSelect');
            if (!select) return;
            select.innerHTML = '<option value="-1">-- Select Sound --</option>';
            sounds.forEach((sound, idx) => {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = sound.name;
                select.appendChild(opt);
            });
        }

        function previewSound() {
            if (currentSoundIndex < 0 || !sounds[currentSoundIndex]) return;
            stopPreview();
            previewAudio = new Audio(sounds[currentSoundIndex].data);
            const volumeEl = document.getElementById('soundVolume');
            previewAudio.volume = volumeEl ? volumeEl.value / 100 : 0.5;
            previewAudio.play();
        }

        function stopPreview() {
            if (previewAudio) {
                previewAudio.pause();
                previewAudio.currentTime = 0;
                previewAudio = null;
            }
        }

        function setSoundAttachMode(attachMode) {
            soundAttachMode = attachMode;
            const tileBtn = document.getElementById('soundAttachTile');
            const playerBtn = document.getElementById('soundAttachPlayer');
            const tileOpts = document.getElementById('tileSoundOptions');
            const playerOpts = document.getElementById('playerSoundOptions');
            if (tileBtn) tileBtn.classList.toggle('active', attachMode === 'tile');
            if (playerBtn) playerBtn.classList.toggle('active', attachMode === 'player');
            if (tileOpts) tileOpts.style.display = attachMode === 'tile' ? 'block' : 'none';
            if (playerOpts) playerOpts.style.display = attachMode === 'player' ? 'block' : 'none';
            renderMap();
        }

        function assignPlayerSound() {
            if (currentSoundIndex < 0) {
                alert('Select a sound first');
                return;
            }
            const actionEl = document.getElementById('playerActionSelect');
            const volumeEl = document.getElementById('playerSoundVolume');
            const intervalEl = document.getElementById('walkInterval');
            const pitchEl = document.getElementById('walkPitch');

            const action = actionEl ? actionEl.value : 'walk';
            playerSounds[action].soundIndex = currentSoundIndex;
            playerSounds[action].volume = volumeEl ? volumeEl.value / 100 : 0.5;
            if (action === 'walk') {
                playerSounds.walk.interval = intervalEl ? parseInt(intervalEl.value) : 200;
                playerSounds.walk.pitchVariation = pitchEl ? parseInt(pitchEl.value) / 100 : 0.1;
            }
            updatePlayerSoundAssignments();
        }

        function updatePlayerSoundAssignments() {
            const container = document.getElementById('playerSoundAssignments');
            if (!container) return;
            let html = '';
            if (playerSounds.walk.soundIndex >= 0) {
                html += `<div>Walk: ${sounds[playerSounds.walk.soundIndex]?.name || 'Unknown'}</div>`;
            }
            if (playerSounds.attack.soundIndex >= 0) {
                html += `<div>Attack: ${sounds[playerSounds.attack.soundIndex]?.name || 'Unknown'}</div>`;
            }
            container.innerHTML = html || '<div style="color:#888;">None assigned</div>';
        }

        function updatePlayerSoundUI() {
            const actionSelect = document.getElementById('playerActionSelect');
            const walkSettings = document.getElementById('walkSoundSettings');
            if (!actionSelect || !walkSettings) return;
            const action = actionSelect.value;
            walkSettings.style.display = action === 'walk' ? 'block' : 'none';
        }

        function placeTileSound(gridX, gridY) {
            if (currentSoundIndex < 0) {
                alert('Select a sound first');
                return;
            }
            const radiusEl = document.getElementById('soundRadius');
            const loopEl = document.getElementById('soundLoop');
            const volumeEl = document.getElementById('soundVolume');
            const fadeEl = document.getElementById('soundFade');
            const key = `${currentMapName}:${gridX},${gridY}`;
            tileSounds[key] = {
                soundIndex: currentSoundIndex,
                radius: radiusEl ? parseInt(radiusEl.value) : 3,
                loop: loopEl ? loopEl.checked : true,
                volume: volumeEl ? volumeEl.value / 100 : 0.5,
                fadePercent: fadeEl ? parseInt(fadeEl.value) / 100 : 0.5
            };
            console.log('Placed tile sound:', key, tileSounds[key]);
            console.log('Total tile sounds:', Object.keys(tileSounds).length);
            // Broadcast to co-op builders
            broadcastEdit({ editType: 'tileSound', key: key, sound: tileSounds[key] });
            updatePlacedSoundsList();
            renderMap();
        }

        function removeTileSound(key) {
            delete tileSounds[key];
            // Broadcast to co-op builders
            broadcastEdit({ editType: 'removeTileSound', key: key });
            updatePlacedSoundsList();
            renderMap();
        }

        function updatePlacedSoundsList() {
            const container = document.getElementById('placedSoundsList');
            if (!container) return;
            const keys = Object.keys(tileSounds).filter(k => k.startsWith(currentMapName + ':'));
            if (keys.length === 0) {
                container.innerHTML = '<div style="color:#888;">No sounds placed</div>';
                return;
            }
            container.innerHTML = keys.map(key => {
                const ts = tileSounds[key];
                const coords = key.split(':')[1]; // Get "x,y" part after map name
                const soundName = sounds[ts.soundIndex]?.name || 'Unknown';
                const isSelected = key === selectedTileSoundKey;
                return `<div style="display:flex; justify-content:space-between; align-items:center; padding:4px; margin:2px 0; background:${isSelected ? '#4a7c59' : '#333'}; border-radius:3px; cursor:pointer;" onclick="selectTileSound('${key}')">
                    <span style="flex:1;">📍 ${coords}: ${soundName}</span>
                    <button onclick="event.stopPropagation(); removeTileSound('${key}')" style="padding:2px 6px;">×</button>
                </div>`;
            }).join('');
        }

        function selectTileSound(key) {
            if (!tileSounds[key]) return;
            selectedTileSoundKey = key;
            const ts = tileSounds[key];

            // Populate UI with current values
            const radiusEl = document.getElementById('soundRadius');
            const loopEl = document.getElementById('soundLoop');
            const volumeEl = document.getElementById('soundVolume');
            const fadeEl = document.getElementById('soundFade');
            const selectEl = document.getElementById('soundSelect');

            if (radiusEl) {
                radiusEl.value = ts.radius || 3;
                document.getElementById('soundRadiusVal').textContent = ts.radius || 3;
            }
            if (loopEl) loopEl.checked = ts.loop !== false;
            if (volumeEl) {
                volumeEl.value = (ts.volume || 0.5) * 100;
                document.getElementById('soundVolumeVal').textContent = Math.round((ts.volume || 0.5) * 100);
            }
            if (fadeEl) {
                fadeEl.value = (ts.fadePercent !== undefined ? ts.fadePercent : 0.5) * 100;
                document.getElementById('soundFadeVal').textContent = Math.round((ts.fadePercent !== undefined ? ts.fadePercent : 0.5) * 100);
            }
            if (selectEl) selectEl.value = ts.soundIndex;
            currentSoundIndex = ts.soundIndex;

            // Show edit mode indicator
            document.getElementById('soundEditMode').style.display = 'block';
            document.getElementById('editingSoundKey').textContent = key;

            updatePlacedSoundsList();
            renderMap();
        }

        function deselectTileSound() {
            selectedTileSoundKey = null;
            document.getElementById('soundEditMode').style.display = 'none';
            updatePlacedSoundsList();
            renderMap();
        }

        function saveSelectedSound() {
            if (!selectedTileSoundKey || !tileSounds[selectedTileSoundKey]) {
                alert('No sound selected to save');
                return;
            }
            if (currentSoundIndex < 0) {
                alert('Select a sound first');
                return;
            }

            const radiusEl = document.getElementById('soundRadius');
            const loopEl = document.getElementById('soundLoop');
            const volumeEl = document.getElementById('soundVolume');
            const fadeEl = document.getElementById('soundFade');

            tileSounds[selectedTileSoundKey] = {
                soundIndex: currentSoundIndex,
                radius: radiusEl ? parseInt(radiusEl.value) : 3,
                loop: loopEl ? loopEl.checked : true,
                volume: volumeEl ? volumeEl.value / 100 : 0.5,
                fadePercent: fadeEl ? parseInt(fadeEl.value) / 100 : 0.5
            };

            console.log('Updated tile sound:', selectedTileSoundKey, tileSounds[selectedTileSoundKey]);
            updatePlacedSoundsList();
            renderMap();
        }

        // ===== LIGHTING MANAGEMENT =====
        let lightingPreviewEnabled = false;

        function toggleLightingPreview() {
            lightingPreviewEnabled = !lightingPreviewEnabled;
            const btn = document.getElementById('lightingPreviewBtn');
            if (btn) {
                btn.textContent = lightingPreviewEnabled ? '👁️ Preview Lighting: ON' : '👁️ Preview Lighting: OFF';
                btn.style.background = lightingPreviewEnabled ? '#5a8a2a' : '#2a5a8a';
            }
            renderMap();
        }

        function updateLightingSettings() {
            lightingSettings.ambientEnabled = document.getElementById('ambientEnabled').checked;
            lightingSettings.blobShadows = document.getElementById('blobShadows').checked;
            lightingSettings.playerLight = document.getElementById('playerLight').checked;
            lightingSettings.playerLightRadius = parseInt(document.getElementById('playerLightRadius').value);
            renderMap();
        }

        function setTimeOfDay(time) {
            lightingSettings.timeOfDay = time;
            // Update button states
            ['dawn', 'day', 'dusk', 'night'].forEach(t => {
                const btn = document.getElementById('tod' + t.charAt(0).toUpperCase() + t.slice(1));
                if (btn) btn.classList.toggle('active', t === time);
            });
            renderMap();
        }

        function placeLightAt(x, y) {
            const key = currentMapName + ':' + x + ',' + y;
            const radius = parseInt(document.getElementById('pointLightRadius').value) || 3;
            const flicker = document.getElementById('pointLightFlicker').checked;
            pointLights[key] = { radius, flicker };
            console.log('Placed light:', key, pointLights[key]);
            // Broadcast to co-op builders
            broadcastEdit({ editType: 'light', key: key, light: pointLights[key] });
            updatePlacedLightsList();
            renderMap();
        }

        function removeLightAt(x, y) {
            const key = currentMapName + ':' + x + ',' + y;
            if (pointLights[key]) {
                delete pointLights[key];
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeLight', key: key });
                updatePlacedLightsList();
                renderMap();
            }
        }

        function removeNearestLight(x, y) {
            // Find nearest light within 1.5 tiles
            let nearestKey = null;
            let nearestDist = 1.5;
            Object.keys(pointLights).forEach(key => {
                if (!key.startsWith(currentMapName + ':')) return;
                const coords = key.split(':')[1].split(',');
                const lx = parseFloat(coords[0]);
                const ly = parseFloat(coords[1]);
                const dist = Math.sqrt((x - lx) ** 2 + (y - ly) ** 2);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestKey = key;
                }
            });
            if (nearestKey) {
                delete pointLights[nearestKey];
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeLight', key: nearestKey });
                updatePlacedLightsList();
                renderMap();
            }
        }

        function updatePlacedLightsList() {
            const container = document.getElementById('placedLightsList');
            if (!container) return;
            const keys = Object.keys(pointLights).filter(k => k.startsWith(currentMapName + ':'));
            if (keys.length === 0) {
                container.innerHTML = '<div style="color:#888;">No lights placed</div>';
                return;
            }
            container.innerHTML = keys.map(key => {
                const light = pointLights[key];
                const coords = key.split(':')[1];
                return `<div style="display:flex; justify-content:space-between; align-items:center; padding:4px; margin:2px 0; background:#333; border-radius:3px;">
                    <span style="flex:1;">💡 ${coords} (r=${light.radius}${light.flicker ? ', flicker' : ''})</span>
                    <button onclick="delete pointLights['${key}']; updatePlacedLightsList(); renderMap();" style="padding:2px 6px;">×</button>
                </div>`;
            }).join('');
        }

        function setRotation(deg) {
            tileRotation = deg;
            document.querySelectorAll('[id^="rot"]').forEach(b => b.classList.remove('active'));
            document.getElementById('rot' + deg).classList.add('active');
            updateSelectedPreview();
            renderMap(); // Update preview
            updateCursorIndicator();
            resetPrattWarning();
        }

        function rotateNext() {
            const rotations = [0, 90, 180, 270];
            const idx = rotations.indexOf(tileRotation);
            setRotation(rotations[(idx + 1) % 4]);
        }

        function toggleFlipH() {
            tileFlippedH = !tileFlippedH;
            updateFlipButton();
            updateSelectedTilePreview();
            renderMap();
            resetPrattWarning();
        }

        function updateFlipButton() {
            const btn = document.getElementById('flipBtn');
            if (btn) {
                if (tileFlippedH) {
                    btn.classList.add('active');
                    btn.innerHTML = 'FLIPPED';
                } else {
                    btn.classList.remove('active');
                    btn.innerHTML = 'Flip H';
                }
            }
            updateCursorIndicator();
        }

        // Pratt warning callback
        let prattPendingCallback = null;

        // Show Pratt warning when tiles are both rotated AND flipped
        function showPrattWarning() {
            if (prattWarningShown) return true; // Already shown, proceed
            if (tileRotation === 0 || !tileFlippedH) return true; // No warning needed

            // Show custom retro modal
            document.getElementById('prattDegrees').textContent = tileRotation + '°';
            document.getElementById('prattModal').style.display = 'flex';
            return false; // Block the action, will be handled by prattConfirm
        }

        function prattConfirm(proceed) {
            document.getElementById('prattModal').style.display = 'none';
            if (proceed) {
                prattWarningShown = true; // Don't ask again this session
                // User confirmed, trigger the paint action
                if (painting && selectedTileData) {
                    // Re-enable painting - the user confirmed
                    renderMap();
                }
            }
        }

        // Reset pratt warning when rotation or flip changes
        function resetPrattWarning() {
            prattWarningShown = false;
        }

        function toggleEraseMode() {
            eraseMode = !eraseMode;
            updateEraseButton();
        }

        function updateEraseButton() {
            const btn = document.getElementById('eraseBtn');
            if (btn) {
                if (eraseMode) {
                    btn.classList.add('active');
                    btn.innerHTML = 'ERASING';
                } else {
                    btn.classList.remove('active');
                    btn.innerHTML = 'Erase';
                }
            }
            updateCursorIndicator();
        }

        // Cursor indicator for active modes
        function updateCursorIndicator() {
            const indicator = document.getElementById('cursorIndicator');
            if (!indicator) return;

            let symbols = [];
            if (eraseMode) symbols.push('[X]');
            if (tileFlippedH) symbols.push('[FLIP]');
            if (tileRotation === 90) symbols.push('[90]');
            else if (tileRotation === 180) symbols.push('[180]');
            else if (tileRotation === 270) symbols.push('[270]');

            if (symbols.length > 0) {
                indicator.textContent = symbols.join(' ');
                indicator.style.display = 'block';
            } else {
                indicator.style.display = 'none';
            }
        }

        // Track mouse for cursor indicator
        document.addEventListener('mousemove', (e) => {
            const indicator = document.getElementById('cursorIndicator');
            if (indicator && indicator.style.display !== 'none') {
                indicator.style.left = (e.clientX + 20) + 'px';
                indicator.style.top = (e.clientY + 5) + 'px';
            }
        });

        // Draw a tile with rotation and optional horizontal flip
        function drawRotatedTile(ctx, img, srcX, srcY, srcSize, destX, destY, destSize, rotation, flipped) {
            ctx.save();
            ctx.translate(destX + destSize / 2, destY + destSize / 2);

            if (rotation !== 0) {
                ctx.rotate(rotation * Math.PI / 180);
            }
            if (flipped) {
                ctx.scale(-1, 1); // Flip horizontally
            }

            ctx.drawImage(img, srcX, srcY, srcSize, srcSize, -destSize / 2, -destSize / 2, destSize, destSize);
            ctx.restore();
        }

        // Draw player preview on map (uses actual sprite if loaded)
        function drawPlayerPreview(tileSize) {
            mapCtx.globalAlpha = 1;

            const px = playerPreviewPos.x * tileSize;
            const py = playerPreviewPos.y * tileSize;

            // Draw at ~1.7 tiles tall to match test game (playerScale default)
            const drawSize = tileSize * 1.7;

            // Draw the actual player sprite if available (idle frame = first 64x64)
            if (playerSpriteImg && playerSpriteImg.complete && playerSpriteImg.naturalWidth > 0) {
                // Draw idle frame (first frame, facing down)
                mapCtx.drawImage(playerSpriteImg, 0, 0, 64, 64, px, py, drawSize, drawSize);
            } else {
                // Fallback: simple placeholder
                mapCtx.fillStyle = '#f0a';
                mapCtx.fillRect(px + drawSize * 0.3, py + drawSize * 0.1, drawSize * 0.4, drawSize * 0.7);
                mapCtx.beginPath();
                mapCtx.arc(px + drawSize * 0.5, py + drawSize * 0.15, drawSize * 0.15, 0, Math.PI * 2);
                mapCtx.fill();
            }

            // Label
            mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
            mapCtx.font = '10px sans-serif';
            mapCtx.textAlign = 'center';
            const labelWidth = mapCtx.measureText('SPAWN').width + 6;
            mapCtx.fillRect(px + drawSize / 2 - labelWidth / 2, py - 14, labelWidth, 12);
            mapCtx.fillStyle = '#4f8';
            mapCtx.fillText('SPAWN', px + drawSize / 2, py - 4);

            // Spawn marker outline
            mapCtx.strokeStyle = '#4f8';
            mapCtx.lineWidth = 2;
            mapCtx.setLineDash([4, 4]);
            mapCtx.strokeRect(px - 2, py - 2, drawSize + 4, drawSize + 4);
            mapCtx.setLineDash([]);
        }

        function drawPaintTileset() {
            if (!tilesetImg) return;

            const displayZoom = 2;
            paintTilesetCanvas.width = tilesetImg.naturalWidth * displayZoom;
            paintTilesetCanvas.height = tilesetImg.naturalHeight * displayZoom;

            paintTilesetCtx.imageSmoothingEnabled = false;
            paintTilesetCtx.drawImage(tilesetImg, 0, 0, paintTilesetCanvas.width, paintTilesetCanvas.height);

            // Grid
            paintTilesetCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            const cols = Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = Math.floor(tilesetImg.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(x * gridSize * displayZoom, 0);
                paintTilesetCtx.lineTo(x * gridSize * displayZoom, paintTilesetCanvas.height);
                paintTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(0, y * gridSize * displayZoom);
                paintTilesetCtx.lineTo(paintTilesetCanvas.width, y * gridSize * displayZoom);
                paintTilesetCtx.stroke();
            }

            // Mark collision tiles
            for (let key in tileCollisions) {
                if (tileCollisions[key] && tileCollisions[key].length >= 3) {
                    const [tx, ty] = key.split(',').map(Number);
                    paintTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.25)';
                    paintTilesetCtx.fillRect(tx * displayZoom, ty * displayZoom, gridSize * displayZoom, gridSize * displayZoom);
                }
            }

            // Mark tiles with depth split lines (cyan indicator)
            const keyPrefix = currentTilesetIndex + ':';
            for (let key in tileSplitLines) {
                if (!key.startsWith(keyPrefix)) continue;

                const splitY = tileSplitLines[key];
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                // Draw cyan horizontal line
                paintTilesetCtx.strokeStyle = '#0ff';
                paintTilesetCtx.lineWidth = 2;
                const lineY = (ty + splitY) * displayZoom;
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(tx * displayZoom, lineY);
                paintTilesetCtx.lineTo((tx + gridSize) * displayZoom, lineY);
                paintTilesetCtx.stroke();

                // Draw small cyan dot in corner to indicate split tile
                paintTilesetCtx.fillStyle = '#0ff';
                paintTilesetCtx.beginPath();
                paintTilesetCtx.arc(tx * displayZoom + 6, ty * displayZoom + 6, 4, 0, Math.PI * 2);
                paintTilesetCtx.fill();
            }

            // Highlight selected tiles
            if (selectedTileData) {
                paintTilesetCtx.strokeStyle = '#0f0';
                paintTilesetCtx.lineWidth = 3;
                const w = (selectedTileData.width || 1) * gridSize * displayZoom;
                const h = (selectedTileData.height || 1) * gridSize * displayZoom;
                paintTilesetCtx.strokeRect(
                    selectedTileData.x * displayZoom,
                    selectedTileData.y * displayZoom,
                    w,
                    h
                );
                paintTilesetCtx.lineWidth = 1;
            }
        }

        // Multi-tile selection on tileset
        let tilesetSelecting = false;
        let tileSelectModeActive = false;

        function toggleTileSelectMode() {
            tileSelectModeActive = !tileSelectModeActive;
            const btn = document.getElementById('tileSelectModeBtn');
            const canvas = document.getElementById('paintTilesetCanvas');

            if (tileSelectModeActive) {
                btn.style.background = '#4af';
                btn.style.color = '#000';
                btn.textContent = 'Select Mode ON';
                canvas.style.touchAction = 'none';
            } else {
                btn.style.background = '#555';
                btn.style.color = 'white';
                btn.textContent = 'Select Tiles';
                canvas.style.touchAction = 'manipulation';
            }
        }

        paintTilesetCanvas.addEventListener('mousedown', (e) => {
            if (mode !== 'tile') return;
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            selectionStart = { x, y };
            tilesetSelecting = true;
        });

        paintTilesetCanvas.addEventListener('mousemove', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            updateTileSelection(e);
        });

        paintTilesetCanvas.addEventListener('mouseup', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            updateTileSelection(e);
            tilesetSelecting = false;
        });

        // Touch support for tileset selection (only when select mode is active)
        paintTilesetCanvas.addEventListener('touchstart', (e) => {
            if (mode !== 'tile') return;
            if (!tileSelectModeActive) return; // Allow scrolling when select mode is off
            e.preventDefault();
            const touch = e.touches[0];
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((touch.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((touch.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            selectionStart = { x, y };
            tilesetSelecting = true;
        }, { passive: false });

        paintTilesetCanvas.addEventListener('touchmove', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            if (!tileSelectModeActive) return;
            e.preventDefault();
            updateTileSelectionTouch(e.touches[0]);
        }, { passive: false });

        paintTilesetCanvas.addEventListener('touchend', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            tilesetSelecting = false;
        });

        function updateTileSelectionTouch(touch) {
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((touch.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((touch.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            const minX = Math.min(selectionStart.x, x);
            const minY = Math.min(selectionStart.y, y);
            const maxX = Math.max(selectionStart.x, x);
            const maxY = Math.max(selectionStart.y, y);

            selectedTiles = [];
            for (let ty = minY; ty <= maxY; ty += gridSize) {
                for (let tx = minX; tx <= maxX; tx += gridSize) {
                    selectedTiles.push({ x: tx, y: ty });
                }
            }

            const selWidth = (maxX - minX) / gridSize + 1;
            const selHeight = (maxY - minY) / gridSize + 1;

            selectedTileData = { x: minX, y: minY, width: selWidth, height: selHeight };
            drawPaintTileset();
        }

        function updateTileSelection(e) {
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            // Calculate selection rectangle
            const minX = Math.min(selectionStart.x, x);
            const minY = Math.min(selectionStart.y, y);
            const maxX = Math.max(selectionStart.x, x);
            const maxY = Math.max(selectionStart.y, y);

            // Build array of selected tiles
            selectedTiles = [];
            for (let ty = minY; ty <= maxY; ty += gridSize) {
                for (let tx = minX; tx <= maxX; tx += gridSize) {
                    selectedTiles.push({ x: tx, y: ty });
                }
            }

            // Calculate selection dimensions
            const selWidth = (maxX - minX) / gridSize + 1;
            const selHeight = (maxY - minY) / gridSize + 1;

            // Store selection bounds for painting
            selectedTileData = { x: minX, y: minY, width: selWidth, height: selHeight };
            drawPaintTileset();
        }

        function updateSelectedPreview() {
            // Preview removed
        }

        function updateSelectedTilePreview() {
            // Preview removed
        }

        // Map painting
        let painting = false;
        let erasing = false;

        mapCanvas.addEventListener('mousedown', (e) => {
            // Skip painting when grab tool is active
            if (grabToolActive) return;

            e.preventDefault();
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((e.clientX - rect.left) / tileSize);
            const y = Math.floor((e.clientY - rect.top) / tileSize);

            // DEBUG: Ctrl+Shift+Click to mark position (in pixel coords like game uses)
            if (e.ctrlKey && e.shiftKey) {
                const pixelX = (e.clientX - rect.left) / zoom;
                const pixelY = (e.clientY - rect.top) / zoom;
                window.debugClickPos = { x: Math.round(pixelX), y: Math.round(pixelY) };
                console.log('[DEBUG] Marked position:', window.debugClickPos, 'tile:', x, y);
                renderMap();
                return;
            }

            // Check if in door animation tile selection mode (only on correct map)
            if (selectingAnimTiles && pendingAnimTrigger && doorAnimMapName === currentMapName && e.button === 0) {
                // Toggle tile selection
                toggleAnimTileSelection(x, y);
                return;
            }

            // In door animation painting mode, let normal tile painting handle clicks
            // (Done button is now HTML, not on canvas)

            // Set spawn mode - click anywhere to place player spawn
            if (setSpawnMode) {
                playerPreviewPos.x = x;
                playerPreviewPos.y = y;
                spawnMapName = currentMapName; // Record which map spawn is on
                playerPreviewVisible = true;
                toggleSetSpawnMode(); // Turn off set spawn mode after placing
                renderMap();
                return;
            }

            if (copyMode) {
                // Start copy selection
                copyStart = { x, y };
                copyEnd = { x, y };
                renderMap();
                return;
            }

            // Animated prop mode - click to place, right-click to remove (no dragging)
            if (mode === 'animProp') {
                if (e.button === 0 && currentAnimPropIndex >= 0) {
                    placeAnimPropAt(x, y);
                } else if (e.button === 2) {
                    removeAnimPropAt(x, y);
                }
                return;
            }

            // Item mode - click to place interactive item, right-click to remove
            if (mode === 'item') {
                if (e.button === 0 && currentItemIndex >= 0) {
                    placeItemAt(x, y);
                } else if (e.button === 2) {
                    removeItemAt(x, y);
                }
                return;
            }

            // Sound mode - click to place/select tile sound, right-click to remove
            if (mode === 'sound' && soundAttachMode === 'tile') {
                const key = `${currentMapName}:${x},${y}`;
                if (e.button === 0) {
                    // If clicking on existing sound, select it for editing
                    if (tileSounds[key]) {
                        selectTileSound(key);
                    } else if (selectedTileSoundKey) {
                        // If a sound is selected and clicking empty tile, deselect
                        deselectTileSound();
                    } else {
                        // Place new sound
                        placeTileSound(x, y);
                    }
                } else if (e.button === 2) {
                    if (selectedTileSoundKey === key) {
                        deselectTileSound();
                    }
                    removeTileSound(key);
                }
                return;
            }

            // Lighting mode - click to place point lights (free placement), right-click to remove
            if (mode === 'lighting') {
                // Use float coordinates for free placement (not grid-snapped)
                const freeX = (e.clientX - rect.left) / tileSize;
                const freeY = (e.clientY - rect.top) / tileSize;
                if (e.button === 0) {
                    placeLightAt(freeX.toFixed(2), freeY.toFixed(2));
                } else if (e.button === 2) {
                    // Find and remove nearest light within 1 tile
                    removeNearestLight(freeX, freeY);
                }
                return;
            }

            // Trigger mode - click to place triggers, right-click to remove, drag green spawns
            if (mode === 'trigger') {
                console.log('[CLICK DEBUG] Trigger mode click at', x, y, 'button:', e.button);
                console.log('[CLICK DEBUG] settingSpawnPoint:', settingSpawnPoint, 'settingWalkOutPoint:', settingWalkOutPoint);

                // Check if we're setting walk-out point (before spawn)
                if (settingWalkOutPoint && e.button === 0) {
                    console.log('[CLICK DEBUG] Calling setWalkOutPointAt');
                    setWalkOutPointAt(x, y);
                    return;
                }

                // Check if we're setting spawn point
                if (settingSpawnPoint && e.button === 0) {
                    console.log('[CLICK DEBUG] Calling setSpawnPointAt');
                    setSpawnPointAt(x, y);
                    return;
                }

                // Check if clicking on a green spawn box (incoming trigger)
                if (e.button === 0) {
                    const incomingTriggers = placedTriggers.filter(t => t.targetMap === currentMapName && t.targetX !== null && t.targetY !== null);
                    for (const trigger of incomingTriggers) {
                        if (x === trigger.targetX && y === trigger.targetY) {
                            // Start dragging this spawn
                            draggingSpawnTrigger = trigger;
                            console.log('[DRAG] Started dragging spawn for Door', trigger.doorNumber);
                            return;
                        }
                    }
                    // Start drag to create trigger area
                    triggerDragStart = { x, y };
                    triggerDragEnd = { x, y };
                    renderMap();
                } else if (e.button === 2) {
                    removeTriggerAt(x, y);
                }
                return;
            }

            // Camera mode - click and drag to set camera bounds
            if (mode === 'camera') {
                if (settingCameraBounds && e.button === 0) {
                    cameraBoundsDragStart = { x, y };
                    cameraBoundsDragEnd = { x, y };
                    renderMap();
                }
                return;
            }

            // Dialog mode - click NPC to attach dialog, or click tile to place sign
            if (mode === 'dialog') {
                if (e.button === 0) {
                    // Check if clicking on an NPC first
                    const npcIdx = findPlacedNpcAt(x, y);
                    if (npcIdx >= 0) {
                        // Attach dialog to this NPC
                        if (currentDialogTileIndex >= 0) {
                            const triggerType = document.getElementById('dialogNpcTrigger')?.value || 'interact';
                            placedNpcs[npcIdx].dialogIndex = currentDialogTileIndex;
                            placedNpcs[npcIdx].dialogTrigger = triggerType;
                            broadcastEdit({ editType: 'attachNpcDialog', npcIndex: npcIdx, dialogIndex: currentDialogTileIndex, dialogTrigger: triggerType });
                            updateDialogNpcDropdown();
                            renderMap();
                        } else {
                            alert('Select a dialog first by clicking it in the list');
                        }
                    } else {
                        // Place dialog tile (sign)
                        placeDialogTileAt(x, y);
                    }
                } else if (e.button === 2) {
                    // Right-click: remove dialog tile or detach from NPC
                    const npcIdx = findPlacedNpcAt(x, y);
                    if (npcIdx >= 0 && placedNpcs[npcIdx].dialogIndex >= 0) {
                        // Detach dialog from NPC
                        placedNpcs[npcIdx].dialogIndex = -1;
                        delete placedNpcs[npcIdx].dialogTrigger;
                        broadcastEdit({ editType: 'attachNpcDialog', npcIndex: npcIdx, dialogIndex: -1 });
                        updateDialogNpcDropdown();
                        renderMap();
                    } else {
                        removeDialogTileAt(x, y);
                    }
                }
                return;
            }

            // NPC mode - place, select, draw path, or edit path
            if (mode === 'npc') {
                if (npcPathEditing && selectedPlacedNpcIndex >= 0) {
                    // Editing path - drag waypoints
                    const placed = placedNpcs[selectedPlacedNpcIndex];
                    if (placed && placed.path) {
                        if (e.button === 0) {
                            // Find closest waypoint to click
                            const waypointIdx = findNearestWaypoint(x, y, placed.path);
                            if (waypointIdx >= 0) {
                                npcDraggingWaypoint = waypointIdx;
                            }
                        } else if (e.button === 2) {
                            // Right-click to delete waypoint
                            const waypointIdx = findNearestWaypoint(x, y, placed.path);
                            if (waypointIdx >= 0) {
                                placed.path.splice(waypointIdx, 1);
                                updateNpcWaypointList();
                                renderMap();
                            }
                        }
                    }
                } else if (npcPathDrawing && selectedPlacedNpcIndex >= 0) {
                    // Drawing path - add waypoint
                    if (e.button === 0) {
                        addNpcWaypoint(x, y);
                    } else if (e.button === 2) {
                        // Right-click removes last waypoint
                        removeLastNpcWaypoint();
                    }
                } else if (e.button === 0) {
                    // Check if clicking on existing placed NPC
                    const clickedNpcIdx = findPlacedNpcAt(x, y);
                    if (clickedNpcIdx >= 0) {
                        selectPlacedNpc(clickedNpcIdx);
                    } else if (currentNpcIndex >= 0) {
                        // Place new NPC
                        placeNpcAt(x, y);
                    }
                } else if (e.button === 2) {
                    // Right-click to remove placed NPC
                    removeNpcAt(x, y);
                }
                return;
            }

            if (e.button === 0) {
                if (eraseMode) {
                    erasing = true;
                } else {
                    painting = true;
                }
                paintAt(x, y);
            }
            if (e.button === 2) {
                erasing = true;
                paintAt(x, y);
            }
        });

        mapCanvas.addEventListener('mousemove', (e) => {
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((e.clientX - rect.left) / tileSize);
            const y = Math.floor((e.clientY - rect.top) / tileSize);

            if (copyMode && copyStart) {
                // Update copy selection
                copyEnd = { x, y };
                renderMap();
                return;
            }

            // Handle spawn point dragging (green boxes)
            if (draggingSpawnTrigger && mode === 'trigger') {
                draggingSpawnTrigger.targetX = x;
                draggingSpawnTrigger.targetY = y;
                renderMap();
                return;
            }

            // Handle trigger area dragging (creating multi-tile triggers)
            if (triggerDragStart && mode === 'trigger') {
                triggerDragEnd = { x, y };
                renderMap();
                return;
            }

            // Handle camera bounds dragging
            if (cameraBoundsDragStart && settingCameraBounds) {
                cameraBoundsDragEnd = { x, y };
                renderMap();
                return;
            }

            // Handle waypoint dragging
            if (npcDraggingWaypoint >= 0 && selectedPlacedNpcIndex >= 0) {
                const placed = placedNpcs[selectedPlacedNpcIndex];
                if (placed && placed.path && placed.path[npcDraggingWaypoint]) {
                    placed.path[npcDraggingWaypoint].x = x;
                    placed.path[npcDraggingWaypoint].y = y;
                    updateNpcWaypointList();
                    renderMap();
                }
                return;
            }

            // Update hover position for preview
            if (hoverMapPos?.x !== x || hoverMapPos?.y !== y) {
                hoverMapPos = { x, y };
                renderMap();
            }

            if (painting || erasing) {
                paintAt(x, y);
            }
        });

        mapCanvas.addEventListener('mouseleave', () => {
            hoverMapPos = null;
            renderMap();
        });

        window.addEventListener('mouseup', (e) => {
            // Stop dragging spawn points
            if (draggingSpawnTrigger) {
                console.log('[DRAG] Stopped dragging spawn for Door', draggingSpawnTrigger.doorNumber,
                    'new position:', draggingSpawnTrigger.targetX, draggingSpawnTrigger.targetY);
                // Sync the trigger update
                const triggerIndex = placedTriggers.indexOf(draggingSpawnTrigger);
                if (triggerIndex >= 0) {
                    broadcastEdit({ editType: 'updateTrigger', index: triggerIndex, trigger: draggingSpawnTrigger });
                }
                draggingSpawnTrigger = null;
                renderMap();
            }

            // Finish trigger area drag - create multi-tile trigger
            if (triggerDragStart && triggerDragEnd) {
                const x1 = Math.min(triggerDragStart.x, triggerDragEnd.x);
                const y1 = Math.min(triggerDragStart.y, triggerDragEnd.y);
                const x2 = Math.max(triggerDragStart.x, triggerDragEnd.x);
                const y2 = Math.max(triggerDragStart.y, triggerDragEnd.y);
                const width = x2 - x1 + 1;
                const height = y2 - y1 + 1;

                // Store dimensions and show modal
                pendingTriggerWidth = width;
                pendingTriggerHeight = height;
                placeTriggerAt(x1, y1);

                triggerDragStart = null;
                triggerDragEnd = null;
                renderMap();
            }

            // Finish camera bounds drag
            if (cameraBoundsDragStart && cameraBoundsDragEnd && settingCameraBounds) {
                setCameraBoundsFromDrag();
            }

            if (copyMode && copyStart && copyEnd) {
                // Finish copy selection
                finishCopyFromMap();
            }
            // End painting/erasing stroke
            painting = false;
            erasing = false;
            // Stop waypoint dragging
            npcDraggingWaypoint = -1;
        });
        mapCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Touch support for mobile
        mapCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((touch.clientX - rect.left) / tileSize);
            const y = Math.floor((touch.clientY - rect.top) / tileSize);

            // Set spawn mode - touch to place player spawn
            if (setSpawnMode) {
                playerPreviewPos.x = x;
                playerPreviewPos.y = y;
                spawnMapName = currentMapName; // Record which map spawn is on
                playerPreviewVisible = true;
                toggleSetSpawnMode();
                renderMap();
                return;
            }

            // Copy mode - touch to start selection
            if (copyMode) {
                copyStart = { x, y };
                copyEnd = { x, y };
                renderMap();
                return;
            }

            // Animated prop mode
            if (mode === 'animProp' && currentAnimPropIndex >= 0) {
                placeAnimPropAt(x, y);
                return;
            }

            // Sound mode
            if (mode === 'sound' && soundAttachMode === 'tile') {
                const key = `${currentMapName}:${x},${y}`;
                if (tileSounds[key]) {
                    selectTileSound(key);
                } else if (!selectedTileSoundKey) {
                    placeTileSound(x, y);
                }
                renderMap();
                return;
            }

            // Default: paint tiles
            if (eraseMode) {
                erasing = true;
            } else {
                painting = true;
            }
            hoverMapPos = { x, y };
            paintAt(x, y);
            renderMap();
        }, { passive: false });

        mapCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((touch.clientX - rect.left) / tileSize);
            const y = Math.floor((touch.clientY - rect.top) / tileSize);

            // Copy mode - update selection
            if (copyMode && copyStart) {
                copyEnd = { x, y };
                renderMap();
                return;
            }

            if (hoverMapPos?.x !== x || hoverMapPos?.y !== y) {
                hoverMapPos = { x, y };
                renderMap();
            }

            if (painting || erasing) {
                paintAt(x, y);
            }
        }, { passive: false });

        mapCanvas.addEventListener('touchend', (e) => {
            // Copy mode - finish selection
            if (copyMode && copyStart && copyEnd) {
                finishCopyFromMap();
                return;
            }

            painting = false;
            erasing = false;
            hoverMapPos = null;
            renderMap();
        });

        // Animated prop placement helpers - stores directly in layer like tiles
        // Supports multi-tile props based on frame size
        // Properly rotates the entire object shape, not just individual tiles
        function placeAnimPropAt(x, y) {
            if (x < 0 || y < 0 || x >= mapCols || y >= mapRows) return;
            if (!layers[currentLayer]) return;
            if (currentAnimPropIndex < 0 || !animatedProps[currentAnimPropIndex]) return;

            const prop = animatedProps[currentAnimPropIndex];
            const frames = prop.frames || [];
            if (frames.length === 0) return;

            // Calculate how many tiles this prop spans based on first frame size
            const frame = frames[0];
            const origW = Math.ceil(frame.w / gridSize);
            const origH = Math.ceil(frame.h / gridSize);

            // Determine placed dimensions based on rotation (90/270 swap W and H)
            const rot = tileRotation;
            const placedW = (rot === 90 || rot === 270) ? origH : origW;
            const placedH = (rot === 90 || rot === 270) ? origW : origH;

            // Place tiles with proper rotation mapping
            for (let ty = 0; ty < origH; ty++) {
                for (let tx = 0; tx < origW; tx++) {
                    // Calculate rotated position on map
                    let placedTx, placedTy;
                    if (rot === 0) {
                        placedTx = tx;
                        placedTy = ty;
                    } else if (rot === 90) {
                        // 90° CW: (tx, ty) -> (origH - 1 - ty, tx)
                        placedTx = origH - 1 - ty;
                        placedTy = tx;
                    } else if (rot === 180) {
                        // 180°: (tx, ty) -> (origW - 1 - tx, origH - 1 - ty)
                        placedTx = origW - 1 - tx;
                        placedTy = origH - 1 - ty;
                    } else { // 270
                        // 270° CW: (tx, ty) -> (ty, origW - 1 - tx)
                        placedTx = ty;
                        placedTy = origW - 1 - tx;
                    }

                    const px = x + placedTx;
                    const py = y + placedTy;
                    if (px < 0 || py < 0 || px >= mapCols || py >= mapRows) continue;

                    if (!layers[currentLayer][py]) layers[currentLayer][py] = [];

                    // Store original source offset (for sprite lookup), rotation, and scale
                    layers[currentLayer][py][px] = {
                        type: 'animTile',
                        propIndex: currentAnimPropIndex,
                        offsetX: tx,  // Original source tile X (for sprite lookup)
                        offsetY: ty,  // Original source tile Y (for sprite lookup)
                        tilesW: origW,  // Original prop size
                        tilesH: origH,
                        placedW: placedW,  // Placed size (after rotation)
                        placedH: placedH,
                        rotation: rot,
                        scale: currentAnimPropScale  // Scale factor
                    };
                    // Broadcast to co-op builders
                    broadcastEdit({ editType: 'tile', layer: currentLayer, x: px, y: py, cell: layers[currentLayer][py][px], mapName: currentMapName });
                }
            }
            renderMap();
        }

        function removeAnimPropAt(x, y) {
            if (x < 0 || y < 0 || x >= mapCols || y >= mapRows) return;
            if (!layers[currentLayer] || !layers[currentLayer][y]) return;

            const cell = layers[currentLayer][y][x];
            if (cell && cell.type === 'animTile') {
                // Remove all tiles of this multi-tile prop
                const rot = cell.rotation || 0;
                const origW = cell.tilesW || 1;
                const origH = cell.tilesH || 1;
                const offsetX = cell.offsetX || 0;
                const offsetY = cell.offsetY || 0;

                // Calculate placed offset based on rotation (reverse of placement)
                let placedOffX, placedOffY;
                if (rot === 0) {
                    placedOffX = offsetX;
                    placedOffY = offsetY;
                } else if (rot === 90) {
                    placedOffX = origH - 1 - offsetY;
                    placedOffY = offsetX;
                } else if (rot === 180) {
                    placedOffX = origW - 1 - offsetX;
                    placedOffY = origH - 1 - offsetY;
                } else { // 270
                    placedOffX = offsetY;
                    placedOffY = origW - 1 - offsetX;
                }

                // Find origin (top-left of placed object)
                const originX = x - placedOffX;
                const originY = y - placedOffY;

                // Get placed dimensions
                const placedW = (rot === 90 || rot === 270) ? origH : origW;
                const placedH = (rot === 90 || rot === 270) ? origW : origH;

                // Remove all tiles in the placed rectangle
                for (let py = 0; py < placedH; py++) {
                    for (let px = 0; px < placedW; px++) {
                        const mapX = originX + px;
                        const mapY = originY + py;
                        if (mapX < 0 || mapY < 0 || mapX >= mapCols || mapY >= mapRows) continue;
                        if (layers[currentLayer][mapY]) {
                            layers[currentLayer][mapY][mapX] = null;
                            // Broadcast to co-op builders
                            broadcastEdit({ editType: 'eraseTile', layer: currentLayer, x: mapX, y: mapY, mapName: currentMapName });
                        }
                    }
                }
            }
            renderMap();
        }

        // Copy from map functions
        function startCopyFromMap() {
            copyMode = true;
            copyStart = null;
            copyEnd = null;
            copiedTiles = null;
            document.getElementById('copyFromMapBtn').classList.add('active');
            document.getElementById('copyFromMapBtn').textContent = 'Selecting...';
            document.getElementById('copyModeInfo').style.display = 'inline';
            mapCanvas.style.cursor = 'copy';
        }

        function finishCopyFromMap() {
            if (!copyStart || !copyEnd) {
                cancelCopyMode();
                return;
            }

            const minX = Math.min(copyStart.x, copyEnd.x);
            const maxX = Math.max(copyStart.x, copyEnd.x);
            const minY = Math.min(copyStart.y, copyEnd.y);
            const maxY = Math.max(copyStart.y, copyEnd.y);

            const width = maxX - minX + 1;
            const height = maxY - minY + 1;

            // Copy tiles from current layer
            copiedTiles = [];
            for (let dy = 0; dy < height; dy++) {
                copiedTiles[dy] = [];
                for (let dx = 0; dx < width; dx++) {
                    const mx = minX + dx;
                    const my = minY + dy;
                    if (my >= 0 && my < mapRows && mx >= 0 && mx < mapCols) {
                        copiedTiles[dy][dx] = map[my][mx] ? { ...map[my][mx] } : null;
                    } else {
                        copiedTiles[dy][dx] = null;
                    }
                }
            }

            // Set as selected tile data for painting
            selectedTileData = {
                isCopied: true,
                width: width,
                height: height
            };

            // Reset flip when copying from map (copied tiles have their own transforms)
            tileFlippedH = false;
            updateFlipButton();

            // Update preview
            updateCopiedPreview();

            // Exit copy mode
            copyMode = false;
            copyStart = null;
            copyEnd = null;
            document.getElementById('copyFromMapBtn').classList.remove('active');
            document.getElementById('copyFromMapBtn').textContent = 'Copy from Map';
            document.getElementById('copyModeInfo').style.display = 'none';
            mapCanvas.style.cursor = 'crosshair';
            renderMap();
        }

        function cancelCopyMode() {
            copyMode = false;
            copyStart = null;
            copyEnd = null;
            document.getElementById('copyFromMapBtn').classList.remove('active');
            document.getElementById('copyFromMapBtn').textContent = 'Copy from Map';
            document.getElementById('copyModeInfo').style.display = 'none';
            mapCanvas.style.cursor = 'crosshair';
            renderMap();
        }

        function updateCopiedPreview() {
            if (!copiedTiles || copiedTiles.length === 0) return;

            const previewCanvas = document.getElementById('selectedTile');
            if (!previewCanvas) return;
            const previewCtx = previewCanvas.getContext('2d');
            const previewSize = 48;

            // Calculate tile size to fit preview
            const width = copiedTiles[0].length;
            const height = copiedTiles.length;
            const tilePreviewSize = Math.min(previewSize / width, previewSize / height, 16);

            previewCanvas.width = previewSize;
            previewCanvas.height = previewSize;

            previewCtx.fillStyle = '#333';
            previewCtx.fillRect(0, 0, previewSize, previewSize);
            previewCtx.imageSmoothingEnabled = false;

            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    const cell = copiedTiles[dy][dx];
                    if (cell) {
                        const px = dx * tilePreviewSize;
                        const py = dy * tilePreviewSize;

                        if (cell.type === 'tile') {
                            const cellTileset = tilesets[cell.tilesetIndex || 0]?.img || tilesetImg;
                            if (cellTileset) {
                                previewCtx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tilePreviewSize, tilePreviewSize);
                            }
                        } else if (cell.type === 'prop' && propImage) {
                            previewCtx.drawImage(propImage, cell.x, cell.y, gridSize, gridSize, px, py, tilePreviewSize, tilePreviewSize);
                        }
                    }
                }
            }

            document.getElementById('selectedInfo').textContent = width + 'x' + height + ' copied';
            document.getElementById('selectedInfo').style.color = '#fff';
            document.getElementById('selectedCollisionInfo').textContent = 'From map';
        }

        function paintAt(x, y) {
            // During door animation painting, only allow painting on selected tiles (matching layer)
            if (paintingAnimTiles) {
                const isSelectedTile = selectedAnimTiles.some(t => t.x === x && t.y === y && t.layer === currentLayer);
                if (!isSelectedTile) {
                    return; // Block painting outside selected area
                }
            }

            if (!selectedTileData) {
                if (erasing && x >= 0 && x < mapCols && y >= 0 && y < mapRows) {
                    map[y][x] = null;
                    // Broadcast erase to co-op builders
                    broadcastEdit({ editType: 'eraseTile', layer: currentLayer, x: x, y: y, mapName: currentMapName });
                    renderMap();
                }
                return;
            }

            const selW = selectedTileData.width || 1;
            const selH = selectedTileData.height || 1;

            if (erasing) {
                // Erase area matching selection size
                for (let dy = 0; dy < selH; dy++) {
                    for (let dx = 0; dx < selW; dx++) {
                        const mx = x + dx;
                        const my = y + dy;
                        if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                            map[my][mx] = null;
                            // Broadcast erase to co-op builders
                            broadcastEdit({ editType: 'eraseTile', layer: currentLayer, x: mx, y: my, mapName: currentMapName });
                        }
                    }
                }
            } else if (painting) {
                // Check for flip+rotation combo (Pratt warning)
                if (!selectedTileData.isCopied && !selectedTileData.isProp && tileRotation !== 0 && tileFlippedH) {
                    if (!showPrattWarning()) {
                        return; // User cancelled
                    }
                }
                // Check if painting with copied tiles
                if (selectedTileData.isCopied && copiedTiles) {
                    // Paint copied tiles
                    for (let dy = 0; dy < selH; dy++) {
                        for (let dx = 0; dx < selW; dx++) {
                            const mx = x + dx;
                            const my = y + dy;

                            // Auto-expand map if painting at or beyond edge
                            if (my >= mapRows - 2) expandMapRows();
                            if (mx >= mapCols - 2) expandMapCols();

                            if (mx >= 0 && my >= 0 && mx < mapCols && my < mapRows) {
                                const srcCell = copiedTiles[dy] && copiedTiles[dy][dx];
                                if (srcCell) {
                                    map[my][mx] = { ...srcCell };
                                    // Broadcast tile to co-op builders
                                    broadcastEdit({ editType: 'tile', layer: currentLayer, x: mx, y: my, cell: map[my][mx], mapName: currentMapName });
                                }
                            }
                        }
                    }
                } else {
                    // Paint from tileset selection
                    for (let dy = 0; dy < selH; dy++) {
                        for (let dx = 0; dx < selW; dx++) {
                            const mx = x + dx;
                            const my = y + dy;

                            // Auto-expand map if painting at or beyond edge
                            if (my >= mapRows - 2) expandMapRows();
                            if (mx >= mapCols - 2) expandMapCols();

                            if (mx >= 0 && my >= 0 && mx < mapCols && my < mapRows) {
                                // When flipped, mirror the source tile positions horizontally
                                const srcDx = tileFlippedH ? (selW - 1 - dx) : dx;
                                const tileX = selectedTileData.x + srcDx * gridSize;
                                const tileY = selectedTileData.y + dy * gridSize;

                                if (selectedTileData.isProp) {
                                    // Paint as prop with propIndex (collision is painted separately in prop panel)
                                    map[my][mx] = { type: 'prop', x: tileX, y: tileY, propIndex: currentPropIndex };
                                } else {
                                    // Paint as tile with rotation and flip
                                    map[my][mx] = { type: 'tile', x: tileX, y: tileY, rotation: tileRotation, flipped: tileFlippedH, tilesetIndex: currentTilesetIndex };
                                }
                                // Broadcast tile to co-op builders
                                broadcastEdit({ editType: 'tile', layer: currentLayer, x: mx, y: my, cell: map[my][mx], mapName: currentMapName });
                            }
                        }
                    }
                }
            }
            renderMap();
        }

        function renderMap() {
            const tileSize = gridSize * zoom;
            mapCanvas.width = mapCols * tileSize;
            mapCanvas.height = mapRows * tileSize;

            // Background
            mapCtx.fillStyle = '#1a1a1a';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    if ((x + y) % 2 === 0) {
                        mapCtx.fillStyle = '#222';
                        mapCtx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }

            // Grid
            mapCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            for (let x = 0; x <= mapCols; x++) {
                mapCtx.beginPath();
                mapCtx.moveTo(x * tileSize, 0);
                mapCtx.lineTo(x * tileSize, mapCanvas.height);
                mapCtx.stroke();
            }
            for (let y = 0; y <= mapRows; y++) {
                mapCtx.beginPath();
                mapCtx.moveTo(0, y * tileSize);
                mapCtx.lineTo(mapCanvas.width, y * tileSize);
                mapCtx.stroke();
            }

            // Draw all visible layers (bottom to top)
            if (tilesetImg) {
                mapCtx.imageSmoothingEnabled = false;

                for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {
                    // Draw player preview at the right layer position (only on spawn map)
                    if (layerIdx === playerLayerIndex && playerPreviewVisible && currentMapName === spawnMapName) {
                        drawPlayerPreview(tileSize);
                    }

                    if (!layerVisibility[layerIdx]) continue;

                    const layerData = layers[layerIdx];
                    // Dim non-current layers slightly
                    mapCtx.globalAlpha = (layerIdx === currentLayer) ? 1 : 0.7;

                    for (let y = 0; y < mapRows; y++) {
                        for (let x = 0; x < mapCols; x++) {
                            const cell = layerData[y] && layerData[y][x];
                            if (!cell) continue;

                            const px = x * tileSize;
                            const py = y * tileSize;

                            if (cell.type === 'tile') {
                                // Use the correct tileset for this tile
                                const cellTileset = tilesets[cell.tilesetIndex || 0]?.img || tilesetImg;
                                drawRotatedTile(mapCtx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize, cell.rotation || 0, cell.flipped || false);

                                // Show collision only on current layer
                                if (layerIdx === currentLayer) {
                                    // Include tileset index in collision key lookup
                                    const tilesetIdx = cell.tilesetIndex || 0;
                                    const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                                    const collision = tileCollisions[key];
                                    if (collision && collision.length >= 3) {
                                        const scale = tileSize / gridSize;
                                        mapCtx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                                        mapCtx.beginPath();
                                        mapCtx.moveTo(px + collision[0].x * scale, py + collision[0].y * scale);
                                        for (let i = 1; i < collision.length; i++) {
                                            mapCtx.lineTo(px + collision[i].x * scale, py + collision[i].y * scale);
                                        }
                                        mapCtx.closePath();
                                        mapCtx.fill();
                                    }
                                }
                            } else if (cell.type === 'prop') {
                                // Draw prop from the correct prop image
                                const propIdx = cell.propIndex || 0;
                                const propImg = props[propIdx]?.img;
                                if (propImg) {
                                    mapCtx.drawImage(propImg, cell.x, cell.y, gridSize, gridSize, px, py, tileSize, tileSize);
                                }
                            } else if (cell.type === 'animTile') {
                                // Animated tile - cycles through frames (supports multi-tile)
                                const prop = animatedProps[cell.propIndex];
                                if (prop && prop._spriteImg && prop.frames && prop.frames.length > 0) {
                                    // Use origin tile's position for animation sync
                                    const originX = x - (cell.offsetX || 0);
                                    const originY = y - (cell.offsetY || 0);
                                    const key = originX + ',' + originY + ',' + layerIdx;
                                    const animState = placedAnimPropFrames[key] || { frame: 0 };
                                    const frameIdx = animState.frame % prop.frames.length;
                                    const frame = prop.frames[frameIdx];

                                    // Draw only this tile's portion of the frame
                                    const offsetX = cell.offsetX || 0;
                                    const offsetY = cell.offsetY || 0;
                                    const srcX = frame.x + offsetX * gridSize;
                                    const srcY = frame.y + offsetY * gridSize;

                                    // Apply scale factor
                                    const propScale = cell.scale || 1;
                                    const scaledTileSize = tileSize * propScale;
                                    const scaleOffset = (scaledTileSize - tileSize) / 2;
                                    const drawX = px - scaleOffset;
                                    const drawY = py - scaleOffset;

                                    mapCtx.imageSmoothingEnabled = false;
                                    // Draw with rotation support
                                    const rot = cell.rotation || 0;
                                    if (rot === 0) {
                                        mapCtx.drawImage(prop._spriteImg, srcX, srcY, gridSize, gridSize, drawX, drawY, scaledTileSize, scaledTileSize);
                                    } else {
                                        mapCtx.save();
                                        mapCtx.translate(px + tileSize / 2, py + tileSize / 2);
                                        mapCtx.rotate(rot * Math.PI / 180);
                                        mapCtx.drawImage(prop._spriteImg, srcX, srcY, gridSize, gridSize, -scaledTileSize / 2, -scaledTileSize / 2, scaledTileSize, scaledTileSize);
                                        mapCtx.restore();
                                    }

                                    // Show label in animProp mode (only on origin tile)
                                    if (mode === 'animProp' && offsetX === 0 && offsetY === 0) {
                                        mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
                                        mapCtx.font = '10px sans-serif';
                                        mapCtx.textAlign = 'center';
                                        const nameWidth = mapCtx.measureText(prop.name).width + 4;
                                        mapCtx.fillRect(px + tileSize / 2 - nameWidth / 2, py - 14, nameWidth, 14);
                                        mapCtx.fillStyle = '#fff';
                                        mapCtx.fillText(prop.name, px + tileSize / 2, py - 3);
                                    }
                                }
                            }
                        }
                    }
                }

                // Draw player preview at end if it's beyond all layers (only on spawn map)
                if (playerLayerIndex >= layers.length && playerPreviewVisible && currentMapName === spawnMapName) {
                    drawPlayerPreview(tileSize);
                }

                mapCtx.globalAlpha = 1;
            }

            // Draw copy selection rectangle if in copy mode
            if (copyMode && copyStart && copyEnd) {
                const minX = Math.min(copyStart.x, copyEnd.x);
                const maxX = Math.max(copyStart.x, copyEnd.x);
                const minY = Math.min(copyStart.y, copyEnd.y);
                const maxY = Math.max(copyStart.y, copyEnd.y);

                mapCtx.fillStyle = 'rgba(74, 175, 255, 0.3)';
                mapCtx.fillRect(minX * tileSize, minY * tileSize, (maxX - minX + 1) * tileSize, (maxY - minY + 1) * tileSize);

                mapCtx.strokeStyle = '#4af';
                mapCtx.lineWidth = 3;
                mapCtx.setLineDash([5, 5]);
                mapCtx.strokeRect(minX * tileSize, minY * tileSize, (maxX - minX + 1) * tileSize, (maxY - minY + 1) * tileSize);
                mapCtx.setLineDash([]);
            }

            // Draw transparent preview of selected tiles at hover position
            // Skip when in animProp mode (animProp has its own preview)
            if (hoverMapPos && selectedTileData && !copyMode && mode !== 'animProp') {
                mapCtx.globalAlpha = 0.5;
                const selW = selectedTileData.width || 1;
                const selH = selectedTileData.height || 1;

                // Check if using copied tiles
                if (selectedTileData.isCopied && copiedTiles) {
                    // Draw preview of copied tiles
                    for (let dy = 0; dy < selH; dy++) {
                        for (let dx = 0; dx < selW; dx++) {
                            const mx = hoverMapPos.x + dx;
                            const my = hoverMapPos.y + dy;
                            if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                                const srcCell = copiedTiles[dy] && copiedTiles[dy][dx];
                                if (srcCell) {
                                    const px = mx * tileSize;
                                    const py = my * tileSize;
                                    if (srcCell.type === 'tile') {
                                        const cellTileset = tilesets[srcCell.tilesetIndex || 0]?.img || tilesetImg;
                                        if (cellTileset) {
                                            drawRotatedTile(mapCtx, cellTileset, srcCell.x, srcCell.y, gridSize, px, py, tileSize, srcCell.rotation || 0, srcCell.inverted || false);
                                        }
                                    } else if (srcCell.type === 'prop') {
                                        const propIdx = srcCell.propIndex || 0;
                                        const propImg = props[propIdx]?.img;
                                        if (propImg) {
                                            mapCtx.drawImage(propImg, srcCell.x, srcCell.y, gridSize, gridSize, px, py, tileSize, tileSize);
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Draw preview from tileset/prop selection
                    const sourceImg = selectedTileData.isProp ? propImage : tilesetImg;

                    if (sourceImg) {
                        for (let dy = 0; dy < selH; dy++) {
                            for (let dx = 0; dx < selW; dx++) {
                                const mx = hoverMapPos.x + dx;
                                const my = hoverMapPos.y + dy;
                                if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                                    // Mirror source tile position when flipped
                                    const srcDx = tileFlippedH ? (selW - 1 - dx) : dx;
                                    const tileX = selectedTileData.x + srcDx * gridSize;
                                    const tileY = selectedTileData.y + dy * gridSize;
                                    const px = mx * tileSize;
                                    const py = my * tileSize;
                                    if (selectedTileData.isProp) {
                                        mapCtx.drawImage(sourceImg, tileX, tileY, gridSize, gridSize, px, py, tileSize, tileSize);
                                    } else {
                                        drawRotatedTile(mapCtx, sourceImg, tileX, tileY, gridSize, px, py, tileSize, tileRotation, tileFlippedH);
                                    }
                                }
                            }
                        }
                    }
                }

                // Draw outline
                mapCtx.globalAlpha = 1;
                mapCtx.strokeStyle = selectedTileData.isCopied ? '#ff0' : (selectedTileData.isProp ? '#4af' : '#0f0');
                mapCtx.lineWidth = 2;
                mapCtx.strokeRect(
                    hoverMapPos.x * tileSize,
                    hoverMapPos.y * tileSize,
                    selW * tileSize,
                    selH * tileSize
                );
            }

            // Draw animated prop placement preview when hovering in animProp mode
            if (mode === 'animProp' && hoverMapPos && currentAnimPropIndex >= 0 && !copyMode) {
                const prop = animatedProps[currentAnimPropIndex];
                if (prop) {
                    const frames = prop.frames || [];
                    const spriteImg = prop._spriteImg;
                    const drawX = hoverMapPos.x * tileSize;
                    const drawY = hoverMapPos.y * tileSize;

                    mapCtx.globalAlpha = 0.5;
                    if (spriteImg && frames.length > 0) {
                        const frame = frames[0];
                        // Calculate how many tiles this prop spans
                        const origW = Math.ceil(frame.w / gridSize);
                        const origH = Math.ceil(frame.h / gridSize);
                        // Apply rotation to dimensions
                        const rot = tileRotation;
                        const placedW = (rot === 90 || rot === 270) ? origH : origW;
                        const placedH = (rot === 90 || rot === 270) ? origW : origH;
                        const drawW = placedW * tileSize;
                        const drawH = placedH * tileSize;

                        mapCtx.imageSmoothingEnabled = false;
                        // Draw with rotation
                        if (rot === 0) {
                            mapCtx.drawImage(spriteImg, frame.x, frame.y, frame.w, frame.h, drawX, drawY, origW * tileSize, origH * tileSize);
                        } else {
                            mapCtx.save();
                            mapCtx.translate(drawX + drawW / 2, drawY + drawH / 2);
                            mapCtx.rotate(rot * Math.PI / 180);
                            // After rotation, draw centered
                            mapCtx.drawImage(spriteImg, frame.x, frame.y, frame.w, frame.h, -origW * tileSize / 2, -origH * tileSize / 2, origW * tileSize, origH * tileSize);
                            mapCtx.restore();
                        }

                        mapCtx.globalAlpha = 1;
                        // Draw outline around full prop area
                        mapCtx.strokeStyle = '#f0a';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(drawX, drawY, drawW, drawH);
                    } else {
                        // Placeholder preview
                        mapCtx.fillStyle = '#f0a';
                        mapCtx.fillRect(drawX + 2, drawY + 2, tileSize - 4, tileSize - 4);
                        mapCtx.globalAlpha = 1;
                        mapCtx.strokeStyle = '#f0a';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(drawX, drawY, tileSize, tileSize);
                    }
                }
            }

            // Draw sound markers when in sound mode
            if (mode === 'sound' && tileSounds) {
                Object.keys(tileSounds).forEach(key => {
                    try {
                        // Filter by current map (keys are "mapName:x,y")
                        if (!key.startsWith(currentMapName + ':')) return;
                        const coords = key.split(':')[1];
                        const parts = coords.split(',');
                        const sx = parseInt(parts[0]) || 0;
                        const sy = parseInt(parts[1]) || 0;
                        const ts = tileSounds[key];
                        if (!ts) return;

                        const px = sx * tileSize + tileSize / 2;
                        const py = sy * tileSize + tileSize / 2;
                        const radius = ts.radius || 3;
                        const isSelected = key === selectedTileSoundKey;

                        // Draw radius circle (highlighted if selected)
                        mapCtx.strokeStyle = isSelected ? 'rgba(0, 255, 100, 0.8)' : 'rgba(255, 165, 0, 0.5)';
                        mapCtx.lineWidth = isSelected ? 3 : 2;
                        mapCtx.setLineDash(isSelected ? [] : [5, 5]);
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, radius * tileSize, 0, Math.PI * 2);
                        mapCtx.stroke();
                        mapCtx.setLineDash([]);

                        // Draw fade zone indicator if selected
                        if (isSelected && ts.fadePercent > 0) {
                            const fadeStartRadius = radius * (1 - ts.fadePercent);
                            mapCtx.strokeStyle = 'rgba(0, 255, 100, 0.4)';
                            mapCtx.lineWidth = 1;
                            mapCtx.setLineDash([3, 3]);
                            mapCtx.beginPath();
                            mapCtx.arc(px, py, fadeStartRadius * tileSize, 0, Math.PI * 2);
                            mapCtx.stroke();
                            mapCtx.setLineDash([]);
                        }

                        // Draw speaker icon (highlighted if selected)
                        mapCtx.fillStyle = isSelected ? '#0f8' : (ts.loop ? '#ffa500' : '#ff6600');
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, tileSize / 4, 0, Math.PI * 2);
                        mapCtx.fill();

                        // Sound wave icon
                        mapCtx.font = `${tileSize / 3}px sans-serif`;
                        mapCtx.textAlign = 'center';
                        mapCtx.textBaseline = 'middle';
                        mapCtx.fillStyle = '#fff';
                        mapCtx.fillText('🔊', px, py);
                    } catch (e) {
                        console.error('Error drawing sound marker:', key, e);
                    }
                });
            }

            // Draw light markers when in lighting mode
            if (mode === 'lighting' && pointLights) {
                Object.keys(pointLights).forEach(key => {
                    try {
                        if (!key.startsWith(currentMapName + ':')) return;
                        const coords = key.split(':')[1];
                        const parts = coords.split(',');
                        const lx = parseInt(parts[0]) || 0;
                        const ly = parseInt(parts[1]) || 0;
                        const light = pointLights[key];
                        if (!light) return;

                        const px = lx * tileSize + tileSize / 2;
                        const py = ly * tileSize + tileSize / 2;
                        const radius = light.radius || 3;

                        // Draw light radius circle
                        mapCtx.strokeStyle = 'rgba(255, 220, 100, 0.6)';
                        mapCtx.lineWidth = 2;
                        mapCtx.setLineDash([5, 5]);
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, radius * tileSize, 0, Math.PI * 2);
                        mapCtx.stroke();
                        mapCtx.setLineDash([]);

                        // Draw light glow gradient preview
                        const gradient = mapCtx.createRadialGradient(px, py, 0, px, py, radius * tileSize);
                        gradient.addColorStop(0, 'rgba(255, 220, 100, 0.3)');
                        gradient.addColorStop(0.6, 'rgba(255, 200, 50, 0.1)');
                        gradient.addColorStop(1, 'rgba(255, 200, 50, 0)');
                        mapCtx.fillStyle = gradient;
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, radius * tileSize, 0, Math.PI * 2);
                        mapCtx.fill();

                        // Draw light bulb icon
                        mapCtx.fillStyle = light.flicker ? '#ffd700' : '#ffaa00';
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, tileSize / 4, 0, Math.PI * 2);
                        mapCtx.fill();

                        mapCtx.font = `${tileSize / 3}px sans-serif`;
                        mapCtx.textAlign = 'center';
                        mapCtx.textBaseline = 'middle';
                        mapCtx.fillStyle = '#fff';
                        mapCtx.fillText('💡', px, py);
                    } catch (e) {
                        console.error('Error drawing light marker:', key, e);
                    }
                });
            }

            // Draw triggers when in trigger mode, camera bounds when in camera mode
            if (mode === 'trigger' || mode === 'camera') {
                // Show trigger drag preview (purple box while dragging)
                if (triggerDragStart && triggerDragEnd) {
                    const x1 = Math.min(triggerDragStart.x, triggerDragEnd.x);
                    const y1 = Math.min(triggerDragStart.y, triggerDragEnd.y);
                    const x2 = Math.max(triggerDragStart.x, triggerDragEnd.x);
                    const y2 = Math.max(triggerDragStart.y, triggerDragEnd.y);
                    const w = (x2 - x1 + 1) * tileSize;
                    const h = (y2 - y1 + 1) * tileSize;

                    mapCtx.fillStyle = 'rgba(255, 0, 255, 0.4)';
                    mapCtx.fillRect(x1 * tileSize, y1 * tileSize, w, h);
                    mapCtx.strokeStyle = '#f0f';
                    mapCtx.lineWidth = 3;
                    mapCtx.setLineDash([5, 5]);
                    mapCtx.strokeRect(x1 * tileSize, y1 * tileSize, w, h);
                    mapCtx.setLineDash([]);

                    // Show dimensions
                    mapCtx.fillStyle = '#fff';
                    mapCtx.font = 'bold 12px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    const dimText = (x2 - x1 + 1) + 'x' + (y2 - y1 + 1);
                    mapCtx.fillText(dimText, x1 * tileSize + w / 2, y1 * tileSize + h / 2);
                }

                // Show spawn point marker following mouse when setting spawn
                if (settingSpawnPoint && hoverMapPos) {
                    const hx = hoverMapPos.x * tileSize;
                    const hy = hoverMapPos.y * tileSize;

                    // Green spawn box follows mouse
                    mapCtx.fillStyle = 'rgba(0, 255, 100, 0.5)';
                    mapCtx.fillRect(hx, hy, tileSize, tileSize);
                    mapCtx.strokeStyle = '#0f0';
                    mapCtx.lineWidth = 3;
                    mapCtx.strokeRect(hx, hy, tileSize, tileSize);

                    // Label
                    mapCtx.fillStyle = '#fff';
                    mapCtx.font = 'bold 10px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    const doorNum = pendingTriggerForSpawn ? pendingTriggerForSpawn.doorNumber : '?';
                    mapCtx.fillText('Door ' + doorNum, hx + tileSize / 2, hy + tileSize / 2 - 6);
                    mapCtx.fillText('SPAWN', hx + tileSize / 2, hy + tileSize / 2 + 6);

                    // Draw instruction banner at top
                    mapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    mapCtx.fillRect(0, 0, mapCanvas.width, 30);
                    mapCtx.fillStyle = '#0f0';
                    mapCtx.font = 'bold 14px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.fillText('CLICK TO PLACE SPAWN FOR DOOR ' + doorNum, mapCanvas.width / 2, 18);
                }

                // Show walk-out point marker following mouse when setting walk-out
                if (settingWalkOutPoint && hoverMapPos) {
                    const hx = hoverMapPos.x * tileSize;
                    const hy = hoverMapPos.y * tileSize;

                    // Cyan walk-out box follows mouse
                    mapCtx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                    mapCtx.fillRect(hx, hy, tileSize, tileSize);
                    mapCtx.strokeStyle = '#0ff';
                    mapCtx.lineWidth = 3;
                    mapCtx.strokeRect(hx, hy, tileSize, tileSize);

                    // Label
                    mapCtx.fillStyle = '#fff';
                    mapCtx.font = 'bold 10px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    const doorNum = pendingWalkOutTrigger ? pendingWalkOutTrigger.doorNumber : '?';
                    mapCtx.fillText('Door ' + doorNum, hx + tileSize / 2, hy + tileSize / 2 - 6);
                    mapCtx.fillText('WALK-OUT', hx + tileSize / 2, hy + tileSize / 2 + 6);

                    // Draw line from door trigger to cursor
                    if (pendingWalkOutTrigger) {
                        const startX = pendingWalkOutTrigger.x * tileSize + tileSize / 2;
                        const startY = pendingWalkOutTrigger.y * tileSize + tileSize / 2;
                        mapCtx.strokeStyle = '#0ff';
                        mapCtx.lineWidth = 2;
                        mapCtx.setLineDash([5, 5]);
                        mapCtx.beginPath();
                        mapCtx.moveTo(startX, startY);
                        mapCtx.lineTo(hx + tileSize / 2, hy + tileSize / 2);
                        mapCtx.stroke();
                        mapCtx.setLineDash([]);
                    }

                    // Draw instruction banner at top
                    mapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    mapCtx.fillRect(0, 0, mapCanvas.width, 30);
                    mapCtx.fillStyle = '#0ff';
                    mapCtx.font = 'bold 14px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.fillText('CLICK WHERE PLAYER WALKS TO BEFORE FADE (DOOR ' + doorNum + ')', mapCanvas.width / 2, 18);
                }

                // Draw triggers ON this map (purple boxes - where you enter)
                const currentTriggers = placedTriggers.filter(t => t.mapName === currentMapName);
                currentTriggers.forEach(trigger => {
                    const px = trigger.x * tileSize;
                    const py = trigger.y * tileSize;
                    const pw = (trigger.width || 1) * tileSize;
                    const ph = (trigger.height || 1) * tileSize;
                    const doorNum = trigger.doorNumber || 1;
                    const doorType = trigger.doorType || 'walkover';
                    const isExternal = doorType === 'external';

                    // Draw trigger zone fill (cyan for external, purple for internal)
                    mapCtx.fillStyle = isExternal ? 'rgba(0, 255, 255, 0.3)' : 'rgba(255, 100, 255, 0.3)';
                    mapCtx.fillRect(px, py, pw, ph);

                    // Draw border
                    mapCtx.strokeStyle = isExternal ? 'rgba(0, 255, 255, 0.8)' : 'rgba(255, 100, 255, 0.8)';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(px, py, pw, ph);

                    // Draw door number label with type indicator
                    mapCtx.fillStyle = '#fff';
                    mapCtx.font = 'bold 11px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    const typeLabel = doorType === 'interact' ? '[E]' : (isExternal ? '[EXT]' : '');
                    mapCtx.fillText('Door ' + doorNum + ' ' + typeLabel, px + pw / 2, py + ph / 2 - 5);

                    // Draw destination below
                    mapCtx.font = '9px monospace';
                    mapCtx.fillStyle = isExternal ? '#0ff' : '#f4f';
                    const destLabel = isExternal ? trigger.externalUrl : trigger.targetMap;
                    mapCtx.fillText('→ ' + destLabel, px + pw / 2, py + ph / 2 + 7);

                    // Draw walk-out point and line if set
                    if (trigger.walkOutX !== null && trigger.walkOutX !== undefined &&
                        trigger.walkOutY !== null && trigger.walkOutY !== undefined) {
                        const woX = trigger.walkOutX * tileSize;
                        const woY = trigger.walkOutY * tileSize;

                        // Draw dashed line from trigger center to walk-out
                        mapCtx.strokeStyle = '#0ff';
                        mapCtx.lineWidth = 2;
                        mapCtx.setLineDash([4, 4]);
                        mapCtx.beginPath();
                        mapCtx.moveTo(px + pw / 2, py + ph / 2);
                        mapCtx.lineTo(woX + tileSize / 2, woY + tileSize / 2);
                        mapCtx.stroke();
                        mapCtx.setLineDash([]);

                        // Draw cyan walk-out box
                        mapCtx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                        mapCtx.fillRect(woX, woY, tileSize, tileSize);
                        mapCtx.strokeStyle = '#0ff';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(woX, woY, tileSize, tileSize);

                        // Label
                        mapCtx.fillStyle = '#0ff';
                        mapCtx.font = 'bold 8px monospace';
                        mapCtx.textAlign = 'center';
                        mapCtx.textBaseline = 'middle';
                        mapCtx.fillText('WALK', woX + tileSize / 2, woY + tileSize / 2 - 4);
                        mapCtx.fillText('OUT', woX + tileSize / 2, woY + tileSize / 2 + 5);
                    }
                });

                // Draw spawn points TO this map (green boxes - where you exit/appear)
                // Only draw if spawn has been set (not null)
                const incomingTriggers = placedTriggers.filter(t => t.targetMap === currentMapName && t.targetX !== null && t.targetY !== null);
                incomingTriggers.forEach(trigger => {
                    const sx = trigger.targetX * tileSize;
                    const sy = trigger.targetY * tileSize;
                    const doorNum = trigger.doorNumber || 1;

                    // Green spawn box
                    mapCtx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    mapCtx.fillRect(sx, sy, tileSize, tileSize);
                    mapCtx.strokeStyle = '#0f0';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(sx, sy, tileSize, tileSize);

                    // Label: "Door X from [mapName]"
                    mapCtx.fillStyle = '#0f0';
                    mapCtx.font = 'bold 10px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    mapCtx.fillText('Door ' + doorNum, sx + tileSize / 2, sy + tileSize / 2 - 5);
                    mapCtx.font = '8px monospace';
                    mapCtx.fillText('from ' + trigger.mapName, sx + tileSize / 2, sy + tileSize / 2 + 6);
                });

                // Draw RETURN spawn points for external doors (cyan boxes - where you return from 3D)
                const externalReturns = placedTriggers.filter(t =>
                    t.doorType === 'external' &&
                    t.mapName === currentMapName &&
                    t.returnX !== null && t.returnY !== null
                );
                externalReturns.forEach(trigger => {
                    const sx = trigger.returnX * tileSize;
                    const sy = trigger.returnY * tileSize;
                    const doorNum = trigger.doorNumber || 1;

                    // Cyan return box
                    mapCtx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                    mapCtx.fillRect(sx, sy, tileSize, tileSize);
                    mapCtx.strokeStyle = '#0ff';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(sx, sy, tileSize, tileSize);

                    // Label: "Door X RETURN"
                    mapCtx.fillStyle = '#0ff';
                    mapCtx.font = 'bold 10px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    mapCtx.fillText('Door ' + doorNum, sx + tileSize / 2, sy + tileSize / 2 - 5);
                    mapCtx.font = '8px monospace';
                    mapCtx.fillText('RETURN', sx + tileSize / 2, sy + tileSize / 2 + 6);
                });

                // Draw dialog tiles (signs) - orange speech bubble markers
                const currentDialogTiles = placedDialogTiles.filter(t => t.mapName === currentMapName);
                currentDialogTiles.forEach(tile => {
                    const tx = tile.x * tileSize;
                    const ty = tile.y * tileSize;
                    const dialogName = dialogs[tile.dialogIndex]?.name || '?';

                    // Orange fill
                    mapCtx.fillStyle = 'rgba(255, 160, 0, 0.4)';
                    mapCtx.fillRect(tx, ty, tileSize, tileSize);

                    // Orange border
                    mapCtx.strokeStyle = '#fa0';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(tx, ty, tileSize, tileSize);

                    // Speech bubble icon (simple triangle + circle)
                    const cx = tx + tileSize / 2;
                    const cy = ty + tileSize / 2 - 3;
                    mapCtx.fillStyle = '#fff';
                    mapCtx.beginPath();
                    mapCtx.arc(cx, cy, tileSize / 4, 0, Math.PI * 2);
                    mapCtx.fill();
                    // Triangle pointer
                    mapCtx.beginPath();
                    mapCtx.moveTo(cx - 3, cy + tileSize / 4 - 2);
                    mapCtx.lineTo(cx - 6, cy + tileSize / 3 + 2);
                    mapCtx.lineTo(cx + 2, cy + tileSize / 4);
                    mapCtx.fill();

                    // Dialog name below
                    mapCtx.fillStyle = '#fa0';
                    mapCtx.font = '8px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'top';
                    mapCtx.fillText(dialogName.substring(0, 8), cx, ty + tileSize + 2);
                });

                // Draw camera bounds (yellow/orange border)
                if (cameraBounds) {
                    const bx = cameraBounds.x * tileSize;
                    const by = cameraBounds.y * tileSize;
                    const bw = cameraBounds.width * tileSize;
                    const bh = cameraBounds.height * tileSize;

                    // Semi-transparent fill outside bounds
                    mapCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    // Top
                    mapCtx.fillRect(0, 0, mapCanvas.width, by);
                    // Bottom
                    mapCtx.fillRect(0, by + bh, mapCanvas.width, mapCanvas.height - (by + bh));
                    // Left
                    mapCtx.fillRect(0, by, bx, bh);
                    // Right
                    mapCtx.fillRect(bx + bw, by, mapCanvas.width - (bx + bw), bh);

                    // Draw bounds border
                    mapCtx.strokeStyle = '#fa0';
                    mapCtx.lineWidth = 3;
                    mapCtx.setLineDash([8, 4]);
                    mapCtx.strokeRect(bx, by, bw, bh);
                    mapCtx.setLineDash([]);

                    // Label
                    mapCtx.fillStyle = '#fa0';
                    mapCtx.font = 'bold 11px monospace';
                    mapCtx.textAlign = 'left';
                    mapCtx.textBaseline = 'top';
                    mapCtx.fillText('CAMERA BOUNDS', bx + 5, by + 5);
                }

                // Draw camera bounds preview while dragging
                if (settingCameraBounds && cameraBoundsDragStart && cameraBoundsDragEnd) {
                    const x1 = Math.min(cameraBoundsDragStart.x, cameraBoundsDragEnd.x);
                    const y1 = Math.min(cameraBoundsDragStart.y, cameraBoundsDragEnd.y);
                    const x2 = Math.max(cameraBoundsDragStart.x, cameraBoundsDragEnd.x);
                    const y2 = Math.max(cameraBoundsDragStart.y, cameraBoundsDragEnd.y);
                    const w = (x2 - x1 + 1) * tileSize;
                    const h = (y2 - y1 + 1) * tileSize;

                    mapCtx.fillStyle = 'rgba(255, 170, 0, 0.2)';
                    mapCtx.fillRect(x1 * tileSize, y1 * tileSize, w, h);
                    mapCtx.strokeStyle = '#fa0';
                    mapCtx.lineWidth = 3;
                    mapCtx.strokeRect(x1 * tileSize, y1 * tileSize, w, h);

                    // Show dimensions
                    mapCtx.fillStyle = '#fff';
                    mapCtx.font = 'bold 12px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    mapCtx.fillText((x2 - x1 + 1) + 'x' + (y2 - y1 + 1) + ' tiles', x1 * tileSize + w / 2, y1 * tileSize + h / 2);
                }
            }

            // === DRAW DOOR ANIMATION SELECTED TILES (orange) ===
            // Draw regardless of mode so they show while in tile mode
            if ((selectingAnimTiles || paintingAnimTiles) && pendingAnimTrigger && doorAnimMapName === currentMapName) {
                // Highlight selected tiles with orange (only on current layer)
                selectedAnimTiles.forEach(tile => {
                    if (tile.layer !== currentLayer) return; // Only show on matching layer
                    const tx = tile.x * tileSize;
                    const ty = tile.y * tileSize;
                    mapCtx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                    mapCtx.fillRect(tx, ty, tileSize, tileSize);
                    mapCtx.strokeStyle = '#f60';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(tx, ty, tileSize, tileSize);
                });
            }

            // === DRAW PLACED NPCs AND PATHS ===
            if (mode === 'npc' || placedNpcs.length > 0) {
                const currentMapNpcs = placedNpcs.filter(p => p.mapName === currentMapName);

                currentMapNpcs.forEach((placed, idx) => {
                    const globalIdx = placedNpcs.indexOf(placed);
                    const npc = npcs[placed.npcIndex];
                    if (!npc) return;

                    const isSelected = globalIdx === selectedPlacedNpcIndex;

                    // Use preview position if preview is active for this NPC
                    const usePreview = npcPathPreviewActive && isSelected && npcPreviewState;
                    const drawX = usePreview ? npcPreviewState.x : placed.x;
                    const drawY = usePreview ? npcPreviewState.y : placed.y;
                    const px = drawX * tileSize;
                    const py = drawY * tileSize;

                    // Draw path if has waypoints (only in NPC mode, hide during preview)
                    if (placed.path && placed.path.length > 0 && mode === 'npc' && !npcPathPreviewActive) {
                        mapCtx.strokeStyle = isSelected ? '#4f4' : 'rgba(100, 255, 100, 0.5)';
                        mapCtx.lineWidth = isSelected ? 3 : 2;
                        mapCtx.setLineDash(isSelected ? [] : [5, 5]);

                        // Draw line from NPC to first waypoint
                        mapCtx.beginPath();
                        mapCtx.moveTo(px + tileSize / 2, py + tileSize / 2);

                        // Draw lines through all waypoints
                        placed.path.forEach((wp, i) => {
                            const wpx = wp.x * tileSize + tileSize / 2;
                            const wpy = wp.y * tileSize + tileSize / 2;
                            mapCtx.lineTo(wpx, wpy);
                        });

                        // If loop trigger, connect back to start
                        if (placed.trigger === 'loop') {
                            mapCtx.lineTo(px + tileSize / 2, py + tileSize / 2);
                        }

                        mapCtx.stroke();
                        mapCtx.setLineDash([]);

                        // Draw waypoint markers
                        placed.path.forEach((wp, i) => {
                            const wpx = wp.x * tileSize + tileSize / 2;
                            const wpy = wp.y * tileSize + tileSize / 2;

                            mapCtx.fillStyle = isSelected ? '#4f4' : 'rgba(100, 255, 100, 0.7)';
                            mapCtx.beginPath();
                            mapCtx.arc(wpx, wpy, 6, 0, Math.PI * 2);
                            mapCtx.fill();

                            // Number
                            mapCtx.fillStyle = '#000';
                            mapCtx.font = 'bold 10px sans-serif';
                            mapCtx.textAlign = 'center';
                            mapCtx.textBaseline = 'middle';
                            mapCtx.fillText((i + 1).toString(), wpx, wpy);
                        });
                    }

                    // Draw NPC sprite - use correct animation if previewing
                    const anims = npc.animations || {};
                    let anim;
                    let frameIdx = 0;

                    if (usePreview && npcPreviewState) {
                        // Use waypoint animation if idling, otherwise directional walk
                        const dirMap = { 'down': 'walkDown', 'up': 'walkUp', 'left': 'walkLeft', 'right': 'walkRight' };
                        if (npcPreviewState.waypointAnimation && npcPreviewState.waypointAnimation !== 'walk' &&
                            anims[npcPreviewState.waypointAnimation] && anims[npcPreviewState.waypointAnimation].length > 0) {
                            // Playing waypoint animation (idle, dance, etc.)
                            anim = anims[npcPreviewState.waypointAnimation];
                        } else {
                            // Walking animation
                            anim = anims[dirMap[npcPreviewState.direction]] || anims.walkDown || anims.idle;
                        }
                        frameIdx = npcPreviewState.frame % (anim ? anim.length : 1);
                    } else {
                        anim = anims.walkDown || anims.idle || Object.values(anims).find(a => a && a.length > 0);
                    }

                    if (npc.spriteData && anim && anim.length > 0) {
                        const frame = anim[frameIdx] || anim[0];
                        const img = npc._editorImg;

                        if (img && img.complete) {
                            mapCtx.imageSmoothingEnabled = false;
                            // Determine which animation key is being used for mirror check
                            let animKey = 'walkDown';
                            if (usePreview && npcPreviewState) {
                                if (npcPreviewState.waypointAnimation && npcPreviewState.waypointAnimation !== 'walk' &&
                                    anims[npcPreviewState.waypointAnimation] && anims[npcPreviewState.waypointAnimation].length > 0) {
                                    animKey = npcPreviewState.waypointAnimation;
                                } else {
                                    const dirMap = { 'down': 'walkDown', 'up': 'walkUp', 'left': 'walkLeft', 'right': 'walkRight' };
                                    animKey = dirMap[npcPreviewState.direction] || 'walkDown';
                                }
                            }
                            // Flip for mirrored animations OR left direction fallback
                            const animMirrors = npc.animMirrors || {};
                            const isMirrored = animMirrors[animKey];
                            const flipX = isMirrored || (usePreview && npcPreviewState && npcPreviewState.direction === 'left' && !anims.walkLeft?.length);
                            if (flipX) {
                                mapCtx.save();
                                mapCtx.translate(px + tileSize, py);
                                mapCtx.scale(-1, 1);
                                mapCtx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, tileSize, tileSize);
                                mapCtx.restore();
                            } else {
                                mapCtx.drawImage(img, frame.x, frame.y, frame.w, frame.h, px, py, tileSize, tileSize);
                            }
                        } else {
                            // Load image if not cached
                            if (!npc._editorImg) {
                                npc._editorImg = new Image();
                                npc._editorImg.onload = () => renderMap();
                                npc._editorImg.src = npc.spriteData;
                            }
                            // Draw placeholder
                            mapCtx.fillStyle = '#a4f';
                            mapCtx.fillRect(px + 4, py + 4, tileSize - 8, tileSize - 8);
                        }
                    } else {
                        // No sprite - draw placeholder
                        mapCtx.fillStyle = '#a4f';
                        mapCtx.fillRect(px + 4, py + 4, tileSize - 8, tileSize - 8);
                    }

                    // Draw selection highlight
                    if (isSelected) {
                        mapCtx.strokeStyle = '#4f4';
                        mapCtx.lineWidth = 3;
                        mapCtx.strokeRect(px, py, tileSize, tileSize);
                    }

                    // Draw enemy AI radius circles when selected
                    if (isSelected && placed.isEnemy && mode === 'npc') {
                        const centerX = px + tileSize / 2;
                        const centerY = py + tileSize / 2;

                        // Vision radius (outer ring - yellow/orange)
                        const visionRadius = (placed.visionRadius || 5) * tileSize;
                        mapCtx.strokeStyle = 'rgba(255, 200, 50, 0.8)';
                        mapCtx.lineWidth = 2;
                        mapCtx.setLineDash([8, 4]);
                        mapCtx.beginPath();
                        mapCtx.arc(centerX, centerY, visionRadius, 0, Math.PI * 2);
                        mapCtx.stroke();
                        // Fill with transparent
                        mapCtx.fillStyle = 'rgba(255, 200, 50, 0.1)';
                        mapCtx.fill();

                        // Attack radius (inner ring - red)
                        const attackRadius = (placed.attackRange || 1) * tileSize;
                        mapCtx.strokeStyle = 'rgba(255, 80, 80, 0.9)';
                        mapCtx.lineWidth = 2;
                        mapCtx.setLineDash([4, 4]);
                        mapCtx.beginPath();
                        mapCtx.arc(centerX, centerY, attackRadius, 0, Math.PI * 2);
                        mapCtx.stroke();
                        // Fill with transparent red
                        mapCtx.fillStyle = 'rgba(255, 80, 80, 0.15)';
                        mapCtx.fill();

                        mapCtx.setLineDash([]);
                    }

                    // Draw NPC name label
                    if (mode === 'npc') {
                        mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
                        mapCtx.font = '10px sans-serif';
                        mapCtx.textAlign = 'center';
                        const nameWidth = mapCtx.measureText(npc.name).width + 4;
                        mapCtx.fillRect(px + tileSize / 2 - nameWidth / 2, py - 14, nameWidth, 14);
                        mapCtx.fillStyle = isSelected ? '#4f4' : '#fff';
                        mapCtx.fillText(npc.name, px + tileSize / 2, py - 3);
                    }
                });
            }

            // === DRAW PLACED ITEMS ===
            if (mode === 'item' || placedItems.length > 0) {
                const currentMapItems = placedItems.filter(p => !p.mapName || p.mapName === currentMapName);

                currentMapItems.forEach((placed, idx) => {
                    const item = items[placed.itemIndex];
                    if (!item || !item.frames || item.frames.length === 0) return;

                    const px = placed.x * tileSize;
                    const py = placed.y * tileSize;

                    // Get idle frame
                    const idleIdx = item.idleFrame || 0;
                    const frame = item.frames[idleIdx] || item.frames[0];

                    // Load/use sprite image
                    if (!item._spriteImg && item.spriteData) {
                        item._spriteImg = new Image();
                        item._spriteImg.src = item.spriteData;
                    }

                    if (item._spriteImg && item._spriteImg.complete) {
                        mapCtx.imageSmoothingEnabled = false;
                        const drawW = (item.frameWidth / gridSize) * tileSize;
                        const drawH = (item.frameHeight / gridSize) * tileSize;
                        mapCtx.drawImage(item._spriteImg,
                            frame.x, frame.y, frame.w, frame.h,
                            px, py, drawW, drawH
                        );
                    }

                    // Draw item highlight and label in item mode
                    if (mode === 'item') {
                        mapCtx.strokeStyle = '#4f8';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(px, py, tileSize, tileSize);

                        // Name label
                        mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
                        mapCtx.font = '10px sans-serif';
                        mapCtx.textAlign = 'center';
                        const nameWidth = mapCtx.measureText(item.name).width + 4;
                        mapCtx.fillRect(px + tileSize / 2 - nameWidth / 2, py - 14, nameWidth, 14);
                        mapCtx.fillStyle = '#4f8';
                        mapCtx.fillText(item.name, px + tileSize / 2, py - 3);
                    }
                });
            }

            // === LIGHTING PREVIEW OVERLAY ===
            if (lightingPreviewEnabled && lightingSettings.ambientEnabled && lightingSettings.timeOfDay !== 'day') {
                const preset = TIME_PRESETS[lightingSettings.timeOfDay];
                if (preset && preset.a > 0) {
                    // Create offscreen canvas for lighting
                    const lightCanvas = document.createElement('canvas');
                    lightCanvas.width = mapCanvas.width;
                    lightCanvas.height = mapCanvas.height;
                    const lightCtx = lightCanvas.getContext('2d');

                    // Fill with ambient darkness
                    lightCtx.fillStyle = 'rgba(' + preset.r + ',' + preset.g + ',' + preset.b + ',' + preset.a + ')';
                    lightCtx.fillRect(0, 0, lightCanvas.width, lightCanvas.height);

                    // Cut out point lights
                    lightCtx.globalCompositeOperation = 'destination-out';
                    Object.keys(pointLights).forEach(key => {
                        if (!key.startsWith(currentMapName + ':')) return;
                        const light = pointLights[key];
                        const coords = key.split(':')[1].split(',');
                        const lx = parseFloat(coords[0]);
                        const ly = parseFloat(coords[1]);
                        const px = lx * tileSize + tileSize / 2;
                        const py = ly * tileSize + tileSize / 2;
                        const radius = light.radius * tileSize;

                        const gradient = lightCtx.createRadialGradient(px, py, 0, px, py, radius);
                        gradient.addColorStop(0, 'rgba(255,255,255,1)');
                        gradient.addColorStop(0.6, 'rgba(255,255,255,0.5)');
                        gradient.addColorStop(1, 'rgba(255,255,255,0)');
                        lightCtx.fillStyle = gradient;
                        lightCtx.beginPath();
                        lightCtx.arc(px, py, radius, 0, Math.PI * 2);
                        lightCtx.fill();
                    });

                    // Draw lighting overlay on map
                    mapCtx.drawImage(lightCanvas, 0, 0);
                }
            }

            // === DRAW INITIAL SPAWN POINT MARKER ===
            // Only show on the map where spawn is set
            if (playerPreviewPos && currentMapName === spawnMapName) {
                const spawnX = playerPreviewPos.x * tileSize;
                const spawnY = playerPreviewPos.y * tileSize;

                // Green spawn box
                mapCtx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                mapCtx.fillRect(spawnX, spawnY, tileSize, tileSize);
                mapCtx.strokeStyle = '#0f0';
                mapCtx.lineWidth = 2;
                mapCtx.strokeRect(spawnX, spawnY, tileSize, tileSize);

                // Label: "SPAWN" and "from [mapName]"
                mapCtx.fillStyle = '#0f0';
                mapCtx.font = 'bold 10px monospace';
                mapCtx.textAlign = 'center';
                mapCtx.textBaseline = 'middle';
                mapCtx.fillText('START', spawnX + tileSize / 2, spawnY + tileSize / 2 - 6);
                mapCtx.font = '9px monospace';
                mapCtx.fillStyle = '#8f8';
                mapCtx.fillText('(' + playerPreviewPos.x + ',' + playerPreviewPos.y + ')', spawnX + tileSize / 2, spawnY + tileSize / 2 + 7);
            }

            // === DRAW GAME PLAYERS (visible to builder when co-op) ===
            if (gamePlayersInBuilder.size > 0) {
                // Same frame data as game test
                const idleFrames = {
                    down: [0, 1, 2],
                    up: [3, 4, 5],
                    right: [6, 7, 8],
                    left: [6, 7, 8]
                };
                const walkFrames = {
                    down: { row: 0, cols: [9, 10, 11, 12] },
                    up: { row: 0, cols: [13, 14, 15] },
                    right: { row: 1, cols: [1, 2, 3, 4] },
                    left: { row: 1, cols: [1, 2, 3, 4] }
                };

                gamePlayersInBuilder.forEach((gPlayer, id) => {
                    // Only show players on current map
                    if (gPlayer.currentMap !== currentMapName) return;

                    // Game coords are 4x builder coords (TILE_SCALE=2 + cameraZoom=2)
                    const px = (gPlayer.x / 4) * zoom;
                    const py = (gPlayer.y / 4) * zoom;

                    const frameWidth = 64;
                    const frameHeight = 64;
                    const drawSize = tileSize * 1.5;
                    const dir = gPlayer.direction || 'down';
                    const frame = gPlayer.frame || 0;

                    let row = 0;
                    let col = 0;
                    let flipX = dir === 'left';

                    if (gPlayer.animation === 'walk') {
                        const walk = walkFrames[dir];
                        row = walk.row;
                        col = walk.cols[frame % walk.cols.length];
                    } else {
                        row = 0;
                        col = idleFrames[dir][frame % idleFrames[dir].length];
                    }

                    if (playerSpriteImg && playerSpriteImg.complete && playerSpriteImg.naturalWidth > 0) {
                        // Draw shadow
                        mapCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        mapCtx.beginPath();
                        mapCtx.ellipse(px, py + drawSize * 0.4, drawSize * 0.3, drawSize * 0.1, 0, 0, Math.PI * 2);
                        mapCtx.fill();

                        // Draw sprite
                        mapCtx.save();
                        if (flipX) {
                            mapCtx.translate(px + drawSize / 2, py - drawSize / 2);
                            mapCtx.scale(-1, 1);
                            mapCtx.drawImage(playerSpriteImg,
                                col * frameWidth, row * frameHeight, frameWidth, frameHeight,
                                0, 0, drawSize, drawSize);
                        } else {
                            mapCtx.drawImage(playerSpriteImg,
                                col * frameWidth, row * frameHeight, frameWidth, frameHeight,
                                px - drawSize / 2, py - drawSize / 2, drawSize, drawSize);
                        }
                        mapCtx.restore();
                    } else {
                        // Fallback: simple colored circle with direction indicator
                        mapCtx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, 12 * zoom, 0, Math.PI * 2);
                        mapCtx.fill();
                        mapCtx.fillStyle = '#000';
                        mapCtx.font = '8px monospace';
                        mapCtx.textAlign = 'center';
                        mapCtx.fillText(dir[0], px, py + 3);
                    }

                    // Draw name above player
                    mapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    mapCtx.font = 'bold ' + (10 * zoom) + 'px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'bottom';
                    const nameWidth = mapCtx.measureText(gPlayer.name).width + 8;
                    mapCtx.fillRect(px - nameWidth / 2, py - drawSize / 2 - 16 * zoom, nameWidth, 14 * zoom);
                    mapCtx.fillStyle = '#0ff';
                    mapCtx.fillText(gPlayer.name, px, py - drawSize / 2 - 4 * zoom);
                });
            }

            // === DEBUG: Show click coords ===
            if (window.debugClickPos) {
                const dx = window.debugClickPos.x * zoom;
                const dy = window.debugClickPos.y * zoom;
                mapCtx.fillStyle = '#f0f';
                mapCtx.beginPath();
                mapCtx.arc(dx, dy, 8 * zoom, 0, Math.PI * 2);
                mapCtx.fill();
                mapCtx.fillStyle = '#fff';
                mapCtx.font = 'bold 12px monospace';
                mapCtx.textAlign = 'left';
                mapCtx.fillText('DEBUG: ' + window.debugClickPos.x + ',' + window.debugClickPos.y, dx + 10, dy);
            }

            // Update expand button positions after canvas resize
            positionExpandButtons();
        }

        // Zoom
        function zoomIn() { if (zoom < 4) { zoom++; document.getElementById('zoomLevel').textContent = zoom + 'x'; renderMap(); } }
        function zoomOut() { if (zoom > 1) { zoom--; document.getElementById('zoomLevel').textContent = zoom + 'x'; renderMap(); } }

        // Only zoom with scroll when grab tool is active
        document.getElementById('mapViewport').addEventListener('wheel', (e) => {
            if (grabToolActive) {
                e.preventDefault();
                if (e.deltaY < 0) zoomIn(); else zoomOut();
            }
        });

        function clearMap() { if (confirm('Clear entire map?')) { initMap(); mapInitialized = true; broadcastEdit({ editType: 'clearMap', mapName: currentMapName }); renderMap(); } }

        // ===== GRAB TOOL =====
        let grabToolActive = false;
        let grabbing = false;
        let grabStartX = 0;
        let grabStartY = 0;
        let grabScrollX = 0;
        let grabScrollY = 0;

        // Tools menu toggle
        function toggleToolsMenu() {
            const menu = document.getElementById('toolsMenu');
            menu.classList.toggle('open');
        }

        // UI Theme changer
        function setUITheme(color) {
            // Apply to panel and toolbar
            document.querySelectorAll('.panel').forEach(el => el.style.background = color);
            document.querySelectorAll('.toolbar').forEach(el => el.style.background = color);
            document.querySelectorAll('.tools-menu').forEach(el => el.style.background = color);

            // Update active swatch indicator
            document.querySelectorAll('.theme-swatch').forEach(el => {
                el.classList.toggle('active', el.style.background === color);
            });

            // Update color picker
            const picker = document.getElementById('customThemeColor');
            if (picker) picker.value = color;

            // Save to localStorage
            localStorage.setItem('builderUITheme', color);
        }

        // Load saved theme on startup
        (function loadSavedTheme() {
            const saved = localStorage.getItem('builderUITheme');
            if (saved) {
                setTimeout(() => setUITheme(saved), 100);
            }
        })();

        // Close tools menu when clicking outside
        document.addEventListener('click', function(e) {
            const dropdown = document.querySelector('.tools-dropdown');
            const menu = document.getElementById('toolsMenu');
            if (dropdown && menu && !dropdown.contains(e.target)) {
                menu.classList.remove('open');
            }
        });

        function toggleGrabTool() {
            grabToolActive = !grabToolActive;
            const btn = document.getElementById('grabToolBtn');
            const canvas = document.getElementById('mapCanvas');
            const hint = document.getElementById('toolHint');

            if (grabToolActive) {
                btn.classList.add('active');
                canvas.classList.add('grabbing');
                hint.textContent = 'Drag to pan | Scroll to zoom';
                // Clear selected tiles when grab tool is activated
                selectedTiles = [];
                document.getElementById('selectedInfo').textContent = 'No tile selected';
                document.getElementById('selectedInfo').style.color = '#888';
                document.getElementById('selectedCollisionInfo').textContent = 'Click tileset to select';
                const canvas = document.getElementById('selectedTile');
                if (canvas) canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
            } else {
                btn.classList.remove('active');
                canvas.classList.remove('grabbing');
                hint.textContent = 'R:rotate | I:flip | E:erase';
            }
        }

        // Grab/pan handlers
        const mapViewport = document.getElementById('mapViewport');

        mapCanvas.addEventListener('mousedown', (e) => {
            if (grabToolActive && e.button === 0) {
                grabbing = true;
                grabStartX = e.clientX;
                grabStartY = e.clientY;
                grabScrollX = mapViewport.scrollLeft;
                grabScrollY = mapViewport.scrollTop;
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (grabbing) {
                const dx = e.clientX - grabStartX;
                const dy = e.clientY - grabStartY;
                mapViewport.scrollLeft = grabScrollX - dx;
                mapViewport.scrollTop = grabScrollY - dy;
            }
        });

        document.addEventListener('mouseup', () => {
            grabbing = false;
        });

        // Touch support for grab tool (iPad/mobile)
        mapCanvas.addEventListener('touchstart', (e) => {
            if (grabToolActive && e.touches.length === 1) {
                grabbing = true;
                grabStartX = e.touches[0].clientX;
                grabStartY = e.touches[0].clientY;
                grabScrollX = mapViewport.scrollLeft;
                grabScrollY = mapViewport.scrollTop;
                e.preventDefault();
            }
        }, { passive: false });

        mapCanvas.addEventListener('touchmove', (e) => {
            if (grabbing && e.touches.length === 1) {
                const dx = e.touches[0].clientX - grabStartX;
                const dy = e.touches[0].clientY - grabStartY;
                mapViewport.scrollLeft = grabScrollX - dx;
                mapViewport.scrollTop = grabScrollY - dy;
                e.preventDefault();
            }
        }, { passive: false });

        mapCanvas.addEventListener('touchend', () => {
            grabbing = false;
        });

        mapCanvas.addEventListener('touchcancel', () => {
            grabbing = false;
        });

        // ===== EXPAND MAP =====
        function expandMap(direction) {
            const expandAmount = 5; // Add 5 rows/cols at a time

            if (direction === 'right') {
                mapCols += expandAmount;
                layers.forEach(layer => {
                    for (let y = 0; y < layer.length; y++) {
                        for (let i = 0; i < expandAmount; i++) {
                            layer[y].push(null);
                        }
                    }
                });
            } else if (direction === 'left') {
                mapCols += expandAmount;
                layers.forEach(layer => {
                    for (let y = 0; y < layer.length; y++) {
                        for (let i = 0; i < expandAmount; i++) {
                            layer[y].unshift(null);
                        }
                    }
                });
                // Shift placed animated props
                placedAnimProps.forEach(ap => ap.x += expandAmount);
                // Shift placed props
                placedProps.forEach(prop => prop.x += expandAmount);
            } else if (direction === 'bottom') {
                mapRows += expandAmount;
                layers.forEach(layer => {
                    for (let i = 0; i < expandAmount; i++) {
                        const newRow = [];
                        for (let x = 0; x < mapCols; x++) newRow.push(null);
                        layer.push(newRow);
                    }
                });
            } else if (direction === 'top') {
                mapRows += expandAmount;
                layers.forEach(layer => {
                    for (let i = 0; i < expandAmount; i++) {
                        const newRow = [];
                        for (let x = 0; x < mapCols; x++) newRow.push(null);
                        layer.unshift(newRow);
                    }
                });
                // Shift placed animated props
                placedAnimProps.forEach(ap => ap.y += expandAmount);
                // Shift placed props
                placedProps.forEach(prop => prop.y += expandAmount);
            }

            renderMap();
        }

        // Position expand buttons at map edges
        function positionExpandButtons() {
            const canvas = document.getElementById('mapCanvas');
            const viewport = document.getElementById('mapViewport');
            if (!canvas || !viewport) return;

            const padding = 40; // viewport padding
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            const topBtn = document.querySelector('.expand-top');
            const bottomBtn = document.querySelector('.expand-bottom');
            const leftBtn = document.querySelector('.expand-left');
            const rightBtn = document.querySelector('.expand-right');

            if (topBtn) {
                topBtn.style.left = (padding + canvasWidth / 2 - 30) + 'px';
            }
            if (bottomBtn) {
                bottomBtn.style.left = (padding + canvasWidth / 2 - 30) + 'px';
                bottomBtn.style.top = (padding + canvasHeight + 5) + 'px';
            }
            if (leftBtn) {
                leftBtn.style.top = (padding + canvasHeight / 2 - 30) + 'px';
            }
            if (rightBtn) {
                rightBtn.style.left = (padding + canvasWidth + 5) + 'px';
                rightBtn.style.top = (padding + canvasHeight / 2 - 30) + 'px';
            }
        }

        // ===== MULTIPLE PROPS SYSTEM =====
        // Props work just like tilesets - load images, select area, paint on map
        // Each prop has its own collision masks

        function loadPropImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Save current prop's collision masks before switching
                    if (currentPropIndex >= 0 && props[currentPropIndex]) {
                        props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
                    }

                    // Add new prop to array
                    const newProp = {
                        name: file.name,
                        img: img,
                        data: e.target.result,
                        collisionMasks: {}
                    };
                    props.push(newProp);
                    currentPropIndex = props.length - 1;

                    // Set current prop shortcuts
                    propImage = img;
                    propImageData = e.target.result;
                    propCollisionMasks = newProp.collisionMasks;
                    propSelection = null;

                    updatePropDropdown();
                    updatePropUI();
                    drawPropTileset();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function switchProp() {
            const select = document.getElementById('propSelect');
            const newIndex = parseInt(select.value);

            // Save current prop's collision masks
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Switch to new prop
            currentPropIndex = newIndex;
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                propImage = props[currentPropIndex].img;
                propImageData = props[currentPropIndex].data;
                propCollisionMasks = props[currentPropIndex].collisionMasks || {};
            } else {
                propImage = null;
                propImageData = null;
                propCollisionMasks = {};
            }

            propSelection = null;
            updatePropUI();
            drawPropTileset();
            renderMap();
        }

        function updatePropDropdown() {
            const select = document.getElementById('propSelect');
            if (!select) return;
            select.innerHTML = '';

            if (props.length === 0) {
                const opt = document.createElement('option');
                opt.value = -1;
                opt.textContent = 'No props loaded';
                select.appendChild(opt);
            } else {
                props.forEach((prop, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = prop.name;
                    if (i === currentPropIndex) opt.selected = true;
                    select.appendChild(opt);
                });
            }
        }

        function updatePropUI() {
            const propControls = document.getElementById('propControls');
            const noPropMessage = document.getElementById('noPropMessage');
            if (!propControls || !noPropMessage) return;
            const hasProps = props.length > 0 && currentPropIndex >= 0;
            propControls.style.display = hasProps ? 'block' : 'none';
            noPropMessage.style.display = hasProps ? 'none' : 'block';
        }

        function drawPropTileset() {
            if (!propTilesetCanvas || !propTilesetCtx) return;
            if (!propImage) {
                propTilesetCanvas.width = 200;
                propTilesetCanvas.height = 50;
                propTilesetCtx.fillStyle = '#333';
                propTilesetCtx.fillRect(0, 0, 200, 50);
                propTilesetCtx.fillStyle = '#888';
                propTilesetCtx.font = '12px sans-serif';
                propTilesetCtx.fillText('Load a prop image...', 20, 30);
                return;
            }

            const displayZoom = 3; // Larger zoom for easier collision painting
            propTilesetCanvas.width = propImage.naturalWidth * displayZoom;
            propTilesetCanvas.height = propImage.naturalHeight * displayZoom;

            propTilesetCtx.imageSmoothingEnabled = false;
            propTilesetCtx.drawImage(propImage, 0, 0, propTilesetCanvas.width, propTilesetCanvas.height);

            // Draw collision overlay (red pixels where collision is set)
            if (propTool === 'collision' || propTool === 'erase') {
                const cols = Math.floor(propImage.naturalWidth / gridSize);
                const rows = Math.floor(propImage.naturalHeight / gridSize);

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const tileX = col * gridSize;
                        const tileY = row * gridSize;
                        const key = tileX + ',' + tileY;
                        const mask = propCollisionMasks[key];

                        if (mask) {
                            for (let py = 0; py < gridSize; py++) {
                                for (let px = 0; px < gridSize; px++) {
                                    if (mask[py] && mask[py][px]) {
                                        propTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                                        propTilesetCtx.fillRect(
                                            (tileX + px) * displayZoom,
                                            (tileY + py) * displayZoom,
                                            displayZoom,
                                            displayZoom
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Grid
            propTilesetCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            const cols = Math.floor(propImage.naturalWidth / gridSize);
            const rows = Math.floor(propImage.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                propTilesetCtx.beginPath();
                propTilesetCtx.moveTo(x * gridSize * displayZoom, 0);
                propTilesetCtx.lineTo(x * gridSize * displayZoom, propTilesetCanvas.height);
                propTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                propTilesetCtx.beginPath();
                propTilesetCtx.moveTo(0, y * gridSize * displayZoom);
                propTilesetCtx.lineTo(propTilesetCanvas.width, y * gridSize * displayZoom);
                propTilesetCtx.stroke();
            }

            // Highlight selection (only in select mode)
            if (propSelection && propTool === 'select') {
                propTilesetCtx.fillStyle = 'rgba(74, 175, 255, 0.4)';
                propTilesetCtx.strokeStyle = '#4af';
                propTilesetCtx.lineWidth = 2;
                propTilesetCtx.fillRect(
                    propSelection.x * displayZoom,
                    propSelection.y * displayZoom,
                    propSelection.width * displayZoom,
                    propSelection.height * displayZoom
                );
                propTilesetCtx.strokeRect(
                    propSelection.x * displayZoom,
                    propSelection.y * displayZoom,
                    propSelection.width * displayZoom,
                    propSelection.height * displayZoom
                );
            }
        }

        // Prop tileset selection and collision painting
        let propSelectionStart = null;

        function paintPropCollisionAt(canvasX, canvasY, isErasing) {
            const displayZoom = 3;
            const imgX = Math.floor(canvasX / displayZoom);
            const imgY = Math.floor(canvasY / displayZoom);

            // Find which tile this pixel belongs to
            const tileCol = Math.floor(imgX / gridSize);
            const tileRow = Math.floor(imgY / gridSize);
            const tileX = tileCol * gridSize;
            const tileY = tileRow * gridSize;
            const key = tileX + ',' + tileY;

            // Initialize mask if needed
            if (!propCollisionMasks[key]) {
                propCollisionMasks[key] = [];
                for (let y = 0; y < gridSize; y++) {
                    propCollisionMasks[key][y] = new Array(gridSize).fill(false);
                }
            }

            // Paint with brush
            const halfBrush = Math.floor(propBrushSize / 2);
            for (let dy = -halfBrush; dy < halfBrush; dy++) {
                for (let dx = -halfBrush; dx < halfBrush; dx++) {
                    const px = imgX + dx;
                    const py = imgY + dy;

                    // Get the tile for this pixel
                    const ptileCol = Math.floor(px / gridSize);
                    const ptileRow = Math.floor(py / gridSize);
                    const ptileX = ptileCol * gridSize;
                    const ptileY = ptileRow * gridSize;
                    const pkey = ptileX + ',' + ptileY;

                    // Local coords within tile
                    const localX = px - ptileX;
                    const localY = py - ptileY;

                    if (localX >= 0 && localX < gridSize && localY >= 0 && localY < gridSize) {
                        if (!propCollisionMasks[pkey]) {
                            propCollisionMasks[pkey] = [];
                            for (let y = 0; y < gridSize; y++) {
                                propCollisionMasks[pkey][y] = new Array(gridSize).fill(false);
                            }
                        }
                        propCollisionMasks[pkey][localY][localX] = !isErasing;
                    }
                }
            }

            drawPropTileset();
        }

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mousedown', (e) => {
            if (!propImage) return;
            const rect = propTilesetCanvas.getBoundingClientRect();
            const displayZoom = 3;

            if (propTool === 'select') {
                // Tile selection mode
                const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
                const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;
                propSelectionStart = { x, y };
            } else {
                // Collision painting mode
                propPainting = true;
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                paintPropCollisionAt(canvasX, canvasY, propTool === 'erase');
            }
        });

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mousemove', (e) => {
            if (!propImage || !propPainting) return;
            if (propTool === 'collision' || propTool === 'erase') {
                const rect = propTilesetCanvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                paintPropCollisionAt(canvasX, canvasY, propTool === 'erase');
            }
        });

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mouseup', (e) => {
            if (!propImage) return;

            if (propTool === 'select' && propSelectionStart) {
                const rect = propTilesetCanvas.getBoundingClientRect();
                const displayZoom = 3;
                const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
                const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

                const minX = Math.min(propSelectionStart.x, x);
                const minY = Math.min(propSelectionStart.y, y);
                const maxX = Math.max(propSelectionStart.x, x) + gridSize;
                const maxY = Math.max(propSelectionStart.y, y) + gridSize;

                propSelection = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };

                // When in prop mode, set this as the selected tile data for painting
                if (mode === 'prop') {
                    selectedTileData = {
                        x: minX,
                        y: minY,
                        width: (maxX - minX) / gridSize,
                        height: (maxY - minY) / gridSize,
                        isProp: true // Flag to indicate this is from prop image
                    };
                }

                propSelectionStart = null;
                drawPropTileset();
            }

            propPainting = false;
        });

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mouseleave', () => {
            propPainting = false;
        });

        if (propTilesetCanvas) propTilesetCanvas.style.cursor = 'crosshair';

        // Expand map size
        function expandMapRows() {
            mapRows += 10;
            layers.forEach(layer => {
                while (layer.length < mapRows) {
                    layer.push(new Array(mapCols).fill(null));
                }
            });
        }

        function expandMapCols() {
            mapCols += 10;
            layers.forEach(layer => {
                layer.forEach((row, i) => {
                    if (row) {
                        while (row.length < mapCols) row.push(null);
                    }
                });
            });
        }

        // ===== NPC FUNCTIONS =====
        let npcCurrentAnim = 'walkDown'; // Currently selected animation type
        let npcAnimations = {}; // { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], attackDown: [], ... }
        let npcAnimMirrors = {}; // { walkLeft: true } - animations to render flipped horizontally

        function openNpcEditor(editIndex = -1) {
            npcStopPreview();
            npcEditorEditingIndex = editIndex;
            npcCurrentAnim = 'walkDown';
            npcAnimations = { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], attackDown: [], attackUp: [], attackLeft: [], attackRight: [] };
            npcAnimMirrors = {}; // Reset mirror flags
            // Reset collision tool to Select mode
            npcTool = 'none';
            npcPainting = false;
            setNpcTool('none');

            if (editIndex >= 0 && npcs[editIndex]) {
                // Editing existing NPC
                const npc = npcs[editIndex];
                npcEditorFrameW = npc.frameWidth || 32;
                npcEditorFrameH = npc.frameHeight || 32;
                npcEditorData = npc.spriteData;
                document.getElementById('npcNameInput').value = npc.name;
                const fps = npc.fps || 8;
                document.getElementById('npcSpeedSlider').value = fps;
                document.getElementById('npcSpeedLabel').textContent = fps + ' fps';

                // Load animations
                if (npc.animations) {
                    npcAnimations = JSON.parse(JSON.stringify(npc.animations));
                }
                // Load mirror flags
                if (npc.animMirrors) {
                    npcAnimMirrors = JSON.parse(JSON.stringify(npc.animMirrors));
                }
                // Load ping-pong setting
                npcPingPong = npc.pingPong || false;
                document.getElementById('npcPingPong').checked = npcPingPong;

                // Load collision mask and split line
                npcSplitLine = npc.splitLine ?? null;

                if (npc.spriteData) {
                    npcEditorImage = new Image();
                    npcEditorImage.onload = () => {
                        document.getElementById('npcFrameSection').style.display = 'block';
                        document.getElementById('npcAnimSection').style.display = 'block';
                        document.getElementById('npcNameSection').style.display = 'block';
                        document.getElementById('npcCollisionSection').style.display = 'block';
                        // Load or initialize collision mask
                        const w = npcEditorImage.naturalWidth;
                        const h = npcEditorImage.naturalHeight;
                        if (npc.collisionMask && npc.collisionMask.length === h) {
                            npcCollisionMask = JSON.parse(JSON.stringify(npc.collisionMask));
                        } else {
                            npcCollisionMask = Array(h).fill(null).map(() => Array(w).fill(0));
                        }
                        npcUpdateGrid();
                        npcDrawCanvas();
                        npcUpdateFramesList();
                        npcStartPreview();
                    };
                    npcEditorImage.src = npc.spriteData;
                    document.getElementById('npcFileName').textContent = 'Sprite loaded';
                }
            } else {
                // New NPC
                npcEditorImage = null;
                npcEditorData = null;
                npcEditorFrameW = 32;
                npcEditorFrameH = 32;
                npcCollisionMask = null;
                npcSplitLine = null;
                document.getElementById('npcNameInput').value = '';
                document.getElementById('npcSpeedSlider').value = 8;
                document.getElementById('npcSpeedLabel').textContent = '8 fps';
                npcPingPong = false;
                document.getElementById('npcPingPong').checked = false;
                document.getElementById('npcFileName').textContent = '';
                document.getElementById('npcFrameSection').style.display = 'none';
                document.getElementById('npcAnimSection').style.display = 'none';
                document.getElementById('npcNameSection').style.display = 'none';
                document.getElementById('npcCollisionSection').style.display = 'none';
                // Clear canvases
                const previewCtx = document.getElementById('npcLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 96, 96);
                const editorCanvas = document.getElementById('npcEditorCanvas');
                const editorCtx = editorCanvas.getContext('2d');
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                const framesList = document.getElementById('npcFramesList');
                if (framesList) framesList.innerHTML = '';
                const fileInput = document.getElementById('npcFileInput');
                if (fileInput) fileInput.value = '';
            }

            npcSelectAnim('walkDown');
            document.getElementById('npcModal').classList.add('visible');
        }

        function npcLoadSheet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                npcEditorData = e.target.result;
                npcEditorImage = new Image();
                npcEditorImage.onload = () => {
                    document.getElementById('npcFileName').textContent = file.name + ' (' + npcEditorImage.naturalWidth + 'x' + npcEditorImage.naturalHeight + ')';
                    document.getElementById('npcFrameSection').style.display = 'block';
                    document.getElementById('npcAnimSection').style.display = 'block';
                    document.getElementById('npcNameSection').style.display = 'block';
                    document.getElementById('npcCollisionSection').style.display = 'block';
                    // Initialize collision mask for new image
                    const w = npcEditorImage.naturalWidth;
                    const h = npcEditorImage.naturalHeight;
                    npcCollisionMask = Array(h).fill(null).map(() => Array(w).fill(0));
                    npcSplitLine = null;
                    npcUpdateGrid();
                    npcDrawCanvas();
                };
                npcEditorImage.src = npcEditorData;
            };
            reader.readAsDataURL(file);
        }

        function npcSetFrameSize(w, h) {
            npcEditorFrameW = w;
            npcEditorFrameH = h;
            npcUpdateGrid();
            npcDrawCanvas();
        }

        function npcResetGrid() {
            npcEditorFrameW = 32;
            npcEditorFrameH = 32;
            npcUpdateGrid();
            npcDrawCanvas();
        }

        function npcUpdateGrid() {
            if (npcEditorImage) {
                const cols = Math.floor(npcEditorImage.naturalWidth / npcEditorFrameW);
                const rows = Math.floor(npcEditorImage.naturalHeight / npcEditorFrameH);
                document.getElementById('npcGridInfo').textContent = cols + ' cols x ' + rows + ' rows (' + npcEditorFrameW + 'x' + npcEditorFrameH + ')';
            }
            npcDrawCanvas();
        }

        function npcSelectAnim(animName) {
            npcCurrentAnim = animName;
            // Update all button states and show frame counts
            npcUpdateAnimButtons();
            // Update display
            const names = { walkDown: 'Walk Down', walkUp: 'Walk Up', walkLeft: 'Walk Left', walkRight: 'Walk Right', idle: 'Idle', attackDown: 'Attack Down', attackUp: 'Attack Up', attackLeft: 'Attack Left', attackRight: 'Attack Right' };
            document.getElementById('npcCurrentAnimName').textContent = names[animName] || animName;
            // Update mirror button state
            npcUpdateMirrorButton();
            npcDrawCanvas();
            npcUpdateFramesList();
            npcStartPreview();
        }

        function npcToggleMirror() {
            npcAnimMirrors[npcCurrentAnim] = !npcAnimMirrors[npcCurrentAnim];
            npcUpdateMirrorButton();
            npcStartPreview(); // Restart preview with new mirror state
        }

        function npcUpdateMirrorButton() {
            const btn = document.getElementById('npcMirrorBtn');
            if (npcAnimMirrors[npcCurrentAnim]) {
                btn.style.background = '#48f';
                btn.style.color = '#000';
                btn.style.borderColor = '#48f';
                btn.textContent = 'Mirrored';
            } else {
                btn.style.background = '#555';
                btn.style.color = '#fff';
                btn.style.borderColor = '#888';
                btn.textContent = 'Mirror';
            }
        }

        function npcUpdateAnimButtons() {
            const animMap = {
                'Down': 'walkDown',
                'Up': 'walkUp',
                'Left': 'walkLeft',
                'Right': 'walkRight',
                'Idle': 'idle',
                'AttackDown': 'attackDown',
                'AttackUp': 'attackUp',
                'AttackLeft': 'attackLeft',
                'AttackRight': 'attackRight'
            };
            const labels = {
                'Down': '↓ Walk',
                'Up': '↑ Walk',
                'Left': '← Walk',
                'Right': '→ Walk',
                'Idle': 'Idle',
                'AttackDown': '↓ Atk',
                'AttackUp': '↑ Atk',
                'AttackLeft': '← Atk',
                'AttackRight': '→ Atk'
            };
            const attackAnims = ['AttackDown', 'AttackUp', 'AttackLeft', 'AttackRight'];

            for (const [dir, animKey] of Object.entries(animMap)) {
                const btn = document.getElementById('npcAnim' + dir);
                if (btn) {
                    const frames = npcAnimations[animKey] || [];
                    const isActive = npcCurrentAnim === animKey;
                    const isAttack = attackAnims.includes(dir);
                    btn.classList.toggle('active', isActive);

                    // Show frame count and checkmark if has frames
                    if (frames.length > 0) {
                        btn.innerHTML = `✓ ${labels[dir]} <span style="color:#4f4;">(${frames.length})</span>`;
                        btn.style.background = isActive ? (isAttack ? '#844' : '#2a5a2a') : (isAttack ? '#633' : '#1a3a1a');
                    } else {
                        btn.innerHTML = labels[dir];
                        btn.style.background = isActive ? (isAttack ? '#955' : '#555') : (isAttack ? '#744' : '#333');
                    }
                }
            }
            // Update custom animations list
            npcUpdateCustomAnimList();
        }

        function npcAddCustomAnim() {
            const input = document.getElementById('npcCustomAnimName');
            const name = input.value.trim().toLowerCase().replace(/\s+/g, '_');
            if (!name) return;

            // Don't allow duplicates or reserved names
            const reserved = ['walkdown', 'walkup', 'walkleft', 'walkright', 'idle'];
            if (reserved.includes(name) || npcAnimations[name]) {
                alert('Animation "' + name + '" already exists');
                return;
            }

            // Create the new animation category
            npcAnimations[name] = [];
            input.value = '';

            // Select the new animation
            npcSelectAnim(name);
        }

        function npcUpdateCustomAnimList() {
            const container = document.getElementById('npcCustomAnimList');
            if (!container) return;

            // Get custom animations (not the default ones)
            const defaultAnims = ['walkDown', 'walkUp', 'walkLeft', 'walkRight', 'idle', 'attackDown', 'attackUp', 'attackLeft', 'attackRight'];
            const customAnims = Object.keys(npcAnimations).filter(k => !defaultAnims.includes(k));

            if (customAnims.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = '<div style="font-size:10px; color:#888; margin-bottom:3px;">Custom:</div>';
            html += '<div style="display:flex; flex-direction:column; gap:3px;">';
            customAnims.forEach(name => {
                const frames = npcAnimations[name] || [];
                const isActive = npcCurrentAnim === name;
                const hasFrames = frames.length > 0;
                const bgColor = isActive ? (hasFrames ? '#2a5a2a' : '#555') : (hasFrames ? '#1a3a1a' : '#333');
                html += `<div style="display:flex; gap:3px;">`;
                html += `<button onclick="npcSelectAnim('${name}')" style="flex:1; padding:4px; font-size:10px; background:${bgColor};">`;
                html += hasFrames ? `✓ ${name} <span style="color:#4f4;">(${frames.length})</span>` : name;
                html += `</button>`;
                html += `<button onclick="npcRemoveCustomAnim('${name}')" style="padding:4px 6px; font-size:10px; background:#a33;" title="Remove">×</button>`;
                html += `</div>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function npcRemoveCustomAnim(name) {
            if (!npcAnimations[name]) return;
            if (npcAnimations[name].length > 0) {
                if (!confirm('Delete "' + name + '" animation with ' + npcAnimations[name].length + ' frames?')) return;
            }
            delete npcAnimations[name];
            if (npcCurrentAnim === name) {
                npcSelectAnim('walkDown');
            } else {
                npcUpdateCustomAnimList();
            }
        }

        function setNpcTool(tool) {
            npcTool = tool;
            document.getElementById('npcToolNone').classList.toggle('active', tool === 'none');
            document.getElementById('npcToolCollision').classList.toggle('active', tool === 'collision');
            document.getElementById('npcToolErase').classList.toggle('active', tool === 'erase');
            document.getElementById('npcToolSplit').classList.toggle('active', tool === 'split');

            // Show brush section for collision/erase
            document.getElementById('npcBrushSection').style.display =
                (tool === 'collision' || tool === 'erase') ? 'block' : 'none';

            // Update canvas cursor
            const canvas = document.getElementById('npcEditorCanvas');
            if (canvas) canvas.style.cursor = (tool === 'none') ? 'crosshair' : 'cell';
        }

        function setNpcBrushSize(size) {
            npcBrushSize = parseInt(size);
            document.getElementById('npcBrushSizeVal').textContent = npcBrushSize;
            npcDrawCanvas(); // Redraw to update preview
        }

        function setNpcBrushShape(shape) {
            npcBrushShape = shape;
            document.querySelectorAll('[id^="npcShape"]').forEach(b => b.classList.remove('active'));
            document.getElementById('npcShape' + shape.charAt(0).toUpperCase() + shape.slice(1)).classList.add('active');
            // Show/hide rectangle controls
            document.getElementById('npcRectControls').style.display = shape === 'rect' ? 'block' : 'none';
            // Hide size slider for rect (uses W/H instead)
            document.getElementById('npcBrushSizeSlider').parentElement.style.display = shape === 'rect' ? 'none' : 'block';
            npcDrawCanvas();
        }

        function setNpcBrushRectW(w) {
            npcBrushRectW = parseInt(w);
            document.getElementById('npcBrushRectWVal').textContent = npcBrushRectW;
            npcDrawCanvas();
        }

        function setNpcBrushRectH(h) {
            npcBrushRectH = parseInt(h);
            document.getElementById('npcBrushRectHVal').textContent = npcBrushRectH;
            npcDrawCanvas();
        }

        function npcPaintCollision(x, y, erase) {
            if (!npcCollisionMask || !npcEditorImage) return;

            const value = erase ? 0 : 1;

            if (npcBrushShape === 'square') {
                const halfBrush = Math.floor(npcBrushSize / 2);
                for (let dy = -halfBrush; dy < halfBrush; dy++) {
                    for (let dx = -halfBrush; dx < halfBrush; dx++) {
                        const px = x + dx;
                        const py = y + dy;
                        if (py >= 0 && py < npcCollisionMask.length && px >= 0 && px < npcCollisionMask[0].length) {
                            npcCollisionMask[py][px] = value;
                        }
                    }
                }
            } else if (npcBrushShape === 'circle') {
                const radius = npcBrushSize / 2;
                const radiusSq = radius * radius;
                for (let dy = -Math.ceil(radius); dy <= Math.ceil(radius); dy++) {
                    for (let dx = -Math.ceil(radius); dx <= Math.ceil(radius); dx++) {
                        if (dx * dx + dy * dy <= radiusSq) {
                            const px = x + dx;
                            const py = y + dy;
                            if (py >= 0 && py < npcCollisionMask.length && px >= 0 && px < npcCollisionMask[0].length) {
                                npcCollisionMask[py][px] = value;
                            }
                        }
                    }
                }
            } else if (npcBrushShape === 'rect') {
                const halfW = Math.floor(npcBrushRectW / 2);
                const halfH = Math.floor(npcBrushRectH / 2);
                for (let dy = -halfH; dy < halfH; dy++) {
                    for (let dx = -halfW; dx < halfW; dx++) {
                        const px = x + dx;
                        const py = y + dy;
                        if (py >= 0 && py < npcCollisionMask.length && px >= 0 && px < npcCollisionMask[0].length) {
                            npcCollisionMask[py][px] = value;
                        }
                    }
                }
            }
        }

        function npcPaintSplit(x, y) {
            if (!npcEditorImage) return;
            // Split line is a single Y value for the entire sprite
            npcSplitLine = Math.max(0, Math.min(npcEditorFrameH, y));
        }

        function npcZoomIn() {
            npcEditorZoom = Math.min(6, npcEditorZoom + 1);
            document.getElementById('npcZoomLevel').textContent = npcEditorZoom + 'x';
            npcDrawCanvas();
        }

        function npcZoomOut() {
            npcEditorZoom = Math.max(1, npcEditorZoom - 1);
            document.getElementById('npcZoomLevel').textContent = npcEditorZoom + 'x';
            npcDrawCanvas();
        }

        function npcDrawCanvas() {
            const canvas = document.getElementById('npcEditorCanvas');
            const ctx = canvas.getContext('2d');

            if (!npcEditorImage) {
                canvas.width = 400;
                canvas.height = 300;
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.textAlign = 'center';
                ctx.font = '14px monospace';
                ctx.fillText('Load a sprite sheet to begin', canvas.width / 2, canvas.height / 2);
                return;
            }

            const scale = npcEditorZoom;
            canvas.width = npcEditorImage.naturalWidth * scale;
            canvas.height = npcEditorImage.naturalHeight * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(npcEditorImage, 0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;

            const fw = npcEditorFrameW * scale;
            const fh = npcEditorFrameH * scale;

            for (let x = 0; x <= canvas.width; x += fw) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += fh) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Highlight frames for current animation
            const currentFrames = npcAnimations[npcCurrentAnim] || [];
            currentFrames.forEach((frame, i) => {
                const sx = frame.x * scale;
                const sy = frame.y * scale;
                const sw = frame.w * scale;
                const sh = frame.h * scale;

                ctx.fillStyle = 'rgba(74, 170, 255, 0.3)';
                ctx.fillRect(sx, sy, sw, sh);
                ctx.strokeStyle = '#4af';
                ctx.lineWidth = 2;
                ctx.strokeRect(sx, sy, sw, sh);

                // Frame number
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText((i + 1).toString(), sx + sw / 2, sy + sh / 2 + 5);
            });

            // Draw drag selection preview
            if (npcFrameDragging && npcFrameDragStart && npcFrameDragEnd) {
                const startGX = Math.min(npcFrameDragStart.gridX, npcFrameDragEnd.gridX);
                const startGY = Math.min(npcFrameDragStart.gridY, npcFrameDragEnd.gridY);
                const endGX = Math.max(npcFrameDragStart.gridX, npcFrameDragEnd.gridX);
                const endGY = Math.max(npcFrameDragStart.gridY, npcFrameDragEnd.gridY);

                const dragX = startGX * npcEditorFrameW * scale;
                const dragY = startGY * npcEditorFrameH * scale;
                const dragW = (endGX - startGX + 1) * npcEditorFrameW * scale;
                const dragH = (endGY - startGY + 1) * npcEditorFrameH * scale;

                ctx.fillStyle = 'rgba(255, 200, 0, 0.3)';
                ctx.fillRect(dragX, dragY, dragW, dragH);
                ctx.strokeStyle = '#fc0';
                ctx.lineWidth = 3;
                ctx.strokeRect(dragX, dragY, dragW, dragH);
            }

            // Draw collision mask overlay
            if (npcCollisionMask && (npcTool === 'collision' || npcTool === 'erase' || npcTool === 'split' || npcTool === 'none')) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.35)';
                for (let py = 0; py < npcCollisionMask.length; py++) {
                    for (let px = 0; px < npcCollisionMask[py].length; px++) {
                        if (npcCollisionMask[py][px] === 1) {
                            ctx.fillRect(px * scale, py * scale, scale, scale);
                        }
                    }
                }
            }

            // Draw brush preview
            if (npcBrushPreviewPos && (npcTool === 'collision' || npcTool === 'erase')) {
                const bx = npcBrushPreviewPos.x;
                const by = npcBrushPreviewPos.y;
                ctx.strokeStyle = npcTool === 'erase' ? '#ff0' : '#0ff';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);

                if (npcBrushShape === 'square') {
                    const halfBrush = Math.floor(npcBrushSize / 2);
                    ctx.strokeRect(
                        (bx - halfBrush) * scale,
                        (by - halfBrush) * scale,
                        npcBrushSize * scale,
                        npcBrushSize * scale
                    );
                } else if (npcBrushShape === 'circle') {
                    const radius = (npcBrushSize / 2) * scale;
                    ctx.beginPath();
                    ctx.arc(bx * scale, by * scale, radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (npcBrushShape === 'rect') {
                    const halfW = Math.floor(npcBrushRectW / 2);
                    const halfH = Math.floor(npcBrushRectH / 2);
                    ctx.strokeRect(
                        (bx - halfW) * scale,
                        (by - halfH) * scale,
                        npcBrushRectW * scale,
                        npcBrushRectH * scale
                    );
                }
                ctx.setLineDash([]);

                // Draw size label near cursor
                ctx.fillStyle = npcTool === 'erase' ? '#ff0' : '#0ff';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'left';
                const sizeText = npcBrushShape === 'rect'
                    ? `${npcBrushRectW}x${npcBrushRectH}`
                    : `${npcBrushSize}px`;
                ctx.fillText(sizeText, (bx + 10) * scale, (by - 5) * scale);
            }

            // Draw split line
            if (npcSplitLine !== null) {
                const splitY = npcSplitLine * scale;
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(0, splitY);
                ctx.lineTo(canvas.width, splitY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label
                ctx.fillStyle = '#0f0';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'left';
                ctx.fillText('DEPTH SPLIT', 4, splitY - 4);
            }
        }

        function npcCanvasClick(e) {
            if (!npcEditorImage) return;

            const canvas = document.getElementById('npcEditorCanvas');
            const rect = canvas.getBoundingClientRect();
            const scale = npcEditorZoom;

            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const gridX = Math.floor(clickX / scale / npcEditorFrameW);
            const gridY = Math.floor(clickY / scale / npcEditorFrameH);

            const frameX = gridX * npcEditorFrameW;
            const frameY = gridY * npcEditorFrameH;

            // Initialize animation array if needed
            if (!npcAnimations[npcCurrentAnim]) {
                npcAnimations[npcCurrentAnim] = [];
            }

            const frames = npcAnimations[npcCurrentAnim];

            // Always add frame (allows same frame multiple times for animation)
            // Use right-click or frame list to remove frames
            frames.push({
                x: frameX,
                y: frameY,
                w: npcEditorFrameW,
                h: npcEditorFrameH
            });

            npcDrawCanvas();
            npcUpdateFramesList();
            npcUpdateAnimButtons();
            npcStartPreview();
        }

        function npcUpdateFramesList() {
            const container = document.getElementById('npcFramesList');
            const countEl = document.getElementById('npcFrameCount');
            const frames = npcAnimations[npcCurrentAnim] || [];

            countEl.textContent = frames.length;

            if (!npcEditorImage || frames.length === 0) {
                container.innerHTML = '<span style="color:#666;">Click frames on sprite sheet to add</span>';
                return;
            }

            container.innerHTML = '';
            frames.forEach((frame, i) => {
                const div = document.createElement('div');
                div.style.cssText = 'display:inline-block; margin:2px; cursor:pointer;';

                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = 40;
                thumbCanvas.height = 40;
                const thumbCtx = thumbCanvas.getContext('2d');
                thumbCtx.imageSmoothingEnabled = false;

                const scale = Math.min(40 / frame.w, 40 / frame.h);
                const dw = frame.w * scale;
                const dh = frame.h * scale;
                const dx = (40 - dw) / 2;
                const dy = (40 - dh) / 2;

                thumbCtx.drawImage(npcEditorImage, frame.x, frame.y, frame.w, frame.h, dx, dy, dw, dh);

                thumbCanvas.style.border = '2px solid #4af';
                thumbCanvas.style.borderRadius = '3px';
                thumbCanvas.title = 'Frame ' + (i + 1) + ' - Click to remove';
                thumbCanvas.onclick = () => {
                    npcAnimations[npcCurrentAnim].splice(i, 1);
                    npcDrawCanvas();
                    npcUpdateFramesList();
                    npcUpdateAnimButtons();
                };

                div.appendChild(thumbCanvas);
                container.appendChild(div);
            });
        }

        function npcUpdateSpeed() {
            const fps = parseInt(document.getElementById('npcSpeedSlider').value);
            document.getElementById('npcSpeedLabel').textContent = fps + ' fps';
            npcStartPreview();
        }

        function npcUpdatePingPong() {
            npcPingPong = document.getElementById('npcPingPong').checked;
            npcPreviewDirection = 1;
            npcStartPreview();
        }

        function npcStartPreview() {
            npcStopPreview();
            const frames = npcAnimations[npcCurrentAnim] || [];
            if (frames.length === 0 || !npcEditorImage) return;

            const fps = parseInt(document.getElementById('npcSpeedSlider').value) || 8;
            const isMirrored = npcAnimMirrors[npcCurrentAnim];
            npcPreviewFrame = 0;
            npcPreviewDirection = 1;
            npcPreviewPlaying = true;

            npcPreviewInterval = setInterval(() => {
                const canvas = document.getElementById('npcLivePreview');
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, 96, 96);

                if (frames.length > 0) {
                    const frame = frames[npcPreviewFrame];
                    const scale = Math.min(96 / frame.w, 96 / frame.h);
                    const dw = frame.w * scale;
                    const dh = frame.h * scale;
                    const dx = (96 - dw) / 2;
                    const dy = (96 - dh) / 2;

                    // Apply mirror transform if enabled
                    if (isMirrored) {
                        ctx.save();
                        ctx.translate(96, 0);
                        ctx.scale(-1, 1);
                        ctx.drawImage(npcEditorImage, frame.x, frame.y, frame.w, frame.h, 96 - dx - dw, dy, dw, dh);
                        ctx.restore();
                    } else {
                        ctx.drawImage(npcEditorImage, frame.x, frame.y, frame.w, frame.h, dx, dy, dw, dh);
                    }

                    // Ping-pong or loop
                    if (npcPingPong && frames.length > 1) {
                        npcPreviewFrame += npcPreviewDirection;
                        if (npcPreviewFrame >= frames.length - 1) {
                            npcPreviewDirection = -1;
                        } else if (npcPreviewFrame <= 0) {
                            npcPreviewDirection = 1;
                        }
                    } else {
                        npcPreviewFrame = (npcPreviewFrame + 1) % frames.length;
                    }
                }
            }, 1000 / fps);
        }

        function npcStopPreview() {
            if (npcPreviewInterval) {
                clearInterval(npcPreviewInterval);
                npcPreviewInterval = null;
            }
            npcPreviewPlaying = false;
        }

        function npcClearCurrentAnim() {
            npcAnimations[npcCurrentAnim] = [];
            npcDrawCanvas();
            npcUpdateFramesList();
            npcStopPreview();
            const ctx = document.getElementById('npcLivePreview').getContext('2d');
            ctx.clearRect(0, 0, 96, 96);
        }

        function npcSave() {
            const name = document.getElementById('npcNameInput').value.trim() || 'NPC ' + (npcs.length + 1);

            // Check if at least one animation has frames
            const hasFrames = Object.values(npcAnimations).some(arr => arr.length > 0);
            if (!hasFrames) {
                alert('Please select at least one frame for any animation');
                return;
            }

            const fps = parseInt(document.getElementById('npcSpeedSlider').value) || 8;

            const npcData = {
                name: name,
                spriteData: npcEditorData,
                frameWidth: npcEditorFrameW,
                frameHeight: npcEditorFrameH,
                animations: JSON.parse(JSON.stringify(npcAnimations)),
                animMirrors: JSON.parse(JSON.stringify(npcAnimMirrors)),
                fps: fps,
                pingPong: npcPingPong,
                collisionMask: npcCollisionMask ? JSON.parse(JSON.stringify(npcCollisionMask)) : null,
                splitLine: npcSplitLine
            };

            if (npcEditorEditingIndex >= 0) {
                npcs[npcEditorEditingIndex] = npcData;
                // Broadcast update to other builders
                broadcastEdit({ editType: 'updateNpc', index: npcEditorEditingIndex, npc: npcData });
            } else {
                npcs.push(npcData);
                currentNpcIndex = npcs.length - 1;
                // Broadcast new NPC to other builders
                broadcastEdit({ editType: 'addNpc', npc: npcData });
            }

            document.getElementById('npcModal').classList.remove('visible');
            npcStopPreview();
            updateNpcList();
        }

        function npcCancel() {
            document.getElementById('npcModal').classList.remove('visible');
            npcStopPreview();
        }

        function updateNpcList() {
            const container = document.getElementById('npcList');

            if (npcs.length === 0) {
                container.innerHTML = '<div style="color:#888; font-size:12px; padding:10px; text-align:center;">No NPCs created yet</div>';
                return;
            }

            container.innerHTML = '';
            npcs.forEach((npc, i) => {
                const div = document.createElement('div');
                div.style.cssText = 'display:flex; align-items:center; gap:8px; padding:5px; margin-bottom:5px; background:' + (i === currentNpcIndex ? '#2a5a8a' : '#333') + '; border-radius:4px; cursor:pointer;';

                // Thumbnail
                const thumb = document.createElement('canvas');
                thumb.width = 32;
                thumb.height = 32;
                thumb.style.cssText = 'border:1px solid #555; border-radius:3px; image-rendering:pixelated;';

                // Use first frame from walkDown or first available animation
                const anims = npc.animations || {};
                const firstAnim = anims.walkDown || anims.idle || Object.values(anims).find(a => a && a.length > 0);
                if (npc.spriteData && firstAnim && firstAnim.length > 0) {
                    const img = new Image();
                    img.onload = () => {
                        const ctx = thumb.getContext('2d');
                        ctx.imageSmoothingEnabled = false;
                        const frame = firstAnim[0];
                        const scale = Math.min(32 / frame.w, 32 / frame.h);
                        const dw = frame.w * scale;
                        const dh = frame.h * scale;
                        ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, (32-dw)/2, (32-dh)/2, dw, dh);
                    };
                    img.src = npc.spriteData;
                }

                // Name
                const nameSpan = document.createElement('span');
                nameSpan.textContent = npc.name;
                nameSpan.style.cssText = 'flex:1; font-size:12px;';

                // Edit button
                const editBtn = document.createElement('button');
                editBtn.textContent = '✎';
                editBtn.style.cssText = 'padding:2px 6px; font-size:11px; background:#666;';
                editBtn.onclick = (e) => { e.stopPropagation(); openNpcEditor(i); };

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = '×';
                delBtn.style.cssText = 'padding:2px 6px; font-size:11px; background:#a55;';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Delete NPC "' + npc.name + '"?')) {
                        npcs.splice(i, 1);
                        if (currentNpcIndex >= npcs.length) currentNpcIndex = npcs.length - 1;
                        updateNpcList();
                    }
                };

                div.onclick = () => {
                    currentNpcIndex = i;
                    updateNpcList();
                };

                div.appendChild(thumb);
                div.appendChild(nameSpan);
                div.appendChild(editBtn);
                div.appendChild(delBtn);
                container.appendChild(div);
            });
        }

        // ============ PLAYER CHARACTER EDITOR ============

        function openPlayerEditor(editIndex = -1) {
            playerEditorEditingIndex = editIndex;
            playerEditorSheets = [];
            playerCurrentSheetIndex = 0;
            playerEditorFrameW = 64;
            playerEditorFrameH = 64;
            playerAnimations = { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], idleDown: [], idleUp: [], idleLeft: [], idleRight: [], attackDown: [], attackUp: [], attackLeft: [], attackRight: [], interact: [], death: [], receivedItem: [] };
            playerAnimMirrors = {}; // Reset mirror flags
            playerHitboxRange = 40; // Reset hitbox shape
            playerHitboxWidth = 60;
            playerHitboxOffsetY = 0;
            playerAttackMovement = 'stop'; // Reset attack movement
            playerGameOverSoundIndex = -1; // Reset game over sound
            playerCurrentAnim = 'walkDown';
            playerAnimFpsList = {}; // Reset per-animation FPS
            playerStopPreview();

            // Reset UI
            document.getElementById('playerFileName').textContent = '';
            document.getElementById('playerSheetTabs').innerHTML = '';
            document.getElementById('playerFrameSection').style.display = 'none';
            document.getElementById('playerAnimSection').style.display = 'none';
            document.getElementById('playerNameSection').style.display = 'none';
            document.getElementById('playerNameInput').value = '';
            document.getElementById('playerSpeedSlider').value = 8;
            document.getElementById('playerSpeedLabel').textContent = '8 fps';
            playerPingPong = false;
            document.getElementById('playerPingPong').checked = false;
            document.getElementById('playerAttackMovement').value = 'stop';
            document.getElementById('playerCustomAnimName').value = '';
            document.getElementById('playerCustomAnimList').innerHTML = '';

            // If editing existing character, load its data
            if (editIndex >= 0 && playerCharacters[editIndex]) {
                const char = playerCharacters[editIndex];
                playerEditorFrameW = char.frameWidth;
                playerEditorFrameH = char.frameHeight;
                playerAnimations = JSON.parse(JSON.stringify(char.animations));
                // Load per-animation FPS (support both old single fps and new per-anim fps)
                if (char.animFps && typeof char.animFps === 'object') {
                    playerAnimFpsList = JSON.parse(JSON.stringify(char.animFps));
                } else {
                    // Old format: single fps value - apply to all anims
                    const defaultFps = char.fps || 8;
                    playerAnimFpsList = {};
                    Object.keys(playerAnimations).forEach(k => {
                        playerAnimFpsList[k] = defaultFps;
                    });
                }

                document.getElementById('playerNameInput').value = char.name;
                const currentFps = playerAnimFpsList[playerCurrentAnim] || 8;
                document.getElementById('playerSpeedSlider').value = currentFps;
                document.getElementById('playerSpeedLabel').textContent = currentFps + ' fps';
                // Load ping-pong setting
                playerPingPong = char.pingPong || false;
                document.getElementById('playerPingPong').checked = playerPingPong;
                // Load mirror flags
                if (char.animMirrors) {
                    playerAnimMirrors = JSON.parse(JSON.stringify(char.animMirrors));
                }
                // Load attack movement setting
                if (char.attackMovement) {
                    playerAttackMovement = char.attackMovement;
                    document.getElementById('playerAttackMovement').value = playerAttackMovement;
                }
                // Load hitbox shape (per-direction or convert from old single-value)
                if (char.hitboxRange !== undefined) {
                    if (typeof char.hitboxRange === 'object') {
                        playerHitboxRange = char.hitboxRange;
                    } else {
                        const val = char.hitboxRange;
                        playerHitboxRange = { up: val, down: val, left: val, right: val };
                    }
                }
                if (char.hitboxWidth !== undefined) {
                    if (typeof char.hitboxWidth === 'object') {
                        playerHitboxWidth = char.hitboxWidth;
                    } else {
                        const val = char.hitboxWidth;
                        playerHitboxWidth = { up: val, down: val, left: val, right: val };
                    }
                }
                if (char.hitboxOffsetX !== undefined) {
                    if (typeof char.hitboxOffsetX === 'object') {
                        playerHitboxOffsetX = char.hitboxOffsetX;
                    } else {
                        const val = char.hitboxOffsetX;
                        playerHitboxOffsetX = { up: val, down: val, left: val, right: val };
                    }
                }
                if (char.hitboxOffsetY !== undefined) {
                    if (typeof char.hitboxOffsetY === 'object') {
                        playerHitboxOffsetY = char.hitboxOffsetY;
                    } else {
                        const val = char.hitboxOffsetY;
                        playerHitboxOffsetY = { up: val, down: val, left: val, right: val };
                    }
                }
                // Load game over sound index
                playerGameOverSoundIndex = char.gameOverSoundIndex !== undefined ? char.gameOverSoundIndex : -1;

                // Load sheets (support both new multi-sheet and old single-sheet format)
                const sheetsToLoad = char.spriteSheets || (char.spriteData ? [char.spriteData] : []);
                let loadedCount = 0;
                sheetsToLoad.forEach((sheetData, index) => {
                    const img = new Image();
                    img.onload = () => {
                        playerEditorSheets[index] = {
                            image: img,
                            data: sheetData,
                            name: 'Sheet ' + (index + 1)
                        };
                        loadedCount++;
                        if (loadedCount === sheetsToLoad.length) {
                            // All sheets loaded
                            playerCurrentSheetIndex = 0;
                            playerUpdateSheetTabs();
                            const sheet = playerGetCurrentSheet();
                            if (sheet) {
                                document.getElementById('playerFileName').textContent = 'Sheet 1: ' + sheet.image.naturalWidth + 'x' + sheet.image.naturalHeight;
                            }
                            document.getElementById('playerFrameSection').style.display = 'block';
                            document.getElementById('playerAnimSection').style.display = 'block';
                            document.getElementById('playerNameSection').style.display = 'block';
                            playerUpdateGrid();
                            playerDrawCanvas();
                            playerUpdateAnimButtons();
                            playerUpdateFramesList();
                            playerStartPreview();
                        }
                    };
                    img.src = sheetData;
                });
            }

            // Populate game over sound dropdown
            playerPopulateGameOverSoundDropdown();

            document.getElementById('playerModal').classList.add('visible');
        }

        function playerLoadSheet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const data = e.target.result;
                const img = new Image();
                img.onload = () => {
                    // Add to sheets array
                    const sheetName = file.name.replace(/\.[^/.]+$/, ''); // Remove extension
                    playerEditorSheets.push({
                        image: img,
                        data: data,
                        name: sheetName
                    });
                    playerCurrentSheetIndex = playerEditorSheets.length - 1;
                    playerUpdateSheetTabs();
                    document.getElementById('playerFileName').textContent = 'Sheet ' + (playerCurrentSheetIndex + 1) + ': ' + img.naturalWidth + 'x' + img.naturalHeight;
                    document.getElementById('playerFrameSection').style.display = 'block';
                    document.getElementById('playerAnimSection').style.display = 'block';
                    document.getElementById('playerNameSection').style.display = 'block';
                    playerUpdateGrid();
                    playerDrawCanvas();
                };
                img.src = data;
            };
            reader.readAsDataURL(file);
            // Reset file input so same file can be loaded again
            event.target.value = '';
        }

        function playerUpdateSheetTabs() {
            const container = document.getElementById('playerSheetTabs');
            container.innerHTML = '';
            playerEditorSheets.forEach((sheet, i) => {
                const tab = document.createElement('div');
                tab.style.cssText = 'display:flex; align-items:center; gap:5px;';
                const btn = document.createElement('button');
                btn.textContent = (i + 1) + '. ' + sheet.name;
                btn.style.cssText = 'flex:1; padding:5px 8px; font-size:11px; text-align:left; overflow:hidden; text-overflow:ellipsis;';
                if (i === playerCurrentSheetIndex) {
                    btn.style.background = '#4f8';
                    btn.style.color = '#000';
                }
                btn.onclick = () => playerSwitchSheet(i);
                tab.appendChild(btn);
                // Remove button (only if more than one sheet)
                if (playerEditorSheets.length > 1) {
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = 'X';
                    removeBtn.style.cssText = 'padding:5px 8px; font-size:11px; background:#a55;';
                    removeBtn.onclick = (e) => { e.stopPropagation(); playerRemoveSheet(i); };
                    tab.appendChild(removeBtn);
                }
                container.appendChild(tab);
            });
        }

        function playerSwitchSheet(index) {
            if (index < 0 || index >= playerEditorSheets.length) return;
            playerCurrentSheetIndex = index;
            const sheet = playerEditorSheets[index];
            document.getElementById('playerFileName').textContent = 'Sheet ' + (index + 1) + ': ' + sheet.image.naturalWidth + 'x' + sheet.image.naturalHeight;
            playerUpdateSheetTabs();
            playerUpdateGrid();
            playerDrawCanvas();
        }

        function playerRemoveSheet(index) {
            if (playerEditorSheets.length <= 1) return;
            // Remove frames that reference this sheet
            Object.keys(playerAnimations).forEach(animKey => {
                playerAnimations[animKey] = playerAnimations[animKey].filter(f => f.sheet !== index);
                // Update sheet indices for frames from higher sheets
                playerAnimations[animKey].forEach(f => {
                    if (f.sheet > index) f.sheet--;
                });
            });
            playerEditorSheets.splice(index, 1);
            if (playerCurrentSheetIndex >= playerEditorSheets.length) {
                playerCurrentSheetIndex = playerEditorSheets.length - 1;
            }
            playerUpdateSheetTabs();
            playerSwitchSheet(playerCurrentSheetIndex);
            playerUpdateAnimButtons();
            playerUpdateFramesList();
        }

        // Helper to get current sheet image
        function playerGetCurrentSheet() {
            if (playerEditorSheets.length === 0) return null;
            return playerEditorSheets[playerCurrentSheetIndex];
        }

        function playerSetFrameSize(w, h) {
            playerEditorFrameW = w;
            playerEditorFrameH = h;
            playerAnimations = { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], idleDown: [], idleUp: [], idleLeft: [], idleRight: [], attackDown: [], attackUp: [], attackLeft: [], attackRight: [], interact: [], death: [], receivedItem: [] };
            playerAnimMirrors = {};
            playerUpdateGrid();
            playerDrawCanvas();
            playerUpdateAnimButtons();
            playerUpdateMirrorButton();
            playerUpdateFramesList();
        }

        function playerResetGrid() {
            playerSetFrameSize(64, 64);
        }

        function playerUpdateGrid() {
            const sheet = playerGetCurrentSheet();
            if (!sheet) return;
            const cols = Math.floor(sheet.image.naturalWidth / playerEditorFrameW);
            const rows = Math.floor(sheet.image.naturalHeight / playerEditorFrameH);
            document.getElementById('playerGridInfo').textContent = playerEditorFrameW + 'x' + playerEditorFrameH + ' (' + cols + 'x' + rows + ' grid)';
        }

        function playerSelectAnim(animName) {
            playerCurrentAnim = animName;
            playerUpdateAnimButtons();
            playerUpdateMirrorButton();
            playerUpdateHitboxUI(); // Show/hide hitbox section based on anim type
            playerUpdateFramesList();
            // Update FPS slider to show this animation's FPS
            const fps = playerAnimFpsList[animName] || 8;
            document.getElementById('playerSpeedSlider').value = fps;
            document.getElementById('playerSpeedLabel').textContent = fps + ' fps';
            playerStartPreview();
        }

        function playerUpdateAnimButtons() {
            const names = {
                walkDown: 'Walk Down',
                walkUp: 'Walk Up',
                walkLeft: 'Walk Left',
                walkRight: 'Walk Right',
                idle: 'Idle (All)',
                idleDown: 'Idle Down',
                idleUp: 'Idle Up',
                idleLeft: 'Idle Left',
                idleRight: 'Idle Right',
                attackDown: 'Attack Down',
                attackUp: 'Attack Up',
                attackLeft: 'Attack Left',
                attackRight: 'Attack Right',
                interact: 'Interact',
                death: 'Death',
                receivedItem: 'Received Item'
            };

            // Walk buttons
            const walkBtnMap = {
                walkDown: 'playerAnimDown',
                walkUp: 'playerAnimUp',
                walkLeft: 'playerAnimLeft',
                walkRight: 'playerAnimRight'
            };
            Object.entries(walkBtnMap).forEach(([anim, btnId]) => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.toggle('active', playerCurrentAnim === anim);
                    const count = playerAnimations[anim]?.length || 0;
                    btn.classList.toggle('has-frames', count > 0);
                    let label = anim === 'walkDown' ? '↓ Walk' : anim === 'walkUp' ? '↑ Walk' : anim === 'walkLeft' ? '← Walk' : '→ Walk';
                    btn.textContent = label + (count > 0 ? ' (' + count + ')' : '');
                }
            });

            // Idle (All) button
            const idleAllBtn = document.getElementById('playerAnimIdle');
            if (idleAllBtn) {
                idleAllBtn.classList.toggle('active', playerCurrentAnim === 'idle');
                const count = playerAnimations['idle']?.length || 0;
                idleAllBtn.classList.toggle('has-frames', count > 0);
                idleAllBtn.textContent = 'Idle (All)' + (count > 0 ? ' (' + count + ')' : '');
            }

            // Directional idle buttons
            const idleBtnMap = {
                idleDown: 'playerAnimIdleDown',
                idleUp: 'playerAnimIdleUp',
                idleLeft: 'playerAnimIdleLeft',
                idleRight: 'playerAnimIdleRight'
            };
            Object.entries(idleBtnMap).forEach(([anim, btnId]) => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.toggle('active', playerCurrentAnim === anim);
                    const count = playerAnimations[anim]?.length || 0;
                    btn.classList.toggle('has-frames', count > 0);
                    let label = anim === 'idleDown' ? '↓' : anim === 'idleUp' ? '↑' : anim === 'idleLeft' ? '←' : '→';
                    btn.textContent = label + (count > 0 ? ' (' + count + ')' : '');
                }
            });

            // Attack buttons
            const attackBtnMap = {
                attackDown: 'playerAnimAttackDown',
                attackUp: 'playerAnimAttackUp',
                attackLeft: 'playerAnimAttackLeft',
                attackRight: 'playerAnimAttackRight'
            };
            Object.entries(attackBtnMap).forEach(([anim, btnId]) => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.toggle('active', playerCurrentAnim === anim);
                    const count = playerAnimations[anim]?.length || 0;
                    btn.classList.toggle('has-frames', count > 0);
                    let label = anim === 'attackDown' ? '↓ Atk' : anim === 'attackUp' ? '↑ Atk' : anim === 'attackLeft' ? '← Atk' : '→ Atk';
                    btn.textContent = label + (count > 0 ? ' (' + count + ')' : '');
                }
            });

            // Interact button
            const interactBtn = document.getElementById('playerAnimInteract');
            if (interactBtn) {
                interactBtn.classList.toggle('active', playerCurrentAnim === 'interact');
                const count = playerAnimations['interact']?.length || 0;
                interactBtn.classList.toggle('has-frames', count > 0);
                interactBtn.textContent = 'Interact' + (count > 0 ? ' (' + count + ')' : '');
            }

            // Death button
            const deathBtn = document.getElementById('playerAnimDeath');
            if (deathBtn) {
                deathBtn.classList.toggle('active', playerCurrentAnim === 'death');
                const count = playerAnimations['death']?.length || 0;
                deathBtn.classList.toggle('has-frames', count > 0);
                deathBtn.textContent = 'Death' + (count > 0 ? ' (' + count + ')' : '');
            }

            // Received Item button
            const receivedItemBtn = document.getElementById('playerAnimReceivedItem');
            if (receivedItemBtn) {
                receivedItemBtn.classList.toggle('active', playerCurrentAnim === 'receivedItem');
                const count = playerAnimations['receivedItem']?.length || 0;
                receivedItemBtn.classList.toggle('has-frames', count > 0);
                receivedItemBtn.textContent = 'Received Item' + (count > 0 ? ' (' + count + ')' : '');
            }

            // Update custom animations list
            playerUpdateCustomAnimList();

            // Update current animation name display
            document.getElementById('playerCurrentAnimName').textContent = names[playerCurrentAnim] || playerCurrentAnim;
            document.getElementById('playerFrameCount').textContent = playerAnimations[playerCurrentAnim]?.length || 0;
        }

        function playerDrawCanvas() {
            const sheet = playerGetCurrentSheet();
            if (!sheet) return;

            const canvas = document.getElementById('playerEditorCanvas');
            const ctx = canvas.getContext('2d');
            const scale = playerEditorZoom;

            canvas.width = sheet.image.naturalWidth * scale;
            canvas.height = sheet.image.naturalHeight * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(sheet.image, 0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;

            const fw = playerEditorFrameW * scale;
            const fh = playerEditorFrameH * scale;

            for (let x = 0; x <= canvas.width; x += fw) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += fh) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Highlight frames in current animation (only those from current sheet)
            const frames = playerAnimations[playerCurrentAnim] || [];
            frames.forEach((frame, i) => {
                // Only highlight if frame is from current sheet (or no sheet specified for backwards compat)
                if (frame.sheet !== undefined && frame.sheet !== playerCurrentSheetIndex) {
                    return; // Skip frames from other sheets
                }
                const x = frame.x * scale;
                const y = frame.y * scale;
                const w = frame.w * scale;
                const h = frame.h * scale;

                ctx.fillStyle = 'rgba(74, 255, 136, 0.3)';
                ctx.fillRect(x, y, w, h);
                ctx.strokeStyle = '#4f8';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                // Frame number
                ctx.fillStyle = '#fff';
                ctx.font = 'bold ' + (12 * scale / 3) + 'px monospace';
                ctx.fillText(i + 1, x + 4, y + 14 * scale / 3);
            });

            // Draw drag selection preview
            if (playerFrameDragging && playerFrameDragStart && playerFrameDragEnd) {
                const startGX = Math.min(playerFrameDragStart.gridX, playerFrameDragEnd.gridX);
                const startGY = Math.min(playerFrameDragStart.gridY, playerFrameDragEnd.gridY);
                const endGX = Math.max(playerFrameDragStart.gridX, playerFrameDragEnd.gridX);
                const endGY = Math.max(playerFrameDragStart.gridY, playerFrameDragEnd.gridY);

                const selX = startGX * fw;
                const selY = startGY * fh;
                const selW = (endGX - startGX + 1) * fw;
                const selH = (endGY - startGY + 1) * fh;

                ctx.fillStyle = 'rgba(255, 200, 0, 0.4)';
                ctx.fillRect(selX, selY, selW, selH);
                ctx.strokeStyle = '#fc0';
                ctx.lineWidth = 3;
                ctx.strokeRect(selX, selY, selW, selH);
            }

            document.getElementById('playerZoomLevel').textContent = scale + 'x';
        }

        function playerZoomIn() {
            if (playerEditorZoom < 6) {
                playerEditorZoom++;
                playerDrawCanvas();
            }
        }

        function playerZoomOut() {
            if (playerEditorZoom > 1) {
                playerEditorZoom--;
                playerDrawCanvas();
            }
        }

        // Canvas drag-selection handlers for multi-tile frames
        (function() {
            const canvas = document.getElementById('playerEditorCanvas');

            canvas.addEventListener('mousedown', function(e) {
                if (playerEditorSheets.length === 0) return;

                const rect = this.getBoundingClientRect();
                const scale = playerEditorZoom;
                const clickX = (e.clientX - rect.left) / scale;
                const clickY = (e.clientY - rect.top) / scale;

                // Start drag for multi-tile selection
                const gridX = Math.floor(clickX / playerEditorFrameW);
                const gridY = Math.floor(clickY / playerEditorFrameH);
                playerFrameDragStart = { gridX, gridY };
                playerFrameDragEnd = { gridX, gridY };
                playerFrameDragging = true;
                playerDrawCanvas();
            });

            canvas.addEventListener('mousemove', function(e) {
                if (playerEditorSheets.length === 0) return;
                if (!playerFrameDragging) return;

                const rect = this.getBoundingClientRect();
                const scale = playerEditorZoom;
                const clickX = (e.clientX - rect.left) / scale;
                const clickY = (e.clientY - rect.top) / scale;

                const gridX = Math.floor(clickX / playerEditorFrameW);
                const gridY = Math.floor(clickY / playerEditorFrameH);
                playerFrameDragEnd = { gridX, gridY };
                playerDrawCanvas();
            });

            canvas.addEventListener('mouseup', function(e) {
                // Finalize frame drag selection
                if (playerFrameDragging && playerFrameDragStart && playerFrameDragEnd) {
                    // Calculate rectangle bounds (handle drag in any direction)
                    const startGX = Math.min(playerFrameDragStart.gridX, playerFrameDragEnd.gridX);
                    const startGY = Math.min(playerFrameDragStart.gridY, playerFrameDragEnd.gridY);
                    const endGX = Math.max(playerFrameDragStart.gridX, playerFrameDragEnd.gridX);
                    const endGY = Math.max(playerFrameDragStart.gridY, playerFrameDragEnd.gridY);

                    // Calculate frame in pixels
                    const frameX = startGX * playerEditorFrameW;
                    const frameY = startGY * playerEditorFrameH;
                    const frameW = (endGX - startGX + 1) * playerEditorFrameW;
                    const frameH = (endGY - startGY + 1) * playerEditorFrameH;

                    // Initialize animation array if needed
                    if (!playerAnimations[playerCurrentAnim]) {
                        playerAnimations[playerCurrentAnim] = [];
                    }

                    const frames = playerAnimations[playerCurrentAnim];

                    // Always add frame (allows same frame multiple times for animation)
                    // Use frame list to remove individual frames
                    frames.push({
                        x: frameX,
                        y: frameY,
                        w: frameW,
                        h: frameH,
                        sheet: playerCurrentSheetIndex
                    });

                    playerDrawCanvas();
                    playerUpdateAnimButtons();
                    playerUpdateFramesList();
                    playerStartPreview();
                }

                // Reset drag state
                playerFrameDragging = false;
                playerFrameDragStart = null;
                playerFrameDragEnd = null;
            });

            canvas.addEventListener('mouseleave', function(e) {
                // Cancel drag on mouse leave
                if (playerFrameDragging) {
                    playerFrameDragging = false;
                    playerFrameDragStart = null;
                    playerFrameDragEnd = null;
                    playerDrawCanvas();
                }
            });
        })();

        function playerUpdateFramesList() {
            const container = document.getElementById('playerFramesList');
            const frames = playerAnimations[playerCurrentAnim] || [];

            if (frames.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px;">Click on sprite sheet to add frames</div>';
                return;
            }

            container.innerHTML = '';
            frames.forEach((frame, i) => {
                const wrapper = document.createElement('div');
                wrapper.style.cssText = 'display:inline-block; position:relative;';

                const thumb = document.createElement('canvas');
                thumb.width = 48;
                thumb.height = 48;
                thumb.style.cssText = 'border:1px solid #4f8; border-radius:3px; background:#111; image-rendering:pixelated; cursor:pointer;';
                const sheetNum = (frame.sheet || 0) + 1;
                thumb.title = 'Frame ' + (i + 1) + ' (Sheet ' + sheetNum + ') - Click to remove';

                // Get correct sheet for this frame
                const sheetIndex = frame.sheet || 0;
                const sheet = playerEditorSheets[sheetIndex];
                if (sheet) {
                    const ctx = thumb.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    const scale = Math.min(46 / frame.w, 46 / frame.h);
                    const dw = frame.w * scale;
                    const dh = frame.h * scale;
                    ctx.drawImage(sheet.image, frame.x, frame.y, frame.w, frame.h, (48 - dw) / 2, (48 - dh) / 2, dw, dh);
                }

                thumb.onclick = () => {
                    frames.splice(i, 1);
                    playerDrawCanvas();
                    playerUpdateAnimButtons();
                    playerUpdateFramesList();
                    playerStartPreview();
                };

                wrapper.appendChild(thumb);

                // Show sheet number badge if multiple sheets
                if (playerEditorSheets.length > 1) {
                    const badge = document.createElement('div');
                    badge.textContent = sheetNum;
                    badge.style.cssText = 'position:absolute; top:-4px; right:-4px; background:#4af; color:#000; font-size:9px; font-weight:bold; width:14px; height:14px; border-radius:50%; display:flex; align-items:center; justify-content:center;';
                    wrapper.appendChild(badge);
                }

                container.appendChild(wrapper);
            });
        }

        function playerUpdateSpeed() {
            const fps = parseInt(document.getElementById('playerSpeedSlider').value);
            playerAnimFpsList[playerCurrentAnim] = fps;
            document.getElementById('playerSpeedLabel').textContent = fps + ' fps';
            if (playerPreviewPlaying) {
                playerStartPreview();
            }
        }

        // Get FPS for current animation (defaults to 8)
        function playerGetCurrentFps() {
            return playerAnimFpsList[playerCurrentAnim] || 8;
        }

        function playerUpdatePingPong() {
            playerPingPong = document.getElementById('playerPingPong').checked;
            playerPreviewDirection = 1;
            playerStartPreview();
        }

        function playerToggleMirror() {
            playerAnimMirrors[playerCurrentAnim] = !playerAnimMirrors[playerCurrentAnim];
            playerUpdateMirrorButton();
            playerStartPreview(); // Restart preview with new mirror state
        }

        function playerUpdateMirrorButton() {
            const btn = document.getElementById('playerMirrorBtn');
            if (playerAnimMirrors[playerCurrentAnim]) {
                btn.style.background = '#4f8';
                btn.style.color = '#000';
                btn.style.borderColor = '#4f8';
                btn.textContent = 'Mirrored';
            } else {
                btn.style.background = '#555';
                btn.style.color = '#fff';
                btn.style.borderColor = '#888';
                btn.textContent = 'Mirror';
            }
        }

        // Shape-based hitbox functions (per-direction)
        let playerHitboxEditDir = 'down';

        function setPlayerHitboxDir(dir) {
            playerHitboxEditDir = dir;
            document.querySelectorAll('[id^="phbDir"]').forEach(b => {
                b.classList.remove('active');
                b.style.background = '';
            });
            const btn = document.getElementById('phbDir' + dir.charAt(0).toUpperCase() + dir.slice(1));
            if (btn) {
                btn.classList.add('active');
                btn.style.background = '#606';
            }
            updatePlayerHitboxSliders();
        }

        function updatePlayerHitboxSliders() {
            const dir = playerHitboxEditDir;
            document.getElementById('playerHitboxRange').value = playerHitboxRange[dir] || 40;
            document.getElementById('playerHitboxWidth').value = playerHitboxWidth[dir] || 60;
            document.getElementById('playerHitboxOffsetX').value = playerHitboxOffsetX[dir] || 0;
            document.getElementById('playerHitboxOffsetY').value = playerHitboxOffsetY[dir] || 0;
            document.getElementById('playerHitboxRangeVal').textContent = playerHitboxRange[dir] || 40;
            document.getElementById('playerHitboxWidthVal').textContent = playerHitboxWidth[dir] || 60;
            document.getElementById('playerHitboxOffsetXVal').textContent = playerHitboxOffsetX[dir] || 0;
            document.getElementById('playerHitboxOffsetYVal').textContent = playerHitboxOffsetY[dir] || 0;
        }

        function updatePlayerHitboxShape() {
            const dir = playerHitboxEditDir;
            playerHitboxRange[dir] = parseInt(document.getElementById('playerHitboxRange').value);
            playerHitboxWidth[dir] = parseInt(document.getElementById('playerHitboxWidth').value);
            playerHitboxOffsetX[dir] = parseInt(document.getElementById('playerHitboxOffsetX').value);
            playerHitboxOffsetY[dir] = parseInt(document.getElementById('playerHitboxOffsetY').value);
            document.getElementById('playerHitboxRangeVal').textContent = playerHitboxRange[dir];
            document.getElementById('playerHitboxWidthVal').textContent = playerHitboxWidth[dir];
            document.getElementById('playerHitboxOffsetXVal').textContent = playerHitboxOffsetX[dir];
            document.getElementById('playerHitboxOffsetYVal').textContent = playerHitboxOffsetY[dir];
        }

        function copyPlayerHitboxToAll() {
            const dir = playerHitboxEditDir;
            ['up', 'down', 'left', 'right'].forEach(d => {
                playerHitboxRange[d] = playerHitboxRange[dir];
                playerHitboxWidth[d] = playerHitboxWidth[dir];
                playerHitboxOffsetX[d] = playerHitboxOffsetX[dir];
                playerHitboxOffsetY[d] = playerHitboxOffsetY[dir];
            });
            console.log('Copied ' + dir + ' hitbox to all directions');
        }

        function playerUpdateHitboxUI() {
            const section = document.getElementById('playerHitboxSection');
            const isAttackAnim = playerCurrentAnim.startsWith('attack');
            // Show hitbox section only for attack animations
            if (section) section.style.display = isAttackAnim ? 'block' : 'none';
            // Update slider values
            if (document.getElementById('playerHitboxRange')) {
                updatePlayerHitboxSliders();
            }
        }

        function playerStartPreview() {
            playerStopPreview();
            const frames = playerAnimations[playerCurrentAnim] || [];
            if (frames.length === 0 || playerEditorSheets.length === 0) return;

            playerPreviewPlaying = true;
            playerPreviewFrame = 0;
            playerPreviewDirection = 1;
            const isMirrored = playerAnimMirrors[playerCurrentAnim];

            const canvas = document.getElementById('playerLivePreview');
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            function drawFrame() {
                if (!playerPreviewPlaying) return;
                const frame = frames[playerPreviewFrame];
                // Get the correct sheet for this frame
                const sheetIndex = frame.sheet || 0;
                const sheet = playerEditorSheets[sheetIndex];
                if (!sheet) return;

                ctx.clearRect(0, 0, 96, 96);
                const scale = Math.min(94 / frame.w, 94 / frame.h);
                const dw = frame.w * scale;
                const dh = frame.h * scale;
                const dx = (96 - dw) / 2;
                const dy = (96 - dh) / 2;

                // Apply mirror transform if enabled
                if (isMirrored) {
                    ctx.save();
                    ctx.translate(96, 0);
                    ctx.scale(-1, 1);
                    ctx.drawImage(sheet.image, frame.x, frame.y, frame.w, frame.h, 96 - dx - dw, dy, dw, dh);
                    ctx.restore();
                } else {
                    ctx.drawImage(sheet.image, frame.x, frame.y, frame.w, frame.h, dx, dy, dw, dh);
                }

                // Ping-pong or loop
                if (playerPingPong && frames.length > 1) {
                    playerPreviewFrame += playerPreviewDirection;
                    if (playerPreviewFrame >= frames.length - 1) {
                        playerPreviewDirection = -1;
                    } else if (playerPreviewFrame <= 0) {
                        playerPreviewDirection = 1;
                    }
                } else {
                    playerPreviewFrame = (playerPreviewFrame + 1) % frames.length;
                }
            }

            drawFrame();
            playerPreviewInterval = setInterval(drawFrame, 1000 / playerGetCurrentFps());
        }

        function playerStopPreview() {
            playerPreviewPlaying = false;
            if (playerPreviewInterval) {
                clearInterval(playerPreviewInterval);
                playerPreviewInterval = null;
            }
        }

        function playerClearCurrentAnim() {
            playerAnimations[playerCurrentAnim] = [];
            playerDrawCanvas();
            playerUpdateAnimButtons();
            playerUpdateFramesList();
            playerStopPreview();
        }

        function playerAddCustomAnim() {
            const input = document.getElementById('playerCustomAnimName');
            const name = input.value.trim();
            if (!name) {
                alert('Enter an animation name');
                return;
            }
            // Reserved names
            const reserved = ['walkDown', 'walkUp', 'walkLeft', 'walkRight', 'idle', 'idleDown', 'idleUp', 'idleLeft', 'idleRight', 'attackDown', 'attackUp', 'attackLeft', 'attackRight', 'interact', 'death', 'receivedItem'];
            if (reserved.includes(name) || playerAnimations[name]) {
                alert('Animation "' + name + '" already exists or is reserved');
                return;
            }

            playerAnimations[name] = [];
            input.value = '';
            playerSelectAnim(name);
            playerUpdateCustomAnimList();
            playerUpdateAnimButtons();
        }

        function playerUpdateCustomAnimList() {
            const container = document.getElementById('playerCustomAnimList');
            if (!container) return;

            // Get custom animations (not the default ones)
            const reserved = ['walkDown', 'walkUp', 'walkLeft', 'walkRight', 'idle', 'idleDown', 'idleUp', 'idleLeft', 'idleRight', 'attackDown', 'attackUp', 'attackLeft', 'attackRight', 'interact', 'death', 'receivedItem'];
            const customAnims = Object.keys(playerAnimations).filter(k => !reserved.includes(k));

            if (customAnims.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = '<div style="font-size:10px; color:#a8f; margin-bottom:5px; border-top:1px solid #555; padding-top:5px;">-- Custom --</div>';
            customAnims.forEach(name => {
                const frames = playerAnimations[name] || [];
                const div = document.createElement('div');
                div.style.cssText = 'display:flex; gap:4px; margin-bottom:4px;';
                div.innerHTML = '<button id="playerAnimCustom_' + name + '" onclick="playerSelectAnim(\'' + name + '\')" style="flex:1; padding:4px 6px; font-size:10px; background:#648;">' + name + (frames.length > 0 ? ' (' + frames.length + ')' : '') + '</button>' +
                    '<button onclick="playerDeleteCustomAnim(\'' + name + '\')" style="padding:4px 6px; font-size:10px; background:#a44;">X</button>';
                container.appendChild(div);
            });
        }

        function playerDeleteCustomAnim(name) {
            if (!playerAnimations[name]) return;
            if (playerAnimations[name].length > 0) {
                if (!confirm('Delete "' + name + '" animation with ' + playerAnimations[name].length + ' frames?')) return;
            }
            delete playerAnimations[name];
            if (playerCurrentAnim === name) {
                playerSelectAnim('walkDown');
            }
            playerUpdateCustomAnimList();
            playerUpdateAnimButtons();
        }

        // Game Over Sound functions
        // Index scheme: -1 = none, 0-99 = builtin sounds, 100+ = project sounds (index - 100)
        function playerPopulateGameOverSoundDropdown() {
            const select = document.getElementById('playerGameOverSound');
            if (!select) return;
            select.innerHTML = '<option value="-1">None</option>';
            // Built-in game over sounds
            builtinGameOverSounds.forEach((sound, index) => {
                const opt = document.createElement('option');
                opt.value = index; // 0, 1, etc for builtin
                opt.textContent = '🎵 ' + sound.name;
                select.appendChild(opt);
            });
            // Project sounds
            if (sounds.length > 0) {
                const separator = document.createElement('option');
                separator.disabled = true;
                separator.textContent = '─── Project Sounds ───';
                select.appendChild(separator);
                sounds.forEach((sound, index) => {
                    const opt = document.createElement('option');
                    opt.value = 100 + index; // 100+ for project sounds
                    opt.textContent = sound.name;
                    select.appendChild(opt);
                });
            }
            select.value = playerGameOverSoundIndex;
        }

        function playerUpdateGameOverSound() {
            const select = document.getElementById('playerGameOverSound');
            playerGameOverSoundIndex = parseInt(select.value);
        }

        function playerPreviewGameOverSound() {
            if (playerGameOverSoundIndex < 0) {
                alert('No game over sound selected');
                return;
            }
            // Check if it's a builtin sound (0-99) or project sound (100+)
            if (playerGameOverSoundIndex < 100) {
                // Builtin sound - lazy load and play
                const builtinIndex = playerGameOverSoundIndex;
                if (builtinIndex >= 0 && builtinIndex < builtinGameOverSounds.length) {
                    if (!builtinGameOverAudios[builtinIndex]) {
                        builtinGameOverAudios[builtinIndex] = new Audio(builtinGameOverSounds[builtinIndex].file);
                    }
                    builtinGameOverAudios[builtinIndex].currentTime = 0;
                    builtinGameOverAudios[builtinIndex].play();
                }
            } else {
                // Project sound
                const projectIndex = playerGameOverSoundIndex - 100;
                if (projectIndex >= 0 && projectIndex < sounds.length) {
                    const sound = sounds[projectIndex];
                    if (sound && sound.audio) {
                        sound.audio.currentTime = 0;
                        sound.audio.play();
                    }
                }
            }
        }

        function playerSave() {
            const name = document.getElementById('playerNameInput').value.trim() || 'Player ' + (playerCharacters.length + 1);

            // Check if at least one animation has frames
            const hasFrames = Object.values(playerAnimations).some(a => a && a.length > 0);
            if (!hasFrames) {
                alert('Please add at least one animation frame');
                return;
            }

            // Save all sheets (array of base64 data)
            const sheetsData = playerEditorSheets.map(s => s.data);

            // Get attack movement setting from dropdown
            playerAttackMovement = document.getElementById('playerAttackMovement').value;

            const charData = {
                name: name,
                spriteData: sheetsData[0] || null, // Keep for backwards compatibility
                spriteSheets: sheetsData, // Array of all sheets
                frameWidth: playerEditorFrameW,
                frameHeight: playerEditorFrameH,
                animations: JSON.parse(JSON.stringify(playerAnimations)),
                animMirrors: JSON.parse(JSON.stringify(playerAnimMirrors)),
                hitboxRange: JSON.parse(JSON.stringify(playerHitboxRange)), // Per-direction range
                hitboxWidth: JSON.parse(JSON.stringify(playerHitboxWidth)), // Per-direction width
                hitboxOffsetX: JSON.parse(JSON.stringify(playerHitboxOffsetX)), // Per-direction X offset
                hitboxOffsetY: JSON.parse(JSON.stringify(playerHitboxOffsetY)), // Per-direction Y offset
                animFps: JSON.parse(JSON.stringify(playerAnimFpsList)), // Per-animation FPS
                fps: 8, // Keep for backwards compatibility
                pingPong: playerPingPong,
                attackMovement: playerAttackMovement, // 'stop', 'slide', 'move'
                gameOverSoundIndex: playerGameOverSoundIndex // Index of game over sound
            };

            if (playerEditorEditingIndex >= 0) {
                playerCharacters[playerEditorEditingIndex] = charData;
                broadcastEdit({ editType: 'updatePlayerCharacter', index: playerEditorEditingIndex, character: charData });
            } else {
                playerCharacters.push(charData);
                broadcastEdit({ editType: 'addPlayerCharacter', character: charData });
            }

            // If this is the first character, make it active
            if (playerCharacters.length === 1 && activePlayerIndex < 0) {
                setActivePlayer(0);
            }

            document.getElementById('playerModal').classList.remove('visible');
            playerStopPreview();
            updatePlayerList();
        }

        function playerCancel() {
            document.getElementById('playerModal').classList.remove('visible');
            playerStopPreview();
        }

        function updatePlayerList() {
            const container = document.getElementById('playerCharacterList');
            const activeNameEl = document.getElementById('activePlayerName');
            const previewCanvas = document.getElementById('activePlayerPreview');

            if (playerCharacters.length === 0) {
                container.innerHTML = '<div style="color:#888; font-size:12px; padding:10px; text-align:center;">No characters created yet</div>';
                activeNameEl.textContent = 'Default Sprite';
                // Draw default sprite preview
                if (previewCanvas && playerSpriteImg && playerSpriteImg.complete && playerSpriteImg.naturalWidth > 0) {
                    const ctx = previewCanvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    ctx.clearRect(0, 0, 64, 64);
                    ctx.drawImage(playerSpriteImg, 0, 0, 64, 64, 0, 0, 64, 64);
                }
                return;
            }

            // Update active player name and preview
            if (activePlayerIndex >= 0 && playerCharacters[activePlayerIndex]) {
                const char = playerCharacters[activePlayerIndex];
                activeNameEl.textContent = char.name;
                // Draw active player preview
                if (previewCanvas && char.spriteData) {
                    const img = new Image();
                    img.onload = () => {
                        const ctx = previewCanvas.getContext('2d');
                        ctx.imageSmoothingEnabled = false;
                        ctx.clearRect(0, 0, 64, 64);
                        const anims = char.animations || {};
                        const frames = anims.walkDown || anims.idle || Object.values(anims).find(a => a && a.length > 0);
                        if (frames && frames.length > 0) {
                            const frame = frames[0];
                            const scale = Math.min(62 / frame.w, 62 / frame.h);
                            const dw = frame.w * scale;
                            const dh = frame.h * scale;
                            ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, (64 - dw) / 2, (64 - dh) / 2, dw, dh);
                        } else {
                            ctx.drawImage(img, 0, 0, char.frameWidth, char.frameHeight, 0, 0, 64, 64);
                        }
                    };
                    img.src = char.spriteData;
                }
            } else {
                activeNameEl.textContent = 'Default Sprite';
            }

            container.innerHTML = '';
            playerCharacters.forEach((char, i) => {
                const div = document.createElement('div');
                const isActive = i === activePlayerIndex;
                div.style.cssText = 'display:flex; align-items:center; gap:8px; padding:5px; margin-bottom:5px; background:' + (isActive ? '#2a5a3a' : '#333') + '; border-radius:4px; cursor:pointer;' + (isActive ? 'border:1px solid #4f8;' : '');

                // Thumbnail
                const thumb = document.createElement('canvas');
                thumb.width = 32;
                thumb.height = 32;
                thumb.style.cssText = 'border:1px solid #555; border-radius:3px; image-rendering:pixelated;';

                const anims = char.animations || {};
                const firstAnim = anims.walkDown || anims.idle || Object.values(anims).find(a => a && a.length > 0);
                if (char.spriteData && firstAnim && firstAnim.length > 0) {
                    const img = new Image();
                    img.onload = () => {
                        const ctx = thumb.getContext('2d');
                        ctx.imageSmoothingEnabled = false;
                        const frame = firstAnim[0];
                        const scale = Math.min(32 / frame.w, 32 / frame.h);
                        const dw = frame.w * scale;
                        const dh = frame.h * scale;
                        ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, (32 - dw) / 2, (32 - dh) / 2, dw, dh);
                    };
                    img.src = char.spriteData;
                }

                // Active indicator
                const indicator = document.createElement('span');
                indicator.textContent = isActive ? '*' : '';
                indicator.style.cssText = 'color:#4f8; font-weight:bold; width:12px;';

                // Name
                const nameSpan = document.createElement('span');
                nameSpan.textContent = char.name;
                nameSpan.style.cssText = 'flex:1; font-size:12px;';

                // Set Active button
                const activeBtn = document.createElement('button');
                activeBtn.textContent = isActive ? 'Active' : 'Use';
                activeBtn.style.cssText = 'padding:2px 6px; font-size:10px; background:' + (isActive ? '#4f8' : '#555') + '; color:' + (isActive ? '#000' : '#fff') + ';';
                activeBtn.onclick = (e) => { e.stopPropagation(); setActivePlayer(i); };

                // Edit button
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.style.cssText = 'padding:2px 6px; font-size:10px; background:#666;';
                editBtn.onclick = (e) => { e.stopPropagation(); openPlayerEditor(i); };

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = 'X';
                delBtn.style.cssText = 'padding:2px 6px; font-size:10px; background:#a55;';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Delete character "' + char.name + '"?')) {
                        deletePlayerCharacter(i);
                    }
                };

                div.onclick = () => setActivePlayer(i);

                div.appendChild(thumb);
                div.appendChild(indicator);
                div.appendChild(nameSpan);
                div.appendChild(activeBtn);
                div.appendChild(editBtn);
                div.appendChild(delBtn);
                container.appendChild(div);
            });
        }

        function setActivePlayer(index) {
            activePlayerIndex = index;
            updatePlayerList();
            broadcastEdit({ editType: 'setActivePlayer', index: index });
        }

        function deletePlayerCharacter(index) {
            playerCharacters.splice(index, 1);
            if (activePlayerIndex >= playerCharacters.length) {
                activePlayerIndex = playerCharacters.length - 1;
            }
            if (activePlayerIndex === index) {
                activePlayerIndex = playerCharacters.length > 0 ? 0 : -1;
            }
            updatePlayerList();
            broadcastEdit({ editType: 'deletePlayerCharacter', index: index });
        }

        // ============ END PLAYER CHARACTER EDITOR ============

        // Button click sounds for start screen
        const buttonNavSound = new Audio('sounds/button-press-382713.mp3'); // Navigation clicks
        buttonNavSound.volume = 0.5;
        const buttonActionSound = new Audio('sounds/button-select.mp3'); // Final action (join/build/start)
        buttonActionSound.volume = 0.5;

        function playButtonSound() {
            buttonNavSound.currentTime = 0;
            buttonNavSound.play().catch(() => {});
        }

        function playActionSound() {
            buttonActionSound.currentTime = 0;
            buttonActionSound.play().catch(() => {});
        }

        // Set up NPC canvas mouse handlers
        document.addEventListener('DOMContentLoaded', () => {
            // Add navigation sound to all retro-btn in loadPhase
            document.querySelectorAll('#loadPhase .retro-btn').forEach(btn => {
                btn.addEventListener('click', playButtonSound);
            });
            const npcCanvas = document.getElementById('npcEditorCanvas');
            if (npcCanvas) {
                npcCanvas.addEventListener('mousedown', function(e) {
                    if (!npcEditorImage) return;

                    const rect = this.getBoundingClientRect();
                    const scale = npcEditorZoom;
                    const clickX = (e.clientX - rect.left) / scale;
                    const clickY = (e.clientY - rect.top) / scale;

                    if (npcTool === 'collision' || npcTool === 'erase') {
                        npcPainting = true;
                        npcPaintCollision(Math.floor(clickX), Math.floor(clickY), npcTool === 'erase');
                        npcDrawCanvas();
                    } else if (npcTool === 'split') {
                        npcPainting = true;
                        npcPaintSplit(Math.floor(clickX), Math.floor(clickY));
                        npcDrawCanvas();
                    } else {
                        // Frame selection mode (npcTool === 'none') - start drag for multi-tile selection
                        const gridX = Math.floor(clickX / npcEditorFrameW);
                        const gridY = Math.floor(clickY / npcEditorFrameH);
                        npcFrameDragStart = { gridX, gridY };
                        npcFrameDragEnd = { gridX, gridY };
                        npcFrameDragging = true;
                        npcDrawCanvas();
                    }
                });

                npcCanvas.addEventListener('mousemove', function(e) {
                    if (!npcEditorImage) return;

                    const rect = this.getBoundingClientRect();
                    const scale = npcEditorZoom;
                    const clickX = (e.clientX - rect.left) / scale;
                    const clickY = (e.clientY - rect.top) / scale;

                    // Update brush preview position
                    if (npcTool === 'collision' || npcTool === 'erase') {
                        npcBrushPreviewPos = { x: Math.floor(clickX), y: Math.floor(clickY) };
                        if (!npcPainting) npcDrawCanvas(); // Redraw for preview
                    } else {
                        npcBrushPreviewPos = null;
                    }

                    // Handle frame drag selection
                    if (npcFrameDragging) {
                        const gridX = Math.floor(clickX / npcEditorFrameW);
                        const gridY = Math.floor(clickY / npcEditorFrameH);
                        npcFrameDragEnd = { gridX, gridY };
                        npcDrawCanvas();
                        return;
                    }

                    if (!npcPainting) return;

                    if (npcTool === 'collision' || npcTool === 'erase') {
                        npcPaintCollision(Math.floor(clickX), Math.floor(clickY), npcTool === 'erase');
                        npcDrawCanvas();
                    } else if (npcTool === 'split') {
                        npcPaintSplit(Math.floor(clickX), Math.floor(clickY));
                        npcDrawCanvas();
                    }
                });

                npcCanvas.addEventListener('mouseleave', function() {
                    npcBrushPreviewPos = null;
                    if (npcTool === 'collision' || npcTool === 'erase') {
                        npcDrawCanvas();
                    }
                });

                npcCanvas.addEventListener('mouseup', function(e) {
                    // Finalize frame drag selection
                    if (npcFrameDragging && npcFrameDragStart && npcFrameDragEnd) {
                        // Calculate rectangle bounds (handle drag in any direction)
                        const startGX = Math.min(npcFrameDragStart.gridX, npcFrameDragEnd.gridX);
                        const startGY = Math.min(npcFrameDragStart.gridY, npcFrameDragEnd.gridY);
                        const endGX = Math.max(npcFrameDragStart.gridX, npcFrameDragEnd.gridX);
                        const endGY = Math.max(npcFrameDragStart.gridY, npcFrameDragEnd.gridY);

                        // Calculate frame in pixels
                        const frameX = startGX * npcEditorFrameW;
                        const frameY = startGY * npcEditorFrameH;
                        const frameW = (endGX - startGX + 1) * npcEditorFrameW;
                        const frameH = (endGY - startGY + 1) * npcEditorFrameH;

                        // Initialize animation array if needed
                        if (!npcAnimations[npcCurrentAnim]) {
                            npcAnimations[npcCurrentAnim] = [];
                        }

                        const frames = npcAnimations[npcCurrentAnim];

                        // Always add frame (allows same frame multiple times for animation)
                        frames.push({
                            x: frameX,
                            y: frameY,
                            w: frameW,
                            h: frameH
                        });

                        npcDrawCanvas();
                        npcUpdateFramesList();
                        npcUpdateAnimButtons();
                        npcStartPreview();
                    }

                    // Reset drag state
                    npcFrameDragging = false;
                    npcFrameDragStart = null;
                    npcFrameDragEnd = null;
                    npcPainting = false;
                });

                npcCanvas.addEventListener('mouseleave', function(e) {
                    // Cancel drag on mouse leave
                    if (npcFrameDragging) {
                        npcFrameDragging = false;
                        npcFrameDragStart = null;
                        npcFrameDragEnd = null;
                        npcDrawCanvas();
                    }
                    npcPainting = false;
                });
            }
        });

        // ===== NPC PLACEMENT & PATH FUNCTIONS =====

        function placeNpcAt(x, y) {
            console.log('placeNpcAt called:', x, y, 'currentNpcIndex:', currentNpcIndex);
            if (currentNpcIndex < 0 || !npcs[currentNpcIndex]) {
                console.log('No NPC selected, cannot place');
                return;
            }

            // Check if there's already an NPC at this position
            const existing = placedNpcs.findIndex(p => p.x === x && p.y === y && p.mapName === currentMapName);
            if (existing >= 0) {
                // Select existing instead of placing new
                selectPlacedNpc(existing);
                return;
            }

            const placed = {
                npcIndex: currentNpcIndex,
                mapName: currentMapName,
                x: x,
                y: y,
                path: [],
                trigger: 'loop',
                speed: 3
            };

            placedNpcs.push(placed);
            selectedPlacedNpcIndex = placedNpcs.length - 1;
            // Broadcast to co-op builders
            broadcastEdit({ editType: 'placeNpc', npc: placed, index: selectedPlacedNpcIndex });

            updatePlacedNpcList();
            showNpcPathPanel();
            renderMap();
        }

        function findPlacedNpcAt(x, y) {
            return placedNpcs.findIndex(p => p.x === x && p.y === y && p.mapName === currentMapName);
        }

        function selectPlacedNpc(index) {
            // Stop any running preview when selecting different NPC
            if (npcPathPreviewActive && index !== selectedPlacedNpcIndex) {
                stopNpcPathPreview();
            }

            selectedPlacedNpcIndex = index;
            npcPathDrawing = false;
            npcPathEditing = false;
            npcDraggingWaypoint = -1;
            updatePathDrawButton();

            const placed = placedNpcs[index];
            if (placed) {
                document.getElementById('npcTriggerType').value = placed.trigger || 'loop';
                document.getElementById('npcWalkSpeed').value = placed.speed || 3;
                document.getElementById('npcSpeedValue').textContent = placed.speed || 3;
                // Load animation speed (default to NPC's fps or 8)
                const npc = npcs[placed.npcIndex];
                const defaultFps = npc?.fps || 8;
                const animSpeed = placed.animSpeed || defaultFps;
                document.getElementById('npcAnimSpeed').value = animSpeed;
                document.getElementById('npcAnimSpeedValue').textContent = animSpeed + ' fps';
            }

            updatePlacedNpcList();
            showNpcPathPanel();
            renderMap();
        }

        function removeNpcAt(x, y) {
            const idx = findPlacedNpcAt(x, y);
            if (idx >= 0) {
                placedNpcs.splice(idx, 1);
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeNpc', index: idx });
                if (selectedPlacedNpcIndex === idx) {
                    selectedPlacedNpcIndex = -1;
                    hideNpcPathPanel();
                } else if (selectedPlacedNpcIndex > idx) {
                    selectedPlacedNpcIndex--;
                }
                updatePlacedNpcList();
                renderMap();
            }
        }

        function deleteSelectedPlacedNpc() {
            if (selectedPlacedNpcIndex >= 0) {
                const idx = selectedPlacedNpcIndex;
                placedNpcs.splice(selectedPlacedNpcIndex, 1);
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeNpc', index: idx });
                selectedPlacedNpcIndex = -1;
                npcPathDrawing = false;
                hideNpcPathPanel();
                updatePlacedNpcList();
                renderMap();
            }
        }

        function showNpcPathPanel() {
            const panel = document.getElementById('npcPathPanel');
            if (!panel) {
                console.error('npcPathPanel not found!');
                return;
            }
            panel.style.display = 'block';
            console.log('Path panel shown, selectedPlacedNpcIndex:', selectedPlacedNpcIndex);

            if (selectedPlacedNpcIndex >= 0) {
                const placed = placedNpcs[selectedPlacedNpcIndex];
                const npc = npcs[placed.npcIndex];
                document.getElementById('npcPathName').textContent = npc ? npc.name : 'NPC';
                updateNpcWaypointList();
                updatePathDrawButton();

                // Load enemy settings
                const isEnemy = placed.isEnemy || false;
                const attackMode = placed.attackMode || 'touch';
                document.getElementById('npcIsEnemy').checked = isEnemy;
                document.getElementById('npcEnemyOptions').style.display = isEnemy ? 'block' : 'none';
                document.getElementById('npcVisionRadius').value = placed.visionRadius || 5;
                document.getElementById('npcVisionValue').textContent = (placed.visionRadius || 5) + ' tiles';
                document.getElementById('npcChaseSpeed').value = placed.chaseSpeed || 4;
                document.getElementById('npcChaseSpeedValue').textContent = placed.chaseSpeed || 4;
                document.getElementById('npcAttackMode').value = attackMode;
                document.getElementById('npcDamage').value = placed.damage || 10;
                document.getElementById('npcDamageValue').textContent = placed.damage || 10;
                document.getElementById('npcAttackCooldown').value = placed.attackCooldown || 1;
                document.getElementById('npcCooldownValue').textContent = (placed.attackCooldown || 1).toFixed(1) + 's';
                document.getElementById('npcLungeOptions').style.display = attackMode === 'lunge' ? 'block' : 'none';
                document.getElementById('npcAttackRange').value = placed.attackRange || 2;
                document.getElementById('npcLungeRangeValue').textContent = (placed.attackRange || 2) + ' tiles';
                document.getElementById('npcLungeSpeed').value = placed.lungeSpeed || 8;
                document.getElementById('npcLungeSpeedValue').textContent = placed.lungeSpeed || 8;
                // Load slowdown settings
                document.getElementById('npcSlowdownPercent').value = placed.slowdownPercent !== undefined ? placed.slowdownPercent : 50;
                document.getElementById('npcSlowdownValue').textContent = (placed.slowdownPercent !== undefined ? placed.slowdownPercent : 50) + '%';
                document.getElementById('npcSlowdownDuration').value = placed.slowdownDuration !== undefined ? placed.slowdownDuration : 0.5;
                document.getElementById('npcSlowdownDurationValue').textContent = (placed.slowdownDuration !== undefined ? placed.slowdownDuration : 0.5).toFixed(2) + 's';

                // Load trigger and speed settings
                document.getElementById('npcTriggerType').value = placed.trigger || 'loop';
                document.getElementById('npcWalkSpeed').value = placed.speed || 3;
                document.getElementById('npcSpeedValue').textContent = placed.speed || 3;

                // Load scale setting
                document.getElementById('npcScale').value = placed.scale || 1;
                document.getElementById('npcScaleValue').textContent = (placed.scale || 1).toFixed(1) + 'x';
            }
        }

        function updateNpcEnemy() {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];

            const isEnemy = document.getElementById('npcIsEnemy').checked;
            const visionRadius = parseInt(document.getElementById('npcVisionRadius').value) || 5;
            const chaseSpeed = parseInt(document.getElementById('npcChaseSpeed').value) || 4;
            const attackMode = document.getElementById('npcAttackMode').value || 'touch';
            const damage = parseInt(document.getElementById('npcDamage').value) || 10;
            const attackCooldown = parseFloat(document.getElementById('npcAttackCooldown').value) || 1;
            const attackRange = parseInt(document.getElementById('npcAttackRange').value) || 2;
            const lungeSpeed = parseInt(document.getElementById('npcLungeSpeed').value) || 8;
            const slowdownPercent = parseInt(document.getElementById('npcSlowdownPercent').value);
            const slowdownDuration = parseFloat(document.getElementById('npcSlowdownDuration').value);

            // Update UI labels
            document.getElementById('npcEnemyOptions').style.display = isEnemy ? 'block' : 'none';
            document.getElementById('npcVisionValue').textContent = visionRadius + ' tiles';
            document.getElementById('npcChaseSpeedValue').textContent = chaseSpeed;
            document.getElementById('npcDamageValue').textContent = damage;
            document.getElementById('npcCooldownValue').textContent = attackCooldown.toFixed(1) + 's';
            document.getElementById('npcLungeOptions').style.display = attackMode === 'lunge' ? 'block' : 'none';
            document.getElementById('npcLungeRangeValue').textContent = attackRange + ' tiles';
            document.getElementById('npcLungeSpeedValue').textContent = lungeSpeed;
            document.getElementById('npcSlowdownValue').textContent = slowdownPercent + '%';
            document.getElementById('npcSlowdownDurationValue').textContent = slowdownDuration.toFixed(2) + 's';

            // Update placed NPC data
            placed.isEnemy = isEnemy;
            placed.visionRadius = visionRadius;
            placed.chaseSpeed = chaseSpeed;
            placed.attackMode = attackMode;
            placed.damage = damage;
            placed.attackCooldown = attackCooldown;
            placed.attackRange = attackRange;
            placed.lungeSpeed = lungeSpeed;
            placed.slowdownPercent = slowdownPercent;
            placed.slowdownDuration = slowdownDuration;

            // Broadcast to live sync
            broadcastEdit({
                editType: 'updatePlacedNpc',
                index: selectedPlacedNpcIndex,
                npc: placed
            });

            renderMap();
        }

        function updateNpcScale() {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];

            const scale = parseFloat(document.getElementById('npcScale').value) || 1;
            document.getElementById('npcScaleValue').textContent = scale.toFixed(1) + 'x';

            placed.scale = scale;

            // Broadcast to live sync
            broadcastEdit({
                editType: 'updatePlacedNpc',
                index: selectedPlacedNpcIndex,
                npc: placed
            });

            renderMap();
        }

        function hideNpcPathPanel() {
            document.getElementById('npcPathPanel').style.display = 'none';
            npcPathDrawing = false;
            updatePathDrawButton();
        }

        // Toggle NPC settings collapsible panel
        let npcSettingsExpanded = false;
        function toggleNpcSettingsPanel() {
            npcSettingsExpanded = !npcSettingsExpanded;
            const content = document.getElementById('npcSettingsContent');
            const toggle = document.getElementById('npcSettingsToggle');
            if (npcSettingsExpanded) {
                content.style.display = 'block';
                toggle.textContent = '-';
            } else {
                content.style.display = 'none';
                toggle.textContent = '+';
            }
        }

        function toggleNpcPathDrawing() {
            npcPathDrawing = !npcPathDrawing;
            if (npcPathDrawing) {
                npcPathEditing = false; // Disable edit mode when drawing
            }
            updatePathDrawButton();
        }

        function updatePathDrawButton() {
            const drawBtn = document.getElementById('npcDrawPathBtn');
            const editBtn = document.getElementById('npcEditPathBtn');
            const info = document.getElementById('npcPathInfo');

            if (npcPathDrawing) {
                drawBtn.textContent = 'Stop Drawing';
                drawBtn.style.background = '#a55';
                editBtn.style.background = '#47a';
                info.textContent = 'Click tiles to add waypoints. Right-click to undo.';
                info.style.color = '#4f4';
            } else if (npcPathEditing) {
                drawBtn.textContent = 'Draw Path';
                drawBtn.style.background = '#4a4';
                editBtn.textContent = 'Stop Editing';
                editBtn.style.background = '#a55';
                info.textContent = 'Drag waypoint markers to move them. Right-click to delete.';
                info.style.color = '#fa4';
            } else {
                drawBtn.textContent = 'Draw Path';
                drawBtn.style.background = '#4a4';
                editBtn.textContent = 'Edit Path';
                editBtn.style.background = '#47a';
                info.textContent = 'Click tiles to add waypoints';
                info.style.color = '#666';
            }
        }

        function toggleNpcPathEditing() {
            npcPathEditing = !npcPathEditing;
            if (npcPathEditing) {
                npcPathDrawing = false; // Disable draw mode when editing
            }
            npcDraggingWaypoint = -1;
            updatePathDrawButton();
        }

        // Find the nearest waypoint to a given position (within 1 tile distance)
        function findNearestWaypoint(x, y, path) {
            if (!path || path.length === 0) return -1;

            let nearest = -1;
            let minDist = 2; // Max distance of 2 tiles to select

            for (let i = 0; i < path.length; i++) {
                const wp = path[i];
                const dist = Math.abs(wp.x - x) + Math.abs(wp.y - y); // Manhattan distance
                if (dist < minDist) {
                    minDist = dist;
                    nearest = i;
                }
            }

            return nearest;
        }

        function addNpcWaypoint(x, y) {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (!placed.path) placed.path = [];

            // Don't add duplicate consecutive waypoints
            const last = placed.path[placed.path.length - 1];
            if (last && last.x === x && last.y === y) return;

            placed.path.push({ x, y });
            updateNpcWaypointList();
            renderMap();
        }

        function removeLastNpcWaypoint() {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (placed.path && placed.path.length > 0) {
                placed.path.pop();
                updateNpcWaypointList();
                renderMap();
            }
        }

        function clearNpcPath() {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            placed.path = [];
            updateNpcWaypointList();
            renderMap();
        }

        function updateNpcTrigger() {
            if (selectedPlacedNpcIndex < 0) return;
            placedNpcs[selectedPlacedNpcIndex].trigger = document.getElementById('npcTriggerType').value;
        }

        function updateNpcSpeed() {
            if (selectedPlacedNpcIndex < 0) return;
            const speed = parseInt(document.getElementById('npcWalkSpeed').value);
            placedNpcs[selectedPlacedNpcIndex].speed = speed;
            document.getElementById('npcSpeedValue').textContent = speed;
        }

        function updateNpcAnimSpeed() {
            if (selectedPlacedNpcIndex < 0) return;
            const fps = parseInt(document.getElementById('npcAnimSpeed').value);
            placedNpcs[selectedPlacedNpcIndex].animSpeed = fps;
            document.getElementById('npcAnimSpeedValue').textContent = fps + ' fps';
        }

        function updateNpcWaypointList() {
            const container = document.getElementById('npcWaypointList');
            if (selectedPlacedNpcIndex < 0) {
                container.innerHTML = 'No NPC selected';
                return;
            }

            const placed = placedNpcs[selectedPlacedNpcIndex];
            const path = placed.path || [];

            if (path.length === 0) {
                container.innerHTML = 'No waypoints - click Draw Path then click map';
                return;
            }

            // Get available animations for this NPC
            const npc = npcs[placed.npcIndex];
            const customAnims = [];
            if (npc && npc.animations) {
                Object.keys(npc.animations).forEach(key => {
                    if (!['walkDown', 'walkUp', 'walkLeft', 'walkRight', 'idle', 'attackDown', 'attackUp', 'attackLeft', 'attackRight'].includes(key)) {
                        customAnims.push(key);
                    }
                });
            }

            // Show list of waypoints with clear action controls
            let html = '<strong>Waypoints:</strong><div style="margin-top:8px;">';
            path.forEach((wp, i) => {
                const duration = wp.idleTime || 0;
                const action = wp.animation || 'walk';
                const hasStop = duration > 0;

                html += `<div style="background:#1a1a2e; border-radius:4px; padding:6px; margin-bottom:6px; border-left:3px solid ${hasStop ? '#4af' : '#444'};">`;

                // Header row: waypoint number and position
                html += `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">`;
                html += `<span style="font-weight:bold; color:#4af;">#${i + 1}</span>`;
                html += `<span style="color:#666; font-size:10px;">(${wp.x}, ${wp.y})</span>`;
                html += `</div>`;

                // Action row: what to do at this waypoint
                html += `<div style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;">`;

                // Action dropdown
                html += `<select id="wpAction${i}" style="font-size:11px; padding:3px; background:#333; border:1px solid #555; color:#fff; border-radius:3px;" onchange="setWaypointAction(${i}, this.value)">`;
                html += `<option value="walk"${action === 'walk' ? ' selected' : ''}>Walk through</option>`;
                html += `<option value="idle"${action === 'idle' ? ' selected' : ''}>Stop & Idle</option>`;
                customAnims.forEach(anim => {
                    html += `<option value="${anim}"${action === anim ? ' selected' : ''}>Stop & ${anim}</option>`;
                });
                html += `</select>`;

                // Duration (only show if not walking through)
                if (action !== 'walk') {
                    html += `<span style="color:#888; font-size:10px;">for</span>`;
                    html += `<input type="number" min="1" max="60" value="${duration || 2}" style="width:40px; padding:3px; font-size:11px; background:#333; border:1px solid #555; color:#fff; border-radius:3px; text-align:center;" onchange="setWaypointDuration(${i}, this.value)">`;
                    html += `<span style="color:#888; font-size:10px;">sec</span>`;
                }

                html += `</div>`;
                html += `</div>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function setWaypointAction(index, action) {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (placed.path && placed.path[index]) {
                placed.path[index].animation = action;
                // If switching from walk to an action, set default duration
                if (action !== 'walk' && !placed.path[index].idleTime) {
                    placed.path[index].idleTime = 2; // Default 2 seconds
                }
                // If switching to walk, clear duration
                if (action === 'walk') {
                    placed.path[index].idleTime = 0;
                }
                updateNpcWaypointList(); // Refresh to show/hide duration
            }
        }

        function setWaypointDuration(index, value) {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (placed.path && placed.path[index]) {
                placed.path[index].idleTime = Math.max(1, parseFloat(value) || 2);
            }
        }

        function setWaypointIdle(index, value) {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (placed.path && placed.path[index]) {
                placed.path[index].idleTime = parseFloat(value) || 0;
            }
        }

        function setWaypointAnim(index, value) {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (placed.path && placed.path[index]) {
                placed.path[index].animation = value || '';
            }
        }

        function updatePlacedNpcList() {
            const container = document.getElementById('placedNpcList');
            const currentMapNpcs = placedNpcs.filter(p => p.mapName === currentMapName);

            if (currentMapNpcs.length === 0) {
                container.innerHTML = 'No NPCs placed on this map';
                return;
            }

            container.innerHTML = '';
            currentMapNpcs.forEach((placed, localIdx) => {
                const globalIdx = placedNpcs.indexOf(placed);
                const npc = npcs[placed.npcIndex];
                const div = document.createElement('div');
                div.style.cssText = 'padding:4px; margin-bottom:3px; background:' +
                    (globalIdx === selectedPlacedNpcIndex ? '#2a5a8a' : '#333') +
                    '; border-radius:3px; cursor:pointer;';
                div.innerHTML = `<strong>${npc ? npc.name : 'Unknown'}</strong> at (${placed.x},${placed.y})` +
                    `<br><span style="font-size:9px; color:#888;">${placed.trigger} | ${placed.path?.length || 0} waypoints</span>`;
                div.onclick = () => selectPlacedNpc(globalIdx);
                container.appendChild(div);
            });
        }

        // ===== NPC PATH PREVIEW =====
        function toggleNpcPathPreview() {
            if (npcPathPreviewActive) {
                stopNpcPathPreview();
            } else {
                startNpcPathPreview();
            }
        }

        function startNpcPathPreview() {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (!placed.path || placed.path.length === 0) {
                alert('No path to preview. Draw a path first.');
                return;
            }

            npcPathPreviewActive = true;
            npcPreviewState = {
                x: placed.x,
                y: placed.y,
                waypointIndex: 0,
                direction: 'down',
                frame: 0,
                frameTimer: 0,
                idleUntil: 0,  // Timestamp when idle ends
                waypointAnimation: ''  // Current animation at waypoint
            };

            // Update button
            const btn = document.getElementById('npcPreviewPathBtn');
            btn.textContent = 'Edit';
            btn.style.background = '#a55';

            // Start animation loop
            npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
        }

        function stopNpcPathPreview() {
            npcPathPreviewActive = false;
            if (npcPreviewAnimId) {
                cancelAnimationFrame(npcPreviewAnimId);
                npcPreviewAnimId = null;
            }
            npcPreviewState = null;

            // Update button
            const btn = document.getElementById('npcPreviewPathBtn');
            if (btn) {
                btn.textContent = '▶ Preview';
                btn.style.background = '#47a';
            }

            renderMap();
        }

        let lastPreviewTime = 0;
        function npcPathPreviewLoop(timestamp) {
            if (!npcPathPreviewActive || selectedPlacedNpcIndex < 0) {
                stopNpcPathPreview();
                return;
            }

            const deltaTime = timestamp - lastPreviewTime;
            lastPreviewTime = timestamp;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            const path = placed.path || [];
            const speed = (placed.speed || 3) * 0.05; // Slower for editor preview

            if (path.length === 0) {
                stopNpcPathPreview();
                return;
            }

            // Check if currently idling at a waypoint
            if (npcPreviewState.idleUntil > 0) {
                if (timestamp < npcPreviewState.idleUntil) {
                    // Still idling - just animate, don't move
                    npcPreviewState.frameTimer++;
                    const npc = npcs[placed.npcIndex];
                    const fps = placed.animSpeed || npc?.fps || 8;
                    const animDelay = Math.max(1, Math.round(60 / fps));
                    if (npcPreviewState.frameTimer >= animDelay) {
                        npcPreviewState.frameTimer = 0;
                        npcPreviewState.frame = (npcPreviewState.frame + 1) % 4;
                    }
                    renderMap();
                    npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
                    return;
                } else {
                    // Idle complete - advance to next waypoint
                    npcPreviewState.idleUntil = 0;
                    npcPreviewState.waypointAnimation = '';
                    npcPreviewState.waypointIndex++;

                    // Check if path complete
                    if (npcPreviewState.waypointIndex >= path.length) {
                        npcPreviewState.waypointIndex = 0;
                        npcPreviewState.x = placed.x;
                        npcPreviewState.y = placed.y;
                    }
                    renderMap();
                    npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
                    return;
                }
            }

            // Get target waypoint
            const waypoint = path[npcPreviewState.waypointIndex];
            if (!waypoint) {
                // Loop back to start
                npcPreviewState.waypointIndex = 0;
                npcPreviewState.x = placed.x;
                npcPreviewState.y = placed.y;
                npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
                return;
            }

            // Move towards waypoint
            const dx = waypoint.x - npcPreviewState.x;
            const dy = waypoint.y - npcPreviewState.y;
            const dist = Math.hypot(dx, dy);

            if (dist < speed) {
                // Reached waypoint
                npcPreviewState.x = waypoint.x;
                npcPreviewState.y = waypoint.y;

                // Check for waypoint action (idle time, animation)
                let idleTime = waypoint.idleTime || 0;
                const wpAnim = waypoint.animation || '';

                // If animation is set but not "walk", ensure minimum idle time
                if (wpAnim && wpAnim !== 'walk' && wpAnim !== '' && idleTime <= 0) {
                    idleTime = 2;
                }

                if (idleTime > 0) {
                    // Start idling at this waypoint
                    npcPreviewState.idleUntil = timestamp + (idleTime * 1000);
                    npcPreviewState.waypointAnimation = wpAnim;
                    // Don't advance waypoint yet
                } else {
                    // No idle - advance immediately
                    npcPreviewState.waypointIndex++;
                    if (npcPreviewState.waypointIndex >= path.length) {
                        npcPreviewState.waypointIndex = 0;
                        npcPreviewState.x = placed.x;
                        npcPreviewState.y = placed.y;
                    }
                }
            } else {
                // Move
                npcPreviewState.x += (dx / dist) * speed;
                npcPreviewState.y += (dy / dist) * speed;

                // Set direction
                if (Math.abs(dx) > Math.abs(dy)) {
                    npcPreviewState.direction = dx > 0 ? 'right' : 'left';
                } else {
                    npcPreviewState.direction = dy > 0 ? 'down' : 'up';
                }
            }

            // Update animation frame
            npcPreviewState.frameTimer++;
            const npc = npcs[placed.npcIndex];
            const fps = placed.animSpeed || npc?.fps || 8;
            const animDelay = Math.max(1, Math.round(60 / fps));
            if (npcPreviewState.frameTimer >= animDelay) {
                npcPreviewState.frameTimer = 0;
                npcPreviewState.frame = (npcPreviewState.frame + 1) % 4;
            }

            // Render
            renderMap();

            // Continue loop
            npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
        }

        // ===== ANIMATED PROPS FUNCTIONS =====
        let animPropEditorImage = null;
        let animPropEditorData = null;
        let animPropEditorFrameW = 16;
        let animPropEditorFrameH = 16;
        let animPropEditorEditingIndex = -1;
        let animPropEditorZoom = 3; // Zoom level for sprite sheet
        let animPropTool = 'none'; // 'none', 'collision', 'erase', 'split'
        let animPropCollisionMask = null; // 2D array for collision pixels
        let animPropSplitLine = null; // Array of Y values per column (like tileSplitLines)
        let animPropPainting = false;

        function animPropZoomIn() {
            animPropEditorZoom = Math.min(6, animPropEditorZoom + 1);
            document.getElementById('animPropZoomLevel').textContent = animPropEditorZoom + 'x';
            animPropDrawCanvas();
        }

        function animPropZoomOut() {
            animPropEditorZoom = Math.max(1, animPropEditorZoom - 1);
            document.getElementById('animPropZoomLevel').textContent = animPropEditorZoom + 'x';
            animPropDrawCanvas();
        }

        function openAnimPropEditor(editIndex = -1) {
            // Stop any running preview from previous session
            animPropStopPreview();

            animPropEditorEditingIndex = editIndex;
            animPropFrames = [];

            // Reset collision/split tool state
            animPropTool = 'none';
            setAnimPropTool('none');

            if (editIndex >= 0 && animatedProps[editIndex]) {
                // Editing existing
                const prop = animatedProps[editIndex];
                animPropEditorFrameW = prop.frameWidth || 16;
                animPropEditorFrameH = prop.frameHeight || 16;
                animPropFrames = JSON.parse(JSON.stringify(prop.frames || []));
                animPropEditorData = prop.spriteData;
                document.getElementById('animPropNameInput').value = prop.name;
                document.getElementById('animPropType').value = prop.type || 'loop';
                const fps = prop.fps || 8;
                document.getElementById('animPropSpeedSlider').value = fps;
                document.getElementById('animPropSpeedLabel').textContent = fps + ' fps';

                // Load existing collision/split data
                animPropCollisionMask = prop.collisionMask ? JSON.parse(JSON.stringify(prop.collisionMask)) : null;
                animPropSplitLine = prop.splitLine ? JSON.parse(JSON.stringify(prop.splitLine)) : null;

                // Load giveItem settings
                document.getElementById('animPropGiveItem').checked = prop.giveItem || false;
                if (prop.type === 'interactive') {
                    document.getElementById('animPropInteractOptions').style.display = 'block';
                    animPropUpdateItemDropdown();
                    if (prop.giveItem) {
                        document.getElementById('animPropItemSection').style.display = 'block';
                        if (prop.giveItemIndex >= 0 && prop.giveItemIndex < items.length) {
                            document.getElementById('animPropItemSelect').value = prop.giveItemIndex;
                        }
                    } else {
                        document.getElementById('animPropItemSection').style.display = 'none';
                    }
                } else {
                    document.getElementById('animPropInteractOptions').style.display = 'none';
                    document.getElementById('animPropItemSection').style.display = 'none';
                }

                if (prop.spriteData) {
                    animPropEditorImage = new Image();
                    animPropEditorImage.onload = () => {
                        document.getElementById('animPropFrameSection').style.display = 'block';
                        document.getElementById('animPropTypeSection').style.display = 'block';
                        document.getElementById('animPropCollisionSection').style.display = 'block';
                        document.getElementById('animPropNameSection').style.display = 'block';
                        animPropDrawCanvas();
                        animPropUpdateFramesList();
                    };
                    animPropEditorImage.src = prop.spriteData;
                    document.getElementById('animPropFileName').textContent = 'Sprite loaded';
                }
            } else {
                // New prop - default frame size to match grid size
                animPropEditorImage = null;
                animPropEditorData = null;
                animPropEditorFrameW = gridSize;
                animPropEditorFrameH = gridSize;
                animPropCollisionMask = null;
                animPropSplitLine = null;
                animPropFrames = []; // Ensure frames list is cleared
                document.getElementById('animPropNameInput').value = '';
                document.getElementById('animPropType').value = 'loop';
                document.getElementById('animPropSpeedSlider').value = 8;
                document.getElementById('animPropSpeedLabel').textContent = '8 fps';
                document.getElementById('animPropFileName').textContent = '';
                document.getElementById('animPropFrameSection').style.display = 'none';
                document.getElementById('animPropTypeSection').style.display = 'none';
                document.getElementById('animPropCollisionSection').style.display = 'none';
                document.getElementById('animPropNameSection').style.display = 'none';
                // Reset give item settings
                document.getElementById('animPropGiveItem').checked = false;
                document.getElementById('animPropInteractOptions').style.display = 'none';
                document.getElementById('animPropItemSection').style.display = 'none';
                // Clear live preview
                const previewCtx = document.getElementById('animPropLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 48, 48);
                // Clear editor canvas
                const editorCanvas = document.getElementById('animPropEditorCanvas');
                const editorCtx = editorCanvas.getContext('2d');
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                // Clear frames list display
                const framesList = document.getElementById('animPropFramesList');
                if (framesList) framesList.innerHTML = '';
                // Reset file input
                const fileInput = document.getElementById('animPropFileInput');
                if (fileInput) fileInput.value = '';
            }

            document.getElementById('animPropFrameW').value = animPropEditorFrameW;
            document.getElementById('animPropFrameH').value = animPropEditorFrameH;
            animPropUpdateFramesList();

            document.getElementById('animPropModal').classList.add('visible');
        }

        function animPropLoadSheet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                animPropEditorData = e.target.result;
                animPropEditorImage = new Image();
                animPropEditorImage.onload = () => {
                    document.getElementById('animPropFileName').textContent = file.name + ' (' + animPropEditorImage.naturalWidth + 'x' + animPropEditorImage.naturalHeight + ')';
                    document.getElementById('animPropFrameSection').style.display = 'block';
                    document.getElementById('animPropTypeSection').style.display = 'block';
                    document.getElementById('animPropCollisionSection').style.display = 'block';
                    document.getElementById('animPropNameSection').style.display = 'block';

                    // Reset collision/split for new sheet
                    animPropCollisionMask = null;
                    animPropSplitLine = null;

                    // Auto-suggest frame size
                    const w = animPropEditorImage.naturalWidth;
                    const h = animPropEditorImage.naturalHeight;
                    const sizes = [16, 32, 24, 48, 64];
                    for (const size of sizes) {
                        if (w % size === 0 && h % size === 0) {
                            animPropEditorFrameW = size;
                            animPropEditorFrameH = size;
                            break;
                        }
                    }
                    document.getElementById('animPropFrameW').value = animPropEditorFrameW;
                    document.getElementById('animPropFrameH').value = animPropEditorFrameH;

                    animPropUpdateGrid();
                    animPropDrawCanvas();
                };
                animPropEditorImage.src = animPropEditorData;
            };
            reader.readAsDataURL(file);
        }

        function animPropUpdateGrid() {
            animPropEditorFrameW = parseInt(document.getElementById('animPropFrameW').value) || 16;
            animPropEditorFrameH = parseInt(document.getElementById('animPropFrameH').value) || 16;

            if (animPropEditorImage) {
                const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
                const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);
                document.getElementById('animPropGridInfo').textContent = cols + ' cols x ' + rows + ' rows';
            }

            animPropDrawCanvas();
        }

        function animPropDrawCanvas() {
            const canvas = document.getElementById('animPropEditorCanvas');
            const ctx = canvas.getContext('2d');

            if (!animPropEditorImage) {
                canvas.width = 400;
                canvas.height = 300;
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Load a sprite sheet to begin', 200, 150);
                return;
            }

            const scale = animPropEditorZoom;
            canvas.width = animPropEditorImage.naturalWidth * scale;
            canvas.height = animPropEditorImage.naturalHeight * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(animPropEditorImage, 0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
            const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);

            for (let x = 0; x <= cols; x++) {
                ctx.beginPath();
                ctx.moveTo(x * animPropEditorFrameW * scale, 0);
                ctx.lineTo(x * animPropEditorFrameW * scale, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * animPropEditorFrameH * scale);
                ctx.lineTo(canvas.width, y * animPropEditorFrameH * scale);
                ctx.stroke();
            }

            // Highlight selected frames
            ctx.strokeStyle = '#4af';
            ctx.lineWidth = 3;
            animPropFrames.forEach((frame, i) => {
                ctx.strokeRect(frame.x * scale + 2, frame.y * scale + 2, frame.w * scale - 4, frame.h * scale - 4);
                ctx.fillStyle = '#4af';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(i + 1, frame.x * scale + 6, frame.y * scale + 18);
            });

            // Draw current drag selection
            if (animPropIsDragging && animPropDragStart && animPropDragEnd) {
                const startGX = Math.min(animPropDragStart.gridX, animPropDragEnd.gridX);
                const startGY = Math.min(animPropDragStart.gridY, animPropDragEnd.gridY);
                const endGX = Math.max(animPropDragStart.gridX, animPropDragEnd.gridX);
                const endGY = Math.max(animPropDragStart.gridY, animPropDragEnd.gridY);

                const selX = startGX * animPropEditorFrameW * scale;
                const selY = startGY * animPropEditorFrameH * scale;
                const selW = (endGX - startGX + 1) * animPropEditorFrameW * scale;
                const selH = (endGY - startGY + 1) * animPropEditorFrameH * scale;

                ctx.fillStyle = 'rgba(74, 170, 255, 0.3)';
                ctx.fillRect(selX, selY, selW, selH);
                ctx.strokeStyle = '#4af';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(selX, selY, selW, selH);
                ctx.setLineDash([]);
            }

            // Draw collision mask overlay on first frame area
            if (animPropFrames.length > 0 && animPropCollisionMask) {
                const frame = animPropFrames[0];
                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                for (let py = 0; py < animPropCollisionMask.length; py++) {
                    if (!animPropCollisionMask[py]) continue;
                    for (let px = 0; px < animPropCollisionMask[py].length; px++) {
                        if (animPropCollisionMask[py][px]) {
                            ctx.fillRect(
                                (frame.x + px) * scale,
                                (frame.y + py) * scale,
                                scale, scale
                            );
                        }
                    }
                }
            }

            // Draw split line overlay on ALL frames - per tile
            if (animPropFrames.length > 0 && animPropSplitLine && typeof animPropSplitLine === 'object') {
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                ctx.font = 'bold 10px sans-serif';
                ctx.fillStyle = '#0ff';

                // Draw on every frame
                for (const frame of animPropFrames) {
                    const tilesW = Math.ceil(frame.w / gridSize);
                    const tilesH = Math.ceil(frame.h / gridSize);

                    for (let ty = 0; ty < tilesH; ty++) {
                        for (let tx = 0; tx < tilesW; tx++) {
                            const key = tx + ',' + ty;
                            const splitY = animPropSplitLine[key];
                            if (splitY === undefined || splitY === null) continue;

                            const tileStartX = frame.x + tx * gridSize;
                            const tileStartY = frame.y + ty * gridSize;

                            // Draw horizontal line across this tile
                            ctx.beginPath();
                            ctx.moveTo(tileStartX * scale, (tileStartY + splitY) * scale);
                            ctx.lineTo((tileStartX + gridSize) * scale, (tileStartY + splitY) * scale);
                            ctx.stroke();

                            // Draw C/T labels (smaller for per-tile)
                            ctx.fillText('C', tileStartX * scale + 2, (tileStartY + splitY / 2) * scale + 5);
                            ctx.fillText('T', tileStartX * scale + 2, (tileStartY + splitY + (gridSize - splitY) / 2) * scale + 5);
                        }
                    }
                }
            }
        }

        // Animated prop editor brush size
        let animPropBrushSize = 4;
        let animPropFlatLineY = null; // Y position locked when flat line mode + dragging

        // Tool switching for animated prop editor
        function setAnimPropTool(tool) {
            animPropTool = tool;
            ['None', 'Collision', 'Erase', 'Split'].forEach(t => {
                const btn = document.getElementById('animPropTool' + t);
                if (btn) btn.classList.toggle('active', t.toLowerCase() === tool);
            });

            // Show/hide brush section for collision/erase tools
            const brushSection = document.getElementById('animPropBrushSection');
            if (brushSection) {
                brushSection.style.display = (tool === 'collision' || tool === 'erase') ? 'block' : 'none';
            }

            // Show/hide split controls
            const splitControls = document.getElementById('animPropSplitControls');
            if (splitControls) {
                splitControls.style.display = (tool === 'split') ? 'block' : 'none';
            }
        }

        function setAnimPropBrush(size) {
            animPropBrushSize = size;
            [1, 2, 4, 8].forEach(s => {
                const btn = document.getElementById('animPropBrush' + s);
                if (btn) btn.classList.toggle('active', s === size);
            });
        }

        function setAnimPropSplitY() {
            const yVal = parseInt(document.getElementById('animPropSplitY').value) || 8;
            if (animPropFrames.length === 0) return;

            // Initialize split lines object if needed
            if (!animPropSplitLine || typeof animPropSplitLine !== 'object' || Array.isArray(animPropSplitLine)) {
                animPropSplitLine = {};
            }

            // Set same Y for all tiles in the prop
            const frame = animPropFrames[0];
            const tilesW = Math.ceil(frame.w / gridSize);
            const tilesH = Math.ceil(frame.h / gridSize);

            for (let ty = 0; ty < tilesH; ty++) {
                for (let tx = 0; tx < tilesW; tx++) {
                    const key = tx + ',' + ty;
                    animPropSplitLine[key] = Math.max(0, Math.min(gridSize, yVal));
                }
            }
            animPropDrawCanvas();
        }

        function clearAnimPropSplit() {
            animPropSplitLine = null;
            animPropDrawCanvas();
        }

        // Collision/split painting helpers
        function animPropPaintCollision(px, py, erase) {
            if (animPropFrames.length === 0) return;

            // Find which frame was clicked (can be any frame)
            let clickedFrame = null;
            for (const frame of animPropFrames) {
                if (px >= frame.x && px < frame.x + frame.w &&
                    py >= frame.y && py < frame.y + frame.h) {
                    clickedFrame = frame;
                    break;
                }
            }
            if (!clickedFrame) return;

            // Use first frame dimensions for mask size
            const frame0 = animPropFrames[0];

            // Initialize mask if needed
            if (!animPropCollisionMask) {
                animPropCollisionMask = [];
                for (let y = 0; y < frame0.h; y++) {
                    animPropCollisionMask[y] = new Array(frame0.w).fill(false);
                }
            }

            // Calculate position relative to clicked frame
            const localX = px - clickedFrame.x;
            const localY = py - clickedFrame.y;

            if (localX < 0 || localX >= frame0.w || localY < 0 || localY >= frame0.h) return;

            // Paint with brush size
            const halfBrush = Math.floor(animPropBrushSize / 2);
            for (let dy = -halfBrush; dy < animPropBrushSize - halfBrush; dy++) {
                for (let dx = -halfBrush; dx < animPropBrushSize - halfBrush; dx++) {
                    const bx = localX + dx;
                    const by = localY + dy;
                    if (bx >= 0 && bx < frame0.w && by >= 0 && by < frame0.h) {
                        if (!animPropCollisionMask[by]) animPropCollisionMask[by] = [];
                        animPropCollisionMask[by][bx] = !erase;
                    }
                }
            }
        }

        function animPropPaintSplit(px, py, isStart = false) {
            if (animPropFrames.length === 0) return;

            // Find which frame was clicked (can be any frame, not just first)
            let clickedFrame = null;
            for (const frame of animPropFrames) {
                if (px >= frame.x && px < frame.x + frame.w &&
                    py >= frame.y && py < frame.y + frame.h) {
                    clickedFrame = frame;
                    break;
                }
            }
            if (!clickedFrame) return;

            // Calculate which tile within the frame was clicked
            const localX = px - clickedFrame.x;
            const localY = py - clickedFrame.y;

            const tileX = Math.floor(localX / gridSize);
            const tileY = Math.floor(localY / gridSize);

            // Y position within the tile
            const tileLocalY = localY - (tileY * gridSize);
            // Round to nearest pixel, and snap to gridSize if in bottom 2 pixels (allows full tile split)
            let clampedY = Math.round(tileLocalY);
            if (tileLocalY >= gridSize - 2) clampedY = gridSize;
            clampedY = Math.max(0, Math.min(gridSize, clampedY));

            // Check flat line mode
            const flatLineCheckbox = document.getElementById('animPropFlatLine');
            const flatLineMode = flatLineCheckbox && flatLineCheckbox.checked;

            if (flatLineMode) {
                if (isStart) {
                    // Lock Y on first click
                    animPropFlatLineY = clampedY;
                } else if (animPropFlatLineY !== null) {
                    // Use locked Y for subsequent drags
                    clampedY = animPropFlatLineY;
                }
            }

            // Initialize split lines object if needed: key "tileX,tileY" -> splitY
            if (!animPropSplitLine || typeof animPropSplitLine !== 'object' || Array.isArray(animPropSplitLine)) {
                animPropSplitLine = {};
            }

            const key = tileX + ',' + tileY;
            animPropSplitLine[key] = clampedY;
        }

        // Canvas drag handlers for animated prop editor (multi-tile selection)
        document.getElementById('animPropEditorCanvas').addEventListener('mousedown', function(e) {
            if (!animPropEditorImage) return;

            const rect = this.getBoundingClientRect();
            const scale = animPropEditorZoom;
            const clickX = (e.clientX - rect.left) / scale;
            const clickY = (e.clientY - rect.top) / scale;

            if (animPropTool === 'collision' || animPropTool === 'erase') {
                animPropPainting = true;
                animPropPaintCollision(Math.floor(clickX), Math.floor(clickY), animPropTool === 'erase');
                animPropDrawCanvas();
            } else if (animPropTool === 'split') {
                animPropPainting = true;
                animPropPaintSplit(Math.floor(clickX), Math.floor(clickY), true); // isStart = true
                animPropDrawCanvas();
            } else {
                // Frame selection mode
                const gridX = Math.floor(clickX / animPropEditorFrameW);
                const gridY = Math.floor(clickY / animPropEditorFrameH);

                animPropDragStart = { gridX, gridY };
                animPropDragEnd = { gridX, gridY };
                animPropIsDragging = true;
                animPropDrawCanvas();
            }
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mousemove', function(e) {
            if (!animPropEditorImage) return;

            const rect = this.getBoundingClientRect();
            const scale = animPropEditorZoom;
            const clickX = (e.clientX - rect.left) / scale;
            const clickY = (e.clientY - rect.top) / scale;

            if (animPropPainting) {
                if (animPropTool === 'collision' || animPropTool === 'erase') {
                    animPropPaintCollision(Math.floor(clickX), Math.floor(clickY), animPropTool === 'erase');
                    animPropDrawCanvas();
                } else if (animPropTool === 'split') {
                    animPropPaintSplit(Math.floor(clickX), Math.floor(clickY));
                    animPropDrawCanvas();
                }
            } else if (animPropIsDragging) {
                const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
                const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);

                const gridX = Math.max(0, Math.min(cols - 1, Math.floor(clickX / animPropEditorFrameW)));
                const gridY = Math.max(0, Math.min(rows - 1, Math.floor(clickY / animPropEditorFrameH)));

                animPropDragEnd = { gridX, gridY };
                animPropDrawCanvas();
            }
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mouseup', function(e) {
            if (!animPropEditorImage) return;

            if (animPropPainting) {
                animPropPainting = false;
                animPropFlatLineY = null; // Reset flat line Y lock
                return;
            }

            if (!animPropIsDragging) return;
            animPropIsDragging = false;

            // Calculate selection rectangle
            const startGX = Math.min(animPropDragStart.gridX, animPropDragEnd.gridX);
            const startGY = Math.min(animPropDragStart.gridY, animPropDragEnd.gridY);
            const endGX = Math.max(animPropDragStart.gridX, animPropDragEnd.gridX);
            const endGY = Math.max(animPropDragStart.gridY, animPropDragEnd.gridY);

            const frameX = startGX * animPropEditorFrameW;
            const frameY = startGY * animPropEditorFrameH;
            const frameW = (endGX - startGX + 1) * animPropEditorFrameW;
            const frameH = (endGY - startGY + 1) * animPropEditorFrameH;

            if (frameX >= animPropEditorImage.naturalWidth || frameY >= animPropEditorImage.naturalHeight) return;

            animPropFrames.push({
                x: frameX,
                y: frameY,
                w: frameW,
                h: frameH
            });

            animPropDragStart = null;
            animPropDragEnd = null;
            animPropDrawCanvas();
            animPropUpdateFramesList();
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mouseleave', function(e) {
            animPropPainting = false;
            if (animPropIsDragging) {
                animPropIsDragging = false;
                animPropDragStart = null;
                animPropDragEnd = null;
                animPropDrawCanvas();
            }
        });

        function animPropUpdateFramesList() {
            const container = document.getElementById('animPropFramesList');
            container.innerHTML = '';
            document.getElementById('animPropFrameCount').textContent = animPropFrames.length;

            if (animPropFrames.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px;">Click or drag on sprite sheet to select frames</div>';
                animPropStopPreview();
                // Clear live preview
                const previewCtx = document.getElementById('animPropLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 48, 48);
                return;
            }

            animPropFrames.forEach((frame, i) => {
                const thumb = document.createElement('div');
                thumb.className = 'anim-frame-thumb';

                const canvas = document.createElement('canvas');
                canvas.width = 48;
                canvas.height = 48;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;

                const scale = Math.min(48 / frame.w, 48 / frame.h);
                const drawW = frame.w * scale;
                const drawH = frame.h * scale;
                const drawX = (48 - drawW) / 2;
                const drawY = (48 - drawH) / 2;

                ctx.drawImage(animPropEditorImage, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);

                const num = document.createElement('span');
                num.className = 'frame-num';
                num.textContent = i + 1;

                thumb.appendChild(canvas);
                thumb.appendChild(num);
                thumb.onclick = () => {
                    animPropFrames.splice(i, 1);
                    animPropUpdateFramesList();
                    animPropDrawCanvas();
                };
                thumb.title = 'Click to remove';

                container.appendChild(thumb);
            });

            // Auto-start live preview when frames exist
            animPropStartLivePreview();
        }

        function animPropClearFrames() {
            if (!confirm('Clear all frames?')) return;
            animPropFrames = [];
            animPropUpdateFramesList();
            animPropDrawCanvas();
        }

        // Live animation preview - starts automatically when frames are added
        function animPropStartLivePreview() {
            if (animPropPreviewInterval) return; // Already running
            if (animPropFrames.length === 0) return;

            animPropPreviewFrame = 0;
            const fps = parseInt(document.getElementById('animPropSpeedSlider').value) || 8;

            animPropPreviewInterval = setInterval(() => {
                animPropPreviewFrame = (animPropPreviewFrame + 1) % animPropFrames.length;
                animPropDrawLivePreview();

                // Highlight current frame in list
                const thumbs = document.querySelectorAll('.anim-frame-thumb');
                thumbs.forEach((t, i) => {
                    t.style.borderColor = i === animPropPreviewFrame ? '#0f0' : '#4af';
                });
            }, 1000 / fps);
        }

        function animPropStopPreview() {
            if (animPropPreviewInterval) {
                clearInterval(animPropPreviewInterval);
                animPropPreviewInterval = null;
            }
            const thumbs = document.querySelectorAll('.anim-frame-thumb');
            thumbs.forEach(t => t.style.borderColor = '#4af');
        }

        function animPropDrawLivePreview() {
            const canvas = document.getElementById('animPropLivePreview');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 48, 48);

            if (!animPropEditorImage || animPropFrames.length === 0) return;

            const frame = animPropFrames[animPropPreviewFrame];
            if (!frame) return;

            ctx.imageSmoothingEnabled = false;
            // Scale to fit 48x48 preview
            const scale = Math.min(48 / frame.w, 48 / frame.h);
            const drawW = frame.w * scale;
            const drawH = frame.h * scale;
            const drawX = (48 - drawW) / 2;
            const drawY = (48 - drawH) / 2;
            ctx.drawImage(animPropEditorImage, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);
        }

        function animPropUpdateSpeed() {
            const fps = parseInt(document.getElementById('animPropSpeedSlider').value) || 8;
            document.getElementById('animPropSpeedLabel').textContent = fps + ' fps';
            document.getElementById('animPropSpeed').value = fps; // Sync with hidden input

            // Restart preview with new speed
            if (animPropPreviewInterval) {
                animPropStopPreview();
                animPropStartLivePreview();
            }
        }

        function animPropTypeChanged() {
            const type = document.getElementById('animPropType').value;
            const interactOptions = document.getElementById('animPropInteractOptions');
            if (type === 'interactive') {
                interactOptions.style.display = 'block';
                animPropUpdateItemDropdown();
            } else {
                interactOptions.style.display = 'none';
            }
        }

        function animPropGiveItemChanged() {
            const giveItem = document.getElementById('animPropGiveItem').checked;
            document.getElementById('animPropItemSection').style.display = giveItem ? 'block' : 'none';
            if (giveItem) {
                animPropUpdateItemDropdown();
            }
        }

        function animPropUpdateItemDropdown() {
            const select = document.getElementById('animPropItemSelect');
            const currentValue = select.value;
            select.innerHTML = '';

            if (items.length === 0) {
                const opt = document.createElement('option');
                opt.value = '-1';
                opt.textContent = '-- No items defined (create in Items tab) --';
                select.appendChild(opt);
            } else {
                items.forEach((item, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = item.name || ('Item ' + (i + 1));
                    select.appendChild(opt);
                });
            }

            // Restore previous selection if valid
            if (currentValue && parseInt(currentValue) >= 0 && parseInt(currentValue) < items.length) {
                select.value = currentValue;
            }
        }

        function animPropSave() {
            const name = document.getElementById('animPropNameInput').value.trim();
            if (!name) {
                alert('Please enter a name for the prop');
                return;
            }

            if (!animPropEditorImage) {
                alert('Please load a sprite sheet first');
                return;
            }

            if (animPropFrames.length === 0) {
                alert('Please add at least one frame');
                return;
            }

            const propType = document.getElementById('animPropType').value;
            const giveItem = document.getElementById('animPropGiveItem').checked;
            const giveItemIndex = giveItem ? parseInt(document.getElementById('animPropItemSelect').value) : -1;

            const propData = {
                name: name,
                spriteData: animPropEditorData,
                frameWidth: animPropEditorFrameW,
                frameHeight: animPropEditorFrameH,
                frames: [...animPropFrames],
                type: propType,
                fps: parseInt(document.getElementById('animPropSpeedSlider').value) || 8,
                collisionMask: animPropCollisionMask ? JSON.parse(JSON.stringify(animPropCollisionMask)) : null,
                splitLine: animPropSplitLine ? JSON.parse(JSON.stringify(animPropSplitLine)) : null,
                giveItem: giveItem,
                giveItemIndex: giveItemIndex,
                _spriteImg: animPropEditorImage // Store the loaded image
            };

            if (animPropEditorEditingIndex >= 0) {
                animatedProps[animPropEditorEditingIndex] = propData;
                // Sync prop update (exclude non-serializable _spriteImg)
                const syncProp = { ...propData };
                delete syncProp._spriteImg;
                broadcastEdit({ editType: 'updateAnimProp', index: animPropEditorEditingIndex, prop: syncProp });
            } else {
                animatedProps.push(propData);
                currentAnimPropIndex = animatedProps.length - 1; // Select the new prop
                // Sync new prop (exclude non-serializable _spriteImg)
                const syncProp = { ...propData };
                delete syncProp._spriteImg;
                broadcastEdit({ editType: 'addAnimProp', prop: syncProp });
            }

            animPropStopPreview();
            document.getElementById('animPropModal').classList.remove('visible');
            updateAnimPropListDisplay();
            renderMap();
        }

        function animPropCancel() {
            animPropStopPreview();
            document.getElementById('animPropModal').classList.remove('visible');
        }

        // ========== ITEM EDITOR FUNCTIONS ==========
        let itemEditorImage = null;
        let itemEditorData = null;
        let itemEditorFrameW = 16;
        let itemEditorFrameH = 16;
        let itemEditorEditingIndex = -1;
        let itemEditorZoom = 3;

        function openItemEditor(editIndex = -1) {
            itemStopPreview();
            itemEditorEditingIndex = editIndex;
            itemFrames = [];

            if (editIndex >= 0 && items[editIndex]) {
                const item = items[editIndex];
                itemEditorFrameW = item.frameWidth || 16;
                itemEditorFrameH = item.frameHeight || 16;
                itemFrames = JSON.parse(JSON.stringify(item.frames || []));
                itemEditorData = item.spriteData;
                document.getElementById('itemNameInput').value = item.name;
                const fps = item.fps || 8;
                document.getElementById('itemSpeedSlider').value = fps;
                document.getElementById('itemSpeedLabel').textContent = fps + ' fps';

                if (item.spriteData) {
                    itemEditorImage = new Image();
                    itemEditorImage.onload = () => {
                        document.getElementById('itemFrameSection').style.display = 'block';
                        document.getElementById('itemIdleSection').style.display = 'block';
                        document.getElementById('itemNameSection').style.display = 'block';
                        itemDrawCanvas();
                        itemUpdateFramesList();
                        itemUpdateIdleDropdown();
                        document.getElementById('itemIdleFrame').value = item.idleFrame || 0;
                    };
                    itemEditorImage.src = item.spriteData;
                    document.getElementById('itemFileName').textContent = 'Sprite loaded';
                }
            } else {
                itemEditorImage = null;
                itemEditorData = null;
                itemEditorFrameW = gridSize;
                itemEditorFrameH = gridSize;
                itemFrames = [];
                document.getElementById('itemNameInput').value = '';
                document.getElementById('itemSpeedSlider').value = 8;
                document.getElementById('itemSpeedLabel').textContent = '8 fps';
                document.getElementById('itemFileName').textContent = '';
                document.getElementById('itemFrameSection').style.display = 'none';
                document.getElementById('itemIdleSection').style.display = 'none';
                document.getElementById('itemNameSection').style.display = 'none';
                const previewCtx = document.getElementById('itemLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 48, 48);
                const editorCanvas = document.getElementById('itemEditorCanvas');
                const editorCtx = editorCanvas.getContext('2d');
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                const framesList = document.getElementById('itemFramesList');
                if (framesList) framesList.innerHTML = '';
                const fileInput = document.getElementById('itemFileInput');
                if (fileInput) fileInput.value = '';
            }

            document.getElementById('itemFrameW').value = itemEditorFrameW;
            document.getElementById('itemFrameH').value = itemEditorFrameH;
            itemUpdateFramesList();

            document.getElementById('itemModal').classList.add('visible');
        }

        function itemLoadSheet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                itemEditorData = e.target.result;
                itemEditorImage = new Image();
                itemEditorImage.onload = () => {
                    document.getElementById('itemFileName').textContent = file.name + ' (' + itemEditorImage.naturalWidth + 'x' + itemEditorImage.naturalHeight + ')';
                    document.getElementById('itemFrameSection').style.display = 'block';
                    document.getElementById('itemIdleSection').style.display = 'block';
                    document.getElementById('itemNameSection').style.display = 'block';

                    // Auto-suggest frame size
                    const w = itemEditorImage.naturalWidth;
                    const h = itemEditorImage.naturalHeight;
                    const sizes = [16, 32, 24, 48, 64];
                    for (const size of sizes) {
                        if (w % size === 0 && h % size === 0) {
                            itemEditorFrameW = size;
                            itemEditorFrameH = size;
                            break;
                        }
                    }
                    document.getElementById('itemFrameW').value = itemEditorFrameW;
                    document.getElementById('itemFrameH').value = itemEditorFrameH;

                    itemUpdateGrid();
                    itemDrawCanvas();
                };
                itemEditorImage.src = itemEditorData;
            };
            reader.readAsDataURL(file);
        }

        function itemUpdateGrid() {
            itemEditorFrameW = parseInt(document.getElementById('itemFrameW').value) || 16;
            itemEditorFrameH = parseInt(document.getElementById('itemFrameH').value) || 16;

            if (itemEditorImage) {
                const cols = Math.floor(itemEditorImage.naturalWidth / itemEditorFrameW);
                const rows = Math.floor(itemEditorImage.naturalHeight / itemEditorFrameH);
                document.getElementById('itemGridInfo').textContent = cols + ' cols x ' + rows + ' rows';
            }

            itemDrawCanvas();
        }

        function itemDrawCanvas() {
            const canvas = document.getElementById('itemEditorCanvas');
            const ctx = canvas.getContext('2d');

            if (!itemEditorImage) {
                canvas.width = 400;
                canvas.height = 300;
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Load a sprite sheet to begin', 200, 150);
                return;
            }

            const scale = itemEditorZoom;
            canvas.width = itemEditorImage.naturalWidth * scale;
            canvas.height = itemEditorImage.naturalHeight * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(itemEditorImage, 0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            const cols = Math.floor(itemEditorImage.naturalWidth / itemEditorFrameW);
            const rows = Math.floor(itemEditorImage.naturalHeight / itemEditorFrameH);

            for (let x = 0; x <= cols; x++) {
                ctx.beginPath();
                ctx.moveTo(x * itemEditorFrameW * scale, 0);
                ctx.lineTo(x * itemEditorFrameW * scale, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * itemEditorFrameH * scale);
                ctx.lineTo(canvas.width, y * itemEditorFrameH * scale);
                ctx.stroke();
            }

            // Highlight selected frames
            ctx.strokeStyle = '#4f8';
            ctx.lineWidth = 3;
            itemFrames.forEach((frame, i) => {
                ctx.strokeRect(frame.x * scale + 2, frame.y * scale + 2, frame.w * scale - 4, frame.h * scale - 4);
                ctx.fillStyle = '#4f8';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(i + 1, frame.x * scale + 6, frame.y * scale + 18);
            });

            // Draw drag selection box
            if (itemIsDragging && itemDragStart && itemDragEnd) {
                const startGX = Math.min(itemDragStart.gridX, itemDragEnd.gridX);
                const startGY = Math.min(itemDragStart.gridY, itemDragEnd.gridY);
                const endGX = Math.max(itemDragStart.gridX, itemDragEnd.gridX);
                const endGY = Math.max(itemDragStart.gridY, itemDragEnd.gridY);

                const selX = startGX * itemEditorFrameW * scale;
                const selY = startGY * itemEditorFrameH * scale;
                const selW = (endGX - startGX + 1) * itemEditorFrameW * scale;
                const selH = (endGY - startGY + 1) * itemEditorFrameH * scale;

                ctx.fillStyle = 'rgba(255, 200, 0, 0.3)';
                ctx.fillRect(selX, selY, selW, selH);
                ctx.strokeStyle = '#fc0';
                ctx.lineWidth = 3;
                ctx.strokeRect(selX, selY, selW, selH);
            }
        }

        // Legacy single-click handler (kept for backwards compat, but drag is preferred)
        function itemCanvasClick(e) {
            if (!itemEditorImage) return;
            const canvas = document.getElementById('itemEditorCanvas');
            const rect = canvas.getBoundingClientRect();
            const scale = itemEditorZoom;
            const x = Math.floor((e.clientX - rect.left) / (itemEditorFrameW * scale));
            const y = Math.floor((e.clientY - rect.top) / (itemEditorFrameH * scale));

            const frameX = x * itemEditorFrameW;
            const frameY = y * itemEditorFrameH;

            // Check if already selected
            const existingIdx = itemFrames.findIndex(f => f.x === frameX && f.y === frameY);
            if (existingIdx >= 0) {
                itemFrames.splice(existingIdx, 1);
            } else {
                itemFrames.push({ x: frameX, y: frameY, w: itemEditorFrameW, h: itemEditorFrameH });
            }

            itemDrawCanvas();
            itemUpdateFramesList();
            itemUpdateIdleDropdown();
            itemStartPreview();
        }

        function itemUpdateFramesList() {
            const container = document.getElementById('itemFramesList');
            const countEl = document.getElementById('itemFrameCount');
            if (!container) return;
            container.innerHTML = '';
            countEl.textContent = itemFrames.length;

            if (!itemEditorImage || itemFrames.length === 0) {
                container.innerHTML = '<span style="color:#666; font-size:11px;">Click frames on the sprite sheet</span>';
                return;
            }

            itemFrames.forEach((frame, i) => {
                const frameEl = document.createElement('div');
                frameEl.className = 'anim-frame-item';
                frameEl.innerHTML = `
                    <canvas width="32" height="32" style="border:1px solid #555; image-rendering:pixelated;"></canvas>
                    <span style="font-size:10px; color:#888;">${i + 1}</span>
                `;
                const canvas = frameEl.querySelector('canvas');
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(itemEditorImage, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                container.appendChild(frameEl);
            });
        }

        function itemUpdateIdleDropdown() {
            const select = document.getElementById('itemIdleFrame');
            if (!select) return;
            select.innerHTML = '';
            itemFrames.forEach((_, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = 'Frame ' + (i + 1) + (i === 0 ? ' (first)' : '');
                select.appendChild(opt);
            });
        }

        function itemClearFrames() {
            itemFrames = [];
            itemDrawCanvas();
            itemUpdateFramesList();
            itemUpdateIdleDropdown();
            itemStopPreview();
        }

        function itemStartPreview() {
            itemStopPreview();
            if (itemFrames.length === 0 || !itemEditorImage) return;
            const fps = parseInt(document.getElementById('itemSpeedSlider').value) || 8;
            itemPreviewPlaying = true;
            itemPreviewFrame = 0;
            itemPreviewInterval = setInterval(() => {
                itemPreviewFrame = (itemPreviewFrame + 1) % itemFrames.length;
                itemDrawPreviewFrame();
            }, 1000 / fps);
            itemDrawPreviewFrame();
        }

        function itemStopPreview() {
            if (itemPreviewInterval) {
                clearInterval(itemPreviewInterval);
                itemPreviewInterval = null;
            }
            itemPreviewPlaying = false;
        }

        function itemDrawPreviewFrame() {
            const canvas = document.getElementById('itemLivePreview');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 48, 48);
            if (!itemEditorImage || itemFrames.length === 0) return;
            const frame = itemFrames[itemPreviewFrame];
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(itemEditorImage, frame.x, frame.y, frame.w, frame.h, 0, 0, 48, 48);
        }

        function itemUpdateSpeed() {
            const fps = document.getElementById('itemSpeedSlider').value;
            document.getElementById('itemSpeedLabel').textContent = fps + ' fps';
            if (itemPreviewPlaying) itemStartPreview();
        }

        function itemZoomIn() {
            itemEditorZoom = Math.min(8, itemEditorZoom + 1);
            document.getElementById('itemZoomLevel').textContent = itemEditorZoom + 'x';
            itemDrawCanvas();
        }

        function itemZoomOut() {
            itemEditorZoom = Math.max(1, itemEditorZoom - 1);
            document.getElementById('itemZoomLevel').textContent = itemEditorZoom + 'x';
            itemDrawCanvas();
        }

        function itemSave() {
            if (!itemEditorData || itemFrames.length === 0) {
                alert('Please load a sprite sheet and select animation frames.');
                return;
            }

            const name = document.getElementById('itemNameInput').value.trim() || 'Item ' + (items.length + 1);
            const fps = parseInt(document.getElementById('itemSpeedSlider').value) || 8;
            const idleFrame = parseInt(document.getElementById('itemIdleFrame').value) || 0;

            const itemData = {
                name: name,
                spriteData: itemEditorData,
                frameWidth: itemEditorFrameW,
                frameHeight: itemEditorFrameH,
                frames: JSON.parse(JSON.stringify(itemFrames)),
                fps: fps,
                idleFrame: idleFrame
            };

            if (itemEditorEditingIndex >= 0) {
                items[itemEditorEditingIndex] = itemData;
            } else {
                items.push(itemData);
            }

            itemStopPreview();
            document.getElementById('itemModal').classList.remove('visible');
            updateItemList();
            renderMap();
        }

        function itemCancel() {
            itemStopPreview();
            document.getElementById('itemModal').classList.remove('visible');
        }

        function updateItemList() {
            const container = document.getElementById('itemList');
            if (!container) return;
            container.innerHTML = '';

            if (items.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; padding:10px;">No items yet</div>';
                return;
            }

            items.forEach((item, i) => {
                const itemEl = document.createElement('div');
                const isSelected = (currentItemIndex === i);
                itemEl.style.cssText = 'display:flex; align-items:center; gap:10px; padding:8px; background:' + (isSelected ? '#3a4a3a' : '#333') + '; border:2px solid ' + (isSelected ? '#4f8' : 'transparent') + '; border-radius:5px; margin-bottom:5px; cursor:pointer;';
                itemEl.onclick = () => { currentItemIndex = i; updateItemList(); };

                // Preview thumbnail
                if (item.frames && item.frames.length > 0) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 32;
                    canvas.height = 32;
                    canvas.style.cssText = 'border:1px solid #555; image-rendering:pixelated;';
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;

                    const idleIdx = item.idleFrame || 0;
                    const frame = item.frames[idleIdx] || item.frames[0];
                    if (item._spriteImg) {
                        ctx.drawImage(item._spriteImg, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                    } else if (item.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            item._spriteImg = img;
                            ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                        };
                        img.src = item.spriteData;
                    }
                    itemEl.appendChild(canvas);
                }

                // Name and info
                const info = document.createElement('div');
                info.innerHTML = `<div style="font-weight:bold; color:#4f8;">${item.name}</div>
                    <div style="font-size:10px; color:#888;">${item.frames?.length || 0} frames</div>`;
                itemEl.appendChild(info);

                // Edit/Delete buttons
                const btns = document.createElement('div');
                btns.style.cssText = 'margin-left:auto; display:flex; gap:5px;';
                btns.innerHTML = `
                    <button onclick="event.stopPropagation(); openItemEditor(${i})" style="padding:3px 6px; font-size:10px;">Edit</button>
                    <button onclick="event.stopPropagation(); deleteItem(${i})" style="padding:3px 6px; font-size:10px; background:#a55;">×</button>
                `;
                itemEl.appendChild(btns);

                container.appendChild(itemEl);
            });
        }

        function deleteItem(index) {
            if (!confirm('Delete this item?')) return;
            items.splice(index, 1);
            if (currentItemIndex >= items.length) currentItemIndex = items.length - 1;
            updateItemList();
            renderMap();
        }

        function updatePlacedItemsList() {
            const container = document.getElementById('placedItemsList');
            if (!container) return;

            const currentMapItems = placedItems.filter(p => !p.mapName || p.mapName === currentMapName);

            if (currentMapItems.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; text-align:center; padding:10px;">No items placed</div>';
                return;
            }

            container.innerHTML = '';
            currentMapItems.forEach((placed, i) => {
                const item = items[placed.itemIndex];
                if (!item) return;
                const realIdx = placedItems.indexOf(placed);
                const div = document.createElement('div');
                div.style.cssText = 'display:flex; justify-content:space-between; align-items:center; padding:4px 0; border-bottom:1px solid #333;';
                div.innerHTML = `
                    <span style="color:#4f8;">${item.name}</span>
                    <span style="font-size:10px; color:#888;">(${placed.x}, ${placed.y})</span>
                    <button onclick="removePlacedItem(${realIdx})" style="padding:2px 6px; font-size:9px; background:#a55;">×</button>
                `;
                container.appendChild(div);
            });
        }

        function removePlacedItem(index) {
            placedItems.splice(index, 1);
            updatePlacedItemsList();
            renderMap();
        }

        function placeItemAt(x, y) {
            if (x < 0 || y < 0 || x >= mapCols || y >= mapRows) return;
            if (currentItemIndex < 0 || !items[currentItemIndex]) return;

            // Check if item already exists at this position
            const existingIdx = placedItems.findIndex(p =>
                p.x === x && p.y === y &&
                (!p.mapName || p.mapName === currentMapName) &&
                p.layer === currentLayer
            );
            if (existingIdx >= 0) return; // Don't stack items

            const newItem = {
                itemIndex: currentItemIndex,
                x: x,
                y: y,
                layer: currentLayer,
                mapName: currentMapName,
                used: false
            };
            placedItems.push(newItem);

            // Broadcast to co-op builders
            broadcastEdit({ editType: 'placeItem', item: newItem, index: placedItems.length - 1 });

            updatePlacedItemsList();
            renderMap();
        }

        function removeItemAt(x, y) {
            const idx = placedItems.findIndex(p =>
                p.x === x && p.y === y &&
                (!p.mapName || p.mapName === currentMapName)
            );
            if (idx >= 0) {
                placedItems.splice(idx, 1);
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeItem', x: x, y: y, mapName: currentMapName });
                updatePlacedItemsList();
                renderMap();
            }
        }

        // Initialize item editor canvas with drag selection handlers
        document.addEventListener('DOMContentLoaded', () => {
            const itemCanvas = document.getElementById('itemEditorCanvas');
            if (itemCanvas) {
                itemCanvas.addEventListener('mousedown', function(e) {
                    if (!itemEditorImage) return;
                    const rect = this.getBoundingClientRect();
                    const scale = itemEditorZoom;
                    const gridX = Math.floor((e.clientX - rect.left) / (itemEditorFrameW * scale));
                    const gridY = Math.floor((e.clientY - rect.top) / (itemEditorFrameH * scale));
                    itemDragStart = { gridX, gridY };
                    itemDragEnd = { gridX, gridY };
                    itemIsDragging = true;
                    itemDrawCanvas();
                });

                itemCanvas.addEventListener('mousemove', function(e) {
                    if (!itemIsDragging || !itemEditorImage) return;
                    const rect = this.getBoundingClientRect();
                    const scale = itemEditorZoom;
                    const gridX = Math.floor((e.clientX - rect.left) / (itemEditorFrameW * scale));
                    const gridY = Math.floor((e.clientY - rect.top) / (itemEditorFrameH * scale));
                    itemDragEnd = { gridX, gridY };
                    itemDrawCanvas();
                });

                itemCanvas.addEventListener('mouseup', function(e) {
                    if (!itemIsDragging || !itemEditorImage) return;
                    itemIsDragging = false;

                    if (itemDragStart && itemDragEnd) {
                        const startGX = Math.min(itemDragStart.gridX, itemDragEnd.gridX);
                        const startGY = Math.min(itemDragStart.gridY, itemDragEnd.gridY);
                        const endGX = Math.max(itemDragStart.gridX, itemDragEnd.gridX);
                        const endGY = Math.max(itemDragStart.gridY, itemDragEnd.gridY);

                        // Add all frames in the selection as a single multi-tile frame
                        const frameX = startGX * itemEditorFrameW;
                        const frameY = startGY * itemEditorFrameH;
                        const frameW = (endGX - startGX + 1) * itemEditorFrameW;
                        const frameH = (endGY - startGY + 1) * itemEditorFrameH;

                        // Check if already exists
                        const existingIdx = itemFrames.findIndex(f => f.x === frameX && f.y === frameY && f.w === frameW && f.h === frameH);
                        if (existingIdx >= 0) {
                            itemFrames.splice(existingIdx, 1);
                        } else {
                            itemFrames.push({ x: frameX, y: frameY, w: frameW, h: frameH });
                        }

                        itemUpdateFramesList();
                        itemUpdateIdleDropdown();
                        itemStartPreview();
                    }

                    itemDragStart = null;
                    itemDragEnd = null;
                    itemDrawCanvas();
                });

                itemCanvas.addEventListener('mouseleave', function() {
                    if (itemIsDragging) {
                        itemIsDragging = false;
                        itemDragStart = null;
                        itemDragEnd = null;
                        itemDrawCanvas();
                    }
                });
            }
        });

        function updateAnimPropScale() {
            const scale = parseFloat(document.getElementById('animPropScale').value) || 1;
            currentAnimPropScale = scale;
            document.getElementById('animPropScaleValue').textContent = scale.toFixed(2) + 'x';
            renderMap(); // Update preview
        }

        function updateAnimPropListDisplay() {
            const container = document.getElementById('animPropList');
            if (!container) return;
            container.innerHTML = '';

            if (animatedProps.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; padding:10px;">No animated props yet</div>';
                return;
            }

            animatedProps.forEach((prop, i) => {
                const item = document.createElement('div');
                const isSelected = (currentAnimPropIndex === i);
                item.style.cssText = 'display:flex; align-items:center; gap:10px; padding:8px; background:' + (isSelected ? '#4a4a6e' : '#333') + '; border:2px solid ' + (isSelected ? '#4af' : 'transparent') + '; border-radius:5px; margin-bottom:5px; cursor:pointer;';
                item.onclick = () => { currentAnimPropIndex = i; updateAnimPropListDisplay(); };

                // Preview thumbnail
                if (prop.frames && prop.frames.length > 0) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 32;
                    canvas.height = 32;
                    canvas.style.cssText = 'border:1px solid #555; image-rendering:pixelated;';
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;

                    const frame = prop.frames[0];
                    if (prop._spriteImg) {
                        ctx.drawImage(prop._spriteImg, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                    } else if (prop.spriteData) {
                        // Fallback: load image if _spriteImg not available
                        const img = new Image();
                        img.onload = () => {
                            prop._spriteImg = img;
                            ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                        };
                        img.src = prop.spriteData;
                    }
                    item.appendChild(canvas);
                }

                const info = document.createElement('div');
                info.style.flex = '1';
                info.innerHTML = '<div style="color:#4af; font-weight:bold;">' + prop.name + '</div>' +
                    '<div style="font-size:10px; color:#888;">' + prop.frames.length + ' frames | ' + prop.type + '</div>';
                item.appendChild(info);

                // Edit button
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.style.cssText = 'padding:4px 8px; font-size:10px;';
                editBtn.onclick = (e) => { e.stopPropagation(); openAnimPropEditor(i); };
                item.appendChild(editBtn);

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = '×';
                delBtn.style.cssText = 'padding:4px 8px; font-size:10px; background:#a55;';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Delete "' + prop.name + '"?')) {
                        const deleteIndex = i;
                        animatedProps.splice(deleteIndex, 1);
                        placedAnimProps = placedAnimProps.filter(p => p.propIndex !== deleteIndex);
                        placedAnimProps.forEach(p => { if (p.propIndex > deleteIndex) p.propIndex--; });
                        broadcastEdit({ editType: 'removeAnimProp', index: deleteIndex });
                        updateAnimPropListDisplay();
                        renderMap();
                    }
                };
                item.appendChild(delBtn);

                container.appendChild(item);
            });
        }

        // ===== INDEXEDDB STORAGE =====
        let projectDB = null;

        function initProjectDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('WorldBuilderDB', 1);
                request.onerror = () => {
                    console.error('IndexedDB error:', request.error);
                    reject(request.error);
                };
                request.onsuccess = () => {
                    projectDB = request.result;
                    console.log('IndexedDB opened successfully');
                    resolve(projectDB);
                };
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('projects')) {
                        db.createObjectStore('projects');
                        console.log('Created projects object store');
                    }
                };
            });
        }

        async function saveProjectToDB(data) {
            try {
                if (!projectDB) await initProjectDB();
                return new Promise((resolve, reject) => {
                    const tx = projectDB.transaction('projects', 'readwrite');
                    const store = tx.objectStore('projects');
                    const request = store.put(data, 'current');
                    request.onsuccess = () => {
                        console.log('Project saved to IndexedDB');
                        resolve();
                    };
                    request.onerror = () => {
                        console.error('IndexedDB save error:', request.error);
                        reject(request.error);
                    };
                });
            } catch (err) {
                console.error('saveProjectToDB error:', err);
                throw err;
            }
        }

        async function loadProjectFromDB() {
            try {
                if (!projectDB) await initProjectDB();
                return new Promise((resolve, reject) => {
                    const tx = projectDB.transaction('projects', 'readonly');
                    const store = tx.objectStore('projects');
                    const request = store.get('current');
                    request.onsuccess = () => {
                        resolve(request.result);
                    };
                    request.onerror = () => {
                        console.error('IndexedDB load error:', request.error);
                        reject(request.error);
                    };
                });
            } catch (err) {
                console.error('loadProjectFromDB error:', err);
                throw err;
            }
        }

        async function showStorageInfo() {
            const data = getProjectData();
            const json = JSON.stringify(data);
            const totalMB = (json.length / 1000000).toFixed(2);

            // Get storage quota (if available)
            let quotaInfo = 'Unknown';
            if (navigator.storage && navigator.storage.estimate) {
                const estimate = await navigator.storage.estimate();
                const usedMB = (estimate.usage / 1000000).toFixed(2);
                const quotaMB = (estimate.quota / 1000000).toFixed(0);
                quotaInfo = usedMB + 'MB / ' + quotaMB + 'MB';
            }

            // Breakdown by component
            const soundsSize = JSON.stringify(data.sounds || []).length;
            const tilesetsSize = JSON.stringify(data.tilesets || []).length;
            const propsSize = JSON.stringify(data.props || []).length;
            const animPropsSize = JSON.stringify(data.animatedProps || []).length;
            const npcsSize = JSON.stringify(data.npcs || []).length;
            const mapSize = JSON.stringify(data.layers || []).length;

            alert('Project Size: ' + totalMB + 'MB\n' +
                'Browser Storage: ' + quotaInfo + '\n\n' +
                'Breakdown:\n' +
                '- Sounds: ' + (soundsSize/1000000).toFixed(2) + 'MB\n' +
                '- Tilesets: ' + (tilesetsSize/1000000).toFixed(2) + 'MB\n' +
                '- Props: ' + (propsSize/1000000).toFixed(2) + 'MB\n' +
                '- Animated Props: ' + (animPropsSize/1000000).toFixed(2) + 'MB\n' +
                '- NPCs: ' + (npcsSize/1000000).toFixed(2) + 'MB\n' +
                '- Map Data: ' + (mapSize/1000000).toFixed(2) + 'MB');
        }

        // Initialize IndexedDB on page load
        initProjectDB().catch(err => console.warn('IndexedDB init failed, will use localStorage:', err));

        // ===== SAVE/LOAD =====
        async function saveProject() {
            // Count tiles in first layer for debugging
            let tileCount = 0;
            if (layers[0]) {
                for (let y = 0; y < layers[0].length; y++) {
                    if (layers[0][y]) {
                        for (let x = 0; x < layers[0][y].length; x++) {
                            if (layers[0][y][x]) tileCount++;
                        }
                    }
                }
            }
            console.log('Saving project with', layers.length, 'layers,', tileCount, 'tiles in first layer,', tilesets.length, 'tilesets,', props.length, 'props');

            // Save current prop's collision masks before saving
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Save all tilesets
            const tilesetsData = tilesets.map(ts => ({ name: ts.name, data: ts.data }));

            // Save all props
            const propsData = props.map(p => ({
                name: p.name,
                data: p.data,
                collisionMasks: p.collisionMasks || {}
            }));

            // Save all animated props
            const animPropsData = animatedProps.map(prop => ({
                name: prop.name,
                spriteData: prop.spriteData,
                frameWidth: prop.frameWidth,
                frameHeight: prop.frameHeight,
                frames: prop.frames,
                type: prop.type,
                fps: prop.fps,
                collisionMask: prop.collisionMask || null,
                splitLine: prop.splitLine || null
            }));

            // Save sounds
            const soundsData = sounds.map(s => ({
                name: s.name,
                data: s.data,
                duration: s.duration,
                type: s.type
            }));
            console.log('=== SAVING SOUNDS ===');
            console.log('Sounds to save:', sounds.length);
            console.log('Tile sounds to save:', Object.keys(tileSounds).length, tileSounds);
            console.log('Player sounds to save:', playerSounds);

            const data = {
                gridSize, mapCols, mapRows,
                layers, layerVisibility, layerNames, currentLayer,
                tileCollisions, collisionMasks,
                tileSplitLines, // Depth split lines for Y-sorting
                tilesets: tilesetsData,
                currentTilesetIndex,
                // Keep for backwards compatibility
                tilesetData: tilesets[0]?.data,
                // Save multiple props
                props: propsData,
                currentPropIndex,
                // Keep old format for backwards compatibility
                propImageData: props[0]?.data || null,
                propCollisionMasks: props[0]?.collisionMasks || {},
                // Save animated props
                animatedProps: animPropsData,
                currentAnimPropIndex,
                placedAnimProps,
                // Save NPCs
                npcs: npcs.map(npc => ({
                    name: npc.name,
                    spriteData: npc.spriteData,
                    frameWidth: npc.frameWidth,
                    frameHeight: npc.frameHeight,
                    animations: npc.animations,
                    animMirrors: npc.animMirrors || {},
                    fps: npc.fps,
                    collisionMask: npc.collisionMask || null,
                    splitLine: npc.splitLine ?? null
                })),
                currentNpcIndex,
                placedNpcs,
                // Save player layer settings
                playerLayerIndex,
                playerPreviewPos,
                spawnMapName,
                playerPreviewVisible,
                // Save sound data
                sounds: soundsData,
                tileSounds,
                playerSounds,
                // Save lighting data
                lightingSettings,
                pointLights,
                // Save player characters with all data
                playerCharacters: playerCharacters.map(c => ({
                    name: c.name,
                    spriteData: c.spriteData,
                    spriteSheets: c.spriteSheets || (c.spriteData ? [c.spriteData] : []),
                    frameWidth: c.frameWidth,
                    frameHeight: c.frameHeight,
                    animations: c.animations,
                    animMirrors: c.animMirrors || {},
                    hitboxMasks: c.hitboxMasks || {},
                    animFps: c.animFps || {},
                    fps: c.fps || 8,
                    pingPong: c.pingPong || false,
                    attackMovement: c.attackMovement || 'stop',
                    gameOverSoundIndex: c.gameOverSoundIndex !== undefined ? c.gameOverSoundIndex : -1
                })),
                activePlayerIndex,
                // Multi-map support
                maps,
                currentMapName,
                placedTriggers,
                // Dialogs
                dialogs
            };
            console.log('Saving playerPreviewPos:', playerPreviewPos, 'on map:', spawnMapName);
            try {
                // Try IndexedDB first (much larger storage)
                await saveProjectToDB(data);
                alert('Saved! Player spawn: (' + playerPreviewPos.x + ', ' + playerPreviewPos.y + ')');
            } catch (e) {
                console.warn('IndexedDB save failed, trying localStorage:', e);
                // Fallback to localStorage for older browsers
                try {
                    localStorage.setItem('worldBuilderProject', JSON.stringify(data));
                    console.log('Project saved to localStorage (fallback)');
                    alert('Saved! Player spawn: (' + playerPreviewPos.x + ', ' + playerPreviewPos.y + ')');
                } catch (e2) {
                    if (e2.name === 'QuotaExceededError') {
                        alert('Project too large to save! Use "Download" to save to a file.');
                    } else {
                        throw e2;
                    }
                }
            }
            return data; // Return for file download
        }

        function downloadProject() {
            // Get save data
            const data = getProjectData();
            const json = JSON.stringify(data, null, 2);

            // Create download
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'world-project-' + new Date().toISOString().slice(0,10) + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function getProjectData() {
            // Save current map state to maps object before saving
            saveCurrentMapState();

            // Save current prop's collision masks before saving
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Save all tilesets
            const tilesetsData = tilesets.map(ts => ({ name: ts.name, data: ts.data }));

            // Save all props
            const propsData = props.map(p => ({
                name: p.name,
                data: p.data,
                collisionMasks: p.collisionMasks || {}
            }));

            // Save all animated props
            const animPropsData = animatedProps.map(prop => ({
                name: prop.name,
                spriteData: prop.spriteData,
                frameWidth: prop.frameWidth,
                frameHeight: prop.frameHeight,
                frames: prop.frames,
                type: prop.type,
                fps: prop.fps,
                collisionMask: prop.collisionMask || null,
                splitLine: prop.splitLine || null
            }));

            // Save sounds
            const soundsData = sounds.map(s => ({
                name: s.name,
                data: s.data,
                duration: s.duration,
                type: s.type
            }));
            console.log('getProjectData - sounds:', sounds.length, 'tileSounds:', Object.keys(tileSounds).length);

            // Debug: log all triggers being passed
            console.log('=== getProjectData TRIGGERS ===');
            placedTriggers.forEach((t, i) => {
                console.log('Trigger ' + i + ': Door ' + t.doorNumber + ' at (' + t.x + ',' + t.y + ') on "' + t.mapName + '" -> "' + t.targetMap + '" spawn (' + t.targetX + ',' + t.targetY + ')');
            });

            return {
                gridSize, mapCols, mapRows,
                layers, layerVisibility, layerNames, currentLayer,
                tileCollisions, collisionMasks,
                tileSplitLines, // Depth split lines for Y-sorting
                tilesets: tilesetsData,
                currentTilesetIndex,
                // Keep for backwards compatibility
                tilesetData: tilesets[0]?.data,
                // Save multiple props
                props: propsData,
                currentPropIndex,
                // Keep old format for backwards compatibility
                propImageData: props[0]?.data || null,
                propCollisionMasks: props[0]?.collisionMasks || {},
                // Save animated props
                animatedProps: animPropsData,
                currentAnimPropIndex,
                placedAnimProps,
                // Save NPCs
                npcs: npcs.map(npc => ({
                    name: npc.name,
                    spriteData: npc.spriteData,
                    frameWidth: npc.frameWidth,
                    frameHeight: npc.frameHeight,
                    animations: npc.animations,
                    animMirrors: npc.animMirrors || {},
                    fps: npc.fps,
                    collisionMask: npc.collisionMask || null,
                    splitLine: npc.splitLine ?? null
                })),
                currentNpcIndex,
                placedNpcs,
                // Save player layer settings
                playerLayerIndex,
                playerPreviewPos,
                spawnMapName,
                playerPreviewVisible,
                // Save sound data
                sounds: soundsData,
                tileSounds,
                playerSounds,
                // Save lighting data
                lightingSettings,
                pointLights,
                // Save player sprite (legacy)
                playerSpriteData,
                // Player characters system
                playerCharacters: playerCharacters.map(c => ({
                    name: c.name,
                    spriteData: c.spriteData, // Legacy single sheet
                    spriteSheets: c.spriteSheets || (c.spriteData ? [c.spriteData] : []), // All sheets
                    frameWidth: c.frameWidth,
                    frameHeight: c.frameHeight,
                    animations: c.animations,
                    animMirrors: c.animMirrors || {},
                    hitboxMasks: c.hitboxMasks || {},
                    animFps: c.animFps || {},
                    fps: c.fps || 8,
                    pingPong: c.pingPong || false,
                    attackMovement: c.attackMovement || 'stop',
                    gameOverSoundIndex: c.gameOverSoundIndex !== undefined ? c.gameOverSoundIndex : -1
                })),
                activePlayerIndex,
                // Multi-map support
                maps,
                currentMapName,
                placedTriggers,
                // Dialogs
                dialogs,
                placedDialogTiles,
                // Items (interactive objects like chests)
                items: items.map(item => ({
                    name: item.name,
                    spriteData: item.spriteData,
                    frameWidth: item.frameWidth,
                    frameHeight: item.frameHeight,
                    frames: item.frames,
                    fps: item.fps,
                    idleFrame: item.idleFrame
                })),
                placedItems
            };
        }

        function uploadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    // Save to IndexedDB so Test Map works
                    try {
                        await saveProjectToDB(data);
                        console.log('Uploaded project saved to IndexedDB');
                    } catch (dbErr) {
                        console.warn('IndexedDB save failed, trying localStorage:', dbErr);
                        try {
                            localStorage.setItem('worldBuilderProject', JSON.stringify(data));
                        } catch (storageErr) {
                            console.warn('localStorage also full, project loaded but not persisted');
                        }
                    }
                    // Load into editor
                    await loadProject(data);
                } catch (err) {
                    alert('Error loading file: ' + err.message);
                }
            };
            reader.readAsText(file);

            // Clear input so same file can be loaded again
            event.target.value = '';
        }

        // Load save and show mode selection
        let pendingSaveData = null;

        // Show save choice menu (demo vs own save)
        function showSaveChoice() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('saveChoice').style.display = 'block';
        }

        // Load save menu HTML
        const saveChoiceOriginalHTML = `
            <h1>LOAD<br>SAVE</h1>
            <p>- SELECT SOURCE -</p>
            <div style="margin-top:20px;">
                <button class="retro-btn" onclick="playButtonSound(); document.getElementById('projectFileInputWelcome').click(); document.getElementById('saveChoice').style.display='none'; document.getElementById('mainMenu').style.display='block';">
                    > YOUR SAVE
                </button>
            </div>
            <div style="margin-top:10px;">
                <button class="retro-btn" onclick="playButtonSound(); document.getElementById('saveChoice').style.display='none'; document.getElementById('mainMenu').style.display='block';" style="font-size:10px;">
                    > BACK
                </button>
            </div>
        `;
        async function loadDemo() {
            document.getElementById('saveChoice').innerHTML = '<h1>LOADING...</h1>';
            try {
                const response = await fetch('thenewdemo.json');
                const data = await response.json();
                pendingSaveData = data;
                await saveProjectToDB(pendingSaveData);
                document.getElementById('saveChoice').innerHTML = saveChoiceOriginalHTML;
                document.getElementById('saveChoice').style.display = 'none';
                document.getElementById('modeSelect').style.display = 'block';
            } catch (err) {
                alert('Error loading demo: ' + err.message);
                document.getElementById('saveChoice').innerHTML = saveChoiceOriginalHTML;
                document.getElementById('saveChoice').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'block';
            }
        }
        function loadSaveWithModeSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    pendingSaveData = JSON.parse(e.target.result);
                    await saveProjectToDB(pendingSaveData);
                    document.getElementById('mainMenu').style.display = 'none';
                    document.getElementById('modeSelect').style.display = 'block';
                } catch (err) {
                    alert('Error: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Multiplayer prompt functions
        function showMultiplayerPrompt() {
            document.getElementById('modeSelect').style.display = 'none';
            document.getElementById('multiplayerPrompt').style.display = 'block';
            document.getElementById('mpPlayerName').focus();
        }

        function hideMultiplayerPrompt() {
            document.getElementById('multiplayerPrompt').style.display = 'none';
            document.getElementById('modeSelect').style.display = 'block';
        }

        // Craft multiplayer prompt functions
        function showCraftMultiplayerPrompt() {
            document.getElementById('modeSelect').style.display = 'none';
            document.getElementById('craftMultiplayerPrompt').style.display = 'block';
            // Focus is handled in showHostPrompt/showJoinPrompt
        }

        function hideCraftMultiplayerPrompt() {
            document.getElementById('craftMultiplayerPrompt').style.display = 'none';
            document.getElementById('modeSelect').style.display = 'block';
        }

        // Simple builder start - shows co-op prompt
        function startBuilder() {
            if (!pendingSaveData) {
                console.log('[START] No save data, returning');
                return;
            }

            // Hide mode select, show co-op prompt
            document.getElementById('modeSelect').style.display = 'none';
            document.getElementById('craftMultiplayerPrompt').style.display = 'block';
            // Focus is handled in showHostPrompt/showJoinPrompt
        }

        // === BUILDER MULTIPLAYER SYSTEM ===
        let builderSocket = null;
        let builderConnected = false;
        let builderPlayerName = 'Builder';
        let builderRoomCode = null;
        let testGameWindow = null; // Reference to test game window for solo live sync

        // Track game players visible in builder
        let gamePlayersInBuilder = new Map(); // id -> {x, y, name, direction, currentMap, animation, frame, lastFrameTime}
        let gamePlayerAnimInterval = null; // Animation loop for game players in builder
        let builderGameSocket = null; // socket to game server to see testers

        // Track builder co-op players in the room
        let builderPlayersInRoom = new Map(); // id -> {name, joinedAt}

        function connectBuilderMultiplayer(name, roomCode) {
            console.log('[BUILDER MP DEBUG] connectBuilderMultiplayer called with name:', name, 'roomCode:', roomCode);

            if (!roomCode) {
                console.log('[BUILDER MP DEBUG] No room code, solo mode');
                return; // Solo mode
            }

            builderPlayerName = name;
            builderRoomCode = roomCode;
            const wsUrl = 'wss://multiplayer.lakotafox.partykit.dev/parties/builder/' + roomCode;
            console.log('[BUILDER MP DEBUG] Connecting to:', wsUrl);

            try {
                builderSocket = new WebSocket(wsUrl);
                console.log('[BUILDER MP DEBUG] WebSocket created, waiting for open...');

                builderSocket.onopen = () => {
                    console.log('[BUILDER MP DEBUG] WebSocket OPEN!');
                    builderConnected = true;
                    const joinMsg = {
                        type: 'join',
                        name: builderPlayerName,
                        gameType: 'builder'
                    };
                    console.log('[BUILDER MP DEBUG] Sending join message:', joinMsg);
                    builderSocket.send(JSON.stringify(joinMsg));
                    showBuilderStatus('Connected: ' + roomCode);
                    console.log('[BUILDER MP DEBUG] builderConnected is now:', builderConnected);
                };

                builderSocket.onmessage = (event) => {
                    console.log('[BUILDER MP DEBUG] Raw message received:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        handleBuilderMessage(data);
                    } catch (e) {
                        console.error('[BUILDER MP DEBUG] Parse error:', e);
                    }
                };

                builderSocket.onclose = (event) => {
                    console.log('[BUILDER MP DEBUG] WebSocket CLOSED, code:', event.code, 'reason:', event.reason);
                    builderConnected = false;
                    showBuilderStatus('Disconnected');
                    // Also close game socket and clear players
                    if (builderGameSocket) {
                        builderGameSocket.close();
                        builderGameSocket = null;
                    }
                    gamePlayersInBuilder.clear();
                    renderMap();
                };

                builderSocket.onerror = (err) => {
                    console.error('[BUILDER MP DEBUG] WebSocket ERROR:', err);
                };
            } catch (e) {
                console.error('[BUILDER MP DEBUG] Connect failed:', e);
            }

            // Also connect to game server to see players testing the game
            connectToGameServerForBuilder(roomCode);
        }

        function connectToGameServerForBuilder(roomCode) {
            const gameWsUrl = 'wss://multiplayer.lakotafox.partykit.dev/party/' + roomCode;
            console.log('[BUILDER GAME] Connecting to game server:', gameWsUrl);
            builderGameSocket = new WebSocket(gameWsUrl);

            builderGameSocket.onopen = () => {
                console.log('[BUILDER GAME] Connected to game server!');
            };

            builderGameSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'welcome' && data.players) {
                        data.players.forEach(p => {
                            if (p.gameType === 'game2d') {
                                p.frame = 0;
                                p.lastFrameTime = Date.now();
                                gamePlayersInBuilder.set(p.id, p);
                            }
                        });
                        startGamePlayerAnimLoop();
                        renderMap();
                    } else if (data.type === 'join' && data.player && data.player.gameType === 'game2d') {
                        console.log('[BUILDER] Game player joined:', data.player.name);
                        data.player.frame = 0;
                        data.player.lastFrameTime = Date.now();
                        gamePlayersInBuilder.set(data.player.id, data.player);
                        startGamePlayerAnimLoop();
                        renderMap();
                    } else if (data.type === 'update' && data.player && data.player.gameType === 'game2d') {
                        const existing = gamePlayersInBuilder.get(data.player.id);
                        data.player.frame = existing ? existing.frame : 0;
                        data.player.lastFrameTime = existing ? existing.lastFrameTime : Date.now();
                        gamePlayersInBuilder.set(data.player.id, data.player);
                    } else if (data.type === 'leave' && data.playerId) {
                        console.log('[BUILDER] Game player left');
                        gamePlayersInBuilder.delete(data.playerId);
                        if (gamePlayersInBuilder.size === 0) stopGamePlayerAnimLoop();
                        renderMap();
                    }
                } catch (e) {}
            };

            builderGameSocket.onclose = () => {
                console.log('[BUILDER GAME] Disconnected from game server');
                gamePlayersInBuilder.clear();
                stopGamePlayerAnimLoop();
            };
        }

        // Animation loop for game players shown in builder
        function startGamePlayerAnimLoop() {
            if (gamePlayerAnimInterval) return; // Already running
            gamePlayerAnimInterval = setInterval(() => {
                if (gamePlayersInBuilder.size === 0) {
                    stopGamePlayerAnimLoop();
                    return;
                }
                const now = Date.now();
                let needsRender = false;
                gamePlayersInBuilder.forEach(p => {
                    // Advance frame every 150ms for walking players
                    if (p.animation === 'walk' && now - p.lastFrameTime > 150) {
                        p.frame = (p.frame + 1) % 4;
                        p.lastFrameTime = now;
                        needsRender = true;
                    } else if (p.animation !== 'walk') {
                        // Reset to idle frame
                        if (p.frame !== 0) needsRender = true;
                        p.frame = 0;
                    }
                });
                if (needsRender) renderMap();
            }, 100);
        }

        function stopGamePlayerAnimLoop() {
            if (gamePlayerAnimInterval) {
                clearInterval(gamePlayerAnimInterval);
                gamePlayerAnimInterval = null;
            }
        }

        function handleBuilderMessage(data) {
            console.log('[BUILDER MP DEBUG] handleBuilderMessage received:', data);
            console.log('[BUILDER MP DEBUG] data.type:', data.type);

            // Track players joining/leaving for room info
            if (data.type === 'welcome') {
                // Initial player list when we join
                if (data.players) {
                    builderPlayersInRoom.clear();
                    data.players.forEach(p => {
                        builderPlayersInRoom.set(p.id, { name: p.name, joinedAt: Date.now() });
                    });
                    console.log('[BUILDER MP] Players in room:', builderPlayersInRoom.size);
                }
                return;
            }

            if (data.type === 'join') {
                if (data.player) {
                    builderPlayersInRoom.set(data.player.id, { name: data.player.name, joinedAt: Date.now() });
                    console.log('[BUILDER MP] Player joined:', data.player.name, '- Total:', builderPlayersInRoom.size);
                }
                return;
            }

            if (data.type === 'leave') {
                if (data.playerId) {
                    builderPlayersInRoom.delete(data.playerId);
                    console.log('[BUILDER MP] Player left - Remaining:', builderPlayersInRoom.size);
                }
                return;
            }

            // Handle edit messages from other builders
            if (data.type === 'builderEdit' && data.editType) {
                console.log('[BUILDER MP DEBUG] >>> APPLYING REMOTE EDIT <<<', data.editType);
                applyRemoteEdit(data);
            }
        }

        function sendFullProject() {
            if (!builderSocket || !builderConnected) return;

            // Save current map state first
            saveCurrentMapState();

            // Create serializable project data (exclude non-serializable stuff like images)
            const projectData = {
                maps: {},
                placedTriggers: placedTriggers,
                placedNpcs: placedNpcs,
                tileSounds: tileSounds,
                pointLights: pointLights,
                tileCollisions: tileCollisions,
                collisionMasks: collisionMasks,
                tileSplitLines: tileSplitLines,
                animatedProps: animatedProps.map(p => {
                    const copy = { ...p };
                    delete copy._spriteImg; // Not serializable
                    return copy;
                }),
                // Tilesets (with base64 data for image reload)
                tilesets: tilesets.map(t => {
                    let data = t.data;
                    // If no data but we have an image, extract base64 from it
                    if (!data && t.img) {
                        try {
                            const canvas = document.createElement('canvas');
                            canvas.width = t.img.width;
                            canvas.height = t.img.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(t.img, 0, 0);
                            data = canvas.toDataURL('image/png');
                            t.data = data; // Cache it for future
                        } catch (e) {
                            console.error('[BUILDER MP] Failed to extract tileset data:', e);
                        }
                    }
                    return { name: t.name, data: data };
                }),
                // NPC definitions (with spriteData for image reload)
                npcs: npcs.map(n => {
                    const copy = { ...n };
                    delete copy._spriteImg; // Not serializable
                    return copy;
                }),
                currentTilesetIndex: currentTilesetIndex,
                currentMapName: currentMapName,
                playerPreviewPos: playerPreviewPos,
                spawnMapName: spawnMapName,
                // Dialogs
                dialogs: dialogs,
                // Player characters
                playerCharacters: playerCharacters.map(c => {
                    const copy = { ...c };
                    delete copy._spriteImg;
                    return copy;
                }),
                activePlayerIndex: activePlayerIndex
            };

            // Copy all maps (without image references)
            for (const mapName in maps) {
                projectData.maps[mapName] = {
                    layers: maps[mapName].layers,
                    layerVisibility: maps[mapName].layerVisibility,
                    layerNames: maps[mapName].layerNames,
                    currentLayer: maps[mapName].currentLayer,
                    tileCollisions: maps[mapName].tileCollisions,
                    collisionMasks: maps[mapName].collisionMasks,
                    tileSplitLines: maps[mapName].tileSplitLines,
                    mapCols: maps[mapName].mapCols,
                    mapRows: maps[mapName].mapRows,
                    cameraBounds: maps[mapName].cameraBounds
                };
            }

            console.log('[BUILDER MP] Sending full project:');
            console.log('[BUILDER MP] - Maps:', Object.keys(projectData.maps).length);
            console.log('[BUILDER MP] - Tilesets:', projectData.tilesets.length);
            console.log('[BUILDER MP] - NPCs:', projectData.npcs.length);
            console.log('[BUILDER MP] - Triggers:', projectData.placedTriggers.length);

            // Send tilesets separately in chunks (base64 images are huge)
            const tilesetsToSend = projectData.tilesets;
            projectData.tilesets = []; // Send empty, will send separately

            // Send main project first (without tileset data)
            // Wrap as builderEdit so server broadcasts it
            const mainMsg = JSON.stringify({
                type: 'builderEdit',
                editType: 'fullProject',
                project: projectData
            });
            console.log('[BUILDER MP] Main project size:', (mainMsg.length / 1024).toFixed(1), 'KB');
            builderSocket.send(mainMsg);

            // Send each tileset as a separate message
            tilesetsToSend.forEach((ts, i) => {
                setTimeout(() => {
                    if (!builderSocket || !builderConnected) return;
                    const tsMsg = JSON.stringify({
                        type: 'builderEdit',
                        editType: 'tilesetSync',
                        index: i,
                        name: ts.name,
                        data: ts.data
                    });
                    console.log('[BUILDER MP] Sending tileset', i, ts.name, (tsMsg.length / 1024).toFixed(1), 'KB');
                    try {
                        builderSocket.send(tsMsg);
                    } catch (e) {
                        console.error('[BUILDER MP] Failed to send tileset:', e);
                    }
                }, 100 * (i + 1)); // Stagger sends to avoid overwhelming
            });

            console.log('[BUILDER MP] Full project queued!');
        }

        function loadFullProject(project) {
            console.log('[BUILDER MP] Loading full project with maps:', Object.keys(project.maps));

            // Load maps
            for (const mapName in project.maps) {
                maps[mapName] = project.maps[mapName];
            }

            // Load triggers, NPCs, sounds, lights
            placedTriggers = project.placedTriggers || [];
            placedNpcs = project.placedNpcs || [];
            tileSounds = project.tileSounds || {};
            pointLights = project.pointLights || {};
            tileCollisions = project.tileCollisions || {};
            collisionMasks = project.collisionMasks || {};
            tileSplitLines = project.tileSplitLines || {};

            // Load animated props (need to reload images)
            animatedProps = project.animatedProps || [];
            animatedProps.forEach((prop, i) => {
                if (prop.spriteData) {
                    const img = new Image();
                    img.onload = () => {
                        animatedProps[i]._spriteImg = img;
                        updateAnimPropListDisplay();
                    };
                    img.src = prop.spriteData;
                }
            });

            // Load tilesets (need to reload images from base64)
            console.log('[BUILDER MP] Loading tilesets:', project.tilesets ? project.tilesets.length : 0);
            if (project.tilesets && project.tilesets.length > 0) {
                tilesets = [];
                project.tilesets.forEach((ts, i) => {
                    console.log('[BUILDER MP] Tileset', i, ts.name, 'data length:', ts.data ? ts.data.length : 'NO DATA');
                    if (!ts.data) {
                        console.error('[BUILDER MP] Tileset', ts.name, 'has no data!');
                        return;
                    }
                    const img = new Image();
                    img.onload = () => {
                        console.log('[BUILDER MP] Tileset loaded:', ts.name, img.width, 'x', img.height);
                        tilesets[i] = { name: ts.name, img: img, data: ts.data };
                        // Update tilesetImg if this is the current tileset
                        if (i === (project.currentTilesetIndex || 0)) {
                            tilesetImg = img;
                            currentTilesetIndex = i;
                        }
                        updateTilesetDropdown();
                        renderTilesetPanel();
                        renderMap();
                    };
                    img.onerror = (e) => {
                        console.error('[BUILDER MP] Failed to load tileset image:', ts.name, e);
                    };
                    img.src = ts.data;
                });
            } else {
                console.warn('[BUILDER MP] No tilesets in project!');
            }

            // Load NPC definitions (need to reload images from spriteData)
            if (project.npcs && project.npcs.length > 0) {
                npcs = [];
                project.npcs.forEach((npc, i) => {
                    npcs[i] = { ...npc };
                    if (npc.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            npcs[i]._spriteImg = img;
                            updateNpcList();
                        };
                        img.src = npc.spriteData;
                    }
                });
            }

            // Load dialogs
            if (project.dialogs) {
                dialogs = project.dialogs;
            }

            // Load player characters
            if (project.playerCharacters && project.playerCharacters.length > 0) {
                playerCharacters = [];
                project.playerCharacters.forEach((char, i) => {
                    playerCharacters[i] = { ...char };
                    if (char.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            playerCharacters[i]._spriteImg = img;
                            updatePlayerList();
                        };
                        img.src = char.spriteData;
                    }
                });
                activePlayerIndex = project.activePlayerIndex !== undefined ? project.activePlayerIndex : 0;
            }

            // Load spawn
            if (project.playerPreviewPos) {
                playerPreviewPos = project.playerPreviewPos;
            }
            spawnMapName = project.spawnMapName || spawnMapName;

            // Switch to the current map
            if (project.currentMapName && maps[project.currentMapName]) {
                currentMapName = project.currentMapName;
                loadMapState(maps[currentMapName]);
            }

            // Update all UI
            updateMapDropdowns();
            updateTriggerList();
            updatePlacedNpcList();
            updatePlacedSoundsList();
            updatePlacedLightsList();
            updateAnimPropListDisplay();
            updateDialogList();
            updatePlayerList();
            renderLayerList();
            renderMap();

            console.log('[BUILDER MP] Full project loaded successfully!');
            showBuilderStatus('Synced: ' + builderRoomCode);
        }

        function applyRemoteEdit(edit) {
            console.log('[BUILDER MP] Applying remote edit:', edit.editType);

            // Get the target map's layers
            let targetLayers;
            if (edit.mapName && edit.mapName !== currentMapName && maps[edit.mapName]) {
                // Edit is for a different map
                targetLayers = maps[edit.mapName].layers;
            } else {
                // Edit is for current map
                targetLayers = layers;
            }

            switch (edit.editType) {
                case 'batch':
                    // Apply batch of edits
                    let needsRender = false;
                    for (const e of edit.edits) {
                        // Apply each edit without rendering
                        applyRemoteEditNoRender(e);
                        if (!e.mapName || e.mapName === currentMapName) needsRender = true;
                    }
                    if (needsRender) renderMap();
                    break;

                case 'tile':
                    // Apply tile placement
                    if (!targetLayers[edit.layer]) targetLayers[edit.layer] = [];
                    if (!targetLayers[edit.layer][edit.y]) targetLayers[edit.layer][edit.y] = [];
                    targetLayers[edit.layer][edit.y][edit.x] = edit.cell;
                    if (!edit.mapName || edit.mapName === currentMapName) {
                        renderMap();
                    }
                    break;

                case 'eraseTile':
                    // Apply tile erasure
                    if (targetLayers[edit.layer] && targetLayers[edit.layer][edit.y]) {
                        targetLayers[edit.layer][edit.y][edit.x] = null;
                    }
                    if (!edit.mapName || edit.mapName === currentMapName) {
                        renderMap();
                    }
                    break;

                case 'tileSound':
                    // Apply tile sound placement
                    tileSounds[edit.key] = edit.sound;
                    updatePlacedSoundsList();
                    renderMap();
                    break;

                case 'removeTileSound':
                    // Remove tile sound
                    delete tileSounds[edit.key];
                    updatePlacedSoundsList();
                    renderMap();
                    break;

                case 'light':
                    // Apply light placement
                    pointLights[edit.key] = edit.light;
                    updatePlacedLightsList();
                    renderMap();
                    break;

                case 'removeLight':
                    // Remove light
                    delete pointLights[edit.key];
                    updatePlacedLightsList();
                    renderMap();
                    break;

                case 'placeNpc':
                    // Add NPC
                    placedNpcs.push(edit.npc);
                    updatePlacedNpcList();
                    renderMap();
                    break;

                case 'removeNpc':
                    // Remove NPC by index
                    if (edit.index >= 0 && edit.index < placedNpcs.length) {
                        placedNpcs.splice(edit.index, 1);
                        updatePlacedNpcList();
                        renderMap();
                    }
                    break;

                case 'placeTrigger':
                    // Add trigger
                    placedTriggers.push(edit.trigger);
                    updateTriggerList();
                    renderMap();
                    break;

                case 'removeTrigger':
                    // Remove trigger by index
                    if (edit.index >= 0 && edit.index < placedTriggers.length) {
                        placedTriggers.splice(edit.index, 1);
                        updateTriggerList();
                        renderMap();
                    }
                    break;

                case 'updateTrigger':
                    // Update existing trigger (spawn point, etc.)
                    if (edit.index >= 0 && edit.index < placedTriggers.length) {
                        placedTriggers[edit.index] = edit.trigger;
                        updateTriggerList();
                        renderMap();
                        console.log('[BUILDER MP] Remote trigger updated:', edit.index);
                    }
                    break;

                case 'placeItem':
                    // Add item
                    placedItems.push(edit.item);
                    updatePlacedItemsList();
                    renderMap();
                    console.log('[BUILDER MP] Remote item placed');
                    break;

                case 'removeItem':
                    // Remove item by position
                    const itemIdx = placedItems.findIndex(p =>
                        p.x === edit.x && p.y === edit.y &&
                        (!p.mapName || p.mapName === edit.mapName)
                    );
                    if (itemIdx >= 0) {
                        placedItems.splice(itemIdx, 1);
                        updatePlacedItemsList();
                        renderMap();
                        console.log('[BUILDER MP] Remote item removed');
                    }
                    break;

                case 'collision':
                    // Apply collision change
                    if (edit.value) {
                        tileCollisions[edit.key] = true;
                    } else {
                        delete tileCollisions[edit.key];
                    }
                    break;

                case 'collisionMask':
                    // Apply collision mask
                    collisionMasks[edit.key] = edit.mask;
                    break;

                case 'addLayer':
                    // Add new layer (from another builder)
                    if (edit.mapName === currentMapName) {
                        addLayer(true); // true = from network, don't rebroadcast
                    } else if (maps[edit.mapName]) {
                        maps[edit.mapName].layers.push(createEmptyLayer());
                    }
                    break;

                case 'addMap':
                    // Another builder created a new map
                    if (!maps[edit.mapName]) {
                        createMapData(edit.mapName);
                        updateMapDropdowns();
                        console.log('[BUILDER MP] Remote map created:', edit.mapName);
                    }
                    break;

                case 'deleteMap':
                    // Another builder deleted a map
                    if (maps[edit.mapName]) {
                        deleteMap(edit.mapName);
                        updateMapDropdowns();
                        updateTriggerList();
                        renderMap();
                        console.log('[BUILDER MP] Remote map deleted:', edit.mapName);
                    }
                    break;

                case 'clearMap':
                    // Another builder cleared a map
                    if (edit.mapName === currentMapName) {
                        initMap();
                        mapInitialized = true;
                        renderMap();
                    } else if (maps[edit.mapName]) {
                        // Clear the other map's data
                        maps[edit.mapName].layers = [createEmptyLayer()];
                        maps[edit.mapName].tileCollisions = {};
                        maps[edit.mapName].collisionMasks = {};
                    }
                    console.log('[BUILDER MP] Remote map cleared:', edit.mapName);
                    break;

                case 'addAnimProp':
                    // Another builder added an animated prop
                    animatedProps.push(edit.prop);
                    // Load the sprite image
                    if (edit.prop.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            animatedProps[animatedProps.length - 1]._spriteImg = img;
                            updateAnimPropListDisplay();
                            renderMap();
                        };
                        img.src = edit.prop.spriteData;
                    }
                    updateAnimPropListDisplay();
                    console.log('[BUILDER MP] Remote anim prop added:', edit.prop.name);
                    break;

                case 'removeAnimProp':
                    // Another builder removed an animated prop
                    if (edit.index >= 0 && edit.index < animatedProps.length) {
                        animatedProps.splice(edit.index, 1);
                        placedAnimProps = placedAnimProps.filter(p => p.propIndex !== edit.index);
                        placedAnimProps.forEach(p => { if (p.propIndex > edit.index) p.propIndex--; });
                        updateAnimPropListDisplay();
                        renderMap();
                        console.log('[BUILDER MP] Remote anim prop removed:', edit.index);
                    }
                    break;

                case 'updateAnimProp':
                    // Another builder updated an animated prop
                    if (edit.index >= 0 && edit.index < animatedProps.length) {
                        animatedProps[edit.index] = edit.prop;
                        // Load the sprite image
                        if (edit.prop.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                animatedProps[edit.index]._spriteImg = img;
                                updateAnimPropListDisplay();
                                renderMap();
                            };
                            img.src = edit.prop.spriteData;
                        }
                        updateAnimPropListDisplay();
                        console.log('[BUILDER MP] Remote anim prop updated:', edit.index);
                    }
                    break;

                case 'addTileset':
                    // Another builder added a tileset
                    if (edit.name && edit.data) {
                        const img = new Image();
                        img.onload = () => {
                            tilesets.push({ name: edit.name, img: img, data: edit.data });
                            updateTilesetDropdown();
                            renderMap();
                            console.log('[BUILDER MP] Remote tileset added:', edit.name);
                        };
                        img.src = edit.data;
                    }
                    break;

                case 'addNpc':
                    // Another builder added an NPC definition
                    if (edit.npc) {
                        npcs.push({ ...edit.npc });
                        const idx = npcs.length - 1;
                        if (edit.npc.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                npcs[idx]._spriteImg = img;
                                updateNpcList();
                            };
                            img.src = edit.npc.spriteData;
                        }
                        updateNpcList();
                        console.log('[BUILDER MP] Remote NPC added:', edit.npc.name);
                    }
                    break;

                case 'updateNpc':
                    // Another builder updated an NPC definition
                    if (edit.index >= 0 && edit.index < npcs.length && edit.npc) {
                        npcs[edit.index] = { ...edit.npc };
                        if (edit.npc.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                npcs[edit.index]._spriteImg = img;
                                updateNpcList();
                            };
                            img.src = edit.npc.spriteData;
                        }
                        updateNpcList();
                        console.log('[BUILDER MP] Remote NPC updated:', edit.npc.name);
                    }
                    break;

                case 'addDialog':
                    // Another builder added a dialog
                    if (edit.dialog) {
                        dialogs.push(edit.dialog);
                        updateDialogList();
                        console.log('[BUILDER MP] Remote dialog added:', edit.dialog.name);
                    }
                    break;

                case 'updateDialog':
                    // Another builder updated a dialog
                    if (edit.index >= 0 && edit.index < dialogs.length && edit.dialog) {
                        dialogs[edit.index] = edit.dialog;
                        updateDialogList();
                        console.log('[BUILDER MP] Remote dialog updated:', edit.dialog.name);
                    }
                    break;

                case 'deleteDialog':
                    // Another builder deleted a dialog
                    if (edit.index >= 0 && edit.index < dialogs.length) {
                        dialogs.splice(edit.index, 1);
                        placedNpcs.forEach(n => {
                            if (n.dialogIndex === edit.index) n.dialogIndex = -1;
                            else if (n.dialogIndex > edit.index) n.dialogIndex--;
                        });
                        updateDialogList();
                        console.log('[BUILDER MP] Remote dialog deleted:', edit.index);
                    }
                    break;

                case 'attachNpcDialog':
                    // Another builder attached a dialog to an NPC
                    if (edit.npcIndex >= 0 && edit.npcIndex < placedNpcs.length) {
                        placedNpcs[edit.npcIndex].dialogIndex = edit.dialogIndex;
                        updateDialogNpcDropdown();
                        console.log('[BUILDER MP] Remote NPC dialog attached:', edit.npcIndex, '->', edit.dialogIndex);
                    }
                    break;

                case 'deleteLayer':
                    // Another builder deleted a layer
                    if (edit.mapName === currentMapName) {
                        deleteLayer(edit.index, true);
                    } else if (maps[edit.mapName]) {
                        maps[edit.mapName].layers.splice(edit.index, 1);
                        maps[edit.mapName].layerVisibility.splice(edit.index, 1);
                        maps[edit.mapName].layerNames.splice(edit.index, 1);
                    }
                    console.log('[BUILDER MP] Remote layer deleted:', edit.index);
                    break;

                case 'moveLayerUp':
                    // Another builder moved a layer up
                    if (edit.mapName === currentMapName) {
                        moveLayerUp(edit.index, true);
                    } else if (maps[edit.mapName] && edit.index > 0) {
                        const m = maps[edit.mapName];
                        [m.layers[edit.index], m.layers[edit.index-1]] = [m.layers[edit.index-1], m.layers[edit.index]];
                        [m.layerVisibility[edit.index], m.layerVisibility[edit.index-1]] = [m.layerVisibility[edit.index-1], m.layerVisibility[edit.index]];
                        [m.layerNames[edit.index], m.layerNames[edit.index-1]] = [m.layerNames[edit.index-1], m.layerNames[edit.index]];
                    }
                    break;

                case 'moveLayerDown':
                    // Another builder moved a layer down
                    if (edit.mapName === currentMapName) {
                        moveLayerDown(edit.index, true);
                    } else if (maps[edit.mapName] && edit.index < maps[edit.mapName].layers.length - 1) {
                        const m = maps[edit.mapName];
                        [m.layers[edit.index], m.layers[edit.index+1]] = [m.layers[edit.index+1], m.layers[edit.index]];
                        [m.layerVisibility[edit.index], m.layerVisibility[edit.index+1]] = [m.layerVisibility[edit.index+1], m.layerVisibility[edit.index]];
                        [m.layerNames[edit.index], m.layerNames[edit.index+1]] = [m.layerNames[edit.index+1], m.layerNames[edit.index]];
                    }
                    break;

                case 'renameLayer':
                    // Another builder renamed a layer
                    if (edit.mapName === currentMapName) {
                        renameLayer(edit.index, edit.name, true);
                    } else if (maps[edit.mapName]) {
                        maps[edit.mapName].layerNames[edit.index] = edit.name;
                    }
                    break;

                case 'renameMap':
                    // Another builder renamed a map
                    if (maps[edit.oldName]) {
                        maps[edit.newName] = maps[edit.oldName];
                        delete maps[edit.oldName];
                        placedTriggers.forEach(t => {
                            if (t.mapName === edit.oldName) t.mapName = edit.newName;
                            if (t.targetMap === edit.oldName) t.targetMap = edit.newName;
                        });
                        placedNpcs.forEach(npc => {
                            if (npc.mapName === edit.oldName) npc.mapName = edit.newName;
                        });
                        if (currentMapName === edit.oldName) currentMapName = edit.newName;
                        if (spawnMapName === edit.oldName) spawnMapName = edit.newName;
                        updateMapDropdowns();
                        updateTriggerList();
                        console.log('[BUILDER MP] Remote map renamed:', edit.oldName, '->', edit.newName);
                    }
                    break;

                case 'cameraBounds':
                    // Another builder set/cleared camera bounds
                    if (edit.mapName === currentMapName) {
                        cameraBounds = edit.bounds;
                        updateCameraBoundsInfo();
                        renderMap();
                    } else if (maps[edit.mapName]) {
                        maps[edit.mapName].cameraBounds = edit.bounds;
                    }
                    break;

                case 'selectAllCollision':
                    // Another builder filled all collision for a tileset
                    selectAllCollision(true, edit.tilesetIndex);
                    break;

                case 'clearAllCollision':
                    // Another builder cleared all collision for a tileset
                    clearAllCollision(true, edit.tilesetIndex);
                    break;

                case 'splitLine':
                    // Another builder set a split line
                    console.log('[SYNC] Received splitLine:', edit.key, 'mask:', edit.mask);
                    if (edit.mask && Array.isArray(edit.mask)) {
                        tileSplitLines[edit.key] = edit.mask;
                    } else {
                        // Fallback: flat line at middle
                        tileSplitLines[edit.key] = new Array(16).fill(8);
                    }
                    drawCollisionTileset();
                    break;

                case 'clearSplitLine':
                    // Another builder cleared a split line
                    delete tileSplitLines[edit.key];
                    drawCollisionTileset();
                    break;

                case 'addPlayerCharacter':
                    // Another builder added a player character
                    if (edit.character) {
                        playerCharacters.push({ ...edit.character });
                        const idx = playerCharacters.length - 1;
                        if (edit.character.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                playerCharacters[idx]._spriteImg = img;
                                updatePlayerList();
                            };
                            img.src = edit.character.spriteData;
                        }
                        updatePlayerList();
                        console.log('[BUILDER MP] Remote player character added:', edit.character.name);
                    }
                    break;

                case 'updatePlayerCharacter':
                    // Another builder updated a player character
                    if (edit.index >= 0 && edit.index < playerCharacters.length && edit.character) {
                        playerCharacters[edit.index] = { ...edit.character };
                        if (edit.character.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                playerCharacters[edit.index]._spriteImg = img;
                                updatePlayerList();
                            };
                            img.src = edit.character.spriteData;
                        }
                        updatePlayerList();
                        console.log('[BUILDER MP] Remote player character updated:', edit.character.name);
                    }
                    break;

                case 'deletePlayerCharacter':
                    // Another builder deleted a player character
                    if (edit.index >= 0 && edit.index < playerCharacters.length) {
                        playerCharacters.splice(edit.index, 1);
                        if (activePlayerIndex >= playerCharacters.length) {
                            activePlayerIndex = playerCharacters.length - 1;
                        }
                        updatePlayerList();
                        console.log('[BUILDER MP] Remote player character deleted:', edit.index);
                    }
                    break;

                case 'setActivePlayer':
                    // Another builder changed active player
                    if (edit.index >= -1 && edit.index < playerCharacters.length) {
                        activePlayerIndex = edit.index;
                        updatePlayerList();
                        console.log('[BUILDER MP] Remote active player changed:', edit.index);
                    }
                    break;
            }
        }

        // Version without renderMap calls (for batching)
        function applyRemoteEditNoRender(edit) {
            let targetLayers = (edit.mapName && edit.mapName !== currentMapName && maps[edit.mapName])
                ? maps[edit.mapName].layers : layers;

            switch (edit.editType) {
                case 'tile':
                    if (!targetLayers[edit.layer]) targetLayers[edit.layer] = [];
                    if (!targetLayers[edit.layer][edit.y]) targetLayers[edit.layer][edit.y] = [];
                    targetLayers[edit.layer][edit.y][edit.x] = edit.cell;
                    break;
                case 'eraseTile':
                    if (targetLayers[edit.layer] && targetLayers[edit.layer][edit.y]) {
                        targetLayers[edit.layer][edit.y][edit.x] = null;
                    }
                    break;
                case 'tileSound':
                    tileSounds[edit.key] = edit.sound;
                    break;
                case 'removeTileSound':
                    delete tileSounds[edit.key];
                    break;
                case 'light':
                    pointLights[edit.key] = edit.light;
                    break;
                case 'removeLight':
                    delete pointLights[edit.key];
                    break;
                case 'placeNpc':
                    placedNpcs.push(edit.npc);
                    break;
                case 'removeNpc':
                    if (edit.index >= 0 && edit.index < placedNpcs.length) {
                        placedNpcs.splice(edit.index, 1);
                    }
                    break;
                case 'placeTrigger':
                    placedTriggers.push(edit.trigger);
                    break;
                case 'removeTrigger':
                    if (edit.index >= 0 && edit.index < placedTriggers.length) {
                        placedTriggers.splice(edit.index, 1);
                    }
                    break;
                case 'collision':
                    if (edit.value) tileCollisions[edit.key] = true;
                    else delete tileCollisions[edit.key];
                    break;
                case 'collisionMask':
                    collisionMasks[edit.key] = edit.mask;
                    break;
            }
        }

        // Batching system for builder edits
        let editBatch = [];
        let batchTimeout = null;
        const BATCH_DELAY = 250; // ms to wait before sending batch (higher = less network traffic)

        function broadcastEdit(editData) {
            // Send to test game window directly (works in solo mode)
            if (testGameWindow && !testGameWindow.closed) {
                try {
                    testGameWindow.postMessage({ type: 'builderEdit', edit: editData }, '*');
                } catch (e) {
                    // Window might be closed or cross-origin
                }
            }

            // Also broadcast via WebSocket if in CO-OP mode
            if (!builderConnected || !builderSocket) return;

            // Add to batch
            editBatch.push(editData);

            // If no pending send, schedule one
            if (!batchTimeout) {
                batchTimeout = setTimeout(flushEditBatch, BATCH_DELAY);
            }
        }

        function flushEditBatch() {
            batchTimeout = null;
            if (editBatch.length === 0 || !builderConnected || !builderSocket) return;

            if (editBatch.length === 1) {
                // Single edit - send normally
                builderSocket.send(JSON.stringify({
                    type: 'update',
                    ...editBatch[0],
                    gameType: 'builder'
                }));
            } else {
                // Multiple edits - send as batch
                builderSocket.send(JSON.stringify({
                    type: 'update',
                    editType: 'batch',
                    edits: editBatch,
                    gameType: 'builder'
                }));
            }
            editBatch = [];
        }

        // Warn before closing tab if in co-op mode
        window.addEventListener('beforeunload', (e) => {
            if (builderConnected) {
                e.preventDefault();
                e.returnValue = 'You are in a co-op session. Make sure to save your work!';
                return e.returnValue;
            }
        });

        function showBuilderStatus(msg) {
            // Show connection status in Tools dropdown menu
            const statusEl = document.getElementById('coopStatusInMenu');
            if (statusEl) {
                statusEl.style.display = 'block';
                statusEl.textContent = 'CO-OP: ' + msg;
                if (msg.includes('Disconnected')) {
                    statusEl.className = 'coop-status-menu disconnected';
                } else {
                    statusEl.className = 'coop-status-menu connected';
                }
            }
            // Also update tools button to show connection indicator
            const toolsBtn = document.querySelector('.tools-toggle');
            if (toolsBtn) {
                if (msg.includes('Disconnected')) {
                    toolsBtn.innerHTML = '⚙ Tools ▼';
                } else {
                    toolsBtn.innerHTML = '⚙ Tools <span style="color:#0f0;">●</span> ▼';
                }
            }
        }

        function showRoomInfo() {
            // Create or update room info modal
            let modal = document.getElementById('roomInfoModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'roomInfoModal';
                modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
                modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
                document.body.appendChild(modal);
            }

            // Build content - retro styled
            let html = '<div style="background:#1a1a1a;border:3px solid #fff;padding:25px;min-width:320px;max-width:500px;font-family:\'Press Start 2P\',monospace;">';
            html += '<h2 style="color:#fff;margin:0 0 20px 0;text-align:center;font-size:14px;letter-spacing:2px;">ROOM INFO</h2>';

            // Connection status
            if (builderConnected && builderRoomCode) {
                html += '<div style="background:#0a1a0a;color:#0f0;padding:10px;margin-bottom:15px;border:2px solid #0f0;text-align:center;font-size:8px;">';
                html += '> CONNECTED: <strong>' + builderRoomCode + '</strong></div>';
            } else {
                html += '<div style="background:#1a0a0a;color:#f00;padding:10px;margin-bottom:15px;border:2px solid #f00;text-align:center;font-size:8px;">';
                html += '> NOT CONNECTED</div>';
            }

            // Your name
            html += '<div style="color:#888;margin-bottom:12px;font-size:8px;"><span style="color:#f90;">PLAYER:</span> ' + builderPlayerName + '</div>';

            // Builder players in room
            html += '<div style="color:#4af;margin-bottom:8px;font-size:8px;">BUILDERS (' + builderPlayersInRoom.size + ')</div>';
            if (builderPlayersInRoom.size > 0) {
                html += '<div style="color:#666;margin:0 0 15px 10px;font-size:7px;">';
                builderPlayersInRoom.forEach((p, id) => {
                    html += '> ' + p.name + '<br>';
                });
                html += '</div>';
            } else {
                html += '<div style="color:#444;margin-bottom:15px;padding-left:10px;font-size:7px;">No other builders</div>';
            }

            // Game testers in room
            html += '<div style="color:#0ff;margin-bottom:8px;font-size:8px;">TESTERS (' + gamePlayersInBuilder.size + ')</div>';
            if (gamePlayersInBuilder.size > 0) {
                html += '<div style="color:#666;margin:0 0 15px 10px;font-size:7px;">';
                gamePlayersInBuilder.forEach((p, id) => {
                    html += '> ' + p.name + ' <span style="color:#444;">[' + (p.currentMap || '?') + ']</span><br>';
                });
                html += '</div>';
            } else {
                html += '<div style="color:#444;margin-bottom:15px;padding-left:10px;font-size:7px;">No game testers</div>';
            }

            // Project info
            html += '<div style="border-top:1px solid #333;padding-top:15px;margin-top:10px;">';
            html += '<div style="color:#a6f;margin-bottom:10px;font-size:8px;">PROJECT STATS</div>';
            html += '<div style="color:#666;margin-left:10px;font-size:7px;">';
            html += '<div style="margin:4px 0;">Maps........ ' + Object.keys(maps).length + '</div>';
            html += '<div style="margin:4px 0;">Tilesets.... ' + tilesets.length + '</div>';
            html += '<div style="margin:4px 0;">NPCs........ ' + npcs.length + '</div>';
            html += '<div style="margin:4px 0;">Triggers.... ' + placedTriggers.length + '</div>';
            html += '</div></div>';

            // Share save button (for host to share with late joiners)
            html += '<div style="border-top:1px solid #333;padding-top:15px;margin-top:15px;">';
            html += '<div style="color:#fd0;margin-bottom:8px;font-size:8px;">LATE JOINERS</div>';
            html += '<p style="color:#444;font-size:6px;margin:0 0 10px 0;">Download save to share with friends</p>';
            html += '<button onclick="downloadProject(); document.getElementById(\'roomInfoModal\').style.display=\'none\'" ';
            html += 'style="width:100%;padding:12px;background:#1a1a1a;color:#0f0;border:2px solid #0f0;cursor:pointer;font-family:\'Press Start 2P\',monospace;font-size:8px;">DOWNLOAD SAVE</button>';
            html += '</div>';

            // Close button
            html += '<button onclick="document.getElementById(\'roomInfoModal\').style.display=\'none\'" ';
            html += 'style="width:100%;margin-top:12px;padding:12px;background:#1a1a1a;color:#f55;border:2px solid #f55;cursor:pointer;font-family:\'Press Start 2P\',monospace;font-size:8px;">CLOSE</button>';

            html += '</div>';
            modal.innerHTML = html;
            modal.style.display = 'flex';
        }

        // Adventure mode - load project, open test, hide UI
        let launchAsAdventure = false;
        let multiplayerSettings = null; // Will be set from prompt

        async function startAdventure() {
            if (!pendingSaveData) return;

            // Get multiplayer settings from prompt
            const playerName = document.getElementById('mpPlayerName').value.trim() || 'Player';
            const roomCode = document.getElementById('mpRoomCode').value.trim();

            if (roomCode) {
                multiplayerSettings = { playerName, roomCode };
            } else {
                multiplayerSettings = null; // Solo mode
            }

            document.getElementById('multiplayerPrompt').style.display = 'none';
            document.getElementById('modeSelect').style.display = 'block';
            document.getElementById('modeSelect').innerHTML = '<h1>LOADING...</h1>';
            // Keep loadPhase visible during entire loading process
            keepLoadPhaseVisible = true;
            document.getElementById('loadPhase').style.zIndex = '9999';

            await loadProject(pendingSaveData);
            pendingSaveData = null;

            // Wait for tilesets to load
            setTimeout(() => {
                launchAsAdventure = true;
                testMap();
                launchAsAdventure = false;
                // Return to start menu after game opens
                setTimeout(() => {
                    keepLoadPhaseVisible = false;
                    document.getElementById('loadPhase').style.zIndex = '';
                    // Reset to start screen (not builder)
                    document.getElementById('modeSelect').style.display = 'none';
                    document.getElementById('mainMenu').style.display = 'block';
                    document.getElementById('loadPhase').classList.add('active');
                    setPhase('load');
                }, 2000);
            }, 1000);
        }

        // Show/hide prompt functions
        function showDirectJoinPrompt() {
            // Show join prompt directly from main menu (no save file needed)
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('joinRoomPrompt').style.display = 'block';
        }

        function showHostPrompt() {
            document.getElementById('craftMultiplayerPrompt').style.display = 'none';
            document.getElementById('hostRoomPrompt').style.display = 'block';
        }

        function hideHostPrompt() {
            document.getElementById('hostRoomPrompt').style.display = 'none';
            document.getElementById('craftMultiplayerPrompt').style.display = 'block';
        }

        function showJoinPrompt() {
            document.getElementById('craftMultiplayerPrompt').style.display = 'none';
            document.getElementById('joinRoomPrompt').style.display = 'block';
        }

        function hideJoinPrompt() {
            document.getElementById('joinRoomPrompt').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';
            joinSaveData = null;
            document.getElementById('joinSaveStatus').textContent = 'No file loaded';
        }

        // Handle save file loaded in Join Room prompt
        let joinSaveData = null;
        function handleJoinSaveFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    joinSaveData = JSON.parse(e.target.result);
                    document.getElementById('joinSaveStatus').textContent = 'Loaded: ' + file.name;
                    document.getElementById('joinSaveStatus').style.color = '#0f0';
                    console.log('[JOIN] Save file loaded:', file.name);
                } catch (err) {
                    alert('Invalid save file!');
                    joinSaveData = null;
                    document.getElementById('joinSaveStatus').textContent = 'Error loading file';
                    document.getElementById('joinSaveStatus').style.color = '#f00';
                }
            };
            reader.readAsText(file);
        }

        // SOLO MODE - Load local save, no multiplayer
        async function startCraftSolo() {
            console.log('[CRAFT] Starting SOLO mode');
            if (!pendingSaveData) {
                console.log('[CRAFT] No pendingSaveData, returning');
                return;
            }

            document.getElementById('craftMultiplayerPrompt').style.display = 'none';

            await loadProject(pendingSaveData);
            pendingSaveData = null;
            document.getElementById('modeSelect').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';

            console.log('[CRAFT] Solo mode ready');
        }

        // HOST MODE - Load local save, then connect to room (others get your project)
        async function startCraftHost() {
            console.log('[CRAFT] Starting HOST mode');
            if (!pendingSaveData) {
                console.log('[CRAFT] No pendingSaveData, returning');
                return;
            }

            const playerName = document.getElementById('hostPlayerName').value.trim() || 'Host';
            const roomCode = document.getElementById('hostRoomCode').value.trim();

            if (!roomCode) {
                alert('Please enter a room code for others to join');
                return;
            }

            document.getElementById('hostRoomPrompt').style.display = 'none';

            // Load YOUR local project first (you're the host, your project is the map)
            await loadProject(pendingSaveData);
            pendingSaveData = null;
            document.getElementById('modeSelect').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';

            // Connect to multiplayer - you're the host
            console.log('[CRAFT] Host connecting to room:', roomCode);
            connectBuilderMultiplayer(playerName, roomCode);

            console.log('[CRAFT] Host mode ready - share room code:', roomCode);
        }

        // JOIN MODE - Load same save as host, then connect for real-time sync
        async function startCraftJoin() {
            console.log('[CRAFT] Starting JOIN mode');

            const playerName = document.getElementById('joinPlayerName').value.trim() || 'Builder';
            const roomCode = document.getElementById('joinRoomCode').value.trim();

            if (!roomCode) {
                alert('Please enter a room code to join');
                return;
            }

            if (!joinSaveData) {
                alert('Please load the save file first!');
                return;
            }

            document.getElementById('joinRoomPrompt').style.display = 'none';

            // Load the save file
            console.log('[CRAFT] Loading save for co-op join');
            await loadProject(joinSaveData);
            joinSaveData = null;

            // Show the builder interface
            document.getElementById('loadPhase').classList.remove('active');
            document.getElementById('buildPhase').classList.add('active');
            setPhase('build');

            // Connect to multiplayer for real-time sync
            console.log('[CRAFT] Joining room:', roomCode);
            connectBuilderMultiplayer(playerName, roomCode);

            console.log('[CRAFT] Join mode ready - edits will sync with room');
        }

        // Initialize an empty project for joiners
        function initEmptyProject() {
            gridSize = 16;
            mapCols = 40;
            mapRows = 30;
            layers = [[]];
            layerVisibility = [true];
            layerNames = ['Layer 1'];
            currentLayer = 0;
            tileCollisions = {};
            collisionMasks = {};
            tileSplitLines = {};
            maps = { 'main': { layers: [[]], layerVisibility: [true], layerNames: ['Layer 1'], currentLayer: 0 }};
            currentMapName = 'main';
            placedTriggers = [];
            placedNpcs = [];
            npcs = [];
            tilesets = [];
            animatedProps = [];
            placedAnimProps = [];
            sounds = [];
            tileSounds = {};
            pointLights = {};
            dialogs = [];

            // Initialize empty layer grid
            for (let y = 0; y < mapRows; y++) {
                layers[0][y] = [];
                for (let x = 0; x < mapCols; x++) {
                    layers[0][y][x] = null;
                }
            }

            console.log('[CRAFT] Empty project initialized');
        }

        // Legacy function for backwards compatibility
        async function startCraft() {
            startCraftSolo();
        }

        async function loadProject(projectData) {
            // If no data passed, load from IndexedDB (or migrate from localStorage)
            let p;
            if (projectData) {
                p = projectData;
            } else {
                // Try IndexedDB first
                try {
                    const dbData = await loadProjectFromDB();
                    if (dbData) {
                        p = dbData;
                        console.log('Loaded project from IndexedDB');
                    }
                } catch (err) {
                    console.warn('IndexedDB load failed:', err);
                }

                // If no IndexedDB data, check localStorage for migration
                if (!p) {
                    const legacyData = localStorage.getItem('worldBuilderProject');
                    if (legacyData) {
                        try {
                            p = JSON.parse(legacyData);
                            console.log('Loaded project from localStorage, migrating to IndexedDB...');
                            // Migrate to IndexedDB
                            try {
                                await saveProjectToDB(p);
                                localStorage.removeItem('worldBuilderProject');
                                console.log('Migration complete, localStorage cleared');
                            } catch (migErr) {
                                console.warn('Migration to IndexedDB failed:', migErr);
                            }
                        } catch (parseErr) {
                            alert('Error parsing saved data: ' + parseErr.message);
                            return;
                        }
                    }
                }

                if (!p) {
                    alert('No saved project found in browser storage. Use "Load File" to load from a downloaded file.');
                    return;
                }
            }

            console.log('Loading project:', p);
            gridSize = p.gridSize || 16;
            mapCols = p.mapCols || 40;
            mapRows = p.mapRows || 30;
            tileCollisions = p.tileCollisions || {};
            collisionMasks = p.collisionMasks || {};
            tileSplitLines = p.tileSplitLines || {}; // Depth split lines for Y-sorting

            // Load multiple props (new format)
            props = [];
            propImage = null;
            propImageData = null;
            propCollisionMasks = {};
            currentPropIndex = -1;

            if (p.props && p.props.length > 0) {
                console.log('Loading', p.props.length, 'props');
                let propsLoaded = 0;
                p.props.forEach((propData, i) => {
                    const img = new Image();
                    img.onload = () => {
                        props[i] = {
                            name: propData.name,
                            img: img,
                            data: propData.data,
                            collisionMasks: propData.collisionMasks || {}
                        };
                        propsLoaded++;
                        if (propsLoaded === p.props.length) {
                            // All props loaded
                            currentPropIndex = p.currentPropIndex >= 0 ? p.currentPropIndex : 0;
                            if (props[currentPropIndex]) {
                                propImage = props[currentPropIndex].img;
                                propImageData = props[currentPropIndex].data;
                                propCollisionMasks = props[currentPropIndex].collisionMasks;
                            }
                            updatePropDropdown();
                            updatePropUI();
                            drawPropTileset();
                            renderMap();
                        }
                    };
                    img.onerror = () => {
                        console.error('Failed to load prop', i);
                        propsLoaded++;
                    };
                    img.src = propData.data;
                });
            } else if (p.propImageData) {
                // Old format - single prop image (backwards compatibility)
                console.log('Loading single prop (old format)');
                const img = new Image();
                img.onload = () => {
                    props = [{
                        name: 'prop',
                        img: img,
                        data: p.propImageData,
                        collisionMasks: p.propCollisionMasks || {}
                    }];
                    currentPropIndex = 0;
                    propImage = img;
                    propImageData = p.propImageData;
                    propCollisionMasks = p.propCollisionMasks || {};
                    updatePropDropdown();
                    updatePropUI();
                    drawPropTileset();
                    renderMap();
                };
                img.onerror = () => console.error('Failed to load prop image');
                img.src = p.propImageData;
            } else {
                console.log('No props in saved project');
                updatePropDropdown();
                updatePropUI();
            }

            // Load animated props
            animatedProps = [];
            animPropSpriteSheet = null;
            animPropSpriteData = null;
            currentAnimPropIndex = -1;
            placedAnimProps = p.placedAnimProps || [];

            if (p.animatedProps && p.animatedProps.length > 0) {
                console.log('Loading', p.animatedProps.length, 'animated props');
                let propsLoaded = 0;
                p.animatedProps.forEach((propData, i) => {
                    animatedProps[i] = {
                        name: propData.name,
                        spriteData: propData.spriteData,
                        frameWidth: propData.frameWidth || 16,
                        frameHeight: propData.frameHeight || 16,
                        frames: propData.frames || [],
                        type: propData.type || 'loop',
                        fps: propData.fps || 8,
                        collisionMask: propData.collisionMask || null,
                        splitLine: propData.splitLine || null
                    };

                    // Load sprite sheet image if present
                    if (propData.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            animatedProps[i]._spriteImg = img;
                            propsLoaded++;
                            if (propsLoaded === p.animatedProps.length) {
                                currentAnimPropIndex = p.currentAnimPropIndex >= 0 ? p.currentAnimPropIndex : 0;
                                if (animatedProps[currentAnimPropIndex] && animatedProps[currentAnimPropIndex]._spriteImg) {
                                    animPropSpriteSheet = animatedProps[currentAnimPropIndex]._spriteImg;
                                    animPropSpriteData = animatedProps[currentAnimPropIndex].spriteData;
                                }
                                updateAnimPropListDisplay();
                                renderMap();
                            }
                        };
                        img.onerror = () => {
                            console.error('Failed to load animated prop sprite', i);
                            propsLoaded++;
                        };
                        img.src = propData.spriteData;
                    } else {
                        propsLoaded++;
                        if (propsLoaded === p.animatedProps.length) {
                            currentAnimPropIndex = p.currentAnimPropIndex >= 0 ? p.currentAnimPropIndex : 0;
                            updateAnimPropListDisplay();
                            renderMap();
                        }
                    }
                });
            } else {
                console.log('No animated props in saved project');
                updateAnimPropListDisplay();
            }

            // Load NPCs
            npcs = [];
            currentNpcIndex = -1;
            placedNpcs = p.placedNpcs || [];
            selectedPlacedNpcIndex = -1;
            npcPathDrawing = false;

            if (p.npcs && p.npcs.length > 0) {
                console.log('Loading', p.npcs.length, 'NPCs');
                p.npcs.forEach((npcData, i) => {
                    npcs[i] = {
                        name: npcData.name,
                        spriteData: npcData.spriteData,
                        frameWidth: npcData.frameWidth || 32,
                        frameHeight: npcData.frameHeight || 32,
                        animations: npcData.animations || { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], attackDown: [], attackUp: [], attackLeft: [], attackRight: [] },
                        animMirrors: npcData.animMirrors || {},
                        fps: npcData.fps || 8,
                        collisionMask: npcData.collisionMask || null,
                        splitLine: npcData.splitLine ?? null
                    };
                    // Preload sprite image
                    if (npcData.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            npcs[i]._editorImg = img;
                            renderMap();
                        };
                        img.src = npcData.spriteData;
                    }
                });
                currentNpcIndex = p.currentNpcIndex >= 0 ? p.currentNpcIndex : 0;
                updateNpcList();
                updatePlacedNpcList();
            } else {
                console.log('No NPCs in saved project');
                updateNpcList();
                updatePlacedNpcList();
            }

            // Load layers (backwards compatible with old saves)
            if (p.layers) {
                layers = p.layers;
                layerVisibility = p.layerVisibility || layers.map(() => true);
                layerNames = p.layerNames || layers.map(() => '');
                currentLayer = p.currentLayer || 0;
            } else if (p.map) {
                // Old format - single map
                layers = [p.map];
                layerVisibility = [true];
                layerNames = [''];
                currentLayer = 0;
            } else {
                layers = [createEmptyLayer()];
                layerVisibility = [true];
                layerNames = [''];
                currentLayer = 0;
            }
            map = layers[currentLayer];

            // Load player layer settings
            playerLayerIndex = p.playerLayerIndex !== undefined ? p.playerLayerIndex : 1;
            playerPreviewPos = p.playerPreviewPos || { x: 5, y: 5 };
            spawnMapName = p.spawnMapName || 'main';
            playerPreviewVisible = p.playerPreviewVisible !== undefined ? p.playerPreviewVisible : true;

            // Load sounds
            sounds = [];
            tileSounds = p.tileSounds || {};
            playerSounds = p.playerSounds || {
                walk: { soundIndex: -1, interval: 200, volume: 0.5, pitchVariation: 0.1 },
                attack: { soundIndex: -1, volume: 0.7 }
            };

            if (p.sounds && p.sounds.length > 0) {
                console.log('Loading', p.sounds.length, 'sounds');
                p.sounds.forEach((soundData, i) => {
                    sounds[i] = {
                        name: soundData.name,
                        data: soundData.data,
                        duration: soundData.duration || 0,
                        type: soundData.type || 'ambient'
                    };
                });
                updateSoundDropdown();
                updatePlacedSoundsList();
                updatePlayerSoundAssignments();
            } else {
                console.log('No sounds in saved project');
                updateSoundDropdown();
                updatePlacedSoundsList();
                updatePlayerSoundAssignments();
            }

            // Load lighting settings
            if (p.lightingSettings) {
                lightingSettings = {
                    blobShadows: p.lightingSettings.blobShadows !== false,
                    ambientEnabled: p.lightingSettings.ambientEnabled || false,
                    timeOfDay: p.lightingSettings.timeOfDay || 'day',
                    playerLight: p.lightingSettings.playerLight || false,
                    playerLightRadius: p.lightingSettings.playerLightRadius || 4
                };
                // Update UI to match loaded settings
                const ambientEl = document.getElementById('ambientEnabled');
                const blobEl = document.getElementById('blobShadows');
                const playerLightEl = document.getElementById('playerLight');
                const radiusEl = document.getElementById('playerLightRadius');
                if (ambientEl) ambientEl.checked = lightingSettings.ambientEnabled;
                if (blobEl) blobEl.checked = lightingSettings.blobShadows;
                if (playerLightEl) playerLightEl.checked = lightingSettings.playerLight;
                if (radiusEl) {
                    radiusEl.value = lightingSettings.playerLightRadius;
                    document.getElementById('playerLightRadiusVal').textContent = lightingSettings.playerLightRadius;
                }
                setTimeOfDay(lightingSettings.timeOfDay);
            }
            pointLights = p.pointLights || {};
            updatePlacedLightsList();

            // Always load default player sprite
            playerSpriteImg = new Image();
            playerSpriteImg.onload = () => {
                console.log('Player sprite loaded, size:', playerSpriteImg.naturalWidth, 'x', playerSpriteImg.naturalHeight);
            };
            playerSpriteImg.onerror = () => {
                // Try relative path as fallback
                playerSpriteImg.src = 'assets/player_sprite.png';
            };
            playerSpriteImg.src = window.location.origin + '/assets/player_sprite.png';

            // Load multi-map data
            if (p.maps && Object.keys(p.maps).length > 0) {
                maps = p.maps;
                currentMapName = p.currentMapName || 'main';
                console.log('Loaded', Object.keys(maps).length, 'maps');
            } else {
                // No multi-map data - will create 'main' map from current data after load
                maps = {};
                currentMapName = 'main';
            }

            // Load triggers
            placedTriggers = p.placedTriggers || [];
            console.log('Loaded', placedTriggers.length, 'triggers');
            updateDoorNumberDropdown();

            // Load dialogs
            dialogs = p.dialogs || [];
            placedDialogTiles = p.placedDialogTiles || [];
            console.log('Loaded', dialogs.length, 'dialogs,', placedDialogTiles.length, 'dialog tiles');
            updateDialogList();

            // Load items
            items = [];
            placedItems = p.placedItems || [];
            currentItemIndex = -1;
            if (p.items && p.items.length > 0) {
                p.items.forEach((itemData, i) => {
                    items[i] = {
                        name: itemData.name,
                        spriteData: itemData.spriteData,
                        frameWidth: itemData.frameWidth || 16,
                        frameHeight: itemData.frameHeight || 16,
                        frames: itemData.frames || [],
                        fps: itemData.fps || 8,
                        idleFrame: itemData.idleFrame || 0
                    };
                    // Preload sprite image
                    if (itemData.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            items[i]._spriteImg = img;
                            renderMap();
                        };
                        img.src = itemData.spriteData;
                    }
                });
                console.log('Loaded', items.length, 'items,', placedItems.length, 'placed items');
            }
            updateItemList();
            updatePlacedItemsList();

            // Load player characters
            playerCharacters = [];
            activePlayerIndex = -1;
            if (p.playerCharacters && p.playerCharacters.length > 0) {
                p.playerCharacters.forEach((char, i) => {
                    playerCharacters[i] = { ...char };
                    if (char.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            playerCharacters[i]._spriteImg = img;
                            updatePlayerList();
                        };
                        img.src = char.spriteData;
                    }
                });
                activePlayerIndex = p.activePlayerIndex !== undefined ? p.activePlayerIndex : 0;
                console.log('Loaded', playerCharacters.length, 'player characters, active:', activePlayerIndex);
            }
            updatePlayerList();

            // Load tilesets (new format with multiple tilesets)
            if (p.tilesets && p.tilesets.length > 0) {
                let loadedCount = 0;
                tilesets = [];
                p.tilesets.forEach((tsData, i) => {
                    const img = new Image();
                    img.onload = () => {
                        tilesets[i] = { name: tsData.name, img: img, data: tsData.data };
                        loadedCount++;
                        if (loadedCount === p.tilesets.length) {
                            // All tilesets loaded
                            currentTilesetIndex = p.currentTilesetIndex || 0;
                            tilesetImg = tilesets[currentTilesetIndex].img;
                            mapInitialized = true; // Mark map as loaded

                            // Initialize maps object if empty (old format project)
                            if (Object.keys(maps).length === 0) {
                                saveCurrentMapState();
                                console.log('Initialized maps object with current data');
                            }

                            updateTilesetDropdown();
                            setPhase('build');
                            drawPaintTileset();
                            renderLayerList();
                            renderMap();
                            updateAnimPropListDisplay();
                            updateMapDropdowns();
                            updateTriggerList();
                        }
                    };
                    img.src = tsData.data;
                });
            } else if (p.tilesetData) {
                // Old format - single tileset
                const img = new Image();
                img.onload = () => {
                    tilesets = [{ name: 'tileset', img: img, data: p.tilesetData }];
                    currentTilesetIndex = 0;
                    tilesetImg = img;
                    mapInitialized = true; // Mark map as loaded

                    // Initialize maps object if empty (old format project)
                    if (Object.keys(maps).length === 0) {
                        saveCurrentMapState();
                        console.log('Initialized maps object with current data');
                    }

                    updateTilesetDropdown();
                    setPhase('build');
                    drawPaintTileset();
                    renderLayerList();
                    renderMap();
                    updateAnimPropListDisplay();
                    updateMapDropdowns();
                    updateTriggerList();
                };
                img.src = p.tilesetData;
            } else {
                alert('No tileset data found in save');
            }
        }

        function exportConfig() {
            const config = { gridSize, mapSize: { cols: mapCols, rows: mapRows }, tileCollisions, layers };
            navigator.clipboard.writeText(JSON.stringify(config, null, 2)).then(() => alert('Copied!'));
        }

        // ===== MULTI-MAP FUNCTIONS =====

        // Save the current map state to the maps object
        // Camera bounds for current map (null = no bounds)
        let cameraBounds = null;

        function saveCurrentMapState() {
            maps[currentMapName] = {
                layers: JSON.parse(JSON.stringify(layers)),
                layerVisibility: [...layerVisibility],
                layerNames: [...layerNames],
                currentLayer: currentLayer,
                tileCollisions: JSON.parse(JSON.stringify(tileCollisions)),
                collisionMasks: JSON.parse(JSON.stringify(collisionMasks)),
                tileSplitLines: JSON.parse(JSON.stringify(tileSplitLines)),
                mapCols: mapCols,
                mapRows: mapRows,
                cameraBounds: cameraBounds ? { ...cameraBounds } : null
            };
            console.log('Saved map state for:', currentMapName);
        }

        // Load a map state from the maps object
        function loadMapState(mapData) {
            layers = JSON.parse(JSON.stringify(mapData.layers));
            layerVisibility = [...mapData.layerVisibility];
            layerNames = [...mapData.layerNames];
            currentLayer = mapData.currentLayer || 0;
            tileCollisions = JSON.parse(JSON.stringify(mapData.tileCollisions || {}));
            collisionMasks = JSON.parse(JSON.stringify(mapData.collisionMasks || {}));
            tileSplitLines = JSON.parse(JSON.stringify(mapData.tileSplitLines || {}));
            mapCols = mapData.mapCols || mapCols;
            mapRows = mapData.mapRows || mapRows;
            cameraBounds = mapData.cameraBounds ? { ...mapData.cameraBounds } : null;
            map = layers[currentLayer];
        }

        // Create a new empty map
        function createMapData(name) {
            maps[name] = {
                layers: [createEmptyLayer()],
                layerVisibility: [true],
                layerNames: ['Layer 1'],
                currentLayer: 0,
                tileCollisions: {},
                collisionMasks: {},
                tileSplitLines: {},
                mapCols: mapCols,
                mapRows: mapRows,
                cameraBounds: null // {x, y, width, height} in tiles, null = no bounds
            };
            console.log('Created new map:', name);
        }

        // Switch to a different map
        function switchToMap(mapName) {
            if (!maps[mapName]) {
                console.warn('Map not found:', mapName);
                return false;
            }

            // Save current map state first
            saveCurrentMapState();

            // Load the new map
            currentMapName = mapName;
            loadMapState(maps[mapName]);

            // Update UI
            renderLayerList();
            renderMap();
            updateTriggerList();
            updatePlacedNpcList();
            updatePlacedSoundsList();
            updatePlacedLightsList();
            updateMapDropdowns(); // Update dropdown to show current map
            updateCameraBoundsInfo(); // Update camera bounds display

            console.log('Switched to map:', mapName);
            return true;
        }

        // Get list of all map names
        function getMapNames() {
            return Object.keys(maps);
        }

        // Delete a map (cannot delete last map)
        function deleteMap(mapName) {
            const mapNames = getMapNames();
            if (mapNames.length <= 1) {
                alert('Cannot delete the last map');
                return false;
            }
            if (mapName === currentMapName) {
                // Switch to another map first
                const otherMap = mapNames.find(n => n !== mapName);
                switchToMap(otherMap);
            }
            delete maps[mapName];

            // Remove triggers that are on or target this map
            placedTriggers = placedTriggers.filter(t => t.mapName !== mapName && t.targetMap !== mapName);
            updateDoorNumberDropdown();

            console.log('Deleted map:', mapName);
            return true;
        }

        // Update map dropdown selectors
        function updateMapDropdowns() {
            const mapNames = getMapNames();

            // Update current map selector (triggers tab)
            const currentSelect = document.getElementById('currentMapSelect');
            if (currentSelect) {
                currentSelect.innerHTML = mapNames.map(name =>
                    `<option value="${name}" ${name === currentMapName ? 'selected' : ''}>${name}</option>`
                ).join('');
            }

            // Update camera map selector
            const cameraSelect = document.getElementById('cameraMapSelect');
            if (cameraSelect) {
                cameraSelect.innerHTML = mapNames.map(name =>
                    `<option value="${name}" ${name === currentMapName ? 'selected' : ''}>${name}</option>`
                ).join('');
            }

            // Update target map selector
            const targetSelect = document.getElementById('triggerTargetMap');
            if (targetSelect) {
                targetSelect.innerHTML = '<option value="">-- Select Map --</option>' +
                    mapNames.map(name => `<option value="${name}">${name}</option>`).join('');
            }
        }

        // Update trigger list UI
        function updateTriggerList() {
            const container = document.getElementById('triggerList');
            if (!container) return;

            const currentTriggers = placedTriggers.filter(t => t.mapName === currentMapName);

            if (currentTriggers.length === 0) {
                container.innerHTML = '<div style="color:#666; text-align:center; padding:10px;">No triggers placed</div>';
                return;
            }

            container.innerHTML = currentTriggers.map((t, i) => {
                const globalIdx = placedTriggers.indexOf(t);
                const doorNum = t.doorNumber || 1;
                const doorType = t.doorType || 'walkover';
                const isExternal = doorType === 'external';
                const spawnSet = isExternal ? (t.returnX != null && t.returnY != null) : (t.targetX != null && t.targetY != null);
                const spawnText = isExternal
                    ? (spawnSet ? `return:(${t.returnX}, ${t.returnY})` : '<span style="color:#f80;">SET RETURN!</span>')
                    : (spawnSet ? `(${t.targetX}, ${t.targetY})` : '<span style="color:#f80;">SET SPAWN!</span>');
                const typeIcon = isExternal ? '🌐' : (doorType === 'interact' ? '🔘' : '🚶');
                const destination = isExternal ? t.externalUrl : t.targetMap;
                const borderColor = spawnSet ? (isExternal ? '#0cc' : '#f4f') : '#f80';
                return `<div style="background:#333; padding:8px; margin-bottom:4px; border-radius:3px; border-left:3px solid ${borderColor};">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <span>${typeIcon} <b>Door ${doorNum}</b> → ${destination}</span>
                        <button onclick="deleteTrigger(${globalIdx})" style="background:#a33; padding:2px 6px; font-size:10px;">x</button>
                    </div>
                    <div style="font-size:10px; color:#888; margin-top:4px;">
                        ${t.width}x${t.height} | ${spawnText}${t.animTiles && t.animTiles.length ? ' | anim:' + t.animTiles.length : ''}
                    </div>
                </div>`;
            }).join('');
        }

        // Prompt for new map name
        function promptNewMap() {
            const name = prompt('Enter new map name:');
            if (!name || !name.trim()) return;

            const cleanName = name.trim().toLowerCase().replace(/[^a-z0-9_-]/g, '_');
            if (maps[cleanName]) {
                alert('Map "' + cleanName + '" already exists');
                return;
            }

            // Save current map first
            saveCurrentMapState();

            // Create new map and switch to it
            createMapData(cleanName);
            broadcastEdit({ editType: 'addMap', mapName: cleanName });
            currentMapName = cleanName;
            loadMapState(maps[cleanName]);

            updateMapDropdowns();
            updateTriggerList();
            renderLayerList();
            renderMap();

            alert('Created and switched to map: ' + cleanName);
        }

        // Prompt to delete current map
        function promptDeleteMap() {
            if (getMapNames().length <= 1) {
                alert('Cannot delete the last map');
                return;
            }

            if (!confirm('Delete map "' + currentMapName + '"? This cannot be undone.')) {
                return;
            }

            const deletedName = currentMapName;
            deleteMap(deletedName);
            broadcastEdit({ editType: 'deleteMap', mapName: deletedName });
            updateMapDropdowns();
            updateTriggerList();
            renderMap();

            alert('Deleted map: ' + deletedName);
        }

        // Rename current map
        function promptRenameMap() {
            const oldName = currentMapName;
            const newName = prompt('Enter new name for map "' + oldName + '":', oldName);

            if (!newName || !newName.trim()) return;

            const cleanName = newName.trim().toLowerCase().replace(/[^a-z0-9_-]/g, '_');

            if (cleanName === oldName) return; // No change

            if (maps[cleanName]) {
                alert('Map "' + cleanName + '" already exists');
                return;
            }

            // Rename in maps object
            maps[cleanName] = maps[oldName];
            delete maps[oldName];

            // Update placedTriggers
            placedTriggers.forEach(t => {
                if (t.mapName === oldName) t.mapName = cleanName;
                if (t.targetMap === oldName) t.targetMap = cleanName;
            });

            // Update placedNpcs
            placedNpcs.forEach(npc => {
                if (npc.mapName === oldName) npc.mapName = cleanName;
            });

            // Update tileSounds keys
            const oldSoundKeys = Object.keys(tileSounds).filter(k => k.startsWith(oldName + ':'));
            oldSoundKeys.forEach(oldKey => {
                const newKey = cleanName + ':' + oldKey.substring(oldName.length + 1);
                tileSounds[newKey] = tileSounds[oldKey];
                delete tileSounds[oldKey];
            });

            // Update pointLights keys
            const oldLightKeys = Object.keys(pointLights).filter(k => k.startsWith(oldName + ':'));
            oldLightKeys.forEach(oldKey => {
                const newKey = cleanName + ':' + oldKey.substring(oldName.length + 1);
                pointLights[newKey] = pointLights[oldKey];
                delete pointLights[oldKey];
            });

            // Update currentMapName
            currentMapName = cleanName;

            // Update spawnMapName if it matches
            if (spawnMapName === oldName) {
                spawnMapName = cleanName;
            }

            // Sync to other builders
            broadcastEdit({ editType: 'renameMap', oldName: oldName, newName: cleanName });

            // Update UI
            updateMapDropdowns();
            updateTriggerList();
            renderMap();

            console.log('[RENAME] Map renamed: "' + oldName + '" → "' + cleanName + '"');
        }

        // Update door number dropdown to only show available numbers
        function updateDoorNumberDropdown() {
            const select = document.getElementById('triggerDoorNumber');
            if (!select) return;

            const usedNumbers = placedTriggers.map(t => t.doorNumber);

            select.innerHTML = '';
            for (let i = 1; i <= 10; i++) {
                if (!usedNumbers.includes(i)) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = 'Door ' + i;
                    select.appendChild(option);
                }
            }

            // If all doors used, show message
            if (select.options.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'All doors used!';
                select.appendChild(option);
            }
        }

        // Door modal state
        let pendingDoorX = 0;
        let pendingDoorY = 0;
        let pendingDoorNumber = 1;
        let selectedWalkDirection = 'down'; // Default walk direction
        let useWalkOutPoint = false; // Whether to set walk-out destination by clicking
        let settingWalkOutPoint = false; // Currently in walk-out setting mode
        let pendingWalkOutTrigger = null; // Trigger waiting for walk-out point

        // Door animation state
        let selectingAnimTiles = false; // Selecting which tiles to swap
        let paintingAnimTiles = false; // Painting replacement tiles
        let pendingAnimTrigger = null; // Trigger being set up for animation
        let selectedAnimTiles = []; // Array of {x, y, layer, tileData} for selected tiles
        let doorAnimMapName = null; // Which map the door animation is being set up on

        // Update door animation panel visibility and hide extra UI
        function updateDoorAnimPanel() {
            const panel = document.getElementById('doorAnimPanel');
            const selectMode = document.getElementById('doorAnimSelectMode');
            const paintMode = document.getElementById('doorAnimPaintMode');

            // Elements to hide during door animation mode
            const hideElements = [
                'tileNormalUI',      // Selected tile + transform
                'tileExtraButtons',  // Select Tiles button
                'tileCopyCollision', // Copy from Map + Edit Collisions
                'tileLayerAdd',      // + Add Layer button
                'tilePlayerSprite'   // Player sprite section
            ];

            const inDoorAnimMode = selectingAnimTiles || paintingAnimTiles;

            // Show/hide extra UI elements
            hideElements.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = inDoorAnimMode ? 'none' : 'block';
            });

            // Hide mode tabs and main toolbar during door animation
            const modeTabs = document.getElementById('modeTabs');
            if (modeTabs) modeTabs.style.display = inDoorAnimMode ? 'none' : 'flex';

            const mainToolbar = document.getElementById('mainToolbar');
            if (mainToolbar) mainToolbar.style.display = inDoorAnimMode ? 'none' : 'flex';

            if (selectingAnimTiles) {
                panel.style.display = 'block';
                selectMode.style.display = 'block';
                paintMode.style.display = 'none';
            } else if (paintingAnimTiles) {
                panel.style.display = 'block';
                selectMode.style.display = 'none';
                paintMode.style.display = 'block';
            } else {
                panel.style.display = 'none';
                selectMode.style.display = 'none';
                paintMode.style.display = 'none';
            }
        }

        // Update modal options visibility based on door type
        function updateDoorModalOptions() {
            const doorType = document.getElementById('doorModalType').value;
            const walkoverOptions = document.getElementById('walkoverOptions');
            const interactOptions = document.getElementById('interactOptions');
            const externalOptions = document.getElementById('externalOptions');
            const mapSelectDiv = document.getElementById('doorMapSelectDiv');
            const confirmBtn = document.getElementById('doorModalConfirmBtn');

            walkoverOptions.style.display = doorType === 'walkover' ? 'block' : 'none';
            interactOptions.style.display = doorType === 'interact' ? 'block' : 'none';
            externalOptions.style.display = doorType === 'external' ? 'block' : 'none';

            // Hide map selector for external doors (they don't need a target map)
            if (mapSelectDiv) mapSelectDiv.style.display = doorType === 'external' ? 'none' : 'block';

            // Change confirm button text and color
            if (confirmBtn) {
                if (doorType === 'external') {
                    confirmBtn.textContent = 'Create Door';
                    confirmBtn.style.background = '#0cc';
                } else {
                    confirmBtn.textContent = 'Set Spawn →';
                    confirmBtn.style.background = '#4af';
                }
            }
        }

        // Toggle between walk-out point mode and direction mode
        function toggleWalkOutMode() {
            useWalkOutPoint = document.getElementById('useWalkOutPoint').checked;
            const dirOptions = document.getElementById('walkDirectionOptions');
            dirOptions.style.display = useWalkOutPoint ? 'none' : 'block';
        }

        // Set walk direction for walkover doors
        function setWalkDirection(dir) {
            selectedWalkDirection = dir;
            // Uncheck walk-out point if direction is selected
            document.getElementById('useWalkOutPoint').checked = false;
            useWalkOutPoint = false;
            document.getElementById('walkDirectionOptions').style.display = 'block';

            // Update button styles
            ['up', 'down', 'left', 'right'].forEach(d => {
                const btn = document.getElementById('walkDir' + d.charAt(0).toUpperCase() + d.slice(1));
                if (btn) {
                    btn.style.background = d === dir ? '#4af' : '#444';
                    btn.style.color = d === dir ? '#000' : '#fff';
                }
            });
        }

        // Show door map selection modal
        function showDoorMapModal(x, y, doorNumber) {
            pendingDoorX = x;
            pendingDoorY = y;
            pendingDoorNumber = doorNumber;

            // Update modal title
            document.getElementById('doorModalNumber').textContent = doorNumber;

            // Populate dropdown with other maps
            const select = document.getElementById('doorMapSelect');
            const otherMaps = Object.keys(maps).filter(m => m !== currentMapName);

            select.innerHTML = '';
            if (otherMaps.length === 0) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = '(No other maps - create one below)';
                select.appendChild(opt);
            } else {
                otherMaps.forEach(mapName => {
                    const opt = document.createElement('option');
                    opt.value = mapName;
                    opt.textContent = mapName;
                    select.appendChild(opt);
                });
            }

            // Clear new map input
            document.getElementById('doorNewMapName').value = '';

            // Reset door options to defaults
            document.getElementById('doorModalType').value = 'walkover';
            document.getElementById('doorWalkDuration').value = '0.5';
            document.getElementById('doorFadeDuration').value = '0.5';
            document.getElementById('useWalkOutPoint').checked = false;
            useWalkOutPoint = false;
            document.getElementById('walkDirectionOptions').style.display = 'block';
            selectedWalkDirection = 'down';
            setWalkDirection('down');
            updateDoorModalOptions();

            // Show modal
            document.getElementById('doorMapModal').style.display = 'flex';
        }

        function closeDoorMapModal() {
            document.getElementById('doorMapModal').style.display = 'none';
            // Reset pending trigger state
            pendingTriggerWidth = 1;
            pendingTriggerHeight = 1;
            useWalkOutPoint = false;
            settingWalkOutPoint = false;
            pendingWalkOutTrigger = null;
        }

        function confirmDoorMapModal() {
            // Get selected or new map
            let targetMap = document.getElementById('doorNewMapName').value.trim();
            const doorType = document.getElementById('doorModalType').value;
            const isExternal = doorType === 'external';

            // Handle external doors (link to another HTML file)
            if (isExternal) {
                const externalUrl = document.getElementById('externalDestination').value;
                const trigger = {
                    x: pendingDoorX,
                    y: pendingDoorY,
                    width: pendingTriggerWidth,
                    height: pendingTriggerHeight,
                    mapName: currentMapName,
                    doorNumber: pendingDoorNumber,
                    type: 'door',
                    doorType: 'external',
                    externalUrl: externalUrl,
                    fadeDuration: parseFloat(document.getElementById('doorFadeDuration').value),
                    returnX: null,  // Return spawn point (set by clicking on map)
                    returnY: null
                };
                pendingTriggerWidth = 1;
                pendingTriggerHeight = 1;

                console.log('=== EXTERNAL DOOR PLACED ===');
                console.log('[DOOR] Door ' + pendingDoorNumber + ' at (' + pendingDoorX + ', ' + pendingDoorY + ') -> "' + externalUrl + '"');

                placedTriggers.push(trigger);
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'placeTrigger', trigger: trigger });
                updateTriggerList();
                updateDoorNumberDropdown();
                closeDoorMapModal();

                // Now set return spawn point (stay on same map)
                pendingTriggerForSpawn = trigger;
                pendingTriggerForSpawn.isExternalReturn = true; // Flag for special handling
                spawnSourceMap = currentMapName;
                settingSpawnPoint = true;
                setMode('trigger');
                renderMap();
                return;
            }

            if (!targetMap) {
                targetMap = document.getElementById('doorMapSelect').value;
            }

            if (!targetMap) {
                alert('Please select a map or enter a new map name');
                return;
            }

            const cleanMapName = targetMap.toLowerCase().replace(/[^a-z0-9_-]/g, '_');

            // Create target map if it doesn't exist
            if (!maps[cleanMapName]) {
                createMapData(cleanMapName);
                broadcastEdit({ editType: 'addMap', mapName: cleanMapName });
                updateMapDropdowns();
            }

            const isWalkOver = doorType === 'walkover';
            const isInteract = doorType === 'interact';
            const useDoorAnim = isInteract && document.getElementById('useDoorAnimation').checked;
            const trigger = {
                x: pendingDoorX,
                y: pendingDoorY,
                width: pendingTriggerWidth,
                height: pendingTriggerHeight,
                mapName: currentMapName,
                targetMap: cleanMapName,
                targetX: null,
                targetY: null,
                doorNumber: pendingDoorNumber,
                type: 'door',
                doorType: doorType, // 'walkover' or 'interact'
                // Walkover properties
                walkOutX: null, // Will be set if useWalkOutPoint is true
                walkOutY: null,
                walkDirection: isWalkOver && !useWalkOutPoint ? selectedWalkDirection : null,
                walkDuration: isWalkOver && !useWalkOutPoint ? parseFloat(document.getElementById('doorWalkDuration').value) : 0,
                fadeDuration: parseFloat(document.getElementById('doorFadeDuration').value),
                // Door animation properties (for interact doors)
                animTiles: useDoorAnim ? [] : null // Array of {x, y, layer} tiles to hide on open
            };
            // Reset for next trigger
            pendingTriggerWidth = 1;
            pendingTriggerHeight = 1;

            console.log('=== DOOR PLACED ===');
            console.log('[DOOR] Door ' + pendingDoorNumber + ' at (' + pendingDoorX + ', ' + pendingDoorY + ') -> "' + cleanMapName + '"');

            placedTriggers.push(trigger);
            // Broadcast to co-op builders
            broadcastEdit({ editType: 'placeTrigger', trigger: trigger });
            updateTriggerList();
            updateDoorNumberDropdown();

            // Close modal
            closeDoorMapModal();

            // If walk-out point mode, stay on this map to set walk-out first
            if (isWalkOver && useWalkOutPoint) {
                settingWalkOutPoint = true;
                pendingWalkOutTrigger = trigger;
                pendingTriggerForSpawn = trigger;
                spawnSourceMap = currentMapName;
                renderMap();
                return;
            }

            // If door animation mode, mark trigger for anim setup after spawn is set
            if (useDoorAnim) {
                trigger.needsAnimSetup = true;
                console.log('[DOOR ANIM] Marked trigger for anim setup, needsAnimSetup =', trigger.needsAnimSetup);
            }

            // Go to target map to set spawn
            pendingTriggerForSpawn = trigger;
            spawnSourceMap = currentMapName;
            settingSpawnPoint = true;
            setMode('trigger'); // Ensure trigger mode for spawn click
            switchToMap(cleanMapName);
            renderMap();
        }

        // Place a trigger at the given tile position
        function placeTriggerAt(x, y) {
            // Auto-select next available door number
            const usedNumbers = placedTriggers.map(t => t.doorNumber);
            let doorNumber = null;
            for (let i = 1; i <= 10; i++) {
                if (!usedNumbers.includes(i)) {
                    doorNumber = i;
                    break;
                }
            }

            if (doorNumber === null) {
                alert('All door numbers (1-10) are in use! Delete an existing door first.');
                return;
            }

            // Show modal to select target map
            showDoorMapModal(x, y, doorNumber);
        }

        // Delete a trigger by index
        function deleteTrigger(index) {
            if (index >= 0 && index < placedTriggers.length) {
                placedTriggers.splice(index, 1);
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeTrigger', index: index });
                updateTriggerList();
                updateDoorNumberDropdown();
                renderMap();
            }
        }

        // Remove trigger at position (for right-click)
        function removeTriggerAt(x, y) {
            const idx = placedTriggers.findIndex(t =>
                t.mapName === currentMapName &&
                x >= t.x && x < t.x + t.width &&
                y >= t.y && y < t.y + t.height
            );
            if (idx >= 0) {
                deleteTrigger(idx);
            }
        }

        // Set spawn point at clicked location
        function setSpawnPointAt(x, y) {
            // Update the pending trigger directly
            if (pendingTriggerForSpawn) {
                // Check if this is an external door return spawn
                if (pendingTriggerForSpawn.isExternalReturn) {
                    pendingTriggerForSpawn.returnX = x;
                    pendingTriggerForSpawn.returnY = y;
                    delete pendingTriggerForSpawn.isExternalReturn; // Clean up temp flag
                    console.log('=== EXTERNAL RETURN SPAWN PLACED ===');
                    console.log('[SPAWN] Door', pendingTriggerForSpawn.doorNumber, 'RETURN spawn set at (' + x + ', ' + y + ') on "' + currentMapName + '"');
                } else {
                    pendingTriggerForSpawn.targetX = x;
                    pendingTriggerForSpawn.targetY = y;
                    console.log('=== SPAWN PLACED ===');
                    console.log('[SPAWN] Door', pendingTriggerForSpawn.doorNumber, 'spawn set at (' + x + ', ' + y + ') on "' + currentMapName + '"');
                }
                // Sync the trigger update
                const triggerIndex = placedTriggers.indexOf(pendingTriggerForSpawn);
                if (triggerIndex >= 0) {
                    broadcastEdit({ editType: 'updateTrigger', index: triggerIndex, trigger: pendingTriggerForSpawn });
                }
            }

            // Check if this trigger needs animation setup
            const needsAnim = pendingTriggerForSpawn && pendingTriggerForSpawn.needsAnimSetup;
            const triggerForAnim = pendingTriggerForSpawn;
            const isExternalDoor = pendingTriggerForSpawn && pendingTriggerForSpawn.doorType === 'external';
            console.log('[DOOR ANIM] In setSpawnPointAt, needsAnim =', needsAnim, 'trigger.needsAnimSetup =', pendingTriggerForSpawn?.needsAnimSetup);

            // Exit spawn setting mode
            settingSpawnPoint = false;
            const returnMap = spawnSourceMap;
            spawnSourceMap = null;
            pendingTriggerForSpawn = null;

            // Auto-return to source map (but not for external doors - we're already on the right map)
            if (returnMap && !isExternalDoor) {
                switchToMap(returnMap);
            }

            // If needs animation setup, start tile selection mode
            if (needsAnim && triggerForAnim) {
                triggerForAnim.needsAnimSetup = false;
                triggerForAnim.animTiles = [];
                pendingAnimTrigger = triggerForAnim;
                selectingAnimTiles = true;
                selectedAnimTiles = [];
                doorAnimMapName = currentMapName; // Track which map we're editing
                console.log('[DOOR ANIM] Starting tile selection for door', triggerForAnim.doorNumber);
                setMode('tile'); // Switch to tile mode for layer controls + palette
                updateDoorAnimPanel();
            } else {
                console.log('[DOOR ANIM] NOT starting tile selection. needsAnim =', needsAnim, 'triggerForAnim =', triggerForAnim);
            }

            renderMap();
        }

        // Set walk-out point at clicked location (where player walks TO before fade)
        function setWalkOutPointAt(x, y) {
            if (pendingWalkOutTrigger) {
                pendingWalkOutTrigger.walkOutX = x;
                pendingWalkOutTrigger.walkOutY = y;
                console.log('=== WALK-OUT POINT SET ===');
                console.log('[WALK-OUT] Door', pendingWalkOutTrigger.doorNumber, 'walk-out at (' + x + ', ' + y + ')');
            }

            // Exit walk-out setting mode
            settingWalkOutPoint = false;
            pendingWalkOutTrigger = null;

            // Now switch to target map to set spawn
            if (pendingTriggerForSpawn) {
                settingSpawnPoint = true;
                switchToMap(pendingTriggerForSpawn.targetMap);
            }
            renderMap();
        }

        // Toggle a tile in the animation selection
        function toggleAnimTileSelection(x, y) {
            // Check if already selected on current layer
            const idx = selectedAnimTiles.findIndex(t => t.x === x && t.y === y && t.layer === currentLayer);
            if (idx >= 0) {
                // Remove it
                selectedAnimTiles.splice(idx, 1);
                console.log('[DOOR ANIM] Deselected tile at', x, y, 'layer', currentLayer);
            } else {
                // Add it - capture current tile data from current layer
                const tileData = (layers[currentLayer] && layers[currentLayer][y] && layers[currentLayer][y][x])
                    ? JSON.parse(JSON.stringify(layers[currentLayer][y][x])) : null;
                selectedAnimTiles.push({
                    x, y,
                    layer: currentLayer,
                    before: tileData
                });
                console.log('[DOOR ANIM] Selected tile at', x, y, 'layer', currentLayer);
            }
            renderMap();
        }

        // Finish tile selection, move to painting mode
        function finishTileSelection() {
            if (selectedAnimTiles.length === 0) {
                alert('Select at least one tile to animate');
                return;
            }

            // Erase the selected tiles so user can paint replacements
            selectedAnimTiles.forEach(tile => {
                if (layers[tile.layer] && layers[tile.layer][tile.y]) {
                    layers[tile.layer][tile.y][tile.x] = null;
                }
            });

            selectingAnimTiles = false;
            paintingAnimTiles = true;
            setMode('tile'); // Switch to tile mode for painting
            console.log('[DOOR ANIM] Moved to paint mode with', selectedAnimTiles.length, 'tiles');
            updateDoorAnimPanel();
            renderMap();
        }

        // Finish painting, save the animation
        function finishAnimPainting() {
            // Capture the "after" state for each selected tile position
            const animChanges = [];
            selectedAnimTiles.forEach(tile => {
                const afterData = (layers[tile.layer] && layers[tile.layer][tile.y] && layers[tile.layer][tile.y][tile.x])
                    ? JSON.parse(JSON.stringify(layers[tile.layer][tile.y][tile.x])) : null;
                animChanges.push({
                    x: tile.x,
                    y: tile.y,
                    layer: tile.layer,
                    before: tile.before,
                    after: afterData
                });
            });

            // Restore the "before" tiles (door starts closed)
            selectedAnimTiles.forEach(tile => {
                if (!layers[tile.layer]) layers[tile.layer] = [];
                if (!layers[tile.layer][tile.y]) layers[tile.layer][tile.y] = [];
                layers[tile.layer][tile.y][tile.x] = tile.before;
            });

            // Save to trigger
            if (pendingAnimTrigger) {
                pendingAnimTrigger.animTiles = animChanges;
                console.log('=== DOOR ANIM SAVED ===');
                console.log('[DOOR ANIM] Door', pendingAnimTrigger.doorNumber, 'has', animChanges.length, 'tile swaps');
            }

            // Reset state
            paintingAnimTiles = false;
            pendingAnimTrigger = null;
            selectedAnimTiles = [];
            doorAnimMapName = null;
            updateDoorAnimPanel();
            renderMap();
        }

        // ===== CAMERA BOUNDS =====
        let settingCameraBounds = false;
        let cameraBoundsDragStart = null;
        let cameraBoundsDragEnd = null;

        function toggleCameraBoundsMode() {
            settingCameraBounds = !settingCameraBounds;
            const btn = document.getElementById('setCameraBoundsBtn');
            if (settingCameraBounds) {
                btn.textContent = '✓ Done';
                btn.style.background = '#8a4';
            } else {
                btn.textContent = 'Set Bounds';
                btn.style.background = '#484';
                cameraBoundsDragStart = null;
                cameraBoundsDragEnd = null;
            }
            updateCameraBoundsInfo();
            renderMap();
        }

        function clearCameraBounds(fromNetwork = false) {
            cameraBounds = null;
            cameraBoundsDragStart = null;
            cameraBoundsDragEnd = null;
            settingCameraBounds = false;
            document.getElementById('setCameraBoundsBtn').textContent = 'Set Bounds';
            document.getElementById('setCameraBoundsBtn').style.background = '#484';
            if (!fromNetwork) {
                broadcastEdit({ editType: 'cameraBounds', bounds: null, mapName: currentMapName });
            }
            updateCameraBoundsInfo();
            renderMap();
        }

        function setCameraBoundsFromDrag() {
            if (!cameraBoundsDragStart || !cameraBoundsDragEnd) return;

            const x1 = Math.min(cameraBoundsDragStart.x, cameraBoundsDragEnd.x);
            const y1 = Math.min(cameraBoundsDragStart.y, cameraBoundsDragEnd.y);
            const x2 = Math.max(cameraBoundsDragStart.x, cameraBoundsDragEnd.x);
            const y2 = Math.max(cameraBoundsDragStart.y, cameraBoundsDragEnd.y);

            if (cameraBounds) {
                // Expand existing bounds to include new selection
                const oldX2 = cameraBounds.x + cameraBounds.width - 1;
                const oldY2 = cameraBounds.y + cameraBounds.height - 1;
                const newX1 = Math.min(cameraBounds.x, x1);
                const newY1 = Math.min(cameraBounds.y, y1);
                const newX2 = Math.max(oldX2, x2);
                const newY2 = Math.max(oldY2, y2);

                cameraBounds = {
                    x: newX1,
                    y: newY1,
                    width: newX2 - newX1 + 1,
                    height: newY2 - newY1 + 1
                };
            } else {
                // First selection
                cameraBounds = {
                    x: x1,
                    y: y1,
                    width: x2 - x1 + 1,
                    height: y2 - y1 + 1
                };
            }

            console.log('Camera bounds expanded:', cameraBounds);
            broadcastEdit({ editType: 'cameraBounds', bounds: cameraBounds, mapName: currentMapName });

            // Stay in bounds mode for more selections
            cameraBoundsDragStart = null;
            cameraBoundsDragEnd = null;
            updateCameraBoundsInfo();
            renderMap();
        }

        function updateCameraBoundsInfo() {
            const info = document.getElementById('cameraBoundsInfo');
            if (!info) return;

            if (settingCameraBounds) {
                if (cameraBounds) {
                    info.innerHTML = `${cameraBounds.width}x${cameraBounds.height} tiles - drag to expand`;
                } else {
                    info.innerHTML = 'Drag on map to select area';
                }
                info.style.color = '#fa0';
            } else if (cameraBounds) {
                info.innerHTML = `Bounds: ${cameraBounds.width}x${cameraBounds.height} tiles`;
                info.style.color = '#8f8';
            } else {
                info.innerHTML = 'No bounds (camera follows player)';
                info.style.color = '#aaa';
            }
        }

        // ===== DIALOG SYSTEM =====
        const dialogStylePresets = {
            1: { name: 'Classic NES', bg: '#000000', border: '#ffffff', text: '#ffffff', accent: '#ffffff', radius: 0, borderW: 4 },
            2: { name: 'Final Fantasy', bg: '#000088', border: '#ffffff', text: '#ffffff', accent: '#ffff00', radius: 0, borderW: 2 },
            3: { name: 'Pokemon', bg: '#f8f8f8', border: '#303030', text: '#303030', accent: '#e03030', radius: 8, borderW: 3 },
            4: { name: 'Earthbound', bg: '#000000', border: '#a080ff', text: '#ffffff', accent: '#ffff00', radius: 0, borderW: 2 },
            5: { name: 'Chrono Trigger', bg: '#1a1a4e', border: '#8888ff', text: '#ffffff', accent: '#ffcc00', radius: 4, borderW: 2 },
            6: { name: 'Modern Pixel', bg: '#2d2d2d', border: '#4a9eff', text: '#ffffff', accent: '#4a9eff', radius: 6, borderW: 2 }
        };

        let dialogEditorPages = [{ speaker: '', text: '' }];
        let dialogEditorPageIndex = 0;
        let dialogEditingIndex = -1; // -1 = new dialog

        function openDialogEditor(index) {
            dialogEditingIndex = index;

            if (index >= 0 && dialogs[index]) {
                // Editing existing dialog
                const d = dialogs[index];
                document.getElementById('dialogNameInput').value = d.name || '';
                document.getElementById('dialogStyleSelect').value = d.style || 1;
                document.getElementById('dialogBgColor').value = d.colors?.background || '#000000';
                document.getElementById('dialogBorderColor').value = d.colors?.border || '#ffffff';
                document.getElementById('dialogTextColor').value = d.colors?.text || '#ffffff';
                document.getElementById('dialogAccentColor').value = d.colors?.accent || '#ffffff';
                document.getElementById('dialogWidth').value = d.width || 280;
                document.getElementById('dialogHeight').value = d.height || 80;
                dialogEditorPages = d.pages ? JSON.parse(JSON.stringify(d.pages)) : [{ speaker: '', text: '' }];
            } else {
                // New dialog
                document.getElementById('dialogNameInput').value = '';
                document.getElementById('dialogStyleSelect').value = '1';
                applyDialogStylePreset(1);
                document.getElementById('dialogWidth').value = 280;
                document.getElementById('dialogHeight').value = 80;
                dialogEditorPages = [{ speaker: '', text: '' }];
            }

            dialogEditorPageIndex = 0;
            loadDialogPage(0);
            updateDialogPagesListEditor();
            updateDialogPreview();

            document.getElementById('dialogModal').classList.add('visible');
        }

        function closeDialogEditor() {
            document.getElementById('dialogModal').classList.remove('visible');
        }

        function applyDialogStylePreset(style) {
            const preset = dialogStylePresets[style];
            if (preset) {
                document.getElementById('dialogBgColor').value = preset.bg;
                document.getElementById('dialogBorderColor').value = preset.border;
                document.getElementById('dialogTextColor').value = preset.text;
                document.getElementById('dialogAccentColor').value = preset.accent;
            }
        }

        function loadDialogPage(index) {
            // Save current page first
            if (dialogEditorPages[dialogEditorPageIndex]) {
                dialogEditorPages[dialogEditorPageIndex] = {
                    speaker: document.getElementById('dialogSpeaker').value,
                    text: document.getElementById('dialogTextInput').value
                };
            }

            dialogEditorPageIndex = index;
            const page = dialogEditorPages[index] || { speaker: '', text: '' };
            document.getElementById('dialogSpeaker').value = page.speaker || '';
            document.getElementById('dialogTextInput').value = page.text || '';
            updateDialogPagesListEditor();
            updateDialogPreview();
        }

        function selectDialogPageEditor(index) {
            loadDialogPage(index);
        }

        function addDialogPage() {
            // Save current page
            dialogEditorPages[dialogEditorPageIndex] = {
                speaker: document.getElementById('dialogSpeaker').value,
                text: document.getElementById('dialogTextInput').value
            };

            dialogEditorPages.push({ speaker: '', text: '' });
            loadDialogPage(dialogEditorPages.length - 1);
        }

        function removeCurrentDialogPage() {
            if (dialogEditorPages.length <= 1) {
                alert('Cannot delete the only page');
                return;
            }

            dialogEditorPages.splice(dialogEditorPageIndex, 1);
            if (dialogEditorPageIndex >= dialogEditorPages.length) {
                dialogEditorPageIndex = dialogEditorPages.length - 1;
            }
            loadDialogPage(dialogEditorPageIndex);
        }

        function updateDialogPagesListEditor() {
            const container = document.getElementById('dialogPagesList');
            container.innerHTML = dialogEditorPages.map((page, i) => {
                const active = i === dialogEditorPageIndex ? 'active' : '';
                const preview = (page.text || 'Empty').substring(0, 15);
                return `<div class="dialog-page ${active}" onclick="selectDialogPageEditor(${i})">${i + 1}</div>`;
            }).join('');
        }

        function updateDialogPreview() {
            const canvas = document.getElementById('dialogPreviewCanvas');
            if (!canvas) return;

            const width = parseInt(document.getElementById('dialogWidth').value) || 280;
            const height = parseInt(document.getElementById('dialogHeight').value) || 80;
            canvas.width = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            const bgColor = document.getElementById('dialogBgColor').value;
            const borderColor = document.getElementById('dialogBorderColor').value;
            const textColor = document.getElementById('dialogTextColor').value;
            const accentColor = document.getElementById('dialogAccentColor').value;
            const style = parseInt(document.getElementById('dialogStyleSelect').value);
            const preset = dialogStylePresets[style];

            // Draw background
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, width, height);

            // Draw border
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = preset?.borderW || 2;
            const radius = preset?.radius || 0;

            if (radius > 0) {
                ctx.beginPath();
                ctx.roundRect(2, 2, width - 4, height - 4, radius);
                ctx.stroke();
            } else {
                ctx.strokeRect(2, 2, width - 4, height - 4);
            }

            // Draw speaker name
            const speaker = document.getElementById('dialogSpeaker').value;
            const text = document.getElementById('dialogTextInput').value;

            ctx.font = '12px monospace';
            let y = 18;

            if (speaker) {
                ctx.fillStyle = accentColor;
                ctx.fillText(speaker, 12, y);
                y += 16;
            }

            // Draw text (simple word wrap)
            ctx.fillStyle = textColor;
            const words = text.split(' ');
            let line = '';
            const maxWidth = width - 24;

            for (const word of words) {
                const testLine = line + word + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && line) {
                    ctx.fillText(line, 12, y);
                    line = word + ' ';
                    y += 14;
                    if (y > height - 10) break;
                } else {
                    line = testLine;
                }
            }
            if (y <= height - 10) {
                ctx.fillText(line, 12, y);
            }
        }

        function saveDialog() {
            // Save current page
            dialogEditorPages[dialogEditorPageIndex] = {
                speaker: document.getElementById('dialogSpeaker').value,
                text: document.getElementById('dialogTextInput').value
            };

            const name = document.getElementById('dialogNameInput').value.trim() || 'Dialog ' + (dialogs.length + 1);
            const style = parseInt(document.getElementById('dialogStyleSelect').value);

            const dialogData = {
                name: name,
                style: style,
                width: parseInt(document.getElementById('dialogWidth').value) || 280,
                height: parseInt(document.getElementById('dialogHeight').value) || 80,
                colors: {
                    background: document.getElementById('dialogBgColor').value,
                    border: document.getElementById('dialogBorderColor').value,
                    text: document.getElementById('dialogTextColor').value,
                    accent: document.getElementById('dialogAccentColor').value
                },
                pages: JSON.parse(JSON.stringify(dialogEditorPages))
            };

            if (dialogEditingIndex >= 0) {
                dialogs[dialogEditingIndex] = dialogData;
                broadcastEdit({ editType: 'updateDialog', index: dialogEditingIndex, dialog: dialogData });
            } else {
                dialogs.push(dialogData);
                broadcastEdit({ editType: 'addDialog', dialog: dialogData });
            }

            closeDialogEditor();
            updateDialogList();
            console.log('[DIALOG] Saved dialog:', name);
        }

        function deleteDialog(index) {
            if (!confirm('Delete dialog "' + dialogs[index].name + '"?')) return;

            // Check if any NPC uses this dialog
            const usedBy = placedNpcs.filter(n => n.dialogIndex === index);
            if (usedBy.length > 0) {
                alert('Cannot delete: This dialog is attached to ' + usedBy.length + ' NPC(s)');
                return;
            }

            dialogs.splice(index, 1);

            // Update NPC dialog references
            placedNpcs.forEach(n => {
                if (n.dialogIndex > index) n.dialogIndex--;
            });

            broadcastEdit({ editType: 'deleteDialog', index: index });
            updateDialogList();
        }

        function updateDialogList() {
            const container = document.getElementById('dialogList');
            if (!container) return;

            if (dialogs.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:12px; text-align:center; padding:20px;">No dialogs created yet</div>';
                return;
            }

            container.innerHTML = dialogs.map((d, i) => {
                const pageCount = d.pages?.length || 1;
                const isSelected = currentDialogTileIndex === i;
                const bgColor = isSelected ? '#4a7c59' : '#333';
                const borderStyle = isSelected ? '2px solid #8f8' : '2px solid transparent';
                return `<div onclick="selectDialogForPlacement(${i})" style="display:flex; align-items:center; gap:8px; padding:8px; margin-bottom:5px; background:${bgColor}; border-radius:4px; cursor:pointer; border:${borderStyle};">
                    <div style="flex:1; min-width:0;">
                        <div style="font-size:12px; color:#fff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${d.name}</div>
                        <div style="font-size:10px; color:#888;">${pageCount} page${pageCount > 1 ? 's' : ''}${isSelected ? ' - SELECTED' : ''}</div>
                    </div>
                    <button onclick="event.stopPropagation(); openDialogEditor(${i})" style="padding:4px 8px; font-size:11px; background:#448;">Edit</button>
                    <button onclick="event.stopPropagation(); deleteDialog(${i})" style="padding:4px 8px; font-size:11px; background:#644;">X</button>
                </div>`;
            }).join('');

            // Also update the dialog dropdown for attaching
            updateDialogDropdown();
            updateDialogTileDropdown();
            updatePlacedDialogTilesList();
        }

        function updateDialogDropdown() {
            const select = document.getElementById('dialogToAttach');
            if (!select) return;

            select.innerHTML = '<option value="">Select a dialog...</option>' +
                dialogs.map((d, i) => `<option value="${i}">${d.name}</option>`).join('');
        }

        function updateDialogNpcDropdown() {
            const select = document.getElementById('dialogNpcSelect');
            if (!select) return;

            select.innerHTML = '<option value="">Select an NPC...</option>' +
                placedNpcs.map((n, i) => {
                    const npcDef = npcs[n.npcIndex];
                    const name = npcDef?.name || 'NPC ' + i;
                    const hasDialog = n.dialogIndex >= 0 ? ' (has dialog)' : '';
                    return `<option value="${i}">${name}${hasDialog}</option>`;
                }).join('');
        }

        function attachDialogToNpc() {
            const npcIdx = parseInt(document.getElementById('dialogNpcSelect').value);
            const dialogIdx = parseInt(document.getElementById('dialogToAttach').value);
            const triggerType = document.getElementById('dialogNpcTrigger').value;

            if (isNaN(npcIdx) || npcIdx < 0) {
                alert('Please select an NPC');
                return;
            }
            if (isNaN(dialogIdx) || dialogIdx < 0) {
                alert('Please select a dialog');
                return;
            }

            placedNpcs[npcIdx].dialogIndex = dialogIdx;
            placedNpcs[npcIdx].dialogTrigger = triggerType; // 'interact' or 'auto'
            broadcastEdit({ editType: 'attachNpcDialog', npcIndex: npcIdx, dialogIndex: dialogIdx, dialogTrigger: triggerType });

            alert('Dialog attached to NPC!');
            updateDialogNpcDropdown();
        }

        // ===== DIALOG TILE PLACEMENT (Signs) =====
        function selectDialogForPlacement(index) {
            // Toggle selection
            if (currentDialogTileIndex === index) {
                currentDialogTileIndex = -1; // Deselect
            } else {
                currentDialogTileIndex = index;
            }
            updateDialogList();
            // Also update dropdown if it exists
            const select = document.getElementById('dialogTileSelect');
            if (select) select.value = currentDialogTileIndex;
        }

        function selectDialogForTile(value) {
            currentDialogTileIndex = parseInt(value);
            updateDialogList();
        }

        function updateDialogTileDropdown() {
            const select = document.getElementById('dialogTileSelect');
            if (!select) return;
            select.innerHTML = '<option value="-1">Select a dialog...</option>' +
                dialogs.map((d, i) => `<option value="${i}">${d.name}</option>`).join('');
            select.value = currentDialogTileIndex;
        }

        function updatePlacedDialogTilesList() {
            const list = document.getElementById('placedDialogTilesList');
            if (!list) return;

            const tilesOnMap = placedDialogTiles.filter(t => t.mapName === currentMapName);
            if (tilesOnMap.length === 0) {
                list.innerHTML = '<div style="color:#666; font-size:11px; text-align:center; padding:10px;">No dialog tiles placed</div>';
                return;
            }

            list.innerHTML = tilesOnMap.map((t, i) => {
                const globalIdx = placedDialogTiles.indexOf(t);
                const dialogName = dialogs[t.dialogIndex]?.name || 'Unknown';
                return `<div style="display:flex; justify-content:space-between; align-items:center; padding:4px; margin:2px 0; background:#333; border-radius:3px; font-size:11px;">
                    <span>(${t.x}, ${t.y}) - ${dialogName}</span>
                    <button onclick="removeDialogTileByIndex(${globalIdx})" style="padding:2px 6px; font-size:10px; background:#a33;">x</button>
                </div>`;
            }).join('');
        }

        function placeDialogTileAt(x, y) {
            if (currentDialogTileIndex < 0) {
                alert('Select a dialog first');
                return;
            }

            // Check if already has dialog tile at this position
            const existing = findDialogTileAt(x, y);
            if (existing >= 0) {
                // Update existing
                placedDialogTiles[existing].dialogIndex = currentDialogTileIndex;
                broadcastEdit({ editType: 'updateDialogTile', index: existing, tile: placedDialogTiles[existing] });
            } else {
                // Add new
                const tile = { x, y, mapName: currentMapName, dialogIndex: currentDialogTileIndex };
                placedDialogTiles.push(tile);
                broadcastEdit({ editType: 'placeDialogTile', tile });
            }

            updatePlacedDialogTilesList();
            renderMap();
        }

        function removeDialogTileAt(x, y) {
            const idx = findDialogTileAt(x, y);
            if (idx >= 0) {
                placedDialogTiles.splice(idx, 1);
                broadcastEdit({ editType: 'removeDialogTile', index: idx });
                updatePlacedDialogTilesList();
                renderMap();
            }
        }

        function removeDialogTileByIndex(idx) {
            if (idx >= 0 && idx < placedDialogTiles.length) {
                placedDialogTiles.splice(idx, 1);
                broadcastEdit({ editType: 'removeDialogTile', index: idx });
                updatePlacedDialogTilesList();
                renderMap();
            }
        }

        function findDialogTileAt(x, y) {
            return placedDialogTiles.findIndex(t => t.x === x && t.y === y && t.mapName === currentMapName);
        }

        // ===== TEST MAP =====
        let testLogs = []; // Logs saved to localStorage for crash recovery

        function logTestEvent(msg, type = 'info') {
            const entry = { time: Date.now(), msg, type };
            testLogs.push(entry);
            localStorage.setItem('testGameCrashLog', JSON.stringify(testLogs));
            console.log('[TestMap]', msg);

            // Add to visible console
            const logsDiv = document.getElementById('testConsoleLogs');
            if (logsDiv) {
                const time = new Date().toLocaleTimeString();
                const div = document.createElement('div');
                div.className = type;
                div.innerHTML = '<span class="time">' + time + '</span>' + msg;
                logsDiv.appendChild(div);
                logsDiv.scrollTop = logsDiv.scrollHeight; // Auto-scroll
            }
        }

        function openTestConsole() {
            const console = document.getElementById('testConsole');
            const logsDiv = document.getElementById('testConsoleLogs');
            if (console) console.classList.add('visible');
            if (logsDiv) logsDiv.innerHTML = ''; // Clear previous logs
        }

        function testMap() {
            // Open visible console and clear previous logs
            openTestConsole();
            testLogs = [];
            logTestEvent('Starting test game...');

            // Get current project data
            const projectDataForTest = getProjectData();
            // Add base URL so external doors can resolve relative paths
            projectDataForTest.baseUrl = window.location.href.replace(/\/[^\/]*$/, '/');
            if (launchAsAdventure) {
                projectDataForTest.autoHideUI = true;
            }
            // Add multiplayer settings if set
            if (multiplayerSettings) {
                projectDataForTest.multiplayer = {
                    playerName: multiplayerSettings.playerName,
                    roomCode: multiplayerSettings.roomCode
                };
                logTestEvent('Multiplayer: ' + multiplayerSettings.playerName + ' in room ' + multiplayerSettings.roomCode);
            }
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

            logTestEvent('Mobile: ' + isMobile + ', Sounds: ' + (projectDataForTest.sounds?.length || 0));

            // On mobile, strip sound data - will stream via postMessage
            let soundsToStream = [];
            if (isMobile && projectDataForTest.sounds && projectDataForTest.sounds.length > 0) {
                soundsToStream = projectDataForTest.sounds.map(s => ({ ...s }));
                projectDataForTest.sounds = projectDataForTest.sounds.map(s => ({
                    name: s.name, duration: s.duration, type: s.type
                }));
                projectDataForTest.soundsWillStream = true;
                logTestEvent('Stripped ' + soundsToStream.length + ' sounds for streaming');
            }

            const projectDataJSON = JSON.stringify(projectDataForTest);
            const dataSize = projectDataJSON.length;
            const sizeMB = (dataSize / 1000000).toFixed(1);
            logTestEvent('Project size: ' + sizeMB + 'MB');

            // Setup message listener for test game communication
            window.testGameData = { projectDataJSON, soundsToStream };
            window.onmessage = (e) => {
                if (e.data.type === 'log') {
                    logTestEvent('[Game] ' + e.data.msg, e.data.level || 'info');
                } else if (e.data.type === 'ready') {
                    logTestEvent('Test game ready, sending data...');
                    // Include builder room code so test game can auto-join multiplayer
                    const payload = { type: 'project-data', data: projectDataJSON };
                    if (builderConnected && builderRoomCode) {
                        payload.autoMultiplayer = {
                            roomCode: builderRoomCode,
                            playerName: builderPlayerName + '-tester'
                        };
                        // Also pass builder room for live sync of edits
                        payload.builderSync = {
                            roomCode: builderRoomCode
                        };
                    }
                    e.source.postMessage(payload, '*');
                    // Stream sounds with delay
                    if (soundsToStream.length > 0) {
                        streamSoundsToWindow(e.source, soundsToStream);
                    }
                }
            };

            logTestEvent('Opening test window...');

            // Create minimal loader HTML
            const loaderHTML = `
<!DOCTYPE html>
<html>
<head>
    <title>Map Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; }
        body { background: #000; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #debugPanel {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            min-width: 200px;
            display: none;
        }
        #debugPanel.visible { display: block; }
        #debugPanel h3 { margin: 0 0 10px 0; color: #4af; font-size: 14px; }
        #debugPanel label { display: block; margin: 8px 0 4px 0; color: #aaa; }
        #debugPanel input[type="range"] { width: 100%; }
        #debugPanel .value { color: #4f8; float: right; }
        #debugPanel button {
            margin-top: 10px;
            padding: 5px 10px;
            background: #4a7c59;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        #debugPanel button:hover { background: #5a9c69; }

        /* Debug log for iPad (no console) */
        #debugLog {
            position: fixed;
            bottom: 10px;
            left: 10px;
            right: 10px;
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0,0,0,0.9);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            padding: 8px;
            border-radius: 5px;
            display: none;
            z-index: 2000;
        }
        #debugLog.visible { display: block; }
        #debugLog .error { color: #f44; }
        #debugLog .warn { color: #fa0; }
        #toggleLogBtn {
            position: fixed;
            bottom: 170px;
            left: 10px;
            background: rgba(0,100,0,0.8);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 2001;
        }

        /* Touch controls - Virtual Joystick */
        #touchControls {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 1000;
            display: none;
        }
        @media (pointer: coarse), (max-width: 800px) {
            #touchControls { display: block; }
        }
        /* Left half touch zone for dynamic joystick */
        #leftTouchZone {
            position: fixed;
            left: 0;
            top: 0;
            width: 50%;
            height: 100%;
            z-index: 999;
            touch-action: none;
            display: none;
        }
        @media (pointer: coarse), (max-width: 800px) {
            #leftTouchZone { display: block; }
        }
        .joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            position: fixed;
            touch-action: none;
            display: none;
            pointer-events: none;
        }
        .joystick-base.active {
            display: block;
        }
        .joystick-thumb {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.5);
            border: 2px solid rgba(255,255,255,0.7);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .touch-actions {
            position: fixed;
            bottom: 50px;
            right: 30px;
        }
        .action-btn {
            width: 80px;
            height: 80px;
            background: rgba(255,100,100,0.3);
            border: 3px solid rgba(255,100,100,0.5);
            border-radius: 50%;
            font-size: 32px;
            color: white;
            cursor: pointer;
            touch-action: manipulation;
        }
        .action-btn:active { background: rgba(255,100,100,0.6); }

        /* Debug buttons */
        #debugButtons {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 5px;
        }
        #debugButtons button {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #666;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
        #debugButtons button:hover { background: rgba(100,100,100,0.7); }
        #debugButtons button.active { background: rgba(74,175,89,0.7); border-color: #4af; }

        /* Loading overlay - retro pixel style */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            font-family: 'Press Start 2P', monospace;
            color: white;
        }
        #loadingOverlay.hidden { display: none; }
        #loadingText {
            font-size: 12px;
            color: #fff;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }
        #loadingProgress {
            width: 200px;
            height: 16px;
            background: #000;
            border: 2px solid #fff;
            padding: 2px;
        }
        #loadingBar {
            width: 0%;
            height: 100%;
            background: #fff;
            transition: width 0.1s steps(20);
        }
        #loadingPercent {
            margin-top: 15px;
            font-size: 10px;
            color: #888;
        }
        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }
        .blink { animation: blink 1s step-end infinite; }
        /* 3D Interior styles */
        #interior3D canvas {
            display: block;
        }
        #exitButton3D {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: 2px solid #4af;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            z-index: 600;
        }
        #exitButton3D:hover { background: rgba(50,100,150,0.8); }
        .hotspot-label {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <!-- Loading overlay shows immediately -->
    <div id="loadingOverlay">
        <div id="loadingText">LOADING</div>
        <div id="loadingProgress"><div id="loadingBar"></div></div>
        <div id="loadingPercent">0%</div>
        <div class="blink" style="margin-top:20px; font-size:8px;">PLEASE WAIT</div>
    </div>
    <canvas id="game"></canvas>
    <!-- 3D Interior container (hidden by default) -->
    <div id="interior3D" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; z-index:500;"></div>
    <div id="leftTouchZone"></div>
    <div class="joystick-base" id="joystickBase">
        <div class="joystick-thumb" id="joystickThumb"></div>
    </div>
    <div id="touchControls">
        <div class="touch-actions">
            <button class="action-btn" id="interactBtn">A</button>
            <button class="action-btn" id="attackBtn">⚔</button>
        </div>
    </div>
    <div id="debugButtons">
        <button onclick="toggleFullscreen()">⛶</button>
        <button onclick="toggleCollision()">C</button>
        <button onclick="toggleSoundDebug()">S</button>
        <button onclick="toggleDebugPanel()">P</button>
        <button onclick="toggleHitboxPanel()">ATK</button>
        <button onclick="hideAllUI()">H</button>
        <button onclick="closeGame()">✕</button>
    </div>
    <div id="info">Move: Arrows | Attack: SPACE | Interact: A</div>
    <!-- Game Over Overlay -->
    <div id="gameOverOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:9999; justify-content:center; align-items:center; flex-direction:column;">
        <div style="text-align:center; font-family:'Press Start 2P', 'Courier New', monospace;">
            <h1 style="font-size:48px; color:#fff; text-shadow:4px 4px 0 #000; margin-bottom:40px; letter-spacing:8px;">GAME OVER</h1>
            <div style="display:flex; flex-direction:column; gap:20px;">
                <button onclick="tryAgain()" style="padding:15px 40px; font-size:18px; font-family:inherit; background:#444; color:#fff; border:3px solid #fff; cursor:pointer; letter-spacing:2px;">TRY AGAIN</button>
                <button onclick="quitGame()" style="padding:15px 40px; font-size:18px; font-family:inherit; background:#222; color:#888; border:3px solid #666; cursor:pointer; letter-spacing:2px;">QUIT</button>
            </div>
        </div>
    </div>
    <!-- Dialog Box -->
    <div id="dialogBox" style="display:none; position:fixed; bottom:60px; left:50%; transform:translateX(-50%); width:80%; max-width:500px; padding:20px; font-family:'Press Start 2P', monospace; font-size:12px; z-index:1000; image-rendering:pixelated;"></div>
    <div id="debugPanel">
        <h3>Player Settings</h3>
        <label>Scale: <span class="value" id="scaleVal">1.7</span></label>
        <input type="range" id="scaleSlider" min="0.5" max="4" step="0.1" value="1.7">
        <label>Move Speed: <span class="value" id="speedVal">5.5</span></label>
        <input type="range" id="speedSlider" min="1" max="15" step="0.5" value="5.5">
        <label>Anim Speed: <span class="value" id="animVal">7</span></label>
        <input type="range" id="animSlider" min="1" max="20" step="1" value="7">
        <label>Hitbox Width: <span class="value" id="widthVal">28</span></label>
        <input type="range" id="widthSlider" min="10" max="60" step="2" value="28">
        <label>Hitbox Height: <span class="value" id="heightVal">76</span></label>
        <input type="range" id="heightSlider" min="20" max="100" step="2" value="76">
        <h3 style="margin-top:15px;">Camera</h3>
        <label>Zoom: <span class="value" id="zoomVal">0.9</span></label>
        <input type="range" id="zoomSlider" min="0.5" max="3" step="0.1" value="0.9">
        <h3 style="margin-top:15px;">Lighting</h3>
        <label>Darkness: <span class="value" id="darknessVal">0</span>%</label>
        <input type="range" id="darknessSlider" min="0" max="100" step="5" value="0">
        <label style="margin-top:10px;"><input type="checkbox" id="torchEnabled"> Player Torch</label>
        <label>Torch Radius: <span class="value" id="torchRadiusVal">4</span></label>
        <input type="range" id="torchRadiusSlider" min="1" max="15" step="1" value="4">
        <label style="margin-top:10px;"><input type="checkbox" id="cycleEnabled"> Enable Day/Night Cycle</label>
        <label>Cycle Time: <span class="value" id="dayLengthVal">1</span> min</label>
        <input type="range" id="dayLengthSlider" min="1" max="10" step="0.5" value="1">
        <div id="timeDisplay" style="color:#4f8;margin-top:5px;"></div>
        <button onclick="copySettings()">Copy Settings</button>
    </div>
    <div id="hitboxPanel" style="display:none; position:fixed; top:60px; left:10px; background:rgba(20,20,40,0.95); padding:12px; border-radius:8px; font-size:10px; color:#fff; z-index:200; width:280px; border:2px solid #66f;">
        <h3 style="margin:0 0 10px 0; color:#88f;">Attack Hitbox (Per Direction)</h3>
        <div style="display:flex; gap:5px; margin-bottom:10px;">
            <button id="hitboxDirUp" onclick="setHitboxDir('up')" style="flex:1; padding:5px; font-size:10px;">↑ Up</button>
            <button id="hitboxDirDown" onclick="setHitboxDir('down')" class="active" style="flex:1; padding:5px; font-size:10px; background:#66f;">↓ Down</button>
            <button id="hitboxDirLeft" onclick="setHitboxDir('left')" style="flex:1; padding:5px; font-size:10px;">← Left</button>
            <button id="hitboxDirRight" onclick="setHitboxDir('right')" style="flex:1; padding:5px; font-size:10px;">→ Right</button>
        </div>
        <div style="background:rgba(0,0,0,0.3); padding:8px; border-radius:4px;">
            <label>Range: <span class="value" id="hbRangeVal">40</span>px</label>
            <input type="range" id="hbRangeSlider" min="10" max="120" step="5" value="40" style="width:100%;">
            <label>Width: <span class="value" id="hbWidthVal">60</span>°</label>
            <input type="range" id="hbWidthSlider" min="20" max="180" step="5" value="60" style="width:100%;">
            <label>Offset X: <span class="value" id="hbOffsetXVal">0</span>px</label>
            <input type="range" id="hbOffsetXSlider" min="-50" max="50" step="5" value="0" style="width:100%;">
            <label>Offset Y: <span class="value" id="hbOffsetYVal">0</span>px</label>
            <input type="range" id="hbOffsetYSlider" min="-50" max="50" step="5" value="0" style="width:100%;">
        </div>
        <div style="margin-top:8px; display:flex; gap:5px;">
            <button onclick="copyAllHitboxFromDir()" style="flex:1; padding:5px; font-size:9px; background:#484;">Copy to All</button>
            <button onclick="copyHitboxSettings()" style="flex:1; padding:5px; font-size:9px; background:#448;">Copy JSON</button>
        </div>
        <p style="font-size:8px; color:#888; margin:8px 0 0 0;">Blue=preview, Magenta=active hit. Press C to show.</p>
    </div>
    <button id="toggleLogBtn" onclick="toggleDebugLog()">Show Log</button>
    <div id="debugLog"></div>
    <script>
        // Debug log for iPad (captures console output)
        const debugLogEl = document.getElementById('debugLog');
        let debugLogVisible = false;

        function toggleDebugLog() {
            debugLogVisible = !debugLogVisible;
            debugLogEl.classList.toggle('visible', debugLogVisible);
            document.getElementById('toggleLogBtn').textContent = debugLogVisible ? 'Hide Log' : 'Show Log';
        }

        function logToScreen(msg, type = 'log') {
            const line = document.createElement('div');
            line.className = type;
            line.textContent = new Date().toLocaleTimeString() + ' ' + msg;
            debugLogEl.appendChild(line);
            debugLogEl.scrollTop = debugLogEl.scrollHeight;
            // Keep only last 50 lines
            while (debugLogEl.children.length > 50) {
                debugLogEl.removeChild(debugLogEl.firstChild);
            }
        }

        // Capture console methods
        const origLog = console.log;
        const origWarn = console.warn;
        const origError = console.error;
        console.log = (...args) => { origLog(...args); logToScreen(args.join(' '), 'log'); };
        console.warn = (...args) => { origWarn(...args); logToScreen(args.join(' '), 'warn'); };
        console.error = (...args) => { origError(...args); logToScreen(args.join(' '), 'error'); };

        // Capture uncaught errors
        window.onerror = (msg, url, line, col, error) => {
            logToScreen('ERROR: ' + msg + ' at line ' + line, 'error');
        };
        window.onunhandledrejection = (e) => {
            logToScreen('PROMISE ERROR: ' + e.reason, 'error');
        };

        logToScreen('Debug log initialized');
    <\/script>
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Fullscreen canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Show loading message with percentage - updates HTML overlay
        function showLoading(current, total) {
            const percent = total > 0 ? Math.round((current / total) * 100) : 0;

            // Update HTML loading overlay (visible immediately)
            const loadingBar = document.getElementById('loadingBar');
            const loadingPercent = document.getElementById('loadingPercent');
            const loadingText = document.getElementById('loadingText');
            if (loadingBar) loadingBar.style.width = percent + '%';
            if (loadingPercent) loadingPercent.textContent = current + '/' + total + ' (' + percent + '%)';
            if (loadingText && current > 0) loadingText.textContent = 'Loading Assets...';
        }

        // Hide loading overlay when game starts
        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) overlay.classList.add('hidden');
        }

        showLoading(0, 1);

        // Load project data via postMessage from opener window
        let projectData = null;
        let builderSyncSocket = null;
        let liveSyncNeedsRedraw = false;

        // Declare game state variables at outer scope so applyLiveEdit can access them
        let layers = [];
        let mapRows = 30;
        let mapCols = 40;
        let tileCollisions = {};
        let collisionMasks = {};
        let tileSplitLines = {};
        let placedNpcs = [];
        let placedTriggers = [];
        let pointLights = {};
        let tileSounds = {};
        let cameraBounds = null;
        let currentGameMap = 'main';

        // NPC data for live sync
        let npcsData = [];
        let npcImages = [];
        let npcRuntimeState = [];
        let gridSize = 16; // Will be set from projectData

        // Live sync: Connect to builder WebSocket to receive real-time edits
        function connectToBuilderSync(roomCode) {
            const wsUrl = 'wss://multiplayer.lakotafox.partykit.dev/parties/builder/' + roomCode;
            console.log('[LIVE SYNC] Connecting to builder room:', roomCode);

            builderSyncSocket = new WebSocket(wsUrl);

            builderSyncSocket.onopen = () => {
                console.log('[LIVE SYNC] Connected to builder!');
                // Join as observer (don't send edits, just receive)
                builderSyncSocket.send(JSON.stringify({
                    type: 'join',
                    name: 'TestGame-Observer',
                    gameType: 'test-observer'
                }));
            };

            builderSyncSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'builderEdit' || data.editType) {
                        applyLiveEdit(data);
                    }
                } catch (e) {
                    console.error('[LIVE SYNC] Parse error:', e);
                }
            };

            builderSyncSocket.onclose = () => {
                console.log('[LIVE SYNC] Disconnected from builder');
                // Reconnect after delay
                setTimeout(() => connectToBuilderSync(roomCode), 3000);
            };

            builderSyncSocket.onerror = (err) => {
                console.error('[LIVE SYNC] WebSocket error:', err);
            };
        }

        // Apply incoming edits from builder to live game state
        // fromMultiplayer = true means this edit came from another player, don't relay it again
        function applyLiveEdit(edit, fromMultiplayer = false) {
            // Handle batch edits
            if (edit.editType === 'batch' && edit.edits) {
                edit.edits.forEach(e => applyLiveEdit(e, fromMultiplayer));
                return;
            }

            const editType = edit.editType;

            // Skip non-edit messages
            if (!editType) return;

            console.log('[LIVE SYNC] Applying:', editType, fromMultiplayer ? '(from MP)' : '(from builder)');

            // Relay builder edits to other multiplayer players
            if (!fromMultiplayer && mpSocket && mpConnected) {
                mpSocket.send(JSON.stringify({
                    type: 'builderEdit',
                    edit: edit
                }));
            }

            // Get current map name (test game uses currentGameMap)
            const gameMapName = (typeof currentGameMap !== 'undefined') ? currentGameMap : 'main';

            switch (editType) {
                case 'tile':
                    // Update tile in the current map
                    if (edit.mapName === gameMapName || !edit.mapName) {
                        if (!layers[edit.layer]) layers[edit.layer] = [];
                        if (!layers[edit.layer][edit.y]) layers[edit.layer][edit.y] = [];
                        layers[edit.layer][edit.y][edit.x] = edit.cell;
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'eraseTile':
                    if (edit.mapName === gameMapName || !edit.mapName) {
                        if (layers[edit.layer] && layers[edit.layer][edit.y]) {
                            layers[edit.layer][edit.y][edit.x] = null;
                            liveSyncNeedsRedraw = true;
                        }
                    }
                    break;

                case 'collision':
                    if (edit.value) {
                        tileCollisions[edit.key] = true;
                    } else {
                        delete tileCollisions[edit.key];
                    }
                    break;

                case 'collisionMask':
                    collisionMasks[edit.key] = edit.mask;
                    break;

                case 'placeNpc':
                    if (typeof placedNpcs !== 'undefined' && edit.npc) {
                        placedNpcs.push(edit.npc);
                        // Create runtime state for new NPC
                        if (typeof createNpcRuntimeState === 'function') {
                            npcRuntimeState.push(createNpcRuntimeState(edit.npc));
                        }
                        console.log('[LIVE SYNC] Added NPC at', edit.npc.x, edit.npc.y);
                    }
                    break;

                case 'removeNpc':
                    if (typeof placedNpcs !== 'undefined' && edit.index >= 0 && edit.index < placedNpcs.length) {
                        placedNpcs.splice(edit.index, 1);
                        // Remove runtime state
                        if (npcRuntimeState && edit.index < npcRuntimeState.length) {
                            npcRuntimeState.splice(edit.index, 1);
                        }
                        console.log('[LIVE SYNC] Removed NPC at index', edit.index);
                    }
                    break;

                case 'updateNpc':
                    if (typeof placedNpcs !== 'undefined' && edit.index >= 0 && edit.index < placedNpcs.length && edit.npc) {
                        placedNpcs[edit.index] = edit.npc;
                        // Update runtime state position if NPC moved
                        if (npcRuntimeState && npcRuntimeState[edit.index]) {
                            npcRuntimeState[edit.index].x = edit.npc.x * gridSize;
                            npcRuntimeState[edit.index].y = edit.npc.y * gridSize;
                            npcRuntimeState[edit.index].targetX = edit.npc.x * gridSize;
                            npcRuntimeState[edit.index].targetY = edit.npc.y * gridSize;
                        }
                        console.log('[LIVE SYNC] Updated NPC at index', edit.index);
                    }
                    break;

                case 'addNpc':
                    // NPC definition added (not placed NPC)
                    if (typeof npcsData !== 'undefined' && edit.npc) {
                        npcsData.push(edit.npc);
                        // Load sprite image
                        if (edit.npc.spriteData) {
                            const img = new Image();
                            img.src = edit.npc.spriteData;
                            npcImages.push(img);
                        }
                        console.log('[LIVE SYNC] Added NPC definition:', edit.npc.name);
                    }
                    break;

                case 'updatePlacedNpc':
                    // Update placed NPC settings (including enemy AI)
                    if (typeof placedNpcs !== 'undefined' && edit.index >= 0 && edit.index < placedNpcs.length && edit.npc) {
                        // Preserve position but update all other settings
                        const oldPlaced = placedNpcs[edit.index];
                        placedNpcs[edit.index] = edit.npc;
                        // Update runtime state with new enemy settings
                        if (npcRuntimeState && npcRuntimeState[edit.index]) {
                            const state = npcRuntimeState[edit.index];
                            // Initialize enemy AI state if becoming an enemy
                            if (edit.npc.isEnemy && !state.aiState) {
                                state.aiState = 'idle';
                                state.aggroTimer = 0;
                                state.attackCooldown = 0;
                                state.returnX = state.x;
                                state.returnY = state.y;
                            }
                        }
                        console.log('[LIVE SYNC] Updated placed NPC at index', edit.index, 'isEnemy:', edit.npc.isEnemy);
                    }
                    break;

                case 'placeTrigger':
                    if (typeof placedTriggers !== 'undefined' && edit.trigger) {
                        placedTriggers.push(edit.trigger);
                        console.log('[LIVE SYNC] Added trigger:', edit.trigger.type, 'at', edit.trigger.x, edit.trigger.y);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'removeTrigger':
                    if (typeof placedTriggers !== 'undefined' && edit.index >= 0 && edit.index < placedTriggers.length) {
                        placedTriggers.splice(edit.index, 1);
                        console.log('[LIVE SYNC] Removed trigger at index', edit.index);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'updateTrigger':
                    if (typeof placedTriggers !== 'undefined' && edit.index >= 0 && edit.index < placedTriggers.length && edit.trigger) {
                        placedTriggers[edit.index] = edit.trigger;
                        console.log('[LIVE SYNC] Updated trigger at index', edit.index);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'light':
                    if (typeof pointLights !== 'undefined' && edit.light) {
                        pointLights[edit.key] = edit.light;
                        console.log('[LIVE SYNC] Added/updated light:', edit.key);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'removeLight':
                    if (typeof pointLights !== 'undefined') {
                        delete pointLights[edit.key];
                        console.log('[LIVE SYNC] Removed light:', edit.key);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'tileSound':
                    if (typeof tileSounds !== 'undefined' && edit.sound) {
                        tileSounds[edit.key] = edit.sound;
                        console.log('[LIVE SYNC] Added tile sound:', edit.key);
                    }
                    break;

                case 'removeTileSound':
                    if (typeof tileSounds !== 'undefined') {
                        delete tileSounds[edit.key];
                        console.log('[LIVE SYNC] Removed tile sound:', edit.key);
                    }
                    break;

                case 'cameraBounds':
                    if (typeof cameraBounds !== 'undefined' && (edit.mapName === gameMapName || !edit.mapName)) {
                        cameraBounds = edit.bounds;
                        console.log('[LIVE SYNC] Updated camera bounds');
                    }
                    break;

                case 'splitLine':
                    if (typeof tileSplitLines !== 'undefined') {
                        tileSplitLines[edit.key] = edit.mask;
                        console.log('[LIVE SYNC] Added split line:', edit.key);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'clearSplitLine':
                    if (typeof tileSplitLines !== 'undefined') {
                        delete tileSplitLines[edit.key];
                        console.log('[LIVE SYNC] Cleared split line:', edit.key);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'addLayer':
                    if (edit.mapName === gameMapName || !edit.mapName) {
                        layers.push([]);
                        for (let y = 0; y < mapRows; y++) {
                            layers[layers.length - 1][y] = [];
                            for (let x = 0; x < mapCols; x++) {
                                layers[layers.length - 1][y][x] = null;
                            }
                        }
                    }
                    break;

                case 'deleteLayer':
                    if (edit.mapName === gameMapName || !edit.mapName) {
                        if (edit.index >= 0 && edit.index < layers.length) {
                            layers.splice(edit.index, 1);
                            liveSyncNeedsRedraw = true;
                        }
                    }
                    break;

                case 'clearMap':
                    if (edit.mapName === gameMapName || !edit.mapName) {
                        layers.forEach((layer, i) => {
                            layers[i] = [];
                            for (let y = 0; y < mapRows; y++) {
                                layers[i][y] = [];
                                for (let x = 0; x < mapCols; x++) {
                                    layers[i][y][x] = null;
                                }
                            }
                        });
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                default:
                    // Silently ignore unhandled edit types
                    break;
            }
        }

        // Wait for data from builder via postMessage
        console.log('Waiting for project data from builder...');
        window.onmessage = function(e) {
            if (e.data.type === 'project-data') {
                console.log('Received project data');
                projectData = JSON.parse(e.data.data);
                // Check for auto-multiplayer from builder co-op
                if (e.data.autoMultiplayer) {
                    console.log('Auto-multiplayer enabled:', e.data.autoMultiplayer);
                    // Set multiplayer config so initGame connects automatically
                    projectData.multiplayer = {
                        playerName: e.data.autoMultiplayer.playerName,
                        roomCode: e.data.autoMultiplayer.roomCode
                    };
                }
                if (window.opener) {
                    window.opener.postMessage({ type: 'log', msg: 'Project data received, size: ' + e.data.data.length }, '*');
                }
                initGame();

                // Connect to builder for live sync of edits
                if (e.data.builderSync && e.data.builderSync.roomCode) {
                    setTimeout(() => connectToBuilderSync(e.data.builderSync.roomCode), 1000);
                }
            } else if (e.data.type === 'sound-data') {
                const { index, data, name } = e.data;
                if (projectData && projectData.sounds && projectData.sounds[index]) {
                    projectData.sounds[index].data = data;
                    console.log('Received sound', index, name);
                    if (window.opener) {
                        window.opener.postMessage({ type: 'log', msg: 'Sound received: ' + name }, '*');
                    }
                }
            } else if (e.data.type === 'builderEdit') {
                // Live edit from builder (solo mode - direct postMessage)
                if (e.data.edit && typeof applyLiveEdit === 'function') {
                    console.log('[LIVE SYNC] Received edit via postMessage');
                    applyLiveEdit(e.data.edit, false);
                }
            }
        };
        // Signal ready to builder
        if (window.opener) {
            window.opener.postMessage({ type: 'ready' }, '*');
        } else {
            console.error('No opener window found!');
        }

        // Debug/UI functions (must be global for onclick handlers)
        let showCollision = false;
        let showSounds = false;

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }
        function toggleCollision() {
            showCollision = !showCollision;
            document.querySelectorAll('#debugButtons button')[1].classList.toggle('active', showCollision);
        }
        function toggleSoundDebug() {
            showSounds = !showSounds;
            document.querySelectorAll('#debugButtons button')[2].classList.toggle('active', showSounds);
        }
        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
            document.querySelectorAll('#debugButtons button')[3].classList.toggle('active', panel.style.display === 'block');
        }

        function closeGame() {
            window.close();
        }
        let uiHidden = true; // Start with UI hidden
        function hideAllUI() {
            uiHidden = true;
            document.getElementById('debugButtons').style.display = 'none';
            document.getElementById('info').style.display = 'none';
            document.getElementById('debugPanel').style.display = 'none';
            const toggleBtn = document.getElementById('toggleLogBtn');
            if (toggleBtn) toggleBtn.style.display = 'none';
            const debugLog = document.getElementById('debugLog');
            if (debugLog) debugLog.style.display = 'none';
        }
        function showAllUI() {
            uiHidden = false;
            document.getElementById('debugButtons').style.display = '';
            document.getElementById('info').style.display = '';
        }
        function toggleAllUI() {
            if (uiHidden) showAllUI();
            else hideAllUI();
        }

        // Shape-based attack hitbox per direction (triangle/cone) - global for hitbox panel
        let playerHitboxRange = { up: 20, down: 20, left: 20, right: 20 };
        let playerHitboxWidth = { up: 90, down: 90, left: 90, right: 90 };
        let playerHitboxOffsetY = { up: 5, down: 0, left: 0, right: 0 };
        let playerHitboxOffsetX = { up: 0, down: 0, left: 5, right: -10 };

        // Hitbox panel functions
        let hitboxEditDir = 'down';
        function toggleHitboxPanel() {
            const panel = document.getElementById('hitboxPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
            document.querySelectorAll('#debugButtons button')[4].classList.toggle('active', panel.style.display === 'block');
            if (panel.style.display === 'block') {
                updateHitboxSliders();
            }
        }

        function setHitboxDir(dir) {
            hitboxEditDir = dir;
            document.querySelectorAll('[id^="hitboxDir"]').forEach(b => {
                b.classList.remove('active');
                b.style.background = '';
            });
            const btn = document.getElementById('hitboxDir' + dir.charAt(0).toUpperCase() + dir.slice(1));
            btn.classList.add('active');
            btn.style.background = '#66f';
            updateHitboxSliders();
        }

        function updateHitboxSliders() {
            const dir = hitboxEditDir;
            document.getElementById('hbRangeSlider').value = playerHitboxRange[dir];
            document.getElementById('hbRangeVal').textContent = playerHitboxRange[dir];
            document.getElementById('hbWidthSlider').value = playerHitboxWidth[dir];
            document.getElementById('hbWidthVal').textContent = playerHitboxWidth[dir];
            document.getElementById('hbOffsetXSlider').value = playerHitboxOffsetX[dir];
            document.getElementById('hbOffsetXVal').textContent = playerHitboxOffsetX[dir];
            document.getElementById('hbOffsetYSlider').value = playerHitboxOffsetY[dir];
            document.getElementById('hbOffsetYVal').textContent = playerHitboxOffsetY[dir];
        }

        function copyAllHitboxFromDir() {
            const dir = hitboxEditDir;
            ['up', 'down', 'left', 'right'].forEach(d => {
                playerHitboxRange[d] = playerHitboxRange[dir];
                playerHitboxWidth[d] = playerHitboxWidth[dir];
                playerHitboxOffsetX[d] = playerHitboxOffsetX[dir];
                playerHitboxOffsetY[d] = playerHitboxOffsetY[dir];
            });
            console.log('Copied ' + dir + ' hitbox to all directions');
        }

        function copyHitboxSettings() {
            const settings = {
                hitboxRange: playerHitboxRange,
                hitboxWidth: playerHitboxWidth,
                hitboxOffsetX: playerHitboxOffsetX,
                hitboxOffsetY: playerHitboxOffsetY
            };
            const json = JSON.stringify(settings, null, 2);
            navigator.clipboard.writeText(json).then(() => {
                console.log('Hitbox settings copied to clipboard');
            });
        }

        function initGame() {
        console.log('Initializing game with project data:', projectData);

        // Auto-hide UI if adventure mode
        if (projectData.autoHideUI) {
            setTimeout(() => hideAllUI(), 100);
        }

        const gridSize = projectData.gridSize || 16;
        mapRows = projectData.mapRows || 30;
        mapCols = projectData.mapCols || 40;

        // Load layers - use spawn map's data if available
        layers = [];
        const spawnMap = projectData.spawnMapName || 'main';
        const spawnMapData = projectData.maps && projectData.maps[spawnMap];

        if (spawnMapData && spawnMapData.layers && spawnMapData.layers.length > 0) {
            // Load from spawn map
            layers = spawnMapData.layers;
            console.log('Loaded layers from spawn map:', spawnMap);
        } else if (projectData.layers && projectData.layers.length > 0) {
            layers = projectData.layers;
            console.log('Loaded layers from projectData.layers');
        } else if (projectData.map && projectData.map.length > 0) {
            layers = [projectData.map];
            console.log('Loaded map from projectData.map (old format)');
        } else {
            console.error('No map data found!');
        }

        let layerVisibility = projectData.layerVisibility || layers.map(() => true);
        const playerLayerIndex = projectData.playerLayerIndex !== undefined ? projectData.playerLayerIndex : 1;

        console.log('Layers:', layers.length, 'MapRows:', mapRows, 'MapCols:', mapCols, 'PlayerLayer:', playerLayerIndex);

        // Debug: Check layer content
        if (layers.length > 0) {
            const firstLayer = layers[0];
            console.log('First layer type:', typeof firstLayer, 'isArray:', Array.isArray(firstLayer));
            if (Array.isArray(firstLayer) && firstLayer.length > 0) {
                console.log('First layer rows:', firstLayer.length);
                // Count non-null cells
                let tileCount = 0;
                for (let y = 0; y < firstLayer.length; y++) {
                    if (firstLayer[y]) {
                        for (let x = 0; x < firstLayer[y].length; x++) {
                            if (firstLayer[y][x]) tileCount++;
                        }
                    }
                }
                console.log('Tiles in first layer:', tileCount);
            }
        }

        // Load collision data - use spawn map's data if available
        tileCollisions = (spawnMapData && spawnMapData.tileCollisions) || projectData.tileCollisions || {};
        collisionMasks = (spawnMapData && spawnMapData.collisionMasks) || projectData.collisionMasks || {};
        tileSplitLines = (spawnMapData && spawnMapData.tileSplitLines) || projectData.tileSplitLines || {}; // Depth split for Y-sorting

        console.log('Tiles with collision:', Object.keys(tileCollisions).length, 'from map:', spawnMap);
        console.log('Tiles with depth split:', Object.keys(tileSplitLines).length);

        // Multiple props system
        const propImages = [];
        const propsData = projectData.props || [];
        const propCollisionMasksAll = {}; // propIndex -> collision masks

        // Load tilesets (support multiple)
        const tilesetImages = [];
        const tilesetsData = projectData.tilesets || [{ data: projectData.tilesetData }];

        // Animated props data (needed for counting)
        const animatedPropsData = projectData.animatedProps || [];

        // Track all images that need to load before starting the game
        let imagesToLoad = 0;
        let imagesLoaded = 0;
        let gameStarted = false;

        function checkAllImagesLoaded() {
            showLoading(imagesLoaded, imagesToLoad);
            if (imagesLoaded >= imagesToLoad && !gameStarted) {
                console.log('All images loaded, starting game...');
                gameStarted = true;
                gameStartTime = Date.now();
                hideLoading();
                findStartPos();
                hideAllUI(); // Start with debug UI hidden
                gameLoop();
            }
        }

        // Count all images to load
        imagesToLoad += tilesetsData.filter(ts => ts && ts.data).length; // Tilesets with valid data
        imagesToLoad += animatedPropsData.filter(p => p && p.spriteData).length; // Animated props
        imagesToLoad += propsData.filter(p => p && p.data).length; // Regular props with valid data
        if (projectData.propImageData && propsData.length === 0) imagesToLoad += 1; // Legacy single prop
        imagesToLoad += (projectData.npcs || []).filter(n => n && n.spriteData).length; // NPC sprites
        imagesToLoad += 1; // Player sprite

        // Detect mobile for staggered loading
        const isMobileDevice = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        console.log('Total images to load:', imagesToLoad, isMobileDevice ? '(mobile - staggered loading)' : '');

        // Safety check - if somehow no images to load, start anyway
        if (imagesToLoad === 0) {
            console.warn('No images to load, starting game immediately');
            imagesToLoad = 1;
            imagesLoaded = 1;
            gameStartTime = Date.now();
            hideLoading();
            findStartPos();
            hideAllUI(); // Start with debug UI hidden
            gameLoop();
        }

        // Fallback timeout - start game after 2 minutes even if some images failed (large projects need more time on iPad)
        setTimeout(() => {
            if (!gameStarted) {
                console.warn('Timeout reached, starting game with', imagesLoaded, '/', imagesToLoad, 'images loaded');
                gameStarted = true;
                gameStartTime = Date.now();
                hideLoading();
                findStartPos();
                hideAllUI(); // Start with debug UI hidden
                gameLoop();
            }
        }, 120000);

        // Load all prop images
        if (propsData.length > 0) {
            propsData.forEach((propData, i) => {
                if (!propData || !propData.data) {
                    console.warn('Prop', i, 'has no data, skipping');
                    return;
                }
                const img = new Image();
                img.onload = () => {
                    console.log('Prop', i, 'loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error('Failed to load prop', i);
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.src = propData.data;
                propImages[i] = img;
                propCollisionMasksAll[i] = propData.collisionMasks || {};
            });
        } else if (projectData.propImageData) {
            // Backwards compatibility - single prop
            const img = new Image();
            img.onload = () => {
                console.log('Prop image loaded (legacy) (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.onerror = () => {
                console.error('Failed to load legacy prop');
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.src = projectData.propImageData;
            propImages[0] = img;
            propCollisionMasksAll[0] = projectData.propCollisionMasks || {};
        }

        tilesetsData.forEach((ts, i) => {
            if (!ts || !ts.data) {
                console.warn('Tileset', i, 'has no data, skipping');
                return;
            }
            const img = new Image();
            img.onload = () => {
                tilesetImages[i] = img;
                imagesLoaded++;
                console.log('Tileset', i, 'loaded (' + imagesLoaded + '/' + imagesToLoad + ')');
                checkAllImagesLoaded();
            };
            img.onerror = () => {
                console.error('Failed to load tileset', i);
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.src = ts.data;
        });

        // For backwards compat
        const tilesetImg = { complete: false };

        // Load animated props (stored as animTile cells in layers)
        const animPropImages = [];
        const animPropFrameTimers = {}; // key: "x,y,layer" -> { frame: 0, timer: 0 }
        const interactivePropStates = {}; // key: "x,y,layer" -> { used: false, animating: false, frame: 0 }

        animatedPropsData.forEach((propData, i) => {
            if (propData && propData.spriteData) {
                const img = new Image();
                img.onload = () => {
                    console.log('AnimProp', i, propData.name, 'loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error('Failed to load AnimProp', i);
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.src = propData.spriteData;
                animPropImages[i] = img;
            }
        });

        console.log('Animated props:', animatedPropsData.length);

        // Load player sprite - check for player characters first, then embedded sprite, then file
        let playerImg = new Image();
        const basePath = window.opener ? window.opener.location.href.replace(/[^/]*$/, '') : '';

        // Player character animation data (if using player characters system)
        let activePlayerChar = null;
        let playerFrameWidth = 64;
        let playerFrameHeight = 64;
        let playerAnimations = null;
        let playerAnimFpsList = {}; // Per-animation FPS
        let playerAnimMirrors = {}; // Per-animation mirror flags
        let playerAttackMovement = 'stop'; // 'stop', 'slide', 'move'

        let playerGameOverSoundIndex = -1; // Index of game over sound (-1 = none, 0-99 = builtin, 100+ = project)
        let playerSpriteSheets = []; // Array of loaded sprite sheet images

        // Built-in game over sounds (lazy loaded)
        const builtinGameOverSounds = [
            { name: 'Game Over 1', file: 'game-over-417465.mp3' },
            { name: 'Game Over 2 (Arcade)', file: 'game-over-arcade-6435.mp3' }
        ];
        let builtinGameOverAudios = [null, null];

        // Check for player characters system first
        if (projectData.playerCharacters && projectData.playerCharacters.length > 0 && projectData.activePlayerIndex >= 0) {
            activePlayerChar = projectData.playerCharacters[projectData.activePlayerIndex];
            console.log('=== PLAYER CHARACTER DATA ===');
            console.log('spriteSheets:', activePlayerChar.spriteSheets ? activePlayerChar.spriteSheets.length + ' sheets' : 'none');
            console.log('animMirrors:', JSON.stringify(activePlayerChar.animMirrors));
            console.log('animations keys:', Object.keys(activePlayerChar.animations || {}));
            console.log('attackDown frames:', activePlayerChar.animations?.attackDown?.length || 0);
            if (activePlayerChar) {
                playerFrameWidth = activePlayerChar.frameWidth || 64;
                playerFrameHeight = activePlayerChar.frameHeight || 64;
                playerAnimations = activePlayerChar.animations;
                // Load per-animation FPS
                if (activePlayerChar.animFps && typeof activePlayerChar.animFps === 'object') {
                    playerAnimFpsList = activePlayerChar.animFps;
                } else {
                    // Old format: use single fps for all
                    const defaultFps = activePlayerChar.fps || 8;
                    if (playerAnimations) {
                        Object.keys(playerAnimations).forEach(k => playerAnimFpsList[k] = defaultFps);
                    }
                }
                // Load per-animation mirror flags
                if (activePlayerChar.animMirrors && typeof activePlayerChar.animMirrors === 'object') {
                    playerAnimMirrors = activePlayerChar.animMirrors;
                    console.log('Loaded animMirrors:', JSON.stringify(playerAnimMirrors));
                }
                // Load attack hitbox shape (per-direction)
                if (activePlayerChar.hitboxRange !== undefined) {
                    // Handle both old single-value format and new per-direction format
                    if (typeof activePlayerChar.hitboxRange === 'object') {
                        playerHitboxRange = activePlayerChar.hitboxRange;
                    } else {
                        // Convert old format to new
                        const val = activePlayerChar.hitboxRange;
                        playerHitboxRange = { up: val, down: val, left: val, right: val };
                    }
                }
                if (activePlayerChar.hitboxWidth !== undefined) {
                    if (typeof activePlayerChar.hitboxWidth === 'object') {
                        playerHitboxWidth = activePlayerChar.hitboxWidth;
                    } else {
                        const val = activePlayerChar.hitboxWidth;
                        playerHitboxWidth = { up: val, down: val, left: val, right: val };
                    }
                }
                if (activePlayerChar.hitboxOffsetY !== undefined) {
                    if (typeof activePlayerChar.hitboxOffsetY === 'object') {
                        playerHitboxOffsetY = activePlayerChar.hitboxOffsetY;
                    } else {
                        const val = activePlayerChar.hitboxOffsetY;
                        playerHitboxOffsetY = { up: val, down: val, left: val, right: val };
                    }
                }
                if (activePlayerChar.hitboxOffsetX !== undefined) {
                    if (typeof activePlayerChar.hitboxOffsetX === 'object') {
                        playerHitboxOffsetX = activePlayerChar.hitboxOffsetX;
                    } else {
                        const val = activePlayerChar.hitboxOffsetX;
                        playerHitboxOffsetX = { up: val, down: val, left: val, right: val };
                    }
                }
                console.log('Loaded per-direction hitbox:', JSON.stringify(playerHitboxRange));
                // Load attack movement setting
                if (activePlayerChar.attackMovement) {
                    playerAttackMovement = activePlayerChar.attackMovement;
                }
                // Load game over sound index
                if (activePlayerChar.gameOverSoundIndex !== undefined) {
                    playerGameOverSoundIndex = activePlayerChar.gameOverSoundIndex;
                }
                console.log('Using player character:', activePlayerChar.name, playerFrameWidth + 'x' + playerFrameHeight, 'attackMovement:', playerAttackMovement);
            }
        }

        // Load player sprite sheets (supports multiple sheets)
        const sheetsToLoad = activePlayerChar?.spriteSheets || (activePlayerChar?.spriteData ? [activePlayerChar.spriteData] : null) || (projectData.playerSpriteData ? [projectData.playerSpriteData] : null);

        if (sheetsToLoad && sheetsToLoad.length > 0) {
            // Load all sprite sheets
            let sheetsLoaded = 0;
            sheetsToLoad.forEach((sheetData, index) => {
                const sheetImg = new Image();
                sheetImg.onload = () => {
                    playerSpriteSheets[index] = sheetImg;
                    sheetsLoaded++;
                    console.log('Player sheet ' + (index + 1) + ' loaded (' + sheetsLoaded + '/' + sheetsToLoad.length + ')');
                    if (sheetsLoaded === sheetsToLoad.length) {
                        // All sheets loaded - set playerImg to first sheet for backwards compat
                        playerImg = playerSpriteSheets[0];
                        imagesLoaded++;
                        checkAllImagesLoaded();
                    }
                };
                sheetImg.onerror = () => {
                    console.error('Failed to load player sheet ' + (index + 1));
                    sheetsLoaded++;
                    if (sheetsLoaded === sheetsToLoad.length) {
                        imagesLoaded++;
                        checkAllImagesLoaded();
                    }
                };
                sheetImg.src = sheetData;
            });
        } else {
            // Fallback to file
            playerImg.onload = () => {
                console.log('Player sprite loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                playerSpriteSheets = [playerImg];
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            playerImg.onerror = () => {
                console.error('Failed to load player sprite');
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            console.log('Loading player sprite from file:', basePath + 'assets/player_sprite.png');
            playerImg.src = basePath + 'assets/player_sprite.png';
        }

        // Player state (matching game.js)
        const player = {
            x: 100,
            y: 100,
            width: 28,
            height: 76,
            speed: 5.5,
            direction: 'down',
            frame: 0,
            frameTimer: 0,
            moving: false,
            attacking: false,
            attackTimer: 0,
            // Health system
            health: 100,
            maxHealth: 100,
            invincible: false,
            invincibleTimer: 0
        };

        // Store initial spawn for respawn on death
        let initialSpawnX = 100;
        let initialSpawnY = 100;
        let initialSpawnMap = '';

        // Damage player function
        function damagePlayer(amount) {
            if (player.invincible || player.health <= 0) return;

            player.health -= amount;
            player.invincible = true;
            player.invincibleTimer = 90; // 1.5 seconds of invincibility

            console.log('[COMBAT] Player took', amount, 'damage! Health:', player.health);

            if (player.health <= 0) {
                player.health = 0;
                startPlayerDeath();
            }
        }

        // Death animation state
        let playerDying = false;
        let deathAnimFrame = 0;
        let deathAnimTimer = 0;
        let gameOverShown = false;

        // Start player death sequence
        function startPlayerDeath() {
            console.log('[COMBAT] Player died! Playing death animation...');
            playerDying = true;
            deathAnimFrame = 0;
            deathAnimTimer = 0;
            player.attacking = false;
            player.attackAnim = false;
        }

        // Update death animation
        function updateDeathAnimation() {
            if (!playerDying) return;

            deathAnimTimer++;

            // Get death animation frames
            const deathFrames = playerAnimations?.death || [];
            const deathFps = playerAnimFpsList?.death || 4; // Slow death anim
            const frameDelay = Math.round(60 / deathFps);

            if (deathFrames.length > 0) {
                if (deathAnimTimer >= frameDelay) {
                    deathAnimTimer = 0;
                    deathAnimFrame++;

                    // Death animation finished
                    if (deathAnimFrame >= deathFrames.length) {
                        playerDying = false;
                        showGameOver();
                    }
                }
            } else {
                // No death animation - just wait a moment then show game over
                if (deathAnimTimer >= 60) {
                    playerDying = false;
                    showGameOver();
                }
            }
        }

        // Show Game Over screen
        function showGameOver() {
            gameOverShown = true;
            document.getElementById('gameOverOverlay').style.display = 'flex';
            // Play game over sound if set
            // Index scheme: -1 = none, 0-99 = builtin sounds, 100+ = project sounds
            if (playerGameOverSoundIndex >= 0) {
                if (playerGameOverSoundIndex < 100) {
                    // Builtin sound
                    const builtinIndex = playerGameOverSoundIndex;
                    if (builtinIndex >= 0 && builtinIndex < builtinGameOverSounds.length) {
                        if (!builtinGameOverAudios[builtinIndex]) {
                            builtinGameOverAudios[builtinIndex] = new Audio(builtinGameOverSounds[builtinIndex].file);
                        }
                        builtinGameOverAudios[builtinIndex].currentTime = 0;
                        builtinGameOverAudios[builtinIndex].volume = 1.0;
                        builtinGameOverAudios[builtinIndex].play().catch(e => console.warn('Game over sound blocked:', e));
                    }
                } else {
                    // Project sound (index - 100)
                    const projectIndex = playerGameOverSoundIndex - 100;
                    if (projectIndex >= 0 && projectIndex < soundsData.length) {
                        playSound(projectIndex, 1.0, 0);
                    }
                }
            }
        }

        // Try Again - respawn player
        function tryAgain() {
            gameOverShown = false;
            document.getElementById('gameOverOverlay').style.display = 'none';
            respawnPlayer();
        }
        window.tryAgain = tryAgain; // Expose to onclick

        // Quit game
        function quitGame() {
            window.close();
        }
        window.quitGame = quitGame; // Expose to onclick

        // Respawn player at initial spawn
        function respawnPlayer() {
            console.log('[COMBAT] Respawning player...');
            player.health = player.maxHealth;
            player.x = initialSpawnX;
            player.y = initialSpawnY;
            player.invincible = true;
            player.invincibleTimer = 120; // 2 seconds after respawn
            playerDying = false;
            deathAnimFrame = 0;
            if (initialSpawnMap && initialSpawnMap !== currentGameMap) {
                // Switch to spawn map
                switchMap(initialSpawnMap, initialSpawnX / (gridSize * TILE_SCALE), initialSpawnY / (gridSize * TILE_SCALE));
            }
        }

        // Damage NPC (enemy) by amount
        function damageNPC(npcIndex, amount) {
            const placed = placedNpcs[npcIndex];
            const state = npcRuntimeState[npcIndex];
            if (!placed || !state || !placed.isEnemy) return;

            // Initialize HP if not set (default to 30 HP)
            if (state.hp === undefined) {
                state.hp = placed.maxHp || 30;
                state.maxHp = state.hp;
            }

            // Apply damage
            state.hp -= amount;
            state.damageCooldown = 30; // Brief invincibility
            state.hitFlash = 10; // Flash white for 10 frames

            console.log('[COMBAT] NPC', npcIndex, 'took', amount, 'damage! HP:', state.hp);

            // Check for death
            if (state.hp <= 0) {
                state.hp = 0;
                state.dead = true;
                console.log('[COMBAT] NPC', npcIndex, 'defeated!');
            }
        }

        // Check player attack hitbox against NPCs using cone/triangle shape
        function checkAttackHitbox() {
            if (!player.attacking || !player.attackAnim) return;

            const attackDamage = 10; // TODO: Make configurable

            // Track which NPCs we've hit this attack to prevent multiple hits
            if (player.attackHitNpcs === undefined) player.attackHitNpcs = {};

            // Get cone parameters for current direction
            const dir = player.direction;
            const range = (playerHitboxRange[dir] || 40) * TILE_SCALE;
            const halfAngle = ((playerHitboxWidth[dir] || 60) / 2) * (Math.PI / 180); // Convert to radians
            const offsetX = (playerHitboxOffsetX[dir] || 0) * TILE_SCALE;
            const offsetY = (playerHitboxOffsetY[dir] || 0) * TILE_SCALE;

            // Direction to angle (radians) - 0 is right, PI/2 is down
            const dirAngles = { right: 0, down: Math.PI / 2, left: Math.PI, up: -Math.PI / 2 };
            const baseAngle = dirAngles[dir] || 0;

            // Player center position with offset
            const playerCenterX = player.x + player.width / 2 + offsetX;
            const playerCenterY = player.y + player.height / 2 + offsetY;

            for (let i = 0; i < placedNpcs.length; i++) {
                const placed = placedNpcs[i];
                const state = npcRuntimeState[i];

                // Skip non-enemies, dead enemies, and already-hit enemies this attack
                if (!placed || !placed.isEnemy || !state) continue;
                if (state.dead) continue;
                if (player.attackHitNpcs[i]) continue;

                // Get NPC center position
                const npcScale = placed.scale || 1;
                const npcW = (placed.npc?.frameWidth || gridSize) * TILE_SCALE * npcScale;
                const npcH = (placed.npc?.frameHeight || gridSize) * TILE_SCALE * npcScale;
                const npcCenterX = state.x * TILE_SCALE + npcW / 2;
                const npcCenterY = state.y * TILE_SCALE + npcH / 2;

                // Vector from player to NPC
                const dx = npcCenterX - playerCenterX;
                const dy = npcCenterY - playerCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Check if NPC is within range
                if (distance > range) continue;

                // Check if NPC is within cone angle
                const angleToNpc = Math.atan2(dy, dx);
                let angleDiff = angleToNpc - baseAngle;
                // Normalize angle difference to -PI to PI
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                if (Math.abs(angleDiff) <= halfAngle) {
                    damageNPC(i, attackDamage);
                    player.attackHitNpcs[i] = true;
                }
            }
        }

        // === MULTIPLAYER SYSTEM ===
        let mpSocket = null;
        let mpConnected = false;
        let mpPlayerName = 'Player';
        let mpLastSendTime = 0;
        const otherPlayers = new Map(); // id -> {x, y, targetX, targetY, direction, animation, name, frame, frameTimer}

        // Initialize multiplayer if settings provided
        if (projectData.multiplayer) {
            mpPlayerName = projectData.multiplayer.playerName || 'Player';
            const roomCode = projectData.multiplayer.roomCode;
            console.log('[MP] Connecting as', mpPlayerName, 'to room', roomCode);

            try {
                mpSocket = new WebSocket('wss://multiplayer.lakotafox.partykit.dev/party/' + roomCode);

                mpSocket.onopen = () => {
                    console.log('[MP] Connected to server');
                    mpConnected = true;
                    // Send join message
                    mpSocket.send(JSON.stringify({
                        type: 'join',
                        name: mpPlayerName,
                        x: player.x,
                        y: player.y,
                        direction: player.direction,
                        animation: 'idle',
                        currentMap: currentGameMap,
                        gameType: 'game2d'
                    }));
                };

                mpSocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleMpMessage(data);
                    } catch (e) {
                        console.error('[MP] Error parsing message:', e);
                    }
                };

                mpSocket.onclose = () => {
                    console.log('[MP] Disconnected');
                    mpConnected = false;
                };

                mpSocket.onerror = (err) => {
                    console.error('[MP] WebSocket error:', err);
                };
            } catch (e) {
                console.error('[MP] Failed to connect:', e);
            }
        }

        function handleMpMessage(data) {
            switch (data.type) {
                case 'welcome':
                    console.log('[MP] Welcome:', data.message);
                    // Spawn existing players (only game2d ones)
                    if (data.players) {
                        data.players.filter(p => p.gameType === 'game2d').forEach(p => {
                            otherPlayers.set(p.id, {
                                x: p.x, y: p.y,
                                targetX: p.x, targetY: p.y,
                                direction: p.direction || 'down',
                                animation: p.animation || 'idle',
                                name: p.name || 'Player',
                                currentMap: p.currentMap || 'main',
                                inTavern: p.inTavern || false,
                                frame: 0, frameTimer: 0
                            });
                            console.log('[MP] Added existing player:', p.name, 'on map:', p.currentMap);
                        });
                    }
                    break;

                case 'join':
                    if (data.player && data.player.gameType === 'game2d') {
                        otherPlayers.set(data.player.id, {
                            x: data.player.x, y: data.player.y,
                            targetX: data.player.x, targetY: data.player.y,
                            direction: data.player.direction || 'down',
                            animation: data.player.animation || 'idle',
                            name: data.player.name || 'Player',
                            currentMap: data.player.currentMap || 'main',
                            inTavern: data.player.inTavern || false,
                            frame: 0, frameTimer: 0
                        });
                        console.log('[MP] Player joined:', data.player.name, 'on map:', data.player.currentMap);
                    }
                    break;

                case 'update':
                    if (data.player && data.player.gameType === 'game2d') {
                        const other = otherPlayers.get(data.player.id);
                        if (other) {
                            // Set target position (will lerp toward it)
                            other.targetX = data.player.x;
                            other.targetY = data.player.y;
                            other.direction = data.player.direction || other.direction;
                            other.animation = data.player.animation || other.animation;
                            other.currentMap = data.player.currentMap || other.currentMap;
                            other.inTavern = data.player.inTavern || false;
                        }
                    }
                    break;

                case 'leave':
                    if (data.playerId) {
                        const leaving = otherPlayers.get(data.playerId);
                        if (leaving) {
                            console.log('[MP] Player left:', leaving.name);
                            otherPlayers.delete(data.playerId);
                        }
                    }
                    break;

                case 'builderEdit':
                    // Received a builder edit relayed from another player
                    if (data.edit) {
                        console.log('[MP] Received builder edit from other player');
                        applyLiveEdit(data.edit, true); // true = from multiplayer, don't relay again
                    }
                    break;

                case 'itemInteract':
                    // Another player interacted with an item
                    if (data.itemIndex !== undefined && itemStates[data.itemIndex]) {
                        const state = itemStates[data.itemIndex];
                        if (!state.used && !state.animating) {
                            state.animating = true;
                            state.frame = 0;
                            state.frameTimer = 0;
                            console.log('[MP] Remote player opened item at', data.x, data.y);
                        }
                    }
                    break;

                case 'propInteract':
                    // Another player interacted with an animated prop
                    if (data.key) {
                        if (!interactivePropStates[data.key]) {
                            interactivePropStates[data.key] = { used: false, animating: false, frame: 0, gaveItem: false };
                        }
                        const state = interactivePropStates[data.key];
                        if (!state.used && !state.animating) {
                            state.animating = true;
                            state.frame = 0;
                            console.log('[MP] Remote player opened prop at', data.originX, data.originY);
                        }
                    }
                    break;
            }
        }

        function sendMpUpdate() {
            if (!mpConnected || !mpSocket) return;
            const now = Date.now();
            if (now - mpLastSendTime < 100) return; // Throttle to 10/sec
            mpLastSendTime = now;

            mpSocket.send(JSON.stringify({
                type: 'update',
                x: player.x,
                y: player.y,
                direction: player.direction,
                animation: player.moving ? 'walk' : 'idle',
                currentMap: currentGameMap,
                inTavern: inTavernMode
            }));
        }

        // === SOUND SYSTEM ===
        let soundsData = projectData.sounds || []; // 'let' so we can receive streamed sounds
        // Use outer scope tileSounds for live sync
        tileSounds = projectData.tileSounds || {};
        const playerSoundsData = projectData.playerSounds || {
            walk: { soundIndex: -1, interval: 200, volume: 0.5, pitchVariation: 0.1 },
            attack: { soundIndex: -1, volume: 0.7 }
        };
        const soundsWillStream = projectData.soundsWillStream || false;
        let soundsStreamedCount = 0;

        console.log('=== SOUND DATA LOADED ===');
        console.log('Sounds array:', soundsData.length, soundsData);
        console.log('Sounds will stream:', soundsWillStream);
        console.log('Tile sounds:', Object.keys(tileSounds).length, tileSounds);
        console.log('Player sounds:', playerSoundsData);

        // === TRIGGER/MAP SYSTEM ===
        // Use outer scope placedTriggers for live sync
        placedTriggers = projectData.placedTriggers || [];
        const mapsData = projectData.maps || {};
        const spawnMapNameData = projectData.spawnMapName || 'main';
        currentGameMap = spawnMapNameData; // Start on the map where spawn is set
        console.log('Triggers:', placedTriggers.length, 'Maps:', Object.keys(mapsData).length, 'SpawnMap:', spawnMapNameData);

        // === DIALOG SYSTEM ===
        const dialogs = projectData.dialogs || [];
        const placedDialogTiles = projectData.placedDialogTiles || [];
        console.log('Dialogs:', dialogs.length, 'Dialog tiles:', placedDialogTiles.length);

        // === ITEMS SYSTEM (interactive objects like chests) ===
        const itemsData = projectData.items || [];
        const placedItemsData = projectData.placedItems || [];
        const itemImages = {}; // Preloaded item sprite images
        const itemStates = {}; // Runtime state for each placed item: { used: false, animating: false, frame: 0 }

        // Preload item sprites
        itemsData.forEach((item, i) => {
            if (item.spriteData) {
                const img = new Image();
                img.src = item.spriteData;
                itemImages[i] = img;
            }
        });

        // Initialize item states
        placedItemsData.forEach((placed, i) => {
            itemStates[i] = {
                used: placed.used || false,
                animating: false,
                frame: itemsData[placed.itemIndex]?.idleFrame || 0,
                frameTimer: 0
            };
        });
        console.log('Items:', itemsData.length, 'Placed items:', placedItemsData.length);

        // Debug: log all received triggers
        console.log('=== TEST GAME RECEIVED TRIGGERS ===');
        placedTriggers.forEach((t, i) => {
            console.log('Trigger ' + i + ': Door ' + t.doorNumber + ' at (' + t.x + ',' + t.y + ') on "' + t.mapName + '" -> "' + t.targetMap + '" spawn (' + t.targetX + ',' + t.targetY + ')');
        });

        // Listen for streamed sound data from builder (mobile only)
        if (soundsWillStream) {
            console.log('Waiting for sound data to stream from builder...');
            window.addEventListener('message', function(e) {
                if (e.data && e.data.type === 'sound-data') {
                    const { index, data, name } = e.data;
                    if (soundsData[index]) {
                        soundsData[index].data = data;
                        soundsStreamedCount++;
                        console.log('Received sound', index, name, '(' + soundsStreamedCount + '/' + soundsData.length + ')');
                    }
                } else if (e.data && e.data.type === 'sounds-complete') {
                    console.log('All sounds received from builder');
                }
            });
        }

        // === LIGHTING SYSTEM ===
        const currentMapName = 'main'; // Default map name for lighting keys
        const lightingSettingsData = projectData.lightingSettings || {
            blobShadows: true,
            ambientEnabled: false,
            timeOfDay: 'day',
            playerLight: false,
            playerLightRadius: 4
        };
        // Use outer scope pointLights for live sync
        pointLights = projectData.pointLights || {};
        const TIME_PRESETS = {
            dawn:  { r: 0, g: 0, b: 20, a: 0.45 },
            day:   { r: 0, g: 0, b: 0, a: 0 },
            dusk:  { r: 0, g: 0, b: 20, a: 0.55 },
            night: { r: 0, g: 0, b: 20, a: 0.95 }
        };

        // Day/Night cycle system
        let dayCycleEnabled = false;
        let dayLength = 60; // seconds for full cycle (1 min default)
        let cycleTime = 0;  // current position in cycle (0-1)
        let lastCycleUpdate = Date.now();
        let currentLighting = { r: 0, g: 0, b: 0, a: 0 }; // interpolated values
        let manualDarkness = 0; // 0-100, used when cycle is off

        // Shadow settings (fixed values)
        const shadowWidth = 21;
        const shadowHeight = 8;
        const shadowYOffset = 17;

        // === NPC SYSTEM ===
        // Use outer scope variables for live sync
        npcsData = projectData.npcs || [];
        placedNpcs = projectData.placedNpcs || [];
        npcImages = [];
        // gridSize is already set from projectData above

        // Load NPC sprites (counted in imagesToLoad)
        npcsData.forEach((npc, i) => {
            if (npc && npc.spriteData) {
                const img = new Image();
                img.onload = () => {
                    console.log('NPC sprite loaded:', npc.name, '(' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error('Failed to load NPC sprite:', npc.name);
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.src = npc.spriteData;
                npcImages[i] = img;
            }
        });

        // NPC runtime state for each placed NPC
        npcRuntimeState = placedNpcs.map((placed, i) => createNpcRuntimeState(placed));

        // Helper function to create NPC runtime state (also used by live sync)
        function createNpcRuntimeState(placed) {
            return {
                // Position (in pixels)
                x: placed.x * gridSize,
                y: placed.y * gridSize,
                // Path following
                currentWaypoint: 0,
                pathDirection: 1, // 1 = forward, -1 = backward (for non-loop paths)
                // Animation
                direction: 'down',
                frame: 0,
                frameTimer: 0,
                // Movement
                moving: false,
                targetX: placed.x * gridSize,
                targetY: placed.y * gridSize,
                // Trigger state
                triggered: placed.trigger === 'loop', // Loop starts immediately
                waitTimer: 0,
                // Waypoint properties
                idleUntil: 0, // Timestamp when idle ends
                waypointAnimation: '', // Custom animation at waypoint
                // Enemy AI state
                aiState: 'idle', // 'idle', 'chase', 'attack', 'recover', 'return'
                aggroTimer: 0, // Time player has been in/out of vision
                attackCooldown: 0, // Time until can attack again
                returnX: placed.x * gridSize, // Position to return to when de-aggro
                returnY: placed.y * gridSize,
                lastAttackTime: 0 // Timestamp of last attack
            };
        }

        console.log('NPCs loaded:', npcsData.length, 'Placed:', placedNpcs.length);

        // Cycle phases: long night with peak darkness held for 50% of each night period
        // Night1: 0-30% (peak 0-15%), EarlyMorn: 30-38%, Dawn: 38-45%, Day: 45-55%,
        // Afternoon: 55-62%, Dusk: 62-70%, Night2: 70-100% (peak 85-100%)
        function updateDayCycle() {
            if (!dayCycleEnabled) return;

            const now = Date.now();
            const delta = (now - lastCycleUpdate) / 1000; // seconds
            lastCycleUpdate = now;

            // Advance cycle
            cycleTime += delta / dayLength;
            if (cycleTime >= 1) cycleTime -= 1;

            // Determine current phase and interpolation
            let fromPreset, toPreset, t, phaseName;

            if (cycleTime < 0.15) {
                // Peak Night 1 (0-15%) - full darkness
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = 0;
                phaseName = 'Night';
            } else if (cycleTime < 0.30) {
                // Late Night (15-30%) - very slowly lightening
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = (cycleTime - 0.15) / 0.15 * 0.1; // barely lighten
                phaseName = 'Late Night';
            } else if (cycleTime < 0.38) {
                // Early Morning (30-38%) - still very dark
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.dawn;
                t = (cycleTime - 0.30) / 0.08 * 0.4;
                phaseName = 'Early Morn';
            } else if (cycleTime < 0.45) {
                // Dawn (38-45%)
                fromPreset = TIME_PRESETS.dawn;
                toPreset = TIME_PRESETS.day;
                t = (cycleTime - 0.38) / 0.07;
                phaseName = 'Dawn';
            } else if (cycleTime < 0.55) {
                // Day (45-55%)
                fromPreset = TIME_PRESETS.day;
                toPreset = TIME_PRESETS.day;
                t = 0;
                phaseName = 'Day';
            } else if (cycleTime < 0.62) {
                // Afternoon (55-62%)
                fromPreset = TIME_PRESETS.day;
                toPreset = TIME_PRESETS.dusk;
                t = (cycleTime - 0.55) / 0.07;
                phaseName = 'Afternoon';
            } else if (cycleTime < 0.70) {
                // Dusk (62-70%)
                fromPreset = TIME_PRESETS.dusk;
                toPreset = TIME_PRESETS.night;
                t = (cycleTime - 0.62) / 0.08;
                phaseName = 'Dusk';
            } else if (cycleTime < 0.85) {
                // Early Night (70-85%) - getting darker
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = 0;
                phaseName = 'Early Night';
            } else {
                // Peak Night 2 (85-100%) - full darkness
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = 0;
                phaseName = 'Night';
            }

            // Smooth interpolation
            currentLighting.r = Math.round(fromPreset.r + (toPreset.r - fromPreset.r) * t);
            currentLighting.g = Math.round(fromPreset.g + (toPreset.g - fromPreset.g) * t);
            currentLighting.b = Math.round(fromPreset.b + (toPreset.b - fromPreset.b) * t);
            currentLighting.a = fromPreset.a + (toPreset.a - fromPreset.a) * t;

            // Update display
            const timeDisplay = document.getElementById('timeDisplay');
            if (timeDisplay) {
                timeDisplay.textContent = 'Time: ' + phaseName + ' (' + Math.round(cycleTime * 100) + '%)';
            }
        }

        console.log('=== LIGHTING DATA LOADED ===');
        console.log('Lighting settings:', lightingSettingsData);
        console.log('Point lights:', Object.keys(pointLights).length);

        // === NPC UPDATE FUNCTION ===
        function updateNPCs() {
            placedNpcs.forEach((placed, i) => {
                // Only update NPCs on current map
                if (placed.mapName && placed.mapName !== currentGameMap) return;

                const state = npcRuntimeState[i];
                if (!state) return;

                // Skip movement if NPC is paused for dialog
                if (state._dialogPaused) {
                    state.moving = false;
                    return;
                }

                const npc = npcsData[placed.npcIndex];
                if (!npc) return;

                const path = placed.path || [];
                const speed = (placed.speed || 3) * 0.5; // Convert to pixel speed

                // Check trigger conditions
                if (!state.triggered) {
                    if (placed.trigger === 'interact') {
                        // Triggered by player attack - check if player is attacking nearby
                        if (player.attacking) {
                            const dist = Math.hypot(player.x - state.x, player.y - state.y);
                            if (dist < gridSize * 2) {
                                state.triggered = true;
                            }
                        }
                    } else if (placed.trigger === 'timeDay') {
                        // Only active during day
                        state.triggered = dayCycleEnabled && cycleTime > 0.38 && cycleTime < 0.70;
                    } else if (placed.trigger === 'timeNight') {
                        // Only active during night
                        state.triggered = dayCycleEnabled && (cycleTime < 0.38 || cycleTime > 0.70);
                    }
                }

                // Reset trigger for time-based when condition no longer met
                if (placed.trigger === 'timeDay' && state.triggered) {
                    if (!dayCycleEnabled || cycleTime < 0.38 || cycleTime > 0.70) {
                        state.triggered = false;
                        state.currentWaypoint = 0;
                    }
                }
                if (placed.trigger === 'timeNight' && state.triggered) {
                    if (!dayCycleEnabled || (cycleTime > 0.38 && cycleTime < 0.70)) {
                        state.triggered = false;
                        state.currentWaypoint = 0;
                    }
                }

                // === ENEMY AI STATE MACHINE ===
                if (placed.isEnemy && !state.dead) {
                    const visionRadius = (placed.visionRadius || 5) * gridSize * TILE_SCALE;
                    const attackRange = (placed.attackRange || 2) * gridSize * TILE_SCALE;
                    const chaseSpeed = (placed.chaseSpeed || 4) * TILE_SCALE * 0.5;
                    const attackMode = placed.attackMode || 'touch';
                    const damage = placed.damage || 10;
                    const cooldownTime = (placed.attackCooldown || 1) * 60; // Convert seconds to frames
                    const lungeSpeed = (placed.lungeSpeed || 8) * TILE_SCALE * 0.5;

                    // NPC state uses unscaled coords, player uses scaled - convert NPC to scaled
                    const npcScaledX = state.x * TILE_SCALE;
                    const npcScaledY = state.y * TILE_SCALE;

                    // Calculate distance to player (both in scaled coordinates now)
                    const distToPlayer = Math.hypot(player.x - npcScaledX, player.y - npcScaledY);

                    // Initialize AI state if not set
                    if (!state.aiState) state.aiState = 'idle';
                    if (state.returnX === undefined) state.returnX = state.x;
                    if (state.returnY === undefined) state.returnY = state.y;
                    if (state.damageCooldown === undefined) state.damageCooldown = 0;

                    // Decrement damage cooldown
                    if (state.damageCooldown > 0) state.damageCooldown--;

                    // NPC scale affects hitbox size
                    const npcScale = placed.scale || 1;

                    // Contact hitbox size (scales with NPC)
                    const npcW = gridSize * TILE_SCALE * 0.7 * npcScale;
                    const npcH = gridSize * TILE_SCALE * 0.7 * npcScale;

                    // Get slowdown settings from placed NPC
                    const slowdownPercent = placed.slowdownPercent !== undefined ? placed.slowdownPercent : 50;
                    const slowdownDuration = placed.slowdownDuration !== undefined ? placed.slowdownDuration : 0.5;
                    const slowdownFrames = Math.floor(slowdownDuration * 60); // Convert to frames

                    // Check for contact damage (Touch mode or during Lunge)
                    const touchDistance = gridSize * TILE_SCALE * 0.6 * npcScale;
                    if (distToPlayer < touchDistance && state.damageCooldown <= 0) {
                        if (attackMode === 'touch' || state.aiState === 'lunge') {
                            damagePlayer(damage);
                            state.damageCooldown = cooldownTime;
                            // Trigger attack animation
                            state.attackAnimTimer = 30; // ~0.5 sec of attack anim
                            state.attackAnimFrame = 0;
                            // Trigger post-attack slowdown
                            state.slowdownTimer = slowdownFrames;
                            if (attackMode === 'lunge' && state.aiState === 'lunge') {
                                state.aiState = 'recover';
                                state.attackCooldown = 0;
                            }
                        }
                    }

                    // Decrement attack animation timer
                    if (state.attackAnimTimer > 0) {
                        state.attackAnimTimer--;
                        state.attackAnimFrame++;
                    }
                    // Decrement slowdown timer
                    if (state.slowdownTimer > 0) {
                        state.slowdownTimer--;
                    }

                    // State machine transitions
                    switch (state.aiState) {
                        case 'idle':
                            // Check if player is in vision range
                            if (distToPlayer <= visionRadius) {
                                state.aiState = 'chase';
                                state.aggroTimer = 0;
                            }
                            break;

                        case 'chase':
                            // Check if player left vision range for too long
                            if (distToPlayer > visionRadius * 1.5) {
                                state.aggroTimer++;
                                if (state.aggroTimer > 180) { // 3 seconds at 60fps
                                    state.aiState = 'return';
                                    state.aggroTimer = 0;
                                }
                            } else {
                                state.aggroTimer = 0;
                            }

                            // Lunge mode: start lunge when in attack range
                            if (attackMode === 'lunge' && distToPlayer <= attackRange && state.damageCooldown <= 0) {
                                state.aiState = 'lunge';
                                // Store target in unscaled coords (same as state.x/y)
                                state.lungeTargetX = player.x / TILE_SCALE;
                                state.lungeTargetY = player.y / TILE_SCALE;
                                state.lungeTimer = 0;
                            }
                            break;

                        case 'lunge':
                            // Dash toward the stored target position (both in unscaled coords)
                            const ldx = state.lungeTargetX - state.x;
                            const ldy = state.lungeTargetY - state.y;
                            const ldist = Math.hypot(ldx, ldy);
                            const unscaledLungeSpeed = lungeSpeed / TILE_SCALE;

                            state.lungeTimer++;

                            if (ldist > unscaledLungeSpeed && state.lungeTimer < 30) {
                                // Move toward lunge target at high speed
                                const lmoveX = (ldx / ldist) * unscaledLungeSpeed;
                                const lmoveY = (ldy / ldist) * unscaledLungeSpeed;

                                // Check collision (scale up position for collision check)
                                const scaledX = (state.x + lmoveX) * TILE_SCALE;
                                const scaledY = (state.y + lmoveY) * TILE_SCALE;
                                if (!checkCollision(scaledX, scaledY, npcW, npcH)) {
                                    state.x += lmoveX;
                                    state.y += lmoveY;
                                    state.moving = true;
                                } else {
                                    // Hit a wall, end lunge
                                    state.aiState = 'recover';
                                    state.attackCooldown = 0;
                                }

                                // Set direction
                                if (Math.abs(ldx) > Math.abs(ldy)) {
                                    state.direction = ldx > 0 ? 'right' : 'left';
                                } else {
                                    state.direction = ldy > 0 ? 'down' : 'up';
                                }
                            } else {
                                // Lunge complete or timeout
                                state.aiState = 'recover';
                                state.attackCooldown = 0;
                            }
                            break;

                        case 'recover':
                            // Recovery period after attack
                            state.attackCooldown++;
                            state.moving = false;
                            if (state.attackCooldown > 45) { // 0.75 second recovery
                                if (distToPlayer <= visionRadius) {
                                    state.aiState = 'chase';
                                } else {
                                    state.aiState = 'return';
                                }
                                state.attackCooldown = 0;
                            }
                            break;

                        case 'return':
                            // Check if back at start position
                            const distToHome = Math.hypot(state.returnX - state.x, state.returnY - state.y);
                            if (distToHome < chaseSpeed) {
                                state.x = state.returnX;
                                state.y = state.returnY;
                                state.aiState = 'idle';
                            }
                            // If player gets close again while returning, chase
                            if (distToPlayer <= visionRadius * 0.75) {
                                state.aiState = 'chase';
                            }
                            break;
                    }

                    // Handle movement based on AI state (chase and return)
                    if (state.aiState === 'chase' || state.aiState === 'return') {
                        let targetX, targetY;
                        if (state.aiState === 'chase') {
                            // Convert player position to unscaled coords
                            targetX = player.x / TILE_SCALE;
                            targetY = player.y / TILE_SCALE;
                        } else {
                            // Return position is already in unscaled coords
                            targetX = state.returnX;
                            targetY = state.returnY;
                        }

                        const dx = targetX - state.x;
                        const dy = targetY - state.y;
                        const dist = Math.hypot(dx, dy);

                        // Convert chase speed to unscaled coords
                        // Apply slowdown if timer is active
                        let effectiveSpeed = chaseSpeed;
                        if (state.slowdownTimer > 0) {
                            effectiveSpeed = chaseSpeed * (1 - slowdownPercent / 100);
                        }
                        const unscaledChaseSpeed = effectiveSpeed / TILE_SCALE;

                        if (dist > unscaledChaseSpeed) {
                            // Normalize movement (in unscaled coords)
                            let moveX = (dx / dist) * unscaledChaseSpeed;
                            let moveY = (dy / dist) * unscaledChaseSpeed;

                            // Scale up for collision checks
                            const newScaledX = (state.x + moveX) * TILE_SCALE;
                            const newScaledY = (state.y + moveY) * TILE_SCALE;

                            // Collision-aware movement - try full move, then axis by axis
                            if (!checkCollision(newScaledX, newScaledY, npcW, npcH) &&
                                !checkNPCPlayerCollision(newScaledX, newScaledY, i)) {
                                state.x += moveX;
                                state.y += moveY;
                                state.moving = true;
                            } else {
                                // Try X-only movement
                                const xOnlyScaledX = (state.x + moveX) * TILE_SCALE;
                                const xOnlyScaledY = state.y * TILE_SCALE;
                                if (Math.abs(moveX) > 0.1 &&
                                    !checkCollision(xOnlyScaledX, xOnlyScaledY, npcW, npcH) &&
                                    !checkNPCPlayerCollision(xOnlyScaledX, xOnlyScaledY, i)) {
                                    state.x += moveX;
                                    state.moving = true;
                                }
                                // Try Y-only movement
                                else {
                                    const yOnlyScaledX = state.x * TILE_SCALE;
                                    const yOnlyScaledY = (state.y + moveY) * TILE_SCALE;
                                    if (Math.abs(moveY) > 0.1 &&
                                        !checkCollision(yOnlyScaledX, yOnlyScaledY, npcW, npcH) &&
                                        !checkNPCPlayerCollision(yOnlyScaledX, yOnlyScaledY, i)) {
                                        state.y += moveY;
                                        state.moving = true;
                                    } else {
                                        state.moving = false;
                                    }
                                }
                            }

                            // Set direction based on target
                            if (Math.abs(dx) > Math.abs(dy)) {
                                state.direction = dx > 0 ? 'right' : 'left';
                            } else {
                                state.direction = dy > 0 ? 'down' : 'up';
                            }
                        } else {
                            state.moving = false;
                        }
                    } else if (state.aiState === 'idle' || state.aiState === 'recover') {
                        state.moving = false;
                    }

                    // Update animation for enemy (only when not idle - idle uses normal path anim)
                    if (state.aiState !== 'idle') {
                        state.frameTimer++;
                        const fps = placed.animSpeed || npc.fps || 8;
                        const animSpeed = Math.max(1, Math.round(60 / fps));
                        if (state.frameTimer >= animSpeed) {
                            state.frameTimer = 0;
                            state.frame = (state.frame + 1) % 4;
                        }
                        return; // Skip normal path movement when chasing/attacking/returning
                    }
                    // If idle, fall through to normal path movement (patrol behavior)
                }

                // Skip movement if not triggered or no path
                if (!state.triggered || path.length === 0) {
                    state.moving = false;
                    return;
                }

                // Get current waypoint target
                const waypoint = path[state.currentWaypoint];
                if (!waypoint) {
                    // Reset to start
                    state.currentWaypoint = 0;
                    return;
                }

                state.targetX = waypoint.x * gridSize;
                state.targetY = waypoint.y * gridSize;

                // Calculate direction to target
                const dx = state.targetX - state.x;
                const dy = state.targetY - state.y;
                const dist = Math.hypot(dx, dy);

                // Check if currently idling at a waypoint
                if (state.idleUntil > 0) {
                    if (performance.now() < state.idleUntil) {
                        // Still idling - don't move, but keep animating
                        state.moving = false;
                        // Update animation while idling (use per-NPC animation speed)
                        state.frameTimer++;
                        const idleFps = placed.animSpeed || npc.fps || 8;
                        const idleAnimSpeed = Math.max(1, Math.round(60 / idleFps));
                        if (state.frameTimer >= idleAnimSpeed) {
                            state.frameTimer = 0;
                            state.frame = (state.frame + 1) % 4;
                        }
                        return;
                    } else {
                        // Idle complete - advance to next waypoint
                        state.idleUntil = 0;
                        state.waypointAnimation = '';
                        state.currentWaypoint++;

                        // Check if path complete after advancing
                        if (state.currentWaypoint >= path.length) {
                            if (placed.trigger === 'loop') {
                                state.currentWaypoint = 0;
                                state.x = placed.x * gridSize;
                                state.y = placed.y * gridSize;
                            } else {
                                state.triggered = false;
                                state.currentWaypoint = 0;
                                state.x = placed.x * gridSize;
                                state.y = placed.y * gridSize;
                            }
                        }
                        return; // Start moving to next waypoint on next frame
                    }
                }

                if (dist < speed) {
                    // Reached waypoint
                    state.x = state.targetX;
                    state.y = state.targetY;

                    // Check for waypoint properties (idle time, animation)
                    const currentWp = path[state.currentWaypoint];
                    let idleTime = currentWp?.idleTime || 0;
                    const wpAnim = currentWp?.animation || '';

                    // If animation is set but not "walk", ensure minimum idle time
                    if (wpAnim && wpAnim !== 'walk' && wpAnim !== '' && idleTime <= 0) {
                        idleTime = 2; // Default 2 seconds if animation set but no duration
                    }

                    if (idleTime > 0 && state.idleUntil === 0) {
                        // Start idling/performing action at this waypoint
                        state.idleUntil = performance.now() + (idleTime * 1000);
                        state.waypointAnimation = wpAnim;
                        state.moving = false;
                        // Don't advance waypoint - will advance after idle completes
                        return;
                    }

                    state.currentWaypoint++;

                    // Check if path complete
                    if (state.currentWaypoint >= path.length) {
                        if (placed.trigger === 'loop') {
                            // Return to start position, then repeat path
                            state.currentWaypoint = 0;
                            state.x = placed.x * gridSize;
                            state.y = placed.y * gridSize;
                        } else {
                            // One-shot trigger - stop and reset
                            state.triggered = false;
                            state.currentWaypoint = 0;
                            state.x = placed.x * gridSize;
                            state.y = placed.y * gridSize;
                        }
                    }
                    state.moving = false;
                } else {
                    // Move towards waypoint
                    const moveX = (dx / dist) * speed;
                    const moveY = (dy / dist) * speed;
                    const newX = state.x + moveX;
                    const newY = state.y + moveY;

                    // Check if NPC would collide with player
                    if (checkNPCPlayerCollision(newX, newY, i)) {
                        // Stop and wait for player to move
                        state.moving = false;
                        // Still face the direction of movement
                        if (Math.abs(dx) > Math.abs(dy)) {
                            state.direction = dx > 0 ? 'right' : 'left';
                        } else {
                            state.direction = dy > 0 ? 'down' : 'up';
                        }
                    } else {
                        // No collision, proceed with movement
                        state.moving = true;
                        state.x = newX;
                        state.y = newY;

                        // Set direction based on movement
                        if (Math.abs(dx) > Math.abs(dy)) {
                            state.direction = dx > 0 ? 'right' : 'left';
                        } else {
                            state.direction = dy > 0 ? 'down' : 'up';
                        }
                    }
                }

                // Update animation using per-NPC animation speed
                state.frameTimer++;
                const fps = placed.animSpeed || npc.fps || 8;
                const animSpeed = Math.max(1, Math.round(60 / fps)); // Convert fps to frame delay
                if (state.frameTimer >= animSpeed) {
                    state.frameTimer = 0;
                    state.frame = (state.frame + 1) % 4;
                }
            });
        }

        // Offscreen canvas for lighting effects
        let lightCanvas = null;
        let lightCtx = null;

        // Audio context for playback
        let audioContext = null;
        let soundBuffers = {}; // soundIndex -> AudioBuffer
        let soundsDecoding = {}; // Track sounds currently being decoded
        let decodeQueue = []; // Queue of sounds waiting to decode
        let isDecoding = false; // Currently decoding a sound
        const DECODE_DELAY = 500; // ms between each decode (give iPad breathing room)
        let gameStartTime = 0; // Track when game started for sound delay
        const SOUND_STARTUP_DELAY = 1500; // Wait 1.5 seconds before starting ambient sounds

        // Walk sound timing
        let lastWalkSoundTime = 0;

        // Ambient sounds currently playing
        let ambientSounds = {}; // "x,y" -> { source, gainNode, playing }

        // Debug flags
        let showLayers = false; // L key to toggle layer debug

        // Initialize audio context on first user interaction (LAZY - don't decode all sounds)
        function initAudio() {
            if (audioContext) {
                // iOS requires resume after user gesture
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                return;
            }
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            // iOS may start suspended - resume it
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            console.log('Audio context initialized (lazy mode - sounds decode on first play)');
            console.log('Sounds available:', soundsData.length);
            console.log('Tile sounds:', Object.keys(tileSounds).length);
            console.log('Player sounds:', playerSoundsData);
        }

        // Queue a sound for decoding (one at a time with delays for iPad)
        function decodeSound(idx, callback) {
            // Already decoded
            if (soundBuffers[idx]) {
                if (callback) callback(soundBuffers[idx]);
                return;
            }
            // Already in queue or decoding
            if (soundsDecoding[idx]) return;

            const sound = soundsData[idx];
            if (!sound || !sound.data) {
                console.warn('No sound data for index', idx);
                return;
            }

            // Mark as queued and add to queue
            soundsDecoding[idx] = true;
            decodeQueue.push({ idx, callback });
            processDecodeQueue();
        }

        // Process decode queue one at a time with delays
        function processDecodeQueue() {
            if (isDecoding || decodeQueue.length === 0) return;

            isDecoding = true;
            const { idx, callback } = decodeQueue.shift();
            const sound = soundsData[idx];

            try {
                const base64 = sound.data.split(',')[1];
                const binary = atob(base64);
                const bytes = Uint8Array.from(binary, c => c.charCodeAt(0));
                const audioBuffer = bytes.buffer.slice(0);

                audioContext.decodeAudioData(audioBuffer, (buffer) => {
                    soundBuffers[idx] = buffer;
                    soundsDecoding[idx] = false;
                    console.log('Sound', idx, sound.name, 'decoded (' + decodeQueue.length + ' in queue)');
                    if (callback) callback(buffer);

                    // Wait before processing next sound
                    setTimeout(() => {
                        isDecoding = false;
                        processDecodeQueue();
                    }, DECODE_DELAY);
                }, (err) => {
                    console.error('Failed to decode sound', idx, err);
                    soundsDecoding[idx] = false;
                    setTimeout(() => {
                        isDecoding = false;
                        processDecodeQueue();
                    }, DECODE_DELAY);
                });
            } catch (e) {
                console.error('Error decoding sound', idx, ':', e.message);
                soundsDecoding[idx] = false;
                setTimeout(() => {
                    isDecoding = false;
                    processDecodeQueue();
                }, DECODE_DELAY);
            }
        }

        // Play a sound with optional pitch variation (lazy decode on first play)
        function playSound(soundIndex, volume = 1, pitchVariation = 0) {
            if (!audioContext) {
                console.log('playSound: No audio context');
                return;
            }
            if (soundIndex < 0 || soundIndex >= soundsData.length) {
                return;
            }

            // Lazy decode: if buffer not ready, decode it first then play
            if (!soundBuffers[soundIndex]) {
                decodeSound(soundIndex, (buffer) => {
                    // Play after decode completes
                    playSoundBuffer(buffer, volume, pitchVariation);
                });
                return;
            }

            return playSoundBuffer(soundBuffers[soundIndex], volume, pitchVariation);
        }

        // Internal: play an already-decoded buffer
        function playSoundBuffer(buffer, volume, pitchVariation) {
            if (!buffer) return;

            const source = audioContext.createBufferSource();
            source.buffer = buffer;

            // Apply pitch variation
            if (pitchVariation > 0) {
                source.playbackRate.value = 1 + (Math.random() - 0.5) * pitchVariation * 2;
            }

            const gainNode = audioContext.createGain();
            gainNode.gain.value = volume;

            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start();

            return { source, gainNode };
        }

        // Update ambient sounds based on player position with smooth fading
        function updateAmbientSounds() {
            if (!audioContext) return;

            // Delay ambient sounds on startup to prevent iPad crashes
            if (gameStartTime && Date.now() - gameStartTime < SOUND_STARTUP_DELAY) {
                return;
            }

            const tileSize = gridSize * TILE_SCALE;
            const playerTileX = Math.floor(player.x / tileSize);
            const playerTileY = Math.floor(player.y / tileSize);
            const fadeTime = 0.1; // Smooth transition time in seconds

            Object.keys(tileSounds).forEach(key => {
                // Filter by current map (keys are "mapName:x,y" or legacy "x,y")
                let sx, sy;
                if (key.includes(':')) {
                    // New format: "mapName:x,y"
                    const parts = key.split(':');
                    if (parts[0] !== currentGameMap) return; // Skip sounds on other maps
                    [sx, sy] = parts[1].split(',').map(Number);
                } else {
                    // Legacy format: "x,y" (treat as main map)
                    if (currentGameMap !== 'main') return;
                    [sx, sy] = key.split(',').map(Number);
                }
                const ts = tileSounds[key];
                let soundBuffer = soundBuffers[ts.soundIndex];

                // Lazy decode: if not loaded yet, trigger decode (will be available next frame)
                if (!soundBuffer && ts.soundIndex >= 0 && ts.soundIndex < soundsData.length) {
                    decodeSound(ts.soundIndex);
                    return;
                }
                if (!soundBuffer) return;

                // Calculate distance from player (in tiles)
                const dx = playerTileX - sx;
                const dy = playerTileY - sy;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Get fade percent (default 50% = half the radius is fade zone)
                const fadePercent = ts.fadePercent !== undefined ? ts.fadePercent : 0.5;

                // Calculate volume based on distance with fade zone
                let targetVolume = 0;
                if (dist <= ts.radius) {
                    // Inside radius - calculate fade
                    const fadeStartDist = ts.radius * (1 - fadePercent); // Where fade begins
                    if (dist <= fadeStartDist) {
                        // Inside inner zone - full volume
                        targetVolume = ts.volume;
                    } else {
                        // In fade zone - linear fade from full to zero
                        const fadeZoneSize = ts.radius - fadeStartDist;
                        const distInFadeZone = dist - fadeStartDist;
                        targetVolume = ts.volume * (1 - distInFadeZone / fadeZoneSize);
                    }
                }

                // Start sound if not playing yet (for looping sounds, keep them running)
                if (!ambientSounds[key]?.playing && ts.loop) {
                    const source = audioContext.createBufferSource();
                    source.buffer = soundBuffer;
                    source.loop = true;

                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = 0; // Start silent

                    source.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    source.start();

                    ambientSounds[key] = { source, gainNode, playing: true };
                }

                // For non-looping sounds, only start when in range
                if (!ambientSounds[key]?.playing && !ts.loop && targetVolume > 0) {
                    const source = audioContext.createBufferSource();
                    source.buffer = soundBuffer;
                    source.loop = false;

                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = targetVolume;

                    source.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    source.start();

                    ambientSounds[key] = { source, gainNode, playing: true };

                    source.onended = () => {
                        if (ambientSounds[key]) {
                            ambientSounds[key].playing = false;
                        }
                    };
                }

                // Smoothly adjust volume for playing sounds
                if (ambientSounds[key]?.playing && ambientSounds[key].gainNode) {
                    const gain = ambientSounds[key].gainNode.gain;
                    // Use linearRampToValueAtTime for smooth transitions
                    gain.cancelScheduledValues(audioContext.currentTime);
                    gain.setValueAtTime(gain.value, audioContext.currentTime);
                    gain.linearRampToValueAtTime(Math.max(0, targetVolume), audioContext.currentTime + fadeTime);
                }
            });
        }

        // === LIGHTING RENDERING (Classic 2D - no WebGL) ===
        function renderLighting() {
            const lighting = lightingSettingsData;

            // Get lighting values - use cycle if enabled, otherwise use darkness slider
            let preset;
            if (dayCycleEnabled) {
                preset = currentLighting;
            } else {
                // Use manual darkness slider (0-100 maps to 0-0.95 alpha)
                const alpha = manualDarkness / 100 * 0.95;
                preset = { r: 0, g: 0, b: 20, a: alpha };
            }

            // Skip if no darkness and no player light
            if (preset.a === 0 && !lighting.playerLight) return;

            // Create/resize offscreen canvas for lighting
            if (!lightCanvas || lightCanvas.width !== canvas.width || lightCanvas.height !== canvas.height) {
                lightCanvas = document.createElement('canvas');
                lightCanvas.width = canvas.width;
                lightCanvas.height = canvas.height;
                lightCtx = lightCanvas.getContext('2d');
            }

            // Clear and fill with ambient darkness
            lightCtx.clearRect(0, 0, lightCanvas.width, lightCanvas.height);
            lightCtx.fillStyle = 'rgba(' + preset.r + ',' + preset.g + ',' + preset.b + ',' + preset.a + ')';
            lightCtx.fillRect(0, 0, lightCanvas.width, lightCanvas.height);

            // Cut out light circles using destination-out compositing
            lightCtx.globalCompositeOperation = 'destination-out';

            const tileSize = gridSize * TILE_SCALE;
            const camX = Math.floor(player.x - canvas.width / (2 * cameraZoom) + player.width / 2);
            const camY = Math.floor(player.y - canvas.height / (2 * cameraZoom) + player.height / 2);

            // Player torch light (always follows player)
            if (lighting.playerLight) {
                const px = (player.x - camX + player.width / 2) * cameraZoom;
                const py = (player.y - camY + player.height / 2) * cameraZoom;
                const radius = lighting.playerLightRadius * tileSize * cameraZoom;

                const gradient = lightCtx.createRadialGradient(px, py, 0, px, py, radius);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.5, 'rgba(255,255,255,0.6)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                lightCtx.fillStyle = gradient;
                lightCtx.beginPath();
                lightCtx.arc(px, py, radius, 0, Math.PI * 2);
                lightCtx.fill();
            }

            // Cut out placed point lights
            const mapPrefix = currentGameMap + ':';
            Object.keys(pointLights).forEach(key => {
                if (!key.startsWith(mapPrefix)) return;

                const coords = key.split(':')[1];
                const [lx, ly] = coords.split(',').map(Number);
                const light = pointLights[key];

                const screenX = ((lx * tileSize + tileSize / 2) - camX) * cameraZoom;
                const screenY = ((ly * tileSize + tileSize / 2) - camY) * cameraZoom;
                let radius = light.radius * tileSize * cameraZoom;

                // Optional flicker effect
                if (light.flicker) {
                    radius *= 0.95 + Math.random() * 0.1;
                }

                const gradient = lightCtx.createRadialGradient(screenX, screenY, 0, screenX, screenY, radius);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.6, 'rgba(255,255,255,0.5)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                lightCtx.fillStyle = gradient;
                lightCtx.beginPath();
                lightCtx.arc(screenX, screenY, radius, 0, Math.PI * 2);
                lightCtx.fill();
            });

            // Reset composite operation and draw darkness over game
            lightCtx.globalCompositeOperation = 'source-over';
            ctx.drawImage(lightCanvas, 0, 0);
        }

        // Initialize audio on first user interaction (key or touch)
        document.addEventListener('keydown', () => initAudio(), { once: true });
        document.addEventListener('touchstart', () => initAudio(), { once: true });
        document.addEventListener('click', () => initAudio(), { once: true });

        // Adjustable settings
        let playerScale = 1.7;
        let animSpeed = 7; // Lower = faster animation

        // Tile scale - how big to render tiles (zoom level)
        const TILE_SCALE = 4;

        // Camera zoom (1 = normal, 2 = 2x closer, etc)
        let cameraZoom = 1.0;

        // Debug panel toggle and slider handlers
        document.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') {
                document.getElementById('debugPanel').classList.toggle('visible');
            }
            if (e.key === 's' || e.key === 'S') {
                showSounds = !showSounds;
                console.log('Sound debug:', showSounds ? 'ON' : 'OFF');
            }
            if (e.key === 'l' || e.key === 'L') {
                showLayers = !showLayers;
                console.log('Layer debug:', showLayers ? 'ON' : 'OFF');
            }
        });

        document.getElementById('scaleSlider').addEventListener('input', (e) => {
            playerScale = parseFloat(e.target.value);
            document.getElementById('scaleVal').textContent = playerScale.toFixed(1);
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            player.speed = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = player.speed.toFixed(1);
        });

        document.getElementById('animSlider').addEventListener('input', (e) => {
            animSpeed = parseInt(e.target.value);
            document.getElementById('animVal').textContent = animSpeed;
        });

        document.getElementById('widthSlider').addEventListener('input', (e) => {
            player.width = parseInt(e.target.value);
            document.getElementById('widthVal').textContent = player.width;
        });

        document.getElementById('heightSlider').addEventListener('input', (e) => {
            player.height = parseInt(e.target.value);
            document.getElementById('heightVal').textContent = player.height;
        });

        // Per-direction hitbox sliders
        document.getElementById('hbRangeSlider').addEventListener('input', (e) => {
            playerHitboxRange[hitboxEditDir] = parseInt(e.target.value);
            document.getElementById('hbRangeVal').textContent = e.target.value;
        });
        document.getElementById('hbWidthSlider').addEventListener('input', (e) => {
            playerHitboxWidth[hitboxEditDir] = parseInt(e.target.value);
            document.getElementById('hbWidthVal').textContent = e.target.value;
        });
        document.getElementById('hbOffsetXSlider').addEventListener('input', (e) => {
            playerHitboxOffsetX[hitboxEditDir] = parseInt(e.target.value);
            document.getElementById('hbOffsetXVal').textContent = e.target.value;
        });
        document.getElementById('hbOffsetYSlider').addEventListener('input', (e) => {
            playerHitboxOffsetY[hitboxEditDir] = parseInt(e.target.value);
            document.getElementById('hbOffsetYVal').textContent = e.target.value;
        });

        document.getElementById('zoomSlider').addEventListener('input', (e) => {
            cameraZoom = parseFloat(e.target.value);
            document.getElementById('zoomVal').textContent = cameraZoom.toFixed(1);
        });

        // Lighting controls
        document.getElementById('darknessSlider').addEventListener('input', (e) => {
            manualDarkness = parseInt(e.target.value);
            document.getElementById('darknessVal').textContent = manualDarkness;
        });

        document.getElementById('torchEnabled').addEventListener('change', (e) => {
            lightingSettingsData.playerLight = e.target.checked;
            console.log('Player torch:', e.target.checked ? 'ON' : 'OFF');
        });

        document.getElementById('torchRadiusSlider').addEventListener('input', (e) => {
            lightingSettingsData.playerLightRadius = parseInt(e.target.value);
            document.getElementById('torchRadiusVal').textContent = e.target.value;
        });

        document.getElementById('cycleEnabled').addEventListener('change', (e) => {
            dayCycleEnabled = e.target.checked;
            lastCycleUpdate = Date.now(); // Reset timer
            if (!dayCycleEnabled) {
                document.getElementById('timeDisplay').textContent = '';
            }
        });

        document.getElementById('dayLengthSlider').addEventListener('input', (e) => {
            const minutes = parseFloat(e.target.value);
            dayLength = minutes * 60; // convert to seconds
            document.getElementById('dayLengthVal').textContent = minutes;
        });

        function copySettings() {
            const settings = \`Player Settings:
  scale: \${playerScale}
  speed: \${player.speed}
  animSpeed: \${animSpeed}
  width: \${player.width}
  height: \${player.height}
  cameraZoom: \${cameraZoom}\`;
            navigator.clipboard.writeText(settings).then(() => {
                alert('Settings copied to clipboard!');
            });
        }

        // Find starting position - ONLY used for initial game start (not door transitions)
        // This uses the global playerPreviewPos from the editor
        function findStartPos() {
            const tileSize = gridSize * TILE_SCALE;

            console.log('findStartPos called - INITIAL GAME START on map:', currentGameMap);

            // Check if returning from external area (3D world)
            const returnInfoStr = localStorage.getItem('externalDoorReturn');
            if (returnInfoStr) {
                try {
                    const returnInfo = JSON.parse(returnInfoStr);
                    // Only use if less than 5 minutes old (in case of stale data)
                    if (Date.now() - returnInfo.timestamp < 5 * 60 * 1000) {
                        console.log('[EXTERNAL RETURN] Spawning at door:', returnInfo);
                        // Clear the return info so we don't use it again
                        localStorage.removeItem('externalDoorReturn');
                        // Switch to the return map if different
                        if (returnInfo.map && returnInfo.map !== currentGameMap) {
                            currentGameMap = returnInfo.map;
                            const mapData = mapsData[returnInfo.map];
                            if (mapData) {
                                layers = mapData.layers || layers;
                                tileCollisions = mapData.tileCollisions || {};
                                collisionMasks = mapData.collisionMasks || {};
                                mapCols = mapData.mapCols || mapCols;
                                mapRows = mapData.mapRows || mapRows;
                            }
                        }
                        // Spawn at the door position
                        player.x = returnInfo.x * tileSize + tileSize / 2;
                        player.y = returnInfo.y * tileSize + tileSize / 2;
                        console.log('[EXTERNAL RETURN] Player spawned at:', player.x, player.y);
                        return;
                    } else {
                        console.log('[EXTERNAL RETURN] Return info too old, ignoring');
                        localStorage.removeItem('externalDoorReturn');
                    }
                } catch (e) {
                    console.error('[EXTERNAL RETURN] Failed to parse return info:', e);
                    localStorage.removeItem('externalDoorReturn');
                }
            }

            // Use global playerPreviewPos for initial spawn
            if (projectData.playerPreviewPos && (projectData.playerPreviewPos.x !== undefined)) {
                const pos = projectData.playerPreviewPos;
                player.x = pos.x * tileSize + tileSize / 2;
                player.y = pos.y * tileSize + tileSize / 2;
                // Store initial spawn for respawn on death
                initialSpawnX = player.x;
                initialSpawnY = player.y;
                initialSpawnMap = projectData.spawnMapName || currentGameMap;
                console.log('Initial spawn: tile', pos.x, pos.y, '-> pixel', player.x, player.y);
                return;
            }

            console.log('No playerPreviewPos found, using fallback');
            // Fallback: find first tile without collision
            const layer = layers[0];
            if (!layer) {
                console.error('No layers found for starting position');
                return;
            }
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y] && layer[y][x];
                    if (cell && cell.type === 'tile') {
                        const key = cell.x + ',' + cell.y;
                        if (!tileCollisions[key]) {
                            player.x = x * tileSize + tileSize / 2;
                            player.y = y * tileSize + tileSize / 2;
                            console.log('Start position: tile', x, y);
                            return;
                        }
                    }
                }
            }
            // If no safe tile, just start at first tile
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y] && layer[y][x];
                    if (cell) {
                        player.x = x * tileSize + tileSize / 2;
                        player.y = y * tileSize + tileSize / 2;
                        console.log('Start position (fallback): tile', x, y);
                        return;
                    }
                }
            }
        }

        // Camera
        const camera = { x: 0, y: 0 };

        // Input
        const keys = {};

        document.addEventListener('keydown', e => {
            keys[e.key] = true;

            if (e.key === 'Escape') window.close();
            if (e.key === 'c' || e.key === 'C') showCollision = !showCollision;
            if (e.key === 'h' || e.key === 'H') toggleAllUI();
            // Interact key (A) - for dialogs, doors, and NPCs
            if ((e.key === 'a' || e.key === 'A') && !player.attacking) {
                handleInteract();
            }
            // Attack key (Space)
            if (e.key === ' ' && !player.attacking) {
                player.attacking = true;
                player.attackAnim = true;
                player.attackFrame = 0;
                player.attackFrameTimer = 0;
                player.attackTimer = 30; // Longer for animation to play
                player.attackHitNpcs = {}; // Reset hit tracking for new attack
                // Play attack sound
                if (playerSoundsData.attack && playerSoundsData.attack.soundIndex >= 0) {
                    playSound(playerSoundsData.attack.soundIndex, playerSoundsData.attack.volume || 0.7, 0);
                }
            }
        });
        document.addEventListener('keyup', e => keys[e.key] = false);

        // Virtual Joystick controls - appears where user touches left half
        const joystickBase = document.getElementById('joystickBase');
        const joystickThumb = document.getElementById('joystickThumb');
        const leftTouchZone = document.getElementById('leftTouchZone');
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickTouchId = null;
        const joystickMaxDist = 40;
        const joystickDeadzone = 10;

        function updateJoystick(touchX, touchY) {
            const dx = touchX - joystickCenter.x;
            const dy = touchY - joystickCenter.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Clamp to max distance
            let clampedX = dx;
            let clampedY = dy;
            if (dist > joystickMaxDist) {
                clampedX = (dx / dist) * joystickMaxDist;
                clampedY = (dy / dist) * joystickMaxDist;
            }

            // Move thumb (relative to joystick center which is 60px from edge)
            joystickThumb.style.left = (60 + clampedX) + 'px';
            joystickThumb.style.top = (60 + clampedY) + 'px';

            // Reset keys
            keys['ArrowUp'] = false;
            keys['ArrowDown'] = false;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;

            // Set keys based on direction (if outside deadzone)
            if (dist > joystickDeadzone) {
                const angle = Math.atan2(dy, dx);
                // Right: -45 to 45 degrees
                if (angle > -Math.PI/4 && angle < Math.PI/4) keys['ArrowRight'] = true;
                // Down: 45 to 135 degrees
                if (angle > Math.PI/4 && angle < 3*Math.PI/4) keys['ArrowDown'] = true;
                // Left: 135 to -135 degrees
                if (angle > 3*Math.PI/4 || angle < -3*Math.PI/4) keys['ArrowLeft'] = true;
                // Up: -135 to -45 degrees
                if (angle > -3*Math.PI/4 && angle < -Math.PI/4) keys['ArrowUp'] = true;
            }
        }

        function resetJoystick() {
            joystickActive = false;
            joystickTouchId = null;
            joystickBase.classList.remove('active');
            joystickThumb.style.left = '50%';
            joystickThumb.style.top = '50%';
            joystickThumb.style.transform = 'translate(-50%, -50%)';
            keys['ArrowUp'] = false;
            keys['ArrowDown'] = false;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        }

        // Touch on left half of screen - show joystick at touch position
        leftTouchZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            joystickTouchId = touch.identifier;
            joystickActive = true;

            // Position joystick centered on touch
            const x = touch.clientX - 60;
            const y = touch.clientY - 60;
            joystickBase.style.left = x + 'px';
            joystickBase.style.top = y + 'px';
            joystickBase.classList.add('active');

            // Set center for movement calculation
            joystickCenter = { x: touch.clientX, y: touch.clientY };
            joystickThumb.style.left = '50%';
            joystickThumb.style.top = '50%';
            joystickThumb.style.transform = 'translate(-50%, -50%)';
        }, { passive: false });

        leftTouchZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!joystickActive) return;
            // Find our touch
            for (let touch of e.touches) {
                if (touch.identifier === joystickTouchId) {
                    updateJoystick(touch.clientX, touch.clientY);
                    break;
                }
            }
        }, { passive: false });

        leftTouchZone.addEventListener('touchend', (e) => {
            // Check if our touch ended
            for (let touch of e.changedTouches) {
                if (touch.identifier === joystickTouchId) {
                    resetJoystick();
                    break;
                }
            }
        });
        leftTouchZone.addEventListener('touchcancel', resetJoystick);

        // Attack button (mobile)
        document.getElementById('attackBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!player.attacking) {
                player.attacking = true;
                player.attackAnim = true;
                player.attackFrame = 0;
                player.attackFrameTimer = 0;
                player.attackTimer = 30;
                if (playerSoundsData.attack && playerSoundsData.attack.soundIndex >= 0) {
                    playSound(playerSoundsData.attack.soundIndex, playerSoundsData.attack.volume || 0.7, 0);
                }
            }
        }, { passive: false });
        document.getElementById('attackBtn').addEventListener('click', () => {
            if (!player.attacking) {
                player.attacking = true;
                player.attackAnim = true;
                player.attackFrame = 0;
                player.attackFrameTimer = 0;
                player.attackTimer = 30;
                if (playerSoundsData.attack && playerSoundsData.attack.soundIndex >= 0) {
                    playSound(playerSoundsData.attack.soundIndex, playerSoundsData.attack.volume || 0.7, 0);
                }
            }
        });

        // Interact button (mobile) - for doors, NPCs, and dialogs
        const interactBtn = document.getElementById('interactBtn');
        if (interactBtn) {
            interactBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleInteract();
            }, { passive: false });
            interactBtn.addEventListener('click', () => {
                handleInteract();
            });
        }

        function handleInteract() {
            // If dialog is active, advance it
            if (activeDialog) {
                advanceDialog();
                return;
            }
            // Check for items first, then animated props, then dialogs, then triggers
            if (!checkItemInteraction()) {
                if (!checkAnimPropInteraction()) {
                    if (!checkDialogInteraction()) {
                        checkTriggerInteraction('interact');
                    }
                }
            }
        }

        // Check for nearby interactive items and trigger their animation
        function checkItemInteraction() {
            const tileSize = gridSize * TILE_SCALE;
            const playerTileX = Math.floor((player.x + player.width / 2) / tileSize);
            const playerTileY = Math.floor((player.y + player.height * 0.8) / tileSize);

            for (let i = 0; i < placedItemsData.length; i++) {
                const placed = placedItemsData[i];
                if (placed.mapName && placed.mapName !== currentGameMap) continue;

                const state = itemStates[i];
                if (!state || state.used || state.animating) continue;

                // Check if player is adjacent to item
                const dx = Math.abs(placed.x - playerTileX);
                const dy = Math.abs(placed.y - playerTileY);
                if (dx <= 1 && dy <= 1) {
                    // Trigger item animation
                    state.animating = true;
                    state.frame = 0;
                    state.frameTimer = 0;
                    // Player does interact animation
                    if (player.interacting !== undefined) {
                        player.interacting = true;
                        player.interactFrame = 0;
                    }
                    console.log('[ITEM] Interacted with item at', placed.x, placed.y);
                    // Broadcast to other players
                    if (mpSocket && mpConnected) {
                        mpSocket.send(JSON.stringify({
                            type: 'itemInteract',
                            itemIndex: i,
                            x: placed.x,
                            y: placed.y,
                            mapName: placed.mapName || currentGameMap
                        }));
                    }
                    return true;
                }
            }
            return false;
        }

        // Update item animations each frame
        function updateItemAnimations() {
            for (let i = 0; i < placedItemsData.length; i++) {
                const placed = placedItemsData[i];
                if (placed.mapName && placed.mapName !== currentGameMap) continue;

                const state = itemStates[i];
                if (!state || !state.animating) continue;

                const item = itemsData[placed.itemIndex];
                if (!item || !item.frames || item.frames.length === 0) continue;

                const fps = item.fps || 8;
                const animSpeed = Math.max(1, Math.round(60 / fps));

                state.frameTimer++;
                if (state.frameTimer >= animSpeed) {
                    state.frameTimer = 0;
                    state.frame++;

                    // Animation complete
                    if (state.frame >= item.frames.length) {
                        state.animating = false;
                        state.used = true;
                        state.frame = item.frames.length - 1; // Stay on last frame
                        console.log('[ITEM] Animation complete, item used');
                    }
                }
            }
        }

        // Check for nearby interactive animated props and trigger their animation
        function checkAnimPropInteraction() {
            const tileSize = gridSize * TILE_SCALE;
            const playerTileX = Math.floor((player.x + player.width / 2) / tileSize);
            const playerTileY = Math.floor((player.y + player.height * 0.8) / tileSize);

            // Search layers for interactive animated props near player
            for (let li = 0; li < layers.length; li++) {
                if (!layers[li]) continue;

                // Check tiles around player
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const tx = playerTileX + dx;
                        const ty = playerTileY + dy;

                        if (ty < 0 || ty >= layers[li].length) continue;
                        if (!layers[li][ty] || tx < 0 || tx >= layers[li][ty].length) continue;

                        const cell = layers[li][ty][tx];
                        if (!cell || (cell.type !== 'animTile' && cell.type !== 'animTrunk') || cell.propIndex === undefined) continue;

                        const propData = animatedPropsData[cell.propIndex];
                        if (!propData || propData.type !== 'interactive') continue;

                        // Use origin position for multi-tile props
                        const originX = tx - (cell.offsetX || 0);
                        const originY = ty - (cell.offsetY || 0);
                        const key = originX + ',' + originY + ',' + li;

                        // Check if already used
                        if (interactivePropStates[key] && interactivePropStates[key].used) continue;

                        // Initialize state if needed
                        if (!interactivePropStates[key]) {
                            interactivePropStates[key] = { used: false, animating: false, frame: 0, gaveItem: false };
                        }

                        // Skip if already animating
                        if (interactivePropStates[key].animating) continue;

                        // Trigger animation!
                        interactivePropStates[key].animating = true;
                        interactivePropStates[key].frame = 0;
                        console.log('[ANIM PROP] Interacted with', propData.name, 'at', originX, originY);

                        // Give item if configured
                        if (propData.giveItem && propData.giveItemIndex >= 0 && propData.giveItemIndex < itemsData.length) {
                            const givenItem = itemsData[propData.giveItemIndex];
                            console.log('[ANIM PROP] Giving item:', givenItem?.name || 'Item ' + propData.giveItemIndex);
                            // TODO: Add to player inventory (for now just log)
                            interactivePropStates[key].gaveItem = true;
                        }

                        // Broadcast to other players
                        if (mpSocket && mpConnected) {
                            mpSocket.send(JSON.stringify({
                                type: 'propInteract',
                                key: key,
                                originX: originX,
                                originY: originY,
                                layer: li,
                                mapName: currentGameMap
                            }));
                        }

                        return true;
                    }
                }
            }
            return false;
        }

        // Update interactive animated prop animations each frame
        function updateAnimPropInteractions() {
            for (const key in interactivePropStates) {
                const state = interactivePropStates[key];
                if (!state.animating) continue;

                // Parse key to get prop info
                const parts = key.split(',');
                const originX = parseInt(parts[0]);
                const originY = parseInt(parts[1]);
                const li = parseInt(parts[2]);

                // Find the prop data from the cell
                if (!layers[li] || !layers[li][originY] || !layers[li][originY][originX]) continue;
                const cell = layers[li][originY][originX];
                if (!cell || cell.propIndex === undefined) continue;

                const propData = animatedPropsData[cell.propIndex];
                if (!propData || !propData.frames || propData.frames.length === 0) continue;

                const fps = propData.fps || 8;
                const frameDelay = Math.max(1, Math.round(60 / fps));

                state.timer = (state.timer || 0) + 1;
                if (state.timer >= frameDelay) {
                    state.timer = 0;
                    state.frame++;

                    // Update the frame timer so rendering uses the correct frame
                    if (!animPropFrameTimers[key]) {
                        animPropFrameTimers[key] = { frame: 0, timer: 0 };
                    }
                    animPropFrameTimers[key].frame = state.frame;

                    // Animation complete
                    if (state.frame >= propData.frames.length) {
                        state.animating = false;
                        state.used = true;
                        state.frame = propData.frames.length - 1;
                        animPropFrameTimers[key].frame = state.frame;
                        console.log('[ANIM PROP] Animation complete');
                    }
                }
            }
        }

        // Pixel-level collision check on ALL layers
        function checkCollision(x, y, w, h) {
            const tileSize = gridSize * TILE_SCALE;
            const pixelScale = tileSize / gridSize;

            // Check corners and edge midpoints
            const points = [
                { x: x, y: y },
                { x: x + w - 1, y: y },
                { x: x, y: y + h - 1 },
                { x: x + w - 1, y: y + h - 1 },
                { x: x + w / 2, y: y },
                { x: x + w / 2, y: y + h - 1 },
                { x: x, y: y + h / 2 },
                { x: x + w - 1, y: y + h / 2 }
            ];

            for (const point of points) {
                const tileX = Math.floor(point.x / tileSize);
                const tileY = Math.floor(point.y / tileSize);

                // Out of bounds = collision
                if (tileX < 0 || tileX >= mapCols || tileY < 0 || tileY >= mapRows) {
                    return true;
                }

                // Check ALL layers for collision
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li];
                    if (!layer) continue;

                    const cell = layer[tileY] && layer[tileY][tileX];
                    if (cell) {
                        // Include tileset index in key for tiles
                        const tilesetIdx = cell.tilesetIndex || 0;
                        const key = cell.type === 'tile'
                            ? tilesetIdx + ':' + cell.x + ',' + cell.y
                            : cell.x + ',' + cell.y;
                        // Use tile collision masks for tiles, prop collision masks for props (by propIndex)
                        let mask = null;
                        let maskOffsetX = 0;
                        let maskOffsetY = 0;

                        if (cell.type === 'prop') {
                            const propIdx = cell.propIndex || 0;
                            const propKey = cell.x + ',' + cell.y;
                            mask = propCollisionMasksAll[propIdx] ? propCollisionMasksAll[propIdx][propKey] : null;
                        } else if (cell.type === 'animTile') {
                            // Animated tile - get collision from prop data
                            const propData = animatedPropsData[cell.propIndex];
                            if (propData && propData.collisionMask) {
                                mask = propData.collisionMask;
                                // For multi-tile props, offset into the mask
                                maskOffsetX = (cell.offsetX || 0) * gridSize;
                                maskOffsetY = (cell.offsetY || 0) * gridSize;
                            }
                        } else {
                            mask = collisionMasks[key];
                        }

                        if (mask) {
                            // Check pixel-level collision (works for both tiles and props)
                            const localX = Math.floor((point.x % tileSize) / pixelScale);
                            const localY = Math.floor((point.y % tileSize) / pixelScale);

                            // Apply offset for multi-tile animated props
                            const maskX = localX + maskOffsetX;
                            const maskY = localY + maskOffsetY;

                            if (maskY >= 0 && maskY < mask.length && mask[maskY]) {
                                if (maskX >= 0 && maskX < mask[maskY].length && mask[maskY][maskX]) {
                                    return true;
                                }
                            }
                        } else if (cell.type === 'tile' && tileCollisions[key]) {
                            // Full tile collision (no mask = solid tile)
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Check collision with all NPCs - uses collision mask bounds or foot hitbox
        function checkNPCCollision(x, y, w, h) {
            const tileSize = gridSize * TILE_SCALE;
            for (let i = 0; i < placedNpcs.length; i++) {
                const placed = placedNpcs[i];
                // Only check NPCs on current map
                if (placed.mapName && placed.mapName !== currentGameMap) continue;

                const state = npcRuntimeState[i];
                if (!state) continue;
                const npc = npcsData[placed.npcIndex];
                if (!npc) continue;

                // Skip collision with enemy NPCs on damage cooldown (lets player escape)
                if (placed.isEnemy && state.damageCooldown > 0) continue;

                let npcX, npcY, npcW, npcH;

                // Use collision mask if available
                if (npc.collisionMask && npc.collisionMask.length > 0) {
                    // Calculate bounds from collision mask
                    let minX = Infinity, maxX = -1, minY = Infinity, maxY = -1;
                    const frameW = npc.frameWidth || gridSize;
                    const frameH = npc.frameHeight || gridSize;
                    for (let py = 0; py < Math.min(frameH, npc.collisionMask.length); py++) {
                        for (let px = 0; px < Math.min(frameW, npc.collisionMask[py]?.length || 0); px++) {
                            if (npc.collisionMask[py][px] === 1) {
                                minX = Math.min(minX, px);
                                maxX = Math.max(maxX, px);
                                minY = Math.min(minY, py);
                                maxY = Math.max(maxY, py);
                            }
                        }
                    }
                    if (maxX >= 0) {
                        // Found collision pixels - use bounds
                        const scaleX = tileSize / frameW;
                        const scaleY = tileSize / frameH;
                        npcX = state.x * TILE_SCALE + minX * scaleX;
                        npcY = state.y * TILE_SCALE + minY * scaleY;
                        npcW = (maxX - minX + 1) * scaleX;
                        npcH = (maxY - minY + 1) * scaleY;
                    } else {
                        // No collision mask pixels drawn - no collision
                        continue;
                    }
                } else {
                    // Default foot hitbox (bottom 33%, 70% width)
                    npcW = tileSize * 0.7;
                    npcH = tileSize * 0.33;
                    npcX = state.x * TILE_SCALE + (tileSize - npcW) / 2;
                    npcY = state.y * TILE_SCALE + tileSize * 0.67;
                }

                // AABB collision check
                if (x < npcX + npcW && x + w > npcX &&
                    y < npcY + npcH && y + h > npcY) {
                    return true;
                }
            }
            return false;
        }

        // Check if NPC at given position would collide with player
        function checkNPCPlayerCollision(npcX, npcY, npcIndex) {
            const tileSize = gridSize * TILE_SCALE;
            const placed = placedNpcs[npcIndex];
            const npc = npcsData[placed?.npcIndex];
            if (!npc) return false;

            let npcHitX, npcHitY, npcW, npcH;

            // Use collision mask if available
            if (npc.collisionMask && npc.collisionMask.length > 0) {
                let minX = Infinity, maxX = -1, minY = Infinity, maxY = -1;
                const frameW = npc.frameWidth || gridSize;
                const frameH = npc.frameHeight || gridSize;
                for (let py = 0; py < Math.min(frameH, npc.collisionMask.length); py++) {
                    for (let px = 0; px < Math.min(frameW, npc.collisionMask[py]?.length || 0); px++) {
                        if (npc.collisionMask[py][px] === 1) {
                            minX = Math.min(minX, px);
                            maxX = Math.max(maxX, px);
                            minY = Math.min(minY, py);
                            maxY = Math.max(maxY, py);
                        }
                    }
                }
                if (maxX >= 0) {
                    const scaleX = tileSize / frameW;
                    const scaleY = tileSize / frameH;
                    npcHitX = npcX * TILE_SCALE + minX * scaleX;
                    npcHitY = npcY * TILE_SCALE + minY * scaleY;
                    npcW = (maxX - minX + 1) * scaleX;
                    npcH = (maxY - minY + 1) * scaleY;
                } else {
                    return false; // No collision mask drawn
                }
            } else {
                // Default foot hitbox
                npcW = tileSize * 0.7;
                npcH = tileSize * 0.33;
                npcHitX = npcX * TILE_SCALE + (tileSize - npcW) / 2;
                npcHitY = npcY * TILE_SCALE + tileSize * 0.67;
            }

            // Player foot hitbox (bottom 1/3)
            const playerW = player.width * 0.7;
            const playerH = player.height / 3;
            const playerHitX = player.x + (player.width - playerW) / 2;
            const playerHitY = player.y + player.height * 2/3;

            // AABB collision check
            return npcHitX < playerHitX + playerW && npcHitX + npcW > playerHitX &&
                   npcHitY < playerHitY + playerH && npcHitY + npcH > playerHitY;
        }

        function update() {
            let dx = 0, dy = 0;
            player.moving = false;

            // Check if player can move (based on attack movement setting)
            let canMove = !player.attacking;
            let moveMultiplier = 1;

            if (player.attacking && playerAttackMovement !== 'stop') {
                if (playerAttackMovement === 'move') {
                    canMove = true; // Full movement during attack
                } else if (playerAttackMovement === 'slide') {
                    canMove = true;
                    // Slide: start at full speed, slow down over attack duration
                    const slideProgress = 1 - (player.attackTimer / 30); // 0 to 1
                    moveMultiplier = Math.max(0, 1 - slideProgress * 2); // Slows to 0 halfway through
                }
            }

            if (canMove) {
                if (keys['ArrowUp']) { dy = -1; player.direction = 'up'; player.moving = true; }
                if (keys['ArrowDown']) { dy = 1; player.direction = 'down'; player.moving = true; }
                if (keys['ArrowLeft']) { dx = -1; player.direction = 'left'; player.moving = true; }
                if (keys['ArrowRight']) { dx = 1; player.direction = 'right'; player.moving = true; }

                // Normalize diagonal movement so it's not faster
                if (dx !== 0 && dy !== 0) {
                    const diag = 0.7071; // 1/sqrt(2)
                    dx *= diag;
                    dy *= diag;
                }

                dx *= player.speed * moveMultiplier;
                dy *= player.speed * moveMultiplier;
            }

            // Move with collision - always use small foot hitbox (bottom 1/3 of player)
            // This allows walking behind objects naturally and prevents getting stuck
            const collisionHeight = player.height / 3;
            const collisionY = player.y + player.height * 2/3;

            let movedX = false;
            let movedY = false;

            // Check tile collision AND NPC collision
            if (dx !== 0 && !checkCollision(player.x + dx, collisionY, player.width, collisionHeight) &&
                !checkNPCCollision(player.x + dx, collisionY, player.width, collisionHeight)) {
                player.x += dx;
                movedX = true;
            }
            if (dy !== 0 && !checkCollision(player.x, collisionY + dy, player.width, collisionHeight) &&
                !checkNPCCollision(player.x, collisionY + dy, player.width, collisionHeight)) {
                player.y += dy;
                movedY = true;
            }

            // If player tried to move but was blocked in all directions, force idle
            if (player.moving && !movedX && !movedY) {
                player.moving = false;
            }

            // Animation - uses per-animation FPS if available
            player.frameTimer++;
            // Get FPS for current animation
            let currentAnimKey = 'walkDown';
            if (playerAnimations) {
                const dirMap = { down: 'walkDown', up: 'walkUp', left: 'walkLeft', right: 'walkRight' };
                const idleDirMap = { down: 'idleDown', up: 'idleUp', left: 'idleLeft', right: 'idleRight' };
                if (player.moving) {
                    currentAnimKey = dirMap[player.direction];
                } else {
                    const dirIdleKey = idleDirMap[player.direction];
                    if (playerAnimations[dirIdleKey] && playerAnimations[dirIdleKey].length > 0) {
                        currentAnimKey = dirIdleKey;
                    } else if (playerAnimations.idle && playerAnimations.idle.length > 0) {
                        currentAnimKey = 'idle';
                    } else {
                        currentAnimKey = dirMap[player.direction];
                    }
                }
            }
            const currentFps = playerAnimFpsList[currentAnimKey] || 8;
            const frameDelay = Math.max(1, Math.round(60 / currentFps));
            if (player.frameTimer >= frameDelay) {
                player.frameTimer = 0;
                player.frame = (player.frame + 1) % 4;
            }

            // Update animated tile animations - scan layers for animTile cells
            for (let li = 0; li < layers.length; li++) {
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell || cell.type !== 'animTile') continue;

                        const propData = animatedPropsData[cell.propIndex];
                        if (!propData || !propData.frames || propData.frames.length <= 1) continue;
                        if (propData.type !== 'loop') continue;

                        // Use origin tile position for multi-tile prop sync
                        const originX = x - (cell.offsetX || 0);
                        const originY = y - (cell.offsetY || 0);
                        const key = originX + ',' + originY + ',' + li;

                        // Only process animation once per prop (at origin tile)
                        if (cell.offsetX === 0 && cell.offsetY === 0 || (!cell.offsetX && !cell.offsetY)) {
                            if (!animPropFrameTimers[key]) {
                                animPropFrameTimers[key] = { frame: 0, timer: 0 };
                            }
                            animPropFrameTimers[key].timer++;

                            const fps = propData.fps || 8;
                            const frameDelay = Math.round(60 / fps);

                            if (animPropFrameTimers[key].timer >= frameDelay) {
                                animPropFrameTimers[key].timer = 0;
                                animPropFrameTimers[key].frame = (animPropFrameTimers[key].frame + 1) % propData.frames.length;
                            }
                        }
                    }
                }
            }

            // Attack timer and animation
            if (player.attacking) {
                player.attackTimer--;

                // Advance attack animation frames
                if (player.attackAnim && playerAnimations) {
                    const attackDirMap = { down: 'attackDown', up: 'attackUp', left: 'attackLeft', right: 'attackRight' };
                    const attackKey = attackDirMap[player.direction];
                    let attackFrames = playerAnimations[attackKey] || playerAnimations.attack || [];

                    if (attackFrames.length > 0) {
                        // Get FPS for attack animation
                        const attackFps = playerAnimFpsList[attackKey] || playerAnimFpsList.attack || 8;
                        const frameDelay = Math.round(60 / attackFps);

                        if (player.attackFrameTimer === undefined) player.attackFrameTimer = 0;
                        player.attackFrameTimer++;

                        if (player.attackFrameTimer >= frameDelay) {
                            player.attackFrameTimer = 0;
                            player.attackFrame++;

                            // If animation finished, end attack
                            if (player.attackFrame >= attackFrames.length) {
                                player.attacking = false;
                                player.attackAnim = false;
                                player.attackFrame = 0;
                            }
                        }
                        // Use attackFrame for drawing
                        player.frame = player.attackFrame;
                    } else {
                        // No attack animation, just use timer
                        if (player.attackTimer <= 0) {
                            player.attacking = false;
                            player.attackAnim = false;
                        }
                    }
                } else if (player.attackTimer <= 0) {
                    player.attacking = false;
                    player.attackAnim = false;
                }

                // Check for attack hitbox collisions with enemy NPCs
                checkAttackHitbox();
            }

            // Invincibility timer
            if (player.invincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                }
            }

            // Camera follow - adjust for zoom so player stays centered
            camera.x = player.x - (canvas.width / 2) / cameraZoom;
            camera.y = player.y - (canvas.height / 2) / cameraZoom;

            // Apply camera bounds if set for this map
            const currentMapData = mapsData[currentGameMap];
            if (currentMapData && currentMapData.cameraBounds) {
                const bounds = currentMapData.cameraBounds;
                const tileSize = gridSize * TILE_SCALE;
                const boundsPixelX = bounds.x * tileSize;
                const boundsPixelY = bounds.y * tileSize;
                const boundsPixelW = bounds.width * tileSize;
                const boundsPixelH = bounds.height * tileSize;

                const viewW = canvas.width / cameraZoom;
                const viewH = canvas.height / cameraZoom;

                // Clamp camera to bounds
                camera.x = Math.max(boundsPixelX, Math.min(camera.x, boundsPixelX + boundsPixelW - viewW));
                camera.y = Math.max(boundsPixelY, Math.min(camera.y, boundsPixelY + boundsPixelH - viewH));

                // If view is larger than bounds, center on bounds
                if (viewW >= boundsPixelW) {
                    camera.x = boundsPixelX + (boundsPixelW - viewW) / 2;
                }
                if (viewH >= boundsPixelH) {
                    camera.y = boundsPixelY + (boundsPixelH - viewH) / 2;
                }
            }

            // === UPDATE NPCs ===
            updateNPCs();

            // === SOUND UPDATES ===
            // Play walk sounds when moving
            if (player.moving && playerSoundsData.walk && playerSoundsData.walk.soundIndex >= 0) {
                const now = performance.now();
                const interval = playerSoundsData.walk.interval || 200;
                if (now - lastWalkSoundTime >= interval) {
                    playSound(
                        playerSoundsData.walk.soundIndex,
                        playerSoundsData.walk.volume || 0.5,
                        playerSoundsData.walk.pitchVariation || 0.1
                    );
                    lastWalkSoundTime = now;
                }
            }

            // Update ambient sounds based on proximity
            updateAmbientSounds();

            // === MULTIPLAYER UPDATES ===
            // Send position update to server
            sendMpUpdate();

            // Update other players - smooth lerp + animations
            const lerpSpeed = 0.15; // Smoothing factor (0.1 = smoother, 0.3 = snappier)
            otherPlayers.forEach((other, id) => {
                // Lerp position toward target
                other.x += (other.targetX - other.x) * lerpSpeed;
                other.y += (other.targetY - other.y) * lerpSpeed;

                // Update animation frame
                other.frameTimer++;
                if (other.frameTimer >= animSpeed) {
                    other.frameTimer = 0;
                    other.frame = (other.frame + 1) % 4;
                }
            });
        }

        // === MAP TRANSITION SYSTEM ===
        let isTransitioning = false;
        let transitionAlpha = 0;
        let transitionPhase = 'none'; // 'fadeOut', 'fadeIn', 'none', 'doorAnim'
        let pendingTransition = null;
        let pendingExternalUrl = null; // For external door navigation
        let inTavernMode = false; // True when player is in tavern (new tab)
        let tavernWindow = null; // Reference to tavern window

        // Check if player is on a trigger and interact
        // doorTypeFilter: 'interact' = only interact doors, 'walkover' = only walkover doors, null = all
        function checkTriggerInteraction(doorTypeFilter) {
            if (isTransitioning) return false;

            const tileSize = gridSize * TILE_SCALE;
            // Get player's foot position (center bottom)
            const playerTileX = Math.floor((player.x + player.width / 2) / tileSize);
            const playerTileY = Math.floor((player.y + player.height * 0.8) / tileSize);

            for (const trigger of placedTriggers) {
                if (trigger.mapName !== currentGameMap) continue;

                // Filter by door type if specified
                const triggerDoorType = trigger.doorType || 'walkover'; // Default to walkover for old triggers
                // External doors act like walkover doors (trigger on contact)
                const effectiveDoorType = triggerDoorType === 'external' ? 'walkover' : triggerDoorType;
                if (doorTypeFilter && effectiveDoorType !== doorTypeFilter) continue;

                // Check if player is in trigger zone
                if (playerTileX >= trigger.x && playerTileX < trigger.x + (trigger.width || 1) &&
                    playerTileY >= trigger.y && playerTileY < trigger.y + (trigger.height || 1)) {

                    // Skip if target map doesn't exist (unless external door)
                    if (trigger.doorType !== 'external' && !mapsData[trigger.targetMap]) {
                        // Only log once per door to avoid spam
                        if (!trigger._warnedMissing) {
                            console.warn('[TRIGGER] Door ' + trigger.doorNumber + ' target map "' + trigger.targetMap + '" not found');
                            trigger._warnedMissing = true;
                        }
                        return false;
                    }

                    // Skip if spawn point hasn't been set (targetX/Y are null)
                    if (trigger.doorType !== 'external' && (trigger.targetX === null || trigger.targetY === null)) {
                        if (!trigger._warnedNoSpawn) {
                            console.warn('[TRIGGER] Door ' + trigger.doorNumber + ' has no spawn point set - skipping');
                            trigger._warnedNoSpawn = true;
                        }
                        return false;
                    }

                    // Found a trigger - start transition
                    startMapTransition(trigger);
                    return true;
                }
            }
            return false;
        }

        // Check for walkover triggers (called every frame)
        function checkWalkoverTriggers() {
            return checkTriggerInteraction('walkover');
        }

        // === DIALOG INTERACTION SYSTEM ===
        let activeDialog = null; // { dialog, pageIndex, npc }
        let dialogCooldown = 0; // Prevent rapid re-trigger

        function checkDialogInteraction() {
            if (activeDialog || dialogCooldown > 0) return false;

            const tileSize = gridSize * TILE_SCALE;
            const playerTileX = Math.floor((player.x + player.width / 2) / tileSize);
            const playerTileY = Math.floor((player.y + player.height * 0.8) / tileSize);

            // Check dialog tiles (signs)
            for (const tile of placedDialogTiles) {
                if (tile.mapName !== currentGameMap) continue;
                if (tile.x === playerTileX && tile.y === playerTileY) {
                    const dialog = dialogs[tile.dialogIndex];
                    if (dialog) {
                        showDialog(dialog, null);
                        return true;
                    }
                }
            }

            // Check NPCs with dialogs (interact trigger type)
            for (const npc of placedNpcs) {
                if (npc.mapName !== currentGameMap) continue;
                if (npc.dialogIndex === undefined || npc.dialogIndex < 0) continue;
                if (npc.dialogTrigger === 'auto') continue; // Skip auto-trigger NPCs (handled elsewhere)

                // Check if player is adjacent to NPC
                const dx = Math.abs(npc.x - playerTileX);
                const dy = Math.abs(npc.y - playerTileY);
                if (dx <= 1 && dy <= 1) {
                    const dialog = dialogs[npc.dialogIndex];
                    if (dialog) {
                        showDialog(dialog, npc);
                        return true;
                    }
                }
            }

            return false;
        }

        function checkAutoDialogs() {
            if (activeDialog || dialogCooldown > 0) return false;

            const tileSize = gridSize * TILE_SCALE;
            const playerTileX = Math.floor((player.x + player.width / 2) / tileSize);
            const playerTileY = Math.floor((player.y + player.height * 0.8) / tileSize);

            // Check NPCs with auto-trigger dialogs
            for (const npc of placedNpcs) {
                if (npc.mapName !== currentGameMap) continue;
                if (npc.dialogIndex === undefined || npc.dialogIndex < 0) continue;
                if (npc.dialogTrigger !== 'auto') continue;

                // Check if player is on or adjacent to NPC
                const dx = Math.abs(npc.x - playerTileX);
                const dy = Math.abs(npc.y - playerTileY);
                if (dx <= 1 && dy <= 1) {
                    const dialog = dialogs[npc.dialogIndex];
                    if (dialog) {
                        showDialog(dialog, npc);
                        return true;
                    }
                }
            }

            return false;
        }

        function showDialog(dialog, npc) {
            activeDialog = { dialog, pageIndex: 0, npc };
            // Pause NPC movement while talking
            if (npc) {
                // Find the NPC's runtime state and set pause flag there
                const npcIndex = placedNpcs.indexOf(npc);
                if (npcIndex >= 0 && npcRuntimeState[npcIndex]) {
                    npcRuntimeState[npcIndex]._dialogPaused = true;
                }
            }
            renderDialogBox();
        }

        function advanceDialog() {
            if (!activeDialog) return;

            activeDialog.pageIndex++;
            if (activeDialog.pageIndex >= activeDialog.dialog.pages.length) {
                closeDialog();
            } else {
                renderDialogBox();
            }
        }

        function closeDialog() {
            // Resume NPC movement
            if (activeDialog && activeDialog.npc) {
                const npcIndex = placedNpcs.indexOf(activeDialog.npc);
                if (npcIndex >= 0 && npcRuntimeState[npcIndex]) {
                    npcRuntimeState[npcIndex]._dialogPaused = false;
                }
            }
            activeDialog = null;
            dialogCooldown = 30; // ~0.5 seconds at 60fps
            hideDialogBox();
        }

        function renderDialogBox() {
            if (!activeDialog) return;

            const dialog = activeDialog.dialog;
            const page = dialog.pages[activeDialog.pageIndex];
            const box = document.getElementById('dialogBox');

            if (!box) return;

            // Apply dialog styling
            const style = dialog.style || 1;
            const presets = {
                1: { bg: '#000000', border: '#ffffff', text: '#ffffff', accent: '#ffffff', radius: 0, borderW: 4 },
                2: { bg: '#000088', border: '#ffffff', text: '#ffffff', accent: '#ffff00', radius: 0, borderW: 2 },
                3: { bg: '#f8f8f8', border: '#303030', text: '#303030', accent: '#e03030', radius: 8, borderW: 3 },
                4: { bg: '#000000', border: '#a080ff', text: '#ffffff', accent: '#ffff00', radius: 0, borderW: 2 },
                5: { bg: '#1a1a4e', border: '#8888ff', text: '#ffffff', accent: '#ffcc00', radius: 4, borderW: 2 },
                6: { bg: '#2d2d2d', border: '#4a9eff', text: '#ffffff', accent: '#4a9eff', radius: 6, borderW: 2 }
            };
            const preset = presets[style] || presets[1];

            box.style.background = dialog.colors?.background || preset.bg;
            box.style.border = (preset.borderW || 3) + 'px solid ' + (dialog.colors?.border || preset.border);
            box.style.borderRadius = (preset.radius || 0) + 'px';
            box.style.color = dialog.colors?.text || preset.text;

            // Build content
            let html = '';
            if (page.speaker) {
                html += '<div style="color:' + (dialog.colors?.accent || preset.accent) + '; font-weight:bold; margin-bottom:8px;">' + page.speaker + '</div>';
            }
            html += '<div style="line-height:1.5;">' + page.text + '</div>';
            html += '<div style="text-align:right; margin-top:10px; font-size:10px; color:#888;">[A] ' + (activeDialog.pageIndex + 1) + '/' + dialog.pages.length + '</div>';

            box.innerHTML = html;
            box.style.display = 'block';
        }

        function hideDialogBox() {
            const box = document.getElementById('dialogBox');
            if (box) box.style.display = 'none';
        }

        // Forced walking state
        let forcedWalk = {
            active: false,
            direction: null,
            targetX: null, // Walk-out destination X (pixels)
            targetY: null, // Walk-out destination Y (pixels)
            duration: 0,
            elapsed: 0,
            speed: 2 // pixels per frame
        };

        // Start map transition
        function startMapTransition(trigger) {
            if (isTransitioning) return;

            isTransitioning = true;
            pendingTransition = trigger;

            // Handle external doors (navigate to another HTML file)
            if (trigger.doorType === 'external' && trigger.externalUrl) {
                // Resolve relative URLs using baseUrl from project data
                let externalUrl = trigger.externalUrl;
                if (!externalUrl.startsWith('http://') && !externalUrl.startsWith('https://')) {
                    // Relative URL - prefix with baseUrl
                    const baseUrl = projectData.baseUrl || '';
                    externalUrl = baseUrl + externalUrl;
                }
                console.log('[EXTERNAL DOOR] Navigating to:', externalUrl);

                // Save return coordinates so we can spawn back here
                // Use returnX/returnY if set, otherwise fall back to door position
                const returnInfo = {
                    map: currentGameMap,
                    x: trigger.returnX !== null ? trigger.returnX : trigger.x,
                    y: trigger.returnY !== null ? trigger.returnY : trigger.y,
                    timestamp: Date.now()
                };
                localStorage.setItem('externalDoorReturn', JSON.stringify(returnInfo));
                console.log('[EXTERNAL DOOR] Saved return info:', returnInfo);

                // Save multiplayer info for the external world (3D tavern)
                if (projectData.multiplayer && projectData.multiplayer.roomCode) {
                    const mpInfo = {
                        playerName: projectData.multiplayer.playerName,
                        roomCode: projectData.multiplayer.roomCode
                    };
                    localStorage.setItem('tavernMultiplayer', JSON.stringify(mpInfo));
                    console.log('[EXTERNAL DOOR] Saved multiplayer info:', mpInfo);
                }

                const fadeDuration = trigger.fadeDuration !== undefined ? trigger.fadeDuration : 0.5;

                if (fadeDuration > 0) {
                    // Fade to black, then navigate
                    transitionPhase = 'fadeOut';
                    transitionAlpha = 0;
                    // Store URL for navigation after fade completes
                    pendingExternalUrl = externalUrl;
                } else {
                    // Instant navigation
                    window.location.href = externalUrl;
                }
                return;
            }

            // Apply door animation tile changes (swap tiles to show "door open")
            if (trigger.animTiles && trigger.animTiles.length > 0) {
                console.log('[DOOR ANIM] Applying', trigger.animTiles.length, 'tile changes for door', trigger.doorNumber);
                trigger.animTiles.forEach(change => {
                    // Update the layers array with the "after" state
                    if (!layers[change.layer]) return;
                    if (!layers[change.layer][change.y]) {
                        layers[change.layer][change.y] = [];
                    }
                    layers[change.layer][change.y][change.x] = change.after;
                });
            }

            // Get fade duration (default to 0.5 if not set)
            const fadeDuration = trigger.fadeDuration !== undefined ? trigger.fadeDuration : 0.5;
            const tileSize = gridSize * TILE_SCALE;

            // Check if this is a walkover door with forced walking
            const hasWalkOut = trigger.walkOutX !== null && trigger.walkOutX !== undefined &&
                               trigger.walkOutY !== null && trigger.walkOutY !== undefined;
            const hasWalkDirection = trigger.walkDirection && trigger.walkDuration > 0;

            if (trigger.doorType === 'walkover' && (hasWalkOut || hasWalkDirection)) {
                // Start forced walking phase
                transitionPhase = 'forceWalk';
                forcedWalk.active = true;
                forcedWalk.elapsed = 0;

                if (hasWalkOut) {
                    // Walk to specific destination
                    forcedWalk.targetX = trigger.walkOutX * tileSize;
                    forcedWalk.targetY = trigger.walkOutY * tileSize;
                    forcedWalk.direction = null;

                    // Calculate duration based on distance if not manually set
                    const dx = forcedWalk.targetX - player.x;
                    const dy = forcedWalk.targetY - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const walkSpeed = forcedWalk.speed; // pixels per frame
                    const framesNeeded = dist / walkSpeed;
                    forcedWalk.duration = (framesNeeded / 60) * 1000; // Convert frames to ms

                    // Set initial facing
                    if (Math.abs(dx) > Math.abs(dy)) {
                        player.facing = dx > 0 ? 'right' : 'left';
                    } else {
                        player.facing = dy > 0 ? 'down' : 'up';
                    }
                } else {
                    // Walk in direction for duration
                    forcedWalk.targetX = null;
                    forcedWalk.targetY = null;
                    forcedWalk.direction = trigger.walkDirection;
                    forcedWalk.duration = trigger.walkDuration * 1000; // Convert to ms
                    player.facing = trigger.walkDirection;
                }
            } else if (fadeDuration === 0) {
                // Instant transition (no fade)
                executeMapTransition(trigger);
            } else {
                // Fade transition
                transitionPhase = 'fadeOut';
                transitionAlpha = 0;
            }
        }

        // Execute the actual map switch
        function executeMapTransition(trigger) {
            console.log('=== DOOR TRANSITION ===');
            console.log('Door ' + trigger.doorNumber + ' used: "' + trigger.mapName + '" -> "' + trigger.targetMap + '"');
            console.log('Player spawning at tile (' + trigger.targetX + ', ' + trigger.targetY + ')');

            const targetMapData = mapsData[trigger.targetMap];
            if (!targetMapData) {
                console.error('[GAME TRIGGER DEBUG] Target map not found:', trigger.targetMap);
                console.log('[GAME TRIGGER DEBUG] Available maps:', Object.keys(mapsData));
                isTransitioning = false;
                pendingTransition = null;
                return;
            }

            // Switch to new map
            currentGameMap = trigger.targetMap;

            // Stop all ambient sounds from previous map
            Object.keys(ambientSounds).forEach(key => {
                if (ambientSounds[key]?.source) {
                    try {
                        ambientSounds[key].source.stop();
                    } catch (e) { /* ignore */ }
                }
            });
            ambientSounds = {}; // Clear all ambient sounds
            console.log('[SOUND] Cleared ambient sounds for map transition');

            // Load the new map data
            layers = targetMapData.layers || layers;
            tileCollisions = targetMapData.tileCollisions || {};
            collisionMasks = targetMapData.collisionMasks || {};
            tileSplitLines = targetMapData.tileSplitLines || {};
            mapCols = targetMapData.mapCols || mapCols;
            mapRows = targetMapData.mapRows || mapRows;

            // Position player at target spawn
            const tileSize = gridSize * TILE_SCALE;

            player.x = trigger.targetX * tileSize;
            player.y = trigger.targetY * tileSize;
            console.log('Player pixel position: (' + player.x + ', ' + player.y + ')');

            // Reset camera to center on player
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;

            // Start fade in (or finish if instant)
            if (pendingTransition && pendingTransition.transitionStyle !== 'instant') {
                transitionPhase = 'fadeIn';
            } else {
                isTransitioning = false;
                pendingTransition = null;
            }
        }

        // Update transition animation
        function updateTransition(deltaTime) {
            if (!isTransitioning) return;

            // Get fade duration from trigger (default to 0.5 seconds)
            const fadeDuration = pendingTransition?.fadeDuration !== undefined ? pendingTransition.fadeDuration : 0.5;
            // Calculate fade speed (alpha change per frame at ~60fps)
            const fadeSpeed = fadeDuration > 0 ? (1 / (fadeDuration * 60)) : 1;

            if (transitionPhase === 'forceWalk') {
                // Update forced walking
                forcedWalk.elapsed += deltaTime;

                // Move player toward walk-out destination (if set) or in direction
                const moveSpeed = forcedWalk.speed;

                if (forcedWalk.targetX !== null && forcedWalk.targetY !== null) {
                    // Walk toward specific destination
                    const dx = forcedWalk.targetX - player.x;
                    const dy = forcedWalk.targetY - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > moveSpeed) {
                        // Move toward target
                        player.x += (dx / dist) * moveSpeed;
                        player.y += (dy / dist) * moveSpeed;

                        // Set facing based on dominant direction
                        if (Math.abs(dx) > Math.abs(dy)) {
                            player.facing = dx > 0 ? 'right' : 'left';
                        } else {
                            player.facing = dy > 0 ? 'down' : 'up';
                        }
                    } else {
                        // Reached destination
                        player.x = forcedWalk.targetX;
                        player.y = forcedWalk.targetY;
                        forcedWalk.elapsed = forcedWalk.duration; // Force completion
                    }
                } else {
                    // Walk in direction for duration
                    switch (forcedWalk.direction) {
                        case 'up':
                            player.y -= moveSpeed;
                            player.facing = 'up';
                            break;
                        case 'down':
                            player.y += moveSpeed;
                            player.facing = 'down';
                            break;
                        case 'left':
                            player.x -= moveSpeed;
                            player.facing = 'left';
                            break;
                        case 'right':
                            player.x += moveSpeed;
                            player.facing = 'right';
                            break;
                    }
                }

                // Animate walking - update frame timer
                player.isMoving = true;
                player.frameTimer++;
                const walkAnimKey = 'walk' + player.direction.charAt(0).toUpperCase() + player.direction.slice(1);
                const walkFps = playerAnimFpsList[walkAnimKey] || 8;
                const walkFrameDelay = Math.max(1, Math.round(60 / walkFps));
                if (player.frameTimer >= walkFrameDelay) {
                    player.frameTimer = 0;
                    player.frame = (player.frame + 1) % 4;
                }

                // Check if walk duration is complete
                if (forcedWalk.elapsed >= forcedWalk.duration) {
                    forcedWalk.active = false;
                    player.isMoving = false;

                    // Move to fade phase (or instant if fadeDuration is 0)
                    if (fadeDuration === 0) {
                        executeMapTransition(pendingTransition);
                    } else {
                        transitionPhase = 'fadeOut';
                        transitionAlpha = 0;
                    }
                }
            } else if (transitionPhase === 'fadeOut') {
                transitionAlpha += fadeSpeed;
                if (transitionAlpha >= 1) {
                    transitionAlpha = 1;
                    // Check if this is an external door navigation
                    if (pendingExternalUrl) {
                        // Open tavern in new tab instead of navigating
                        tavernWindow = window.open(pendingExternalUrl, '_blank');
                        inTavernMode = true;
                        pendingExternalUrl = null;
                        transitionPhase = 'tavern'; // Stay on black screen
                        return;
                    }
                    executeMapTransition(pendingTransition);
                }
            } else if (transitionPhase === 'fadeIn') {
                transitionAlpha -= fadeSpeed;
                if (transitionAlpha <= 0) {
                    transitionAlpha = 0;
                    transitionPhase = 'none';
                    isTransitioning = false;

                    // Restore door tiles on source map (close the door after transition)
                    if (pendingTransition && pendingTransition.animTiles && pendingTransition.animTiles.length > 0) {
                        const sourceMapName = pendingTransition.mapName;
                        const sourceMapData = mapsData[sourceMapName];
                        if (sourceMapData && sourceMapData.layers) {
                            console.log('[DOOR ANIM] Restoring', pendingTransition.animTiles.length, 'tiles on', sourceMapName, '(closing door)');
                            pendingTransition.animTiles.forEach(change => {
                                if (!sourceMapData.layers[change.layer]) return;
                                if (!sourceMapData.layers[change.layer][change.y]) {
                                    sourceMapData.layers[change.layer][change.y] = [];
                                }
                                sourceMapData.layers[change.layer][change.y][change.x] = change.before;
                            });
                        }
                    }

                    pendingTransition = null;
                }
            }
        }

        // Draw transition overlay
        function drawTransitionOverlay() {
            if (transitionAlpha > 0 || inTavernMode) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Show tavern message when in tavern mode
                if (inTavernMode) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 24px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText("YOU ARE IN THE TAVERN", canvas.width / 2, canvas.height / 2 - 30);
                    ctx.font = '12px "Press Start 2P", monospace';
                    ctx.fillStyle = '#888';
                    ctx.fillText("( DO NOT CLOSE THIS TAB )", canvas.width / 2, canvas.height / 2 + 20);
                    ctx.fillText("RETURN THROUGH THE BLUE DOOR", canvas.width / 2, canvas.height / 2 + 50);
                }
            }
        }

        // Listen for focus to detect return from tavern
        window.addEventListener('focus', () => {
            if (inTavernMode) {
                // Check if tavern window was closed
                if (!tavernWindow || tavernWindow.closed) {
                    inTavernMode = false;

                    // Spawn player at return point
                    const returnInfoStr = localStorage.getItem('externalDoorReturn');
                    if (returnInfoStr) {
                        try {
                            const returnInfo = JSON.parse(returnInfoStr);
                            const tileSize = gridSize * TILE_SCALE;

                            // Switch map if needed
                            if (returnInfo.map && returnInfo.map !== currentGameMap) {
                                currentGameMap = returnInfo.map;
                                const mapData = mapsData[returnInfo.map];
                                if (mapData) {
                                    layers = mapData.layers || [];
                                    triggers = mapData.triggers || [];
                                }
                            }

                            // Move player to return position
                            player.x = returnInfo.x * tileSize + tileSize / 2;
                            player.y = returnInfo.y * tileSize + tileSize / 2;
                            console.log('[TAVERN RETURN] Spawned at:', player.x, player.y);

                            // Clear the return info
                            localStorage.removeItem('externalDoorReturn');
                        } catch (e) {
                            console.error('[TAVERN RETURN] Error:', e);
                        }
                    }

                    transitionPhase = 'fadeIn';
                    transitionAlpha = 1;
                }
            }
        });

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const tileSize = gridSize * TILE_SCALE;
            ctx.imageSmoothingEnabled = false;

            // Check if all tilesets are ready
            let allTilesetsReady = true;
            for (let i = 0; i < tilesetImages.length; i++) {
                if (!tilesetImages[i] || !tilesetImages[i].complete) {
                    allTilesetsReady = false;
                    break;
                }
            }
            if (!allTilesetsReady) {
                ctx.fillStyle = '#4af';
                ctx.font = '20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Loading tilesets...', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Debug: Show message if no layers
            if (layers.length === 0) {
                ctx.fillStyle = '#f00';
                ctx.font = '16px monospace';
                ctx.fillText('ERROR: No layers loaded!', 20, 70);
                return;
            }

            // Apply camera zoom transform
            ctx.save();
            ctx.scale(cameraZoom, cameraZoom);

            // Draw tiles - use Math.round for camera to prevent seams
            const camX = Math.round(camera.x);
            const camY = Math.round(camera.y);

            // === 3-PASS RENDERING FOR Y-SORTING ===

            // PASS 1: Draw ground layer (layer 0) - always behind everything
            let tilesDrawn = drawLayer(0, camX, camY, tileSize);

            // PASS 2: Y-sort player with tiles from layers 1+
            tilesDrawn += drawYSortedEntities(camX, camY, tileSize);

            // PASS 3: Draw canopy overlay (split tile tops)
            drawCanopyOverlay(camX, camY, tileSize);

            // PASS 4: Redraw higher layer content that canopy covered
            redrawHigherLayerContent(camX, camY, tileSize);

            // Draw sound debug visualization
            if (showSounds) {
                Object.keys(tileSounds).forEach(key => {
                    // Filter by current map
                    let sx, sy;
                    if (key.includes(':')) {
                        const parts = key.split(':');
                        if (parts[0] !== currentGameMap) return;
                        [sx, sy] = parts[1].split(',').map(Number);
                    } else {
                        if (currentGameMap !== 'main') return;
                        [sx, sy] = key.split(',').map(Number);
                    }
                    const ts = tileSounds[key];
                    if (!ts) return;

                    const px = sx * tileSize - camX + tileSize / 2;
                    const py = sy * tileSize - camY + tileSize / 2;
                    const radius = (ts.radius || 3) * tileSize;

                    // Draw radius circle - filled purple gradient for visibility
                    const isPlaying = ambientSounds[key]?.playing;

                    // Filled gradient circle
                    const gradient = ctx.createRadialGradient(px, py, 0, px, py, radius);
                    if (isPlaying) {
                        gradient.addColorStop(0, 'rgba(100, 255, 100, 0.3)');
                        gradient.addColorStop(0.7, 'rgba(100, 255, 100, 0.15)');
                        gradient.addColorStop(1, 'rgba(100, 255, 100, 0)');
                    } else {
                        gradient.addColorStop(0, 'rgba(180, 100, 255, 0.3)');
                        gradient.addColorStop(0.7, 'rgba(180, 100, 255, 0.15)');
                        gradient.addColorStop(1, 'rgba(180, 100, 255, 0)');
                    }
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(px, py, radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Outer ring
                    ctx.strokeStyle = isPlaying ? 'rgba(100, 255, 100, 0.8)' : 'rgba(180, 100, 255, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Draw center marker
                    ctx.fillStyle = isPlaying ? '#0f0' : '#b464ff';
                    ctx.beginPath();
                    ctx.arc(px, py, tileSize / 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    const soundName = soundsData[ts.soundIndex]?.name || 'Sound ' + ts.soundIndex;
                    ctx.fillText(soundName, px, py - tileSize / 2);
                    ctx.fillText(isPlaying ? 'PLAYING' : 'idle', px, py + tileSize / 2 + 12);
                });
            }

            // Layer debug visualization
            if (showLayers) {
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li];
                    if (!layer) continue;
                    for (let y = 0; y < mapRows; y++) {
                        if (!layer[y]) continue;
                        for (let x = 0; x < mapCols; x++) {
                            const cell = layer[y][x];
                            if (!cell) continue;
                            const px = x * tileSize - camX + tileSize / 2;
                            const py = y * tileSize - camY + tileSize / 2;
                            // Skip off-screen tiles
                            if (px < -tileSize || px > canvas.width / cameraZoom + tileSize || py < -tileSize || py > canvas.height / cameraZoom + tileSize) continue;
                            // Different color for animTiles
                            if (cell.type === 'animTile') {
                                ctx.fillStyle = 'rgba(255, 0, 255, 0.8)'; // Magenta for animTiles
                                ctx.fillRect(px - 8, py - 6, 16, 12);
                                ctx.fillStyle = '#fff';
                                ctx.fillText('A' + li, px, py);
                            } else if (li > 0) {
                                // Only show layer number for non-ground tiles
                                ctx.fillStyle = 'rgba(0, 100, 255, 0.7)';
                                ctx.fillRect(px - 6, py - 6, 12, 12);
                                ctx.fillStyle = '#fff';
                                ctx.fillText(li, px, py);
                            }
                        }
                    }
                }
            }

            // Draw trigger zones when collision debug is enabled
            if (showCollision && placedTriggers) {
                const triggersOnMap = placedTriggers.filter(t => t.mapName === currentGameMap);

                triggersOnMap.forEach(trigger => {
                    const px = trigger.x * tileSize - camX;
                    const py = trigger.y * tileSize - camY;
                    const pw = (trigger.width || 1) * tileSize;
                    const ph = (trigger.height || 1) * tileSize;

                    // Draw trigger zone - bright magenta
                    ctx.fillStyle = 'rgba(255, 0, 255, 0.4)';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.strokeStyle = '#f0f';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(px, py, pw, ph);

                    // Draw type label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(trigger.type.toUpperCase(), px + pw / 2, py + ph / 2 - 8);

                    // Show target info
                    ctx.font = '10px monospace';
                    const doorNum = trigger.doorNumber || '?';
                    ctx.fillText('Door ' + doorNum + ' > ' + trigger.targetMap, px + pw / 2, py + ph / 2 + 6);
                });

                // Draw GREEN spawn boxes for incoming doors (doors that lead TO this map)
                // Only draw if spawn has been set (not null)
                const incomingTriggers = placedTriggers.filter(t => t.targetMap === currentGameMap && t.targetX !== null && t.targetY !== null);
                incomingTriggers.forEach(trigger => {
                    const sx = trigger.targetX * tileSize - camX;
                    const sy = trigger.targetY * tileSize - camY;

                    // Green spawn box
                    ctx.fillStyle = 'rgba(0, 255, 100, 0.4)';
                    ctx.fillRect(sx, sy, tileSize, tileSize);
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(sx, sy, tileSize, tileSize);

                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const doorNum = trigger.doorNumber || '?';
                    ctx.fillText('Door ' + doorNum, sx + tileSize / 2, sy + tileSize / 2 - 6);
                    ctx.fillText('from ' + trigger.mapName, sx + tileSize / 2, sy + tileSize / 2 + 6);
                });
            }

            // Draw INITIAL spawn point when collision debug is enabled
            // Only shows on the spawn map - this is where player spawns when game first loads
            // Door targets are separate (shown as magenta trigger zones with yellow coordinates)
            if (showCollision && projectData.playerPreviewPos) {
                // Only show initial spawn on the spawn map
                if (currentGameMap === spawnMapNameData) {
                    const spawnPos = projectData.playerPreviewPos;
                    const spawnX = spawnPos.x * tileSize - camX;
                    const spawnY = spawnPos.y * tileSize - camY;

                    // Green spawn marker
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                    ctx.fillRect(spawnX, spawnY, tileSize, tileSize);
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(spawnX, spawnY, tileSize, tileSize);

                    // Label with coordinates
                    ctx.fillStyle = '#0f0';
                    ctx.font = 'bold 10px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('START', spawnX + tileSize/2, spawnY + tileSize/2 - 6);
                    ctx.font = '9px monospace';
                    ctx.fillText('(' + spawnPos.x + ',' + spawnPos.y + ')', spawnX + tileSize/2, spawnY + tileSize/2 + 6);
                }
            }

            // DEBUG: Draw player position marker at player feet (only when UI visible)
            if (!uiHidden) {
                ctx.fillStyle = '#f0f';
                ctx.beginPath();
                ctx.arc(player.x - camX, player.y - camY, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();

            // DEBUG HUD: Show player position (only when UI visible)
            if (!uiHidden) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(10, 10, 200, 50);
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText('PLAYER POS (for builder)', 15, 15);
                ctx.fillStyle = '#ff0';
                ctx.fillText('x:' + Math.round(player.x) + ' y:' + Math.round(player.y), 15, 35);
            }

            // === LIGHTING OVERLAY (drawn after all game content) ===
            renderLighting();

            // Debug info - stacked properly from bottom up
            if (!uiHidden) {
                ctx.font = '12px monospace';
                let debugY = canvas.height - 10;
                const lineHeight = 15;

                // Always show basic info at bottom
                ctx.fillStyle = '#fff';
                ctx.fillText('Layers: ' + layers.length + ' | Tiles: ' + tilesDrawn + ' | Zoom: ' + cameraZoom.toFixed(1) + 'x', 10, debugY);
                debugY -= lineHeight;

                // Health display (always visible when collision debug on)
                if (showCollision) {
                    ctx.fillStyle = player.health <= 25 ? '#f44' : (player.health <= 50 ? '#fa4' : '#4f4');
                    ctx.fillText('HEALTH: ' + player.health + '/' + player.maxHealth + (player.invincible ? ' [INV]' : ''), 10, debugY);
                    debugY -= lineHeight;

                    // Spawn and player position
                    const playerTileX = Math.floor(player.x / tileSize);
                    const playerTileY = Math.floor(player.y / tileSize);
                    const spawnPos = projectData.playerPreviewPos || {x: '?', y: '?'};
                    ctx.fillStyle = '#0f0';
                    ctx.fillText('START: (' + spawnPos.x + ',' + spawnPos.y + ') | PLAYER: (' + playerTileX + ',' + playerTileY + ') on "' + currentGameMap + '"', 10, debugY);
                    debugY -= lineHeight;
                }

                // Sound debug info
                if (showSounds) {
                    ctx.fillStyle = '#ff0';
                    ctx.fillText('Sounds: ' + soundsData.length + ' | Tile sounds: ' + Object.keys(tileSounds).length + ' | Audio: ' + (audioContext ? 'ON' : 'OFF'), 10, debugY);
                    debugY -= lineHeight;
                }

                // Layer debug info
                if (showLayers) {
                    let animCounts = [];
                    for (let li = 0; li < layers.length; li++) {
                        let count = 0;
                        const layer = layers[li];
                        if (layer) {
                            for (let y = 0; y < mapRows; y++) {
                                if (!layer[y]) continue;
                                for (let x = 0; x < mapCols; x++) {
                                    if (layer[y][x]?.type === 'animTile') count++;
                                }
                            }
                        }
                        if (count > 0) animCounts.push('L' + li + ':' + count);
                    }
                    ctx.fillStyle = '#4af';
                    ctx.fillText('AnimTiles: ' + (animCounts.length > 0 ? animCounts.join(', ') : 'none') + ' | Press L to toggle', 10, debugY);
                }
            }
        }

        // Helper for drawing tiles with rotation and flip in test game
        function drawTileWithEffects(ctx, img, srcX, srcY, srcSize, destX, destY, destSize, rotation, flipped) {
            ctx.save();
            ctx.translate(destX + destSize / 2, destY + destSize / 2);

            if (rotation !== 0) {
                ctx.rotate(rotation * Math.PI / 180);
            }
            if (flipped) {
                ctx.scale(-1, 1); // Flip horizontally
            }

            ctx.drawImage(img, srcX, srcY, srcSize, srcSize, -destSize / 2, -destSize / 2, destSize, destSize);
            ctx.restore();
        }

        function drawLayer(li, camX, camY, tileSize) {
            if (!layerVisibility[li]) return 0;
            const layer = layers[li];
            if (!layer) return 0;

            let count = 0;
            for (let y = 0; y < mapRows; y++) {
                if (!layer[y]) continue;
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y][x];
                    if (!cell) continue;

                    const px = Math.floor(x * tileSize - camX);
                    const py = Math.floor(y * tileSize - camY);

                    // Account for zoom in off-screen check
                    if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                    // Overlap to prevent seams when zoomed
                    const overlap = 1;

                    if (cell.type === 'tile') {
                        count++;
                        // Use correct tileset for this tile
                        const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
                        if (cellTileset) {
                            // Draw with rotation and inversion
                            drawTileWithEffects(ctx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize + overlap, cell.rotation || 0, cell.flipped || false);
                        } else {
                            // Fallback: draw colored rectangle if tileset not loaded
                            ctx.fillStyle = '#4a7c59';
                            ctx.fillRect(px, py, tileSize, tileSize);
                        }

                        // Draw collision overlay if debug enabled (all layers)
                        if (showCollision) {
                            // Include tileset index in collision key
                            const tilesetIdx = cell.tilesetIndex || 0;
                            const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                            const mask = collisionMasks[key];

                            if (mask) {
                                // Draw pixel-level collision
                                const pixelSize = tileSize / gridSize;
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                for (let my = 0; my < gridSize; my++) {
                                    for (let mx = 0; mx < gridSize; mx++) {
                                        if (mask[my] && mask[my][mx]) {
                                            ctx.fillRect(
                                                px + mx * pixelSize,
                                                py + my * pixelSize,
                                                pixelSize,
                                                pixelSize
                                            );
                                        }
                                    }
                                }
                            } else if (tileCollisions[key]) {
                                // Full tile collision
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                ctx.fillRect(px, py, tileSize, tileSize);
                            }
                        }
                    } else if (cell.type === 'prop') {
                        const propIdx = cell.propIndex || 0;
                        const propImg = propImages[propIdx];
                        if (propImg && propImg.complete) {
                            count++;
                            ctx.drawImage(propImg, cell.x, cell.y, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
                        }

                        // Show collision in debug mode
                        if (showCollision) {
                            const key = cell.x + ',' + cell.y;
                            const mask = propCollisionMasksAll[propIdx] ? propCollisionMasksAll[propIdx][key] : null;
                            if (mask) {
                                const pixelSize = tileSize / gridSize;
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                for (let my = 0; my < gridSize; my++) {
                                    for (let mx = 0; mx < gridSize; mx++) {
                                        if (mask[my] && mask[my][mx]) {
                                            ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                                        }
                                    }
                                }
                            }
                        }
                    } else if (cell.type === 'animTile') {
                        // Animated tile - cycles through frames like a regular tile
                        const propData = animatedPropsData[cell.propIndex];
                        const propImg = animPropImages[cell.propIndex];
                        if (propData && propImg && propImg.complete && propData.frames && propData.frames.length > 0) {
                            // Use origin tile position for synced animation
                            const originX = x - (cell.offsetX || 0);
                            const originY = y - (cell.offsetY || 0);
                            const key = originX + ',' + originY + ',' + li;
                            const timer = animPropFrameTimers[key] || { frame: 0 };
                            const frameIdx = timer.frame % propData.frames.length;
                            const frame = propData.frames[frameIdx];

                            // Draw only this tile's portion of the frame
                            const offsetX = cell.offsetX || 0;
                            const offsetY = cell.offsetY || 0;
                            const srcX = frame.x + offsetX * gridSize;
                            const srcY = frame.y + offsetY * gridSize;

                            count++;
                            // Draw with rotation support
                            const rot = cell.rotation || 0;
                            if (rot === 0) {
                                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
                            } else {
                                ctx.save();
                                ctx.translate(px + tileSize / 2, py + tileSize / 2);
                                ctx.rotate(rot * Math.PI / 180);
                                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, -tileSize / 2, -tileSize / 2, tileSize + overlap, tileSize + overlap);
                                ctx.restore();
                            }
                        }
                    }
                }
            }

            return count;
        }

        // === Y-SORTING FUNCTIONS ===

        // Original Y-sorting: Y position is primary, layer is tiebreaker
        function drawYSortedEntities(camX, camY, tileSize) {
            const entities = [];

            // Add player
            const playerGridY = Math.floor((player.y + player.height) / (gridSize * TILE_SCALE));
            const playerLayer = playerLayerIndex || 1;
            entities.push({
                type: 'player',
                sortY: (playerGridY + 1) * 1000 + playerLayer + 0.5
            });

            // Add NPCs
            placedNpcs.forEach((placed, i) => {
                // Only show NPCs on current map
                if (placed.mapName && placed.mapName !== currentGameMap) return;

                const state = npcRuntimeState[i];
                if (!state) return;
                const npc = npcsData[placed.npcIndex];
                if (!npc) return;

                // state.y is in grid pixels (unscaled), so divide by gridSize to get tile Y
                // Add gridSize to get bottom of NPC (feet position) for proper Y-sorting
                const npcGridY = Math.floor((state.y + gridSize) / gridSize);
                entities.push({
                    type: 'npc',
                    npcIndex: i,
                    sortY: (npcGridY + 1) * 1000 + playerLayer + 0.4 // Slightly before player at same Y
                });
            });

            // Add items (interactive objects like chests)
            placedItemsData.forEach((placed, i) => {
                if (placed.mapName && placed.mapName !== currentGameMap) return;

                const item = itemsData[placed.itemIndex];
                if (!item) return;

                const itemGridY = placed.y + 1; // Bottom of item tile for Y-sorting
                entities.push({
                    type: 'item',
                    itemIndex: i,
                    sortY: (itemGridY + 1) * 1000 + (placed.layer || 1) + 0.3 // Before NPCs at same Y
                });
            });

            // Add other multiplayer players (only on same map, not in tavern)
            otherPlayers.forEach((other, odId) => {
                // Skip players in tavern or on different map
                if (other.inTavern || other.currentMap !== currentGameMap) return;

                const otherGridY = Math.floor((other.y + player.height) / (gridSize * TILE_SCALE));
                entities.push({
                    type: 'otherPlayer',
                    playerId: odId,
                    sortY: (otherGridY + 1) * 1000 + playerLayer + 0.45 // Between NPCs and player
                });
            });

            // Add tiles from all layers 1+
            for (let li = 1; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        const px = x * tileSize - camX;
                        const py = y * tileSize - camY;

                        // Skip off-screen tiles
                        if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                        // Y is primary, layer is tiebreaker
                        const baseSortY = (y + 1) * 1000 + li;

                        if (cell.type === 'tile') {
                            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
                            const splitData = tileSplitLines[key];
                            const hasSplit = splitData !== undefined && splitData !== null;

                            entities.push({
                                type: hasSplit ? 'trunk' : 'tile',
                                cell, x, y, layer: li,
                                sortY: baseSortY
                            });
                        } else if (cell.type === 'animTile') {
                            const propData = animatedPropsData[cell.propIndex];
                            const hasSplit = propData && propData.splitLine !== null && propData.splitLine !== undefined &&
                                (typeof propData.splitLine === 'number' ||
                                 (typeof propData.splitLine === 'object' && Object.keys(propData.splitLine).length > 0));

                            entities.push({
                                type: hasSplit ? 'animTrunk' : 'animTile',
                                cell, x, y, layer: li,
                                sortY: baseSortY
                            });
                        }
                    }
                }
            }

            // Sort by Y, then layer
            entities.sort((a, b) => a.sortY - b.sortY);

            // Draw in sorted order
            let count = 0;
            for (const e of entities) {
                if (e.type === 'player') {
                    drawPlayer();
                } else if (e.type === 'otherPlayer') {
                    drawOtherPlayer(e.playerId, camX, camY);
                } else if (e.type === 'npc') {
                    drawNPC(e.npcIndex, camX, camY, tileSize);
                } else if (e.type === 'item') {
                    drawItem(e.itemIndex, camX, camY, tileSize);
                } else if (e.type === 'trunk') {
                    drawTileTrunk(e.cell, e.x, e.y, camX, camY, tileSize);
                    count++;
                } else if (e.type === 'animTrunk') {
                    drawAnimTileTrunk(e.cell, e.x, e.y, e.layer, camX, camY, tileSize);
                    count++;
                } else if (e.type === 'animTile') {
                    drawAnimTile(e.cell, e.x, e.y, e.layer, camX, camY, tileSize);
                    count++;
                } else {
                    drawTileFull(e.cell, e.x, e.y, camX, camY, tileSize);
                    count++;
                }
            }

            return count;
        }

        // Redraw content from higher layers that overlaps with canopy from lower layers
        function redrawHigherLayerContent(camX, camY, tileSize) {
            // For each position that has canopy (split line), redraw any higher layer content
            for (let li = 1; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        // Check if this cell has canopy (split line)
                        let hasCanopy = false;
                        if (cell.type === 'tile') {
                            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
                            hasCanopy = tileSplitLines[key] !== undefined && tileSplitLines[key] !== null;
                        } else if (cell.type === 'animTile') {
                            const propData = animatedPropsData[cell.propIndex];
                            hasCanopy = propData && propData.splitLine !== null && propData.splitLine !== undefined;
                        }

                        if (!hasCanopy) continue;

                        // This cell has canopy - redraw any higher layer content at this position
                        for (let hi = li + 1; hi < layers.length; hi++) {
                            if (!layerVisibility[hi]) continue;
                            const higherLayer = layers[hi];
                            if (!higherLayer || !higherLayer[y] || !higherLayer[y][x]) continue;

                            const higherCell = higherLayer[y][x];
                            if (higherCell.type === 'animTile') {
                                drawAnimTile(higherCell, x, y, hi, camX, camY, tileSize);
                            } else if (higherCell.type === 'tile') {
                                drawTileFull(higherCell, x, y, camX, camY, tileSize);
                            }
                        }
                    }
                }
            }
        }

        function drawAnimTile(cell, tx, ty, li, camX, camY, tileSize) {
            const propData = animatedPropsData[cell.propIndex];
            const propImg = animPropImages[cell.propIndex];

            if (!propData || !propImg || !propImg.complete || !propData.frames || propData.frames.length === 0) {
                return;
            }

            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const overlap = 1;

            // Use origin tile position for synced animation
            const originX = tx - (cell.offsetX || 0);
            const originY = ty - (cell.offsetY || 0);
            const key = originX + ',' + originY + ',' + li;
            const timer = animPropFrameTimers[key] || { frame: 0 };
            const frameIdx = timer.frame % propData.frames.length;
            const frame = propData.frames[frameIdx];

            // Draw only this tile's portion of the frame
            const offsetX = cell.offsetX || 0;
            const offsetY = cell.offsetY || 0;
            const srcX = frame.x + offsetX * gridSize;
            const srcY = frame.y + offsetY * gridSize;

            // Apply scale factor
            const propScale = cell.scale || 1;
            const scaledTileSize = tileSize * propScale;
            const scaleOffset = (scaledTileSize - tileSize) / 2;
            const drawX = px - scaleOffset;
            const drawY = py - scaleOffset;

            ctx.imageSmoothingEnabled = false;

            // Draw with rotation support
            const rot = cell.rotation || 0;
            if (rot === 0) {
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, drawX - overlap, drawY - overlap, scaledTileSize + overlap * 2, scaledTileSize + overlap * 2);
            } else {
                ctx.save();
                ctx.translate(px + tileSize / 2, py + tileSize / 2);
                ctx.rotate(rot * Math.PI / 180);
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, -scaledTileSize / 2 - overlap, -scaledTileSize / 2 - overlap, scaledTileSize + overlap * 2, scaledTileSize + overlap * 2);
                ctx.restore();
            }
        }

        // Draw only the trunk (bottom) portion of an animated tile with split line
        function drawAnimTileTrunk(cell, tx, ty, li, camX, camY, tileSize) {
            const propData = animatedPropsData[cell.propIndex];
            const propImg = animPropImages[cell.propIndex];
            if (!propData || !propImg || !propImg.complete) return;
            if (!propData.frames || propData.frames.length === 0) return;
            if (!propData.splitLine) return;

            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const scale = tileSize / gridSize;

            // Use origin tile position for synced animation
            const originX = tx - (cell.offsetX || 0);
            const originY = ty - (cell.offsetY || 0);
            const key = originX + ',' + originY + ',' + li;
            const timer = animPropFrameTimers[key] || { frame: 0 };
            const frameIdx = timer.frame % propData.frames.length;
            const frame = propData.frames[frameIdx];

            // Calculate this tile's portion
            const offsetX = cell.offsetX || 0;
            const offsetY = cell.offsetY || 0;

            // Get split Y for this specific tile within the prop
            const tileKey = offsetX + ',' + offsetY;
            let splitY = null;

            if (typeof propData.splitLine === 'object' && !Array.isArray(propData.splitLine)) {
                // New format: object with "tileX,tileY" -> splitY
                splitY = propData.splitLine[tileKey];
            } else if (typeof propData.splitLine === 'number') {
                // Old format: single number (only applies to tile 0,0)
                if (offsetX === 0 && offsetY === 0) splitY = propData.splitLine;
            }

            // If no split for this tile, draw full tile
            if (splitY === null || splitY === undefined) {
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize;
                const overlap = 1;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px - overlap, py - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
                return;
            }

            // splitY is already local to this tile (0 to gridSize)
            const localSplitY = splitY;

            // Only draw if split is within this tile
            const overlap = 1;
            if (localSplitY <= 0) {
                // Split is above this tile - draw full tile
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px - overlap, py - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
            } else if (localSplitY < gridSize) {
                // Split is within this tile - draw only trunk (below split)
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize + localSplitY;
                const srcH = gridSize - localSplitY;
                const destY = py + localSplitY * scale;
                const destH = srcH * scale;

                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, srcH, px - overlap, destY, tileSize + overlap * 2, destH + overlap);
            }
            // If localSplitY >= gridSize, split is below this tile - don't draw trunk here
        }

        function drawTileFull(cell, tx, ty, camX, camY, tileSize) {
            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
            // Overlap to prevent seams when zoomed
            const overlap = 1;

            if (cellTileset) {
                ctx.imageSmoothingEnabled = false;
                drawTileWithEffects(ctx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize + overlap, cell.rotation || 0, cell.flipped || false);
            }

            // Draw collision overlay if debug enabled
            if (showCollision) {
                const tilesetIdx = cell.tilesetIndex || 0;
                const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                const mask = collisionMasks[key];

                if (mask) {
                    const pixelSize = tileSize / gridSize;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    for (let my = 0; my < gridSize; my++) {
                        for (let mx = 0; mx < gridSize; mx++) {
                            if (mask[my] && mask[my][mx]) {
                                ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                            }
                        }
                    }
                } else if (tileCollisions[key]) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(px, py, tileSize, tileSize);
                }
            }
        }

        function drawTileTrunk(cell, tx, ty, camX, camY, tileSize) {
            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
            const splitData = tileSplitLines[key];
            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];

            if (!cellTileset || splitData === undefined) return;

            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const scale = tileSize / gridSize;
            // Overlap to prevent seams when zoomed
            const overlap = 1;

            ctx.imageSmoothingEnabled = false;

            // Handle rotation or flip
            const rot = cell.rotation || 0;
            if (rot !== 0 || cell.flipped) {
                // For rotated/flipped tiles, just draw full tile (rotation + split is complex)
                drawTileWithEffects(ctx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize + overlap, rot, cell.flipped || false);
                return;
            }

            // Draw trunk using clipping path for freeform line
            ctx.save();
            ctx.beginPath();

            // Create clip path for trunk (below the split line)
            const splitYArray = Array.isArray(splitData) ? splitData : new Array(gridSize).fill(splitData);

            // Start at bottom-left, go up the left edge to first split point
            ctx.moveTo(px - overlap, py + tileSize + overlap);
            ctx.lineTo(px - overlap, py + splitYArray[0] * scale);

            // Draw along the split line (left to right)
            for (let col = 0; col < gridSize; col++) {
                const splitY = splitYArray[col];
                ctx.lineTo(px + col * scale, py + splitY * scale);
                ctx.lineTo(px + (col + 1) * scale, py + splitY * scale);
            }

            // Go down right edge and close
            ctx.lineTo(px + tileSize + overlap, py + tileSize + overlap);
            ctx.closePath();
            ctx.clip();

            // Draw the full tile, clipped to trunk region
            ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
            ctx.restore();

            // Draw collision overlay if debug enabled
            if (showCollision) {
                const mask = collisionMasks[key];
                if (mask) {
                    const pixelSize = tileSize / gridSize;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    for (let my = 0; my < gridSize; my++) {
                        for (let mx = 0; mx < gridSize; mx++) {
                            if (mask[my] && mask[my][mx]) {
                                ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                            }
                        }
                    }
                } else if (tileCollisions[key]) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(px, py, tileSize, tileSize);
                }
            }
        }

        function drawCanopyOverlay(camX, camY, tileSize) {
            // Draw canopy portions (above split line) for all split tiles
            for (let li = 1; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        const px = Math.floor(x * tileSize - camX);
                        const py = Math.floor(y * tileSize - camY);
                        const overlap = 1;
                        const scale = tileSize / gridSize;

                        // Skip off-screen
                        if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                        if (cell.type === 'tile') {
                            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
                            const splitData = tileSplitLines[key];
                            if (splitData === undefined || splitData === null) continue;

                            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
                            if (!cellTileset) continue;

                            ctx.imageSmoothingEnabled = false;

                            // Handle rotation
                            const rot = cell.rotation || 0;
                            if (rot !== 0) continue; // Skip rotated tiles (already drawn full in trunk pass)

                            // Draw canopy using clipping path for freeform line
                            ctx.save();
                            ctx.beginPath();

                            // Create clip path for canopy (above the split line)
                            const splitYArray = Array.isArray(splitData) ? splitData : new Array(gridSize).fill(splitData);

                            // Start at top-left, go along top edge
                            ctx.moveTo(px - overlap, py - overlap);
                            ctx.lineTo(px + tileSize + overlap, py - overlap);

                            // Go down right edge to last split point
                            ctx.lineTo(px + tileSize + overlap, py + splitYArray[gridSize - 1] * scale);

                            // Draw along the split line (right to left)
                            for (let col = gridSize - 1; col >= 0; col--) {
                                const splitY = splitYArray[col];
                                ctx.lineTo(px + (col + 1) * scale, py + splitY * scale);
                                ctx.lineTo(px + col * scale, py + splitY * scale);
                            }

                            // Go up left edge and close
                            ctx.lineTo(px - overlap, py - overlap);
                            ctx.closePath();
                            ctx.clip();

                            // Draw the full tile, clipped to canopy region
                            ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
                            ctx.restore();

                        } else if (cell.type === 'animTile') {
                            // Animated tile canopy
                            const propData = animatedPropsData[cell.propIndex];
                            const propImg = animPropImages[cell.propIndex];
                            if (!propData || !propImg || !propImg.complete) continue;
                            if (propData.splitLine === null || propData.splitLine === undefined) continue;
                            if (!propData.frames || propData.frames.length === 0) continue;

                            // Get current animation frame
                            const originX = x - (cell.offsetX || 0);
                            const originY = y - (cell.offsetY || 0);
                            const key = originX + ',' + originY + ',' + li;
                            const timer = animPropFrameTimers[key] || { frame: 0 };
                            const frameIdx = timer.frame % propData.frames.length;
                            const frame = propData.frames[frameIdx];

                            const offsetX = cell.offsetX || 0;
                            const offsetY = cell.offsetY || 0;

                            // Get split Y for this specific tile within the prop
                            const tileKey = offsetX + ',' + offsetY;
                            let splitY = null;

                            if (typeof propData.splitLine === 'object' && !Array.isArray(propData.splitLine)) {
                                // New format: object with "tileX,tileY" -> splitY
                                splitY = propData.splitLine[tileKey];
                            } else if (typeof propData.splitLine === 'number') {
                                // Old format: single number (only applies to tile 0,0)
                                if (offsetX === 0 && offsetY === 0) splitY = propData.splitLine;
                            }

                            // If no split for this tile, skip canopy
                            if (splitY === null || splitY === undefined) continue;

                            // splitY is already local to this tile (0 to gridSize)
                            const localSplitY = splitY;

                            // Only draw canopy if split is within this tile
                            if (localSplitY > 0 && localSplitY < gridSize) {
                                const srcX = frame.x + offsetX * gridSize;
                                const srcY = frame.y + offsetY * gridSize;
                                const srcH = localSplitY;
                                const destH = srcH * scale;

                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(propImg, srcX, srcY, gridSize, srcH, px - overlap, py - overlap, tileSize + overlap * 2, destH + overlap * 2);
                            } else if (localSplitY >= gridSize) {
                                // Full tile is canopy (split at bottom)
                                const srcX = frame.x + offsetX * gridSize;
                                const srcY = frame.y + offsetY * gridSize;

                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px - overlap, py - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
                            }
                        }
                    }
                }
            }
        }

        function drawPlayer() {
            const camX = Math.round(camera.x);
            const camY = Math.round(camera.y);
            const sx = Math.round(player.x - camX);
            const sy = Math.round(player.y - camY);

            // Use player character animation if available, otherwise use legacy layout
            let srcX = 0, srcY = 0, srcW = playerFrameWidth, srcH = playerFrameHeight;
            let flipX = false;

            if (playerAnimations) {
                // New animation system: use frame data from playerAnimations
                const dirMap = {
                    down: 'walkDown',
                    up: 'walkUp',
                    left: 'walkLeft',
                    right: 'walkRight'
                };
                const idleDirMap = {
                    down: 'idleDown',
                    up: 'idleUp',
                    left: 'idleLeft',
                    right: 'idleRight'
                };
                const attackDirMap = {
                    down: 'attackDown',
                    up: 'attackUp',
                    left: 'attackLeft',
                    right: 'attackRight'
                };
                let animKey;
                let useDeathFrame = false;
                if (playerDying) {
                    // Death animation
                    animKey = 'death';
                    useDeathFrame = true;
                } else if (player.attacking && player.attackAnim) {
                    // Check for directional attack animation
                    const attackKey = attackDirMap[player.direction];
                    if (playerAnimations[attackKey] && playerAnimations[attackKey].length > 0) {
                        animKey = attackKey;
                    } else if (playerAnimations.attack && playerAnimations.attack.length > 0) {
                        // Fall back to generic attack
                        animKey = 'attack';
                    } else {
                        // No attack animation, use walk
                        animKey = dirMap[player.direction];
                    }
                } else if (player.moving) {
                    animKey = dirMap[player.direction];
                } else {
                    // Check for directional idle first, then fall back to generic idle
                    const dirIdleKey = idleDirMap[player.direction];
                    if (playerAnimations[dirIdleKey] && playerAnimations[dirIdleKey].length > 0) {
                        animKey = dirIdleKey;
                    } else {
                        animKey = 'idle';
                    }
                }
                let frames = playerAnimations[animKey];

                // Fallback: if no idle frames, use first frame of walkDown
                if (!frames || frames.length === 0) {
                    frames = playerAnimations.walkDown || [];
                }
                // Fallback for left: use right and flip
                if ((!frames || frames.length === 0) && player.direction === 'left') {
                    frames = playerAnimations.walkRight || [];
                    flipX = true;
                }

                let currentSheetIndex = 0;
                if (frames && frames.length > 0) {
                    // Use attackFrame for attack animations, deathAnimFrame for death, otherwise use regular frame
                    let frameIndex;
                    if (useDeathFrame) {
                        frameIndex = Math.min(deathAnimFrame, frames.length - 1);
                    } else if (player.attacking && player.attackAnim) {
                        frameIndex = (player.attackFrame || 0) % frames.length;
                    } else {
                        frameIndex = player.frame % frames.length;
                    }
                    const frame = frames[frameIndex];
                    srcX = frame.x;
                    srcY = frame.y;
                    srcW = frame.w;
                    srcH = frame.h;
                    currentSheetIndex = frame.sheet || 0;
                }

                // Use the correct sprite sheet for this frame
                if (playerSpriteSheets && playerSpriteSheets[currentSheetIndex]) {
                    playerImg = playerSpriteSheets[currentSheetIndex];
                }

                // Check if this animation should be mirrored (from player editor mirror toggle)
                if (playerAnimMirrors && playerAnimMirrors[animKey]) {
                    flipX = !flipX; // Toggle flip - if already flipping, unflip; if not, flip
                }

                // Handle left direction by mirroring right (fallback if no walkLeft defined)
                if (player.direction === 'left' && (!playerAnimations.walkLeft || playerAnimations.walkLeft.length === 0)) {
                    flipX = true;
                }
            } else {
                // Legacy sprite layout: 1024x512, 16 cols x 8 rows = 64x64 each
                const frameWidth = 64;
                const frameHeight = 64;

                // Idle frames (Row 0)
                const idleFrames = {
                    down: [0, 1, 2],
                    up: [3, 4, 5],
                    right: [6, 7, 8],
                    left: [6, 7, 8]
                };

                // Walk frames
                const walkFrames = {
                    down: { row: 0, cols: [9, 10, 11, 12] },
                    up: { row: 0, cols: [13, 14, 15] },
                    right: { row: 1, cols: [1, 2, 3, 4] },
                    left: { row: 1, cols: [1, 2, 3, 4] }
                };

                let row = 0;
                let col = 0;

                if (player.attacking) {
                    row = walkFrames[player.direction].row;
                    col = walkFrames[player.direction].cols[Math.min(player.frame, walkFrames[player.direction].cols.length - 1)];
                    if (player.direction === 'left') flipX = true;
                } else if (player.moving) {
                    const walk = walkFrames[player.direction];
                    row = walk.row;
                    col = walk.cols[player.frame % walk.cols.length];
                    if (player.direction === 'left') flipX = true;
                } else {
                    row = 0;
                    col = idleFrames[player.direction][player.frame % idleFrames[player.direction].length];
                    if (player.direction === 'left') flipX = true;
                }

                srcX = col * frameWidth;
                srcY = row * frameHeight;
                srcW = frameWidth;
                srcH = frameHeight;
            }

            const drawW = Math.round(playerFrameWidth * playerScale);
            const drawH = Math.round(playerFrameHeight * playerScale);

            // Center sprite on collision box
            // Collision box should cover body from feet to near head
            // Sprite is drawn so collision box aligns with the character body
            const spriteX = sx + player.width / 2 - drawW / 2;
            const spriteY = sy - 15; // shift sprite up so collision box covers body properly

            // Simple ellipse shadow under hero
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(
                spriteX + drawW / 2,
                spriteY + drawH - shadowYOffset,
                drawW * (shadowWidth / 100),
                drawW * (shadowHeight / 100),
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // Invincibility flashing effect - blink every 4 frames
            const shouldDraw = !player.invincible || (Math.floor(player.invincibleTimer / 4) % 2 === 0);

            if (playerImg.complete && shouldDraw) {
                // Tint red briefly when just hit
                if (player.invincible && player.invincibleTimer > 80) {
                    ctx.globalAlpha = 0.7;
                }
                if (flipX) {
                    ctx.save();
                    ctx.translate(spriteX + drawW, spriteY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(playerImg, srcX, srcY, srcW, srcH, 0, 0, drawW, drawH);
                    ctx.restore();
                } else {
                    ctx.drawImage(playerImg, srcX, srcY, srcW, srcH, spriteX, spriteY, drawW, drawH);
                }
                ctx.globalAlpha = 1;
            } else if (!playerImg.complete) {
                ctx.fillStyle = '#4a7';
                ctx.fillRect(sx, sy, player.width, player.height);
            }

            // Attack effect removed - using attack animation instead

            // DEBUG: Draw collision box (shows actual foot hitbox used for collision)
            if (showCollision) {
                // Always show the small foot hitbox (bottom 1/3)
                const collisionHeight = player.height / 3;
                const collisionOffsetY = player.height * 2/3;

                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.strokeRect(sx, sy + collisionOffsetY, player.width, collisionHeight);

                // Draw center point of collision box
                ctx.fillStyle = '#0f0';
                ctx.beginPath();
                ctx.arc(sx + player.width / 2, sy + collisionOffsetY + collisionHeight / 2, 3, 0, Math.PI * 2);
                ctx.fill();

                // Draw attack hitbox preview (dark blue, always visible in debug)
                const dir = player.direction;
                const hbRange = playerHitboxRange[dir] || 40;
                const hbWidth = playerHitboxWidth[dir] || 60;
                const hbOffX = playerHitboxOffsetX[dir] || 0;
                const hbOffY = playerHitboxOffsetY[dir] || 0;

                if (hbRange > 0) {
                    const range = hbRange * TILE_SCALE;
                    const halfAngle = (hbWidth / 2) * (Math.PI / 180);
                    const dirAngles = { right: 0, down: Math.PI / 2, left: Math.PI, up: -Math.PI / 2 };
                    const baseAngle = dirAngles[dir] || 0;

                    const centerX = sx + player.width / 2 + hbOffX * TILE_SCALE;
                    const centerY = sy + player.height / 2 + hbOffY * TILE_SCALE;

                    // Draw preview cone (dark blue, semi-transparent)
                    ctx.fillStyle = 'rgba(30, 60, 120, 0.3)';
                    ctx.strokeStyle = 'rgba(60, 120, 200, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(
                        centerX + Math.cos(baseAngle - halfAngle) * range,
                        centerY + Math.sin(baseAngle - halfAngle) * range
                    );
                    ctx.arc(centerX, centerY, range, baseAngle - halfAngle, baseAngle + halfAngle);
                    ctx.lineTo(centerX, centerY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw yellow origin dot
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Draw player attack hitbox cone when attacking (magenta - active)
                if (player.attacking && player.attackAnim && hbRange > 0) {
                    const range = hbRange * TILE_SCALE;
                    const halfAngle = (hbWidth / 2) * (Math.PI / 180);
                    const dirAngles = { right: 0, down: Math.PI / 2, left: Math.PI, up: -Math.PI / 2 };
                    const baseAngle = dirAngles[dir] || 0;

                    const centerX = sx + player.width / 2 + hbOffX * TILE_SCALE;
                    const centerY = sy + player.height / 2 + hbOffY * TILE_SCALE;

                    // Draw cone/triangle shape
                    ctx.fillStyle = 'rgba(255, 0, 255, 0.35)';
                    ctx.strokeStyle = 'rgba(255, 0, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    // Left edge of cone
                    ctx.lineTo(
                        centerX + Math.cos(baseAngle - halfAngle) * range,
                        centerY + Math.sin(baseAngle - halfAngle) * range
                    );
                    // Arc at the end of the cone
                    ctx.arc(centerX, centerY, range, baseAngle - halfAngle, baseAngle + halfAngle);
                    // Right edge back to center
                    ctx.lineTo(centerX, centerY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }

        // Draw other multiplayer player
        function drawOtherPlayer(playerId, camX, camY) {
            const other = otherPlayers.get(playerId);
            if (!other) return;

            const sx = Math.round(other.x - camX);
            const sy = Math.round(other.y - camY);
            const dir = other.direction || 'down';

            // Use player character animation if available, otherwise use legacy layout
            let srcX = 0, srcY = 0, srcW = playerFrameWidth, srcH = playerFrameHeight;
            let flipX = false;

            if (playerAnimations) {
                // New animation system
                const dirMap = { down: 'walkDown', up: 'walkUp', left: 'walkLeft', right: 'walkRight' };
                let animKey = other.animation === 'walk' ? dirMap[dir] : 'idle';
                let frames = playerAnimations[animKey];

                if (!frames || frames.length === 0) frames = playerAnimations.walkDown || [];
                if ((!frames || frames.length === 0) && dir === 'left') {
                    frames = playerAnimations.walkRight || [];
                    flipX = true;
                }

                if (frames && frames.length > 0) {
                    const frame = frames[other.frame % frames.length];
                    srcX = frame.x;
                    srcY = frame.y;
                    srcW = frame.w;
                    srcH = frame.h;
                }

                if (dir === 'left' && (!playerAnimations.walkLeft || playerAnimations.walkLeft.length === 0)) {
                    flipX = true;
                }
            } else {
                // Legacy sprite layout
                const frameWidth = 64;
                const frameHeight = 64;

                const idleFrames = {
                    down: [0, 1, 2], up: [3, 4, 5], right: [6, 7, 8], left: [6, 7, 8]
                };
                const walkFrames = {
                    down: { row: 0, cols: [9, 10, 11, 12] },
                    up: { row: 0, cols: [13, 14, 15] },
                    right: { row: 1, cols: [1, 2, 3, 4] },
                    left: { row: 1, cols: [1, 2, 3, 4] }
                };

                let row = 0, col = 0;
                if (other.animation === 'walk') {
                    const walk = walkFrames[dir];
                    row = walk.row;
                    col = walk.cols[other.frame % walk.cols.length];
                    if (dir === 'left') flipX = true;
                } else {
                    row = 0;
                    col = idleFrames[dir][other.frame % idleFrames[dir].length];
                    if (dir === 'left') flipX = true;
                }

                srcX = col * frameWidth;
                srcY = row * frameHeight;
                srcW = frameWidth;
                srcH = frameHeight;
            }

            const drawW = Math.round(playerFrameWidth * playerScale);
            const drawH = Math.round(playerFrameHeight * playerScale);
            const spriteX = sx + player.width / 2 - drawW / 2;
            const spriteY = sy - 15;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(spriteX + drawW / 2, spriteY + drawH - shadowYOffset, drawW * 0.2, drawW * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();

            // Draw sprite
            if (playerImg.complete) {
                ctx.save();
                if (flipX) {
                    ctx.translate(spriteX + drawW, spriteY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(playerImg, srcX, srcY, srcW, srcH, 0, 0, drawW, drawH);
                } else {
                    ctx.drawImage(playerImg, srcX, srcY, srcW, srcH, spriteX, spriteY, drawW, drawH);
                }
                ctx.restore();
            }

            // Draw nametag above player
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            const nameWidth = ctx.measureText(other.name).width + 8;
            ctx.fillRect(spriteX + drawW / 2 - nameWidth / 2, spriteY - 18, nameWidth, 14);
            ctx.fillStyle = '#fff';
            ctx.fillText(other.name, spriteX + drawW / 2, spriteY - 8);
        }

        // Draw NPC with correct animation based on direction
        function drawNPC(npcIdx, camX, camY, tileSize) {
            const placed = placedNpcs[npcIdx];
            const state = npcRuntimeState[npcIdx];
            const npc = npcsData[placed.npcIndex];
            const img = npcImages[placed.npcIndex];

            if (!placed || !state || !npc || !img || !img.complete) return;

            // Skip dead enemies
            if (state.dead) return;

            const sx = Math.round(state.x * TILE_SCALE - camX);
            const sy = Math.round(state.y * TILE_SCALE - camY);

            // Get correct animation based on direction or waypoint animation
            const anims = npc.animations || {};
            const dirMap = {
                'down': 'walkDown',
                'up': 'walkUp',
                'left': 'walkLeft',
                'right': 'walkRight'
            };
            const attackDirMap = {
                'down': 'attackDown',
                'up': 'attackUp',
                'left': 'attackLeft',
                'right': 'attackRight'
            };
            // Use waypoint animation if set AND has frames, otherwise use walk/idle based on state
            let animKey;
            let useAttackFrame = false;
            // Check if playing attack animation (enemy attacking)
            if (state.attackAnimTimer > 0 && placed.isEnemy) {
                const attackKey = attackDirMap[state.direction];
                if (anims[attackKey] && anims[attackKey].length > 0) {
                    animKey = attackKey;
                    useAttackFrame = true;
                } else {
                    // No attack anim, use walk anim
                    animKey = dirMap[state.direction];
                }
            } else if (state.waypointAnimation && state.waypointAnimation !== 'walk' &&
                anims[state.waypointAnimation] && anims[state.waypointAnimation].length > 0) {
                animKey = state.waypointAnimation;
            } else {
                animKey = state.moving ? dirMap[state.direction] : 'idle';
            }
            let anim = anims[animKey];

            // Fallback to any available animation
            if (!anim || anim.length === 0) {
                anim = anims.walkDown || anims.idle || Object.values(anims).find(a => a && a.length > 0);
            }
            if (!anim || anim.length === 0) return;

            // Get current frame (use attack frame counter for attack anims)
            let frameIdx;
            if (useAttackFrame) {
                // Attack anims cycle through frames based on attack timer
                const attackAnimSpeed = Math.floor(30 / Math.max(anim.length, 1));
                frameIdx = Math.min(Math.floor(state.attackAnimFrame / Math.max(attackAnimSpeed, 1)), anim.length - 1);
            } else {
                frameIdx = state.frame % anim.length;
            }
            const frame = anim[frameIdx];
            if (!frame) return;

            // Apply NPC scale (default 1.0)
            const npcScale = placed.scale || 1;
            const drawW = tileSize * npcScale;
            const drawH = tileSize * npcScale;

            // Adjust position so NPC is centered and feet stay on ground
            const offsetX = (drawW - tileSize) / 2;
            const offsetY = drawH - tileSize; // Bottom-aligned
            const drawX = sx - offsetX;
            const drawY = sy - offsetY;

            // Draw shadow (scales with NPC)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(
                drawX + drawW / 2,
                drawY + drawH - 4,
                drawW * 0.35,
                drawW * 0.12,
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // Handle horizontal flip - either for left fallback OR if animation is marked as mirrored
            const animMirrors = npc.animMirrors || {};
            const isMirrored = animMirrors[animKey];
            const flipX = isMirrored || (state.direction === 'left' && !anims.walkLeft?.length);

            // Blink effect when NPC takes damage (skip drawing on odd frames)
            if (state.hitFlash > 0) {
                state.hitFlash--;
                if (Math.floor(state.hitFlash / 2) % 2 === 1) {
                    return; // Skip drawing this frame - creates blink effect
                }
            }

            if (flipX) {
                ctx.save();
                ctx.translate(drawX + drawW, drawY);
                ctx.scale(-1, 1);
                ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, drawW, drawH);
                ctx.restore();
            } else {
                ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);
            }

            // DEBUG: Draw NPC collision/hurtbox when C is pressed (cyan overlay)
            if (showCollision) {
                // Use actual frame dimensions from animation data
                const frameW = frame.w || npc.frameWidth || 64;
                const frameH = frame.h || npc.frameHeight || 64;
                const pixelScale = drawW / frameW;

                // Draw collision mask if available (cyan for all NPCs - this is their hurtbox)
                // Collision mask is painted per-frame, so we need to offset based on current frame
                if (npc.collisionMask && npc.collisionMask.length > 0) {
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.4)'; // Cyan for hurtbox

                    // Get the frame offset in the sprite sheet
                    const frameOffsetX = frame.x;
                    const frameOffsetY = frame.y;

                    // Iterate over the current frame's area in the collision mask
                    for (let py = 0; py < frameH; py++) {
                        const maskY = frameOffsetY + py;
                        if (maskY >= npc.collisionMask.length) continue;
                        if (!npc.collisionMask[maskY]) continue;

                        for (let px = 0; px < frameW; px++) {
                            const maskX = frameOffsetX + px;
                            if (maskX >= npc.collisionMask[maskY].length) continue;

                            if (npc.collisionMask[maskY][maskX] === 1) {
                                const pixelX = flipX ? drawX + drawW - (px + 1) * pixelScale : drawX + px * pixelScale;
                                ctx.fillRect(pixelX, drawY + py * pixelScale, pixelScale, pixelScale);
                            }
                        }
                    }
                } else {
                    // No collision mask - draw cyan bounding box
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(drawX, drawY, drawW, drawH);
                }
            }
        }

        // Draw an interactive item (chest, pot, etc.)
        function drawItem(itemIdx, camX, camY, tileSize) {
            const placed = placedItemsData[itemIdx];
            if (!placed) return;

            const item = itemsData[placed.itemIndex];
            if (!item || !item.frames || item.frames.length === 0) return;

            const state = itemStates[itemIdx];
            if (!state) return;

            const img = itemImages[placed.itemIndex];
            if (!img || !img.complete) return;

            // Get current frame based on state
            const frameIdx = state.frame;
            const frame = item.frames[frameIdx] || item.frames[0];

            // Draw position
            const drawX = placed.x * tileSize - camX;
            const drawY = placed.y * tileSize - camY;
            const drawW = (item.frameWidth / gridSize) * tileSize;
            const drawH = (item.frameHeight / gridSize) * tileSize;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);
        }

        let lastFrameTime = 0;
        function gameLoop(timestamp) {
            if (!timestamp) timestamp = performance.now();
            const deltaTime = lastFrameTime ? timestamp - lastFrameTime : 16.67;
            lastFrameTime = timestamp;

            updateDayCycle();
            updateDeathAnimation();
            updateTransition(deltaTime);

            // Dialog cooldown
            if (dialogCooldown > 0) dialogCooldown--;

            if (!isTransitioning || transitionPhase === 'fadeIn' || transitionPhase === 'forceWalk') {
                // Allow player to be visible during forced walk but don't allow input
                // Don't update if player is dying or game over
                if (transitionPhase !== 'forceWalk' && !playerDying && !gameOverShown) {
                    update();
                }
                // Check for walkover triggers after movement (but not during forced walk)
                if (transitionPhase !== 'forceWalk' && !playerDying && !gameOverShown) {
                    checkWalkoverTriggers();
                    // Check for auto-trigger dialogs (NPCs with auto trigger)
                    checkAutoDialogs();
                }
                // Update item animations
                updateItemAnimations();
                // Update interactive animated prop animations
                updateAnimPropInteractions();
            }
            draw();
            drawTransitionOverlay();
            requestAnimationFrame(gameLoop);
        }

        // Game loop is started when all tilesets load (see tileset loading code above)
        } // end initGame()
    <\/script>
</body>
</html>
            `;

            // Open test game window and write HTML directly
            // Data is streamed via postMessage after the page loads (prevents iPad memory crash)
            const testWindow = window.open('', '_blank');
            if (testWindow) {
                testWindow.document.write(loaderHTML);
                testWindow.document.close();
                testGameWindow = testWindow; // Store reference for live sync
                logTestEvent('Test window opened (live sync enabled)');
            } else {
                logTestEvent('Failed to open test window - popup blocked?', 'error');
                alert('Could not open test window. Please allow popups for this site.');
            }
        }

        // Stream sounds via postMessage (called when test game signals ready)
        function streamSoundsToWindow(targetWindow, sounds) {
            logTestEvent('Starting to stream ' + sounds.length + ' sounds...');
            let index = 0;

            function sendNext() {
                if (index >= sounds.length) {
                    logTestEvent('All sounds streamed');
                    targetWindow.postMessage({ type: 'sounds-complete' }, '*');
                    return;
                }

                const sound = sounds[index];
                logTestEvent('Streaming sound ' + (index + 1) + '/' + sounds.length + ': ' + sound.name);
                targetWindow.postMessage({
                    type: 'sound-data',
                    index: index,
                    data: sound.data,
                    name: sound.name
                }, '*');

                index++;
                // Delay between sounds to let iPad breathe
                setTimeout(sendNext, 500);
            }

            sendNext();
        }
    </script>
</body>
</html>
