<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>World Builder</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        /* Phase screens */
        .phase { display: none; height: 100vh; }
        .phase.active { display: flex; }

        /* LOAD PHASE */
        #loadPhase {
            justify-content: center;
            align-items: center;
            background: #000;
        }

        .load-box {
            text-align: center;
            padding: 40px 50px;
            background: #000;
            border: 4px solid #fff;
        }

        .load-box h1 {
            font-family: 'Press Start 2P', monospace;
            font-size: 20px;
            color: #fff;
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .load-box p {
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            color: #888;
            margin-bottom: 20px;
        }

        .retro-btn {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            padding: 12px 20px;
            margin: 8px;
            background: #000;
            color: #fff;
            border: 2px solid #fff;
            cursor: pointer;
        }

        .retro-btn:hover {
            background: #fff;
            color: #000;
        }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }
        .blink { animation: blink 1s step-end infinite; }

        /* COLLISION PHASE */
        #collisionPhase {
            flex-direction: column;
        }

        .collision-header {
            background: #2a2a4e;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #4af;
        }

        .collision-header h2 { color: #4af; }

        .collision-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .collision-sidebar {
            width: 280px;
            background: #2a2a4e;
            padding: 15px;
            overflow-y: auto;
        }

        .collision-main {
            flex: 1;
            overflow: auto;
            padding: 20px;
            background: #111;
        }

        #collisionTilesetCanvas {
            cursor: crosshair;
            image-rendering: pixelated;
            border: 2px solid #555;
        }

        .tool-buttons {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .tool-buttons button.active {
            background: #4af;
            color: #000;
        }

        /* Retro Button Styles */
        .retro-btn {
            min-height: 28px;
            min-width: 32px;
            padding: 4px 8px;
            font-size: 11px;
            font-weight: bold;
            border: 2px solid;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.1s ease;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            box-shadow: 0 3px 0 rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        .retro-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 0 rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        .retro-btn:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
        }
        .retro-cyan { background: #3a8; border-color: #2a6; color: #fff; }
        .retro-cyan.active { background: #5fc; border-color: #3da; color: #000; box-shadow: 0 0 12px #5fc, 0 3px 0 rgba(0,0,0,0.3); }
        .retro-purple { background: #86c; border-color: #64a; color: #fff; }
        .retro-purple.active { background: #a8f; border-color: #86c; color: #000; box-shadow: 0 0 12px #a8f, 0 3px 0 rgba(0,0,0,0.3); }
        .retro-orange { background: #d84; border-color: #b62; color: #fff; }
        .retro-orange.active { background: #fa6; border-color: #d84; color: #000; box-shadow: 0 0 12px #fa6, 0 3px 0 rgba(0,0,0,0.3); }
        .retro-pink { background: #c6a; border-color: #a48; color: #fff; }
        .retro-pink.active { background: #f8c; border-color: #c6a; color: #000; box-shadow: 0 0 12px #f8c, 0 3px 0 rgba(0,0,0,0.3); }
        /* Flip - cyan/magenta shift */
        .retro-blue { background: #38a; border-color: #268; color: #fff; }
        .retro-blue.active { background: #f0f; border-color: #c0c; color: #fff; box-shadow: 0 0 20px #f0f, 0 0 40px #f0f, 0 3px 0 rgba(0,0,0,0.3); animation: flipPulse 0.5s infinite alternate; }
        /* Erase - red/yellow danger flash */
        .retro-red { background: #833; border-color: #611; color: #fff; }
        .retro-red.active { background: #f00; border-color: #ff0; color: #ff0; box-shadow: 0 0 20px #f00, 0 0 40px #ff0, 0 3px 0 rgba(0,0,0,0.3); animation: erasePulse 0.3s infinite alternate; }
        .retro-green { background: #3a5; border-color: #283; color: #fff; }
        .retro-green.active { background: #5f8; border-color: #3a5; color: #000; box-shadow: 0 0 15px #5f8, 0 3px 0 rgba(0,0,0,0.3); animation: copyPulse 0.8s infinite alternate; }

        @keyframes copyPulse {
            from { background: #5f8; box-shadow: 0 0 10px #5f8, 0 3px 0 rgba(0,0,0,0.3); }
            to { background: #8fc; box-shadow: 0 0 20px #8fc, 0 3px 0 rgba(0,0,0,0.3); }
        }

        @keyframes flipPulse {
            from { background: #f0f; box-shadow: 0 0 15px #f0f, 0 3px 0 rgba(0,0,0,0.3); }
            to { background: #0ff; box-shadow: 0 0 25px #0ff, 0 3px 0 rgba(0,0,0,0.3); }
        }
        @keyframes erasePulse {
            from { background: #f00; border-color: #ff0; }
            to { background: #ff0; border-color: #f00; color: #f00; }
        }

        /* Tileset Picker Styles */
        .tileset-picker {
            position: relative;
            flex: 1;
        }
        .tileset-picker-btn {
            width: 100%;
            padding: 8px 12px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            text-align: left;
        }
        .tileset-picker-btn:hover {
            background: #444;
            border-color: #666;
        }
        .tileset-picker-btn .thumb {
            width: 32px;
            height: 32px;
            border: 1px solid #555;
            border-radius: 3px;
            image-rendering: pixelated;
            background: #222;
            object-fit: cover;
        }
        .tileset-picker-btn .name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .tileset-picker-btn .arrow {
            font-size: 10px;
            color: #888;
        }
        .tileset-picker-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 300px;
            overflow-y: auto;
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 4px;
            margin-top: 4px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .tileset-picker-dropdown.open {
            display: block;
        }
        .tileset-picker-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #3a3a3a;
        }
        .tileset-picker-item:last-child {
            border-bottom: none;
        }
        .tileset-picker-item:hover {
            background: #3a3a3a;
        }
        .tileset-picker-item.selected {
            background: #2a4a6a;
        }
        .tileset-picker-item .thumb {
            width: 48px;
            height: 48px;
            border: 1px solid #555;
            border-radius: 3px;
            image-rendering: pixelated;
            background: #222;
            object-fit: cover;
        }
        .tileset-picker-item .info {
            flex: 1;
            min-width: 0;
        }
        .tileset-picker-item .name {
            font-weight: bold;
            color: #fff;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .tileset-picker-item .size {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }

        /* BUILD PHASE */
        #buildPhase {
            flex-direction: row;
        }

        .panel {
            background: #1a1a1a;
            padding: 15px;
            overflow-y: scroll;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            border-right: 2px solid #333;
        }

        .left-panel {
            width: 320px;
            min-width: 100px;
            max-width: 600px;
        }

        .map-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .toolbar {
            padding: 8px 12px;
            display: flex;
            gap: 8px;
            align-items: center;
            background: #0a0a0a;
            border-bottom: 2px solid #333;
            flex-wrap: wrap;
        }

        .toolbar-modes {
            display: flex;
            gap: 3px;
        }

        .toolbar-modes button {
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            padding: 14px 12px;
            background: #1a1a1a;
            color: #555;
            border: 1px solid #333;
            border-radius: 0;
            transition: all 0.15s;
        }

        .toolbar-modes button:hover {
            color: #fff;
            border-color: #666;
            background: #222;
        }

        /* Toolbar mode colors */
        #tileMode2:hover, #tileMode2.active { border-color: #4a7; color: #4a7; background: #0a1a0a; }
        #npcMode2:hover, #npcMode2.active { border-color: #f93; color: #f93; background: #1a0f0a; }
        #animPropMode2:hover, #animPropMode2.active { border-color: #a6f; color: #a6f; background: #120a1a; }
        #soundMode2:hover, #soundMode2.active { border-color: #fd0; color: #fd0; background: #1a1a0a; }
        #lightingMode2:hover, #lightingMode2.active { border-color: #0ff; color: #0ff; background: #0a1a1a; }
        #triggerMode2:hover, #triggerMode2.active { border-color: #f55; color: #f55; background: #1a0a0a; }
        #cameraMode2:hover, #cameraMode2.active { border-color: #58f; color: #58f; background: #0a0a1a; }
        #dialogMode2:hover, #dialogMode2.active { border-color: #f6a; color: #f6a; background: #1a0a12; }

        .toolbar-separator {
            width: 1px;
            height: 24px;
            background: #333;
            margin: 0 5px;
        }

        .toolbar-spacer {
            flex: 1;
        }

        .tools-dropdown {
            position: relative;
        }

        .tools-toggle {
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            padding: 14px 12px;
            background: #1a1a1a;
            color: #888;
            border: 1px solid #444;
        }

        .tools-toggle:hover {
            background: #222;
            color: #fff;
        }

        .tools-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #1a1a1a;
            border: 1px solid #444;
            padding: 8px;
            z-index: 1000;
            min-width: 150px;
            margin-top: 4px;
        }

        .tools-menu.open {
            display: block;
        }

        .tools-menu button {
            display: block;
            width: 100%;
            text-align: left;
            margin: 2px 0;
            font-size: 10px;
            padding: 8px 10px;
        }

        .tools-menu-separator {
            height: 1px;
            background: #333;
            margin: 8px 0;
        }

        .tools-menu-zoom {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px;
            color: #888;
            font-size: 10px;
        }

        .tools-menu-zoom button {
            width: auto;
            padding: 5px 10px;
            margin: 0;
        }

        .coop-status-menu {
            padding: 8px 10px;
            margin-bottom: 8px;
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            text-align: center;
            border: 1px solid;
            border-radius: 0;
        }

        .coop-status-menu.connected {
            background: #0a1a0a;
            color: #0f0;
            border-color: #0f0;
        }

        .coop-status-menu.disconnected {
            background: #1a0a0a;
            color: #f55;
            border-color: #f55;
        }

        .tools-menu-theme {
            padding: 5px;
            color: #888;
            font-size: 10px;
        }

        .theme-swatches {
            display: flex;
            gap: 4px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .theme-swatch {
            width: 24px;
            height: 24px;
            border: 2px solid #444;
            padding: 0;
            cursor: pointer;
            transition: all 0.15s;
        }

        .theme-swatch:hover {
            border-color: #fff;
            transform: scale(1.1);
        }

        .theme-swatch.active {
            border-color: #4af;
            box-shadow: 0 0 8px #4af;
        }

        .toolbar-grab {
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            padding: 14px 12px;
            background: #1a1a1a;
            color: #888;
            border: 1px solid #444;
        }

        .toolbar-grab:hover {
            background: #222;
            color: #fff;
            border-color: #666;
        }

        .toolbar-grab.active {
            background: #0a1a2a;
            color: #4af;
            border-color: #4af;
        }

        .spawn-btn {
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            padding: 8px 12px;
            background: #0a1a0a;
            color: #4a4;
            border: 2px solid #4a4;
        }

        .spawn-btn:hover {
            background: #4a4;
            color: #000;
        }

        .spawn-btn.active {
            background: #4a4;
            color: #000;
            animation: spawn-pulse 1s infinite;
        }

        @keyframes spawn-pulse {
            0%, 100% { box-shadow: 0 0 5px #4a4; }
            50% { box-shadow: 0 0 15px #4a4; }
        }

        .test-map-btn {
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            padding: 10px 20px;
            background: #1a0a0a;
            color: #f44;
            border: 2px solid #f44;
            animation: pulse-glow 2s infinite;
        }

        .test-map-btn:hover {
            background: #f44;
            color: #000;
            box-shadow: 0 0 20px #f44;
        }

        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 5px #f44; }
            50% { box-shadow: 0 0 15px #f44; }
        }

        @keyframes glow-blink {
            0%, 100% { opacity: 1; text-shadow: 0 0 10px #0ff, 0 0 20px #0ff; }
            50% { opacity: 0.5; text-shadow: 0 0 5px #0ff; }
        }

        .toolbar-hint {
            color: #444;
            font-size: 9px;
            font-family: monospace;
        }

        .map-viewport {
            flex: 1;
            overflow: scroll;
            -webkit-overflow-scrolling: touch;
            background: #111;
            padding: 40px;
            position: relative;
        }

        #mapCanvas {
            border: 2px solid #555;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        #mapCanvas.grabbing {
            cursor: grab;
        }

        #mapCanvas.grabbing:active {
            cursor: grabbing;
        }

        /* Expand buttons */
        .expand-btn {
            position: absolute;
            background: #4a7c59;
            color: white;
            border: none;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.6;
            z-index: 10;
            padding: 0;
        }

        .expand-btn:hover {
            opacity: 1;
            background: #5a9c69;
        }

        .expand-top {
            top: 10px;
            width: 60px;
            height: 25px;
        }

        .expand-bottom {
            width: 60px;
            height: 25px;
        }

        .expand-left {
            left: 10px;
            width: 25px;
            height: 60px;
        }

        .expand-right {
            width: 25px;
            height: 60px;
        }

        /* Common */
        button {
            background: #222;
            color: #aaa;
            border: 1px solid #444;
            padding: 8px 14px;
            border-radius: 0;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.15s;
        }
        button:hover { background: #333; color: #fff; border-color: #666; }
        button.danger { background: #311; color: #f66; border-color: #a55; }
        button.danger:hover { background: #422; color: #f88; }
        button.primary { background: #124; color: #4af; border-color: #4af; }
        button.primary:hover { background: #236; }

        h2 {
            color: #888;
            font-size: 11px;
            margin: 15px 0 8px;
            font-family: 'Press Start 2P', monospace;
            letter-spacing: 1px;
        }
        h3 {
            color: #666;
            font-size: 10px;
            margin: 10px 0 5px;
        }

        input[type="file"] { display: none; }

        select, input[type="text"] {
            padding: 6px;
            background: #111;
            border: 1px solid #444;
            color: #ccc;
            border-radius: 0;
            font-size: 12px;
        }

        .info {
            color: #666;
            font-size: 10px;
            padding: 10px;
            background: #111;
            border: 1px solid #333;
            border-radius: 0;
            margin: 10px 0;
        }

        .tileset-container {
            background: #000;
            padding: 5px;
            border: 1px solid #333;
            border-radius: 0;
            overflow: scroll;
            -webkit-overflow-scrolling: touch;
            max-height: 300px;
        }

        #paintTilesetCanvas {
            cursor: crosshair;
            image-rendering: pixelated;
            border: 1px solid #444;
        }

        .selected-preview {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            margin: 10px 0;
            min-height: 68px;
            max-height: 68px;
            overflow: hidden;
        }

        .selected-preview canvas {
            border: 2px solid #0f0;
            image-rendering: pixelated;
            max-width: 48px;
            max-height: 48px;
            flex-shrink: 0;
        }

        .mode-tabs {
            display: none; /* Hidden - now in toolbar */
            gap: 4px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .mode-tabs button {
            flex: 1;
            min-width: 70px;
            font-family: 'Press Start 2P', monospace;
            font-size: 7px;
            padding: 8px 4px;
            background: #000;
            color: #666;
            border: 1px solid #444;
            border-radius: 0;
            transition: all 0.15s;
        }

        .mode-tabs button:hover {
            color: #fff;
            border-color: #888;
        }

        /* Each tab gets its own color theme */
        #tileMode:hover, #tileMode.active { border-color: #4a7; color: #4a7; background: #0a1a0a; }
        #npcMode:hover, #npcMode.active { border-color: #f93; color: #f93; background: #1a0f0a; }
        #animPropMode:hover, #animPropMode.active { border-color: #a6f; color: #a6f; background: #120a1a; }
        #soundMode:hover, #soundMode.active { border-color: #fd0; color: #fd0; background: #1a1a0a; }
        #lightingMode:hover, #lightingMode.active { border-color: #0ff; color: #0ff; background: #0a1a1a; }
        #triggerMode:hover, #triggerMode.active { border-color: #f55; color: #f55; background: #1a0a0a; }
        #cameraMode:hover, #cameraMode.active { border-color: #58f; color: #58f; background: #0a0a1a; }
        #dialogMode:hover, #dialogMode.active { border-color: #f6a; color: #f6a; background: #1a0a12; }
        #questMode:hover, #questMode.active { border-color: #a8f; color: #a8f; background: #1a0a1f; }
        #questMode2:hover, #questMode2.active { border-color: #a8f; color: #a8f; background: #1a0a1f; }

        .prop-item {
            background: #333;
            padding: 8px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 11px;
        }

        .prop-item .name { color: #4af; font-weight: bold; }

        .state-picker {
            position: fixed;
            background: #2a2a4e;
            border: 2px solid #4af;
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            display: none;
        }

        .state-picker.visible { display: block; }

        .state-option {
            padding: 8px 12px;
            margin: 3px 0;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
        }

        .state-option:hover { background: #444; }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .zoom-controls button { padding: 4px 10px; }
        .zoom-controls span { color: #888; font-size: 12px; min-width: 30px; text-align: center; }

        .toolbar span { color: #888; font-size: 11px; }

        /* Animated Prop Editor Modal */
        .anim-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
        }
        .anim-modal.visible { display: flex; }

        .anim-modal-content {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .anim-sidebar {
            width: 280px;
            background: #2a2a4e;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #4af;
        }

        .anim-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1a1a2e;
            overflow: hidden;
            min-width: 0;
        }

        .anim-header {
            padding: 15px 20px;
            background: #2a2a4e;
            border-bottom: 2px solid #4af;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .anim-header h2 { color: #4af; margin: 0; }

        .anim-canvas-area {
            flex: 1;
            overflow: auto;
            padding: 20px;
            display: block;
            min-height: 0;
        }

        .anim-canvas-area canvas {
            border: 2px solid #555;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .anim-frames-bar {
            background: #2a2a4e;
            padding: 15px 20px;
            border-top: 2px solid #4af;
        }

        .anim-frames-list {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            min-height: 50px;
            background: #111;
            padding: 10px;
            border-radius: 5px;
        }

        .anim-frame-thumb {
            border: 2px solid #4af;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .anim-frame-thumb:hover { border-color: #fff; }

        /* Dialog page button styles */
        .dialog-page {
            padding: 8px 12px;
            background: #333;
            border: 2px solid #555;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #aaa;
        }
        .dialog-page:hover { border-color: #888; }
        .dialog-page.active {
            background: #484;
            border-color: #6a6;
            color: #fff;
        }

        .anim-frame-thumb .frame-num {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0,0,0,0.8);
            color: #4af;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 2px;
        }

        /* NPC System Styles */
        .npc-item {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            cursor: pointer;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .npc-item:hover { background: #444; }
        .npc-item.selected { border-color: #4af; background: #3a3a5e; }
        .npc-item .npc-preview {
            width: 32px;
            height: 32px;
            background: #222;
            border-radius: 4px;
            image-rendering: pixelated;
        }
        .npc-item .npc-info { flex: 1; }
        .npc-item .npc-name { color: #4af; font-weight: bold; font-size: 12px; }
        .npc-item .npc-type { color: #888; font-size: 10px; }
        .npc-item .npc-actions { display: flex; gap: 5px; }
        .npc-item .npc-actions button { padding: 3px 8px; font-size: 10px; }

        .npc-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
        }
        .npc-modal.visible { display: flex; justify-content: center; align-items: center; }

        .npc-modal-content {
            background: #2a2a4e;
            border: 2px solid #4af;
            border-radius: 10px;
            padding: 25px;
            width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .npc-modal h2 { color: #4af; margin-bottom: 20px; }
        .npc-modal label { display: block; color: #aaa; font-size: 12px; margin: 10px 0 5px; }
        .npc-modal input[type="text"], .npc-modal textarea, .npc-modal select {
            width: 100%;
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }
        .npc-modal textarea { min-height: 80px; resize: vertical; }

        .npc-sprite-preview {
            background: #111;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }
        .npc-sprite-preview canvas {
            image-rendering: pixelated;
            border: 1px solid #444;
        }

        .npc-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .placed-npc-item {
            background: #2a2a3e;
            padding: 6px 10px;
            border-radius: 4px;
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .placed-npc-item button { padding: 2px 8px; font-size: 10px; background: #a55; }

        /* Hamburger menu and resize handle */
        .mode-tabs-header {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #2a2a3e;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .hamburger-btn {
            background: #444;
            border: none;
            color: #fff;
            font-size: 20px;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
        }
        .hamburger-btn:hover { background: #555; }
        #currentModeLabel {
            font-weight: bold;
            font-size: 14px;
        }
        .mode-tabs.collapsed {
            display: none;
        }
        .resize-handle {
            position: relative;
            width: 24px;
            height: 100%;
            min-height: 200px;
            background: #333;
            border-left: 2px solid #555;
            border-right: 2px solid #555;
            cursor: ew-resize;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .resize-handle::before {
            content: '‹›';
            color: #888;
            font-size: 24px;
            font-weight: bold;
        }
        .resize-handle:hover, .resize-handle.active {
            background: #4af;
            border-color: #4af;
        }
        .resize-handle:hover::before, .resize-handle.active::before {
            color: #000;
        }

        /* Mobile/Touch friendly styles */
        @media (max-width: 1024px), (pointer: coarse) {
            .toolbar button, .tool-buttons button, .zoom-controls button {
                min-height: 44px;
                min-width: 44px;
                font-size: 14px;
                padding: 8px 12px;
            }
            .sidebar { width: 280px; }
            .mode-buttons button { padding: 10px 15px; font-size: 13px; }
            #mapCanvas { touch-action: none; }
            #paintTilesetCanvas { touch-action: manipulation; }
            .tileset-container { touch-action: pan-x pan-y; }
            .map-viewport { touch-action: pan-x pan-y; }
            .panel { touch-action: pan-y; }
            .mode-tabs-header { display: flex; }
            .mode-tabs { display: none; }
            .mode-tabs.expanded { display: flex; }
        }

        /* Test Game Console - visible log panel */
        #testConsole {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 320px;
            max-height: 300px;
            background: rgba(0,0,0,0.95);
            border: 2px solid #4af;
            border-radius: 8px;
            font-family: monospace;
            font-size: 11px;
            z-index: 9999;
            display: none;
            flex-direction: column;
        }
        #testConsole.visible { display: flex; }
        #testConsoleHeader {
            background: #234;
            padding: 8px 12px;
            border-radius: 6px 6px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #4af;
            font-weight: bold;
            font-size: 12px;
        }
        #testConsoleHeader button {
            background: #633;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        #testConsoleHeader button:hover { background: #944; }
        #testConsoleLogs {
            flex: 1;
            max-height: 240px;
            overflow-y: auto;
            padding: 8px;
            color: #0f0;
        }
        #testConsoleLogs div {
            margin: 3px 0;
            padding: 2px 0;
            border-bottom: 1px solid #222;
        }
        #testConsoleLogs .error { color: #f66; }
        #testConsoleLogs .warn { color: #fa0; }
        #testConsoleLogs .info { color: #4af; }
        #testConsoleLogs .stream { color: #8f8; }
        #testConsoleLogs .time { color: #666; margin-right: 6px; }
    </style>
</head>
<body>
    <!-- Cursor Mode Indicator -->
    <div id="cursorIndicator" style="display:none; position:fixed; pointer-events:none; z-index:99999; font-size:18px; text-shadow: 0 0 4px #000, 0 0 2px #000;"></div>

    <!-- Test Game Console (auto-opens on test start) -->
    <div id="testConsole">
        <div id="testConsoleHeader">
            <span>Test Game Console</span>
            <button onclick="document.getElementById('testConsole').classList.remove('visible')">✕</button>
        </div>
        <div id="testConsoleLogs"></div>
    </div>
    <!-- PHASE 1: LOAD -->
    <div id="loadPhase" class="phase active">
        <div class="load-box" id="mainMenu">
            <h1>ADVENTURE<br>CRAFTER</h1>
            <p>- WORLD BUILDER -</p>
            <div style="margin-top:20px;">
                <button class="retro-btn" onclick="document.getElementById('fileInput').click()">
                    > NEW GAME
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="showSaveChoice()">
                    > LOAD SAVE
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="showDirectJoinPrompt()" style="background:#226;">
                    > JOIN ROOM
                </button>
            </div>
            <p class="blink" style="margin-top:20px; font-size:8px; color:#fff;">
                SELECT OPTION
            </p>
        </div>
        <div class="load-box" id="saveChoice" style="display:none;">
            <h1>LOAD<br>SAVE</h1>
            <p>- SELECT SOURCE -</p>
            <div style="margin-top:20px;">
                <button class="retro-btn" onclick="playButtonSound(); document.getElementById('projectFileInputWelcome').click(); document.getElementById('saveChoice').style.display='none'; document.getElementById('mainMenu').style.display='block';">
                    > YOUR SAVE
                </button>
            </div>
            <div style="margin-top:10px;">
                <button class="retro-btn" onclick="playButtonSound(); document.getElementById('saveChoice').style.display='none'; document.getElementById('mainMenu').style.display='block';" style="font-size:10px;">
                    > BACK
                </button>
            </div>
        </div>
        <div class="load-box" id="modeSelect" style="display:none;">
            <h1>WHO ARE<br>YOU?</h1>
            <div style="margin-top:20px;">
                <button class="retro-btn" onclick="playButtonSound(); startBuilder()">
                    > ADVENTURER
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="playButtonSound(); startBuilder()">
                    > CRAFTER
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="playButtonSound(); startBuilder()">
                    > BOTH
                </button>
            </div>
        </div>
        <div class="load-box" id="craftMultiplayerPrompt" style="display:none;">
            <h1>BUILD MODE</h1>
            <p style="font-size:7px; color:#888;">CHOOSE HOW TO BUILD</p>
            <div style="margin-top:20px;">
                <button class="retro-btn" onclick="playActionSound(); startCraftSolo()" style="width:200px;">
                    > SOLO
                </button>
                <p style="font-size:6px; color:#666; margin:5px 0 15px 0;">BUILD ALONE</p>
            </div>
            <div>
                <button class="retro-btn" onclick="showHostPrompt()" style="width:200px;">
                    > HOST ROOM
                </button>
                <p style="font-size:6px; color:#666; margin:5px 0 15px 0;">OTHERS JOIN YOU</p>
            </div>
            <div>
                <button class="retro-btn" onclick="showJoinPrompt()" style="width:200px;">
                    > JOIN ROOM
                </button>
                <p style="font-size:6px; color:#666; margin:5px 0 15px 0;">JOIN SOMEONE ELSE</p>
            </div>
            <div style="margin-top:10px;">
                <button class="retro-btn" onclick="hideCraftMultiplayerPrompt()" style="font-size:8px;">
                    > BACK
                </button>
            </div>
        </div>
        <!-- HOST ROOM PROMPT -->
        <div class="load-box" id="hostRoomPrompt" style="display:none;">
            <h1>HOST ROOM</h1>
            <div style="margin-top:15px;">
                <input type="text" id="hostPlayerName" placeholder="YOUR NAME" maxlength="12" autocomplete="off"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;"
                    onkeydown="if(event.key==='Enter'){event.preventDefault();document.getElementById('hostRoomCode').focus();}">
            </div>
            <div style="margin-top:10px;">
                <input type="text" id="hostRoomCode" placeholder="ROOM CODE" maxlength="12" autocomplete="off"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;"
                    onkeydown="if(event.key==='Enter'){event.preventDefault();playActionSound();startCraftHost();}">
            </div>
            <p style="font-size:7px; color:#0ff; margin-top:8px; text-shadow:0 0 10px #0ff, 0 0 20px #0ff; animation:glow-blink 1s ease-in-out infinite;">SHARE THIS CODE WITH FRIENDS</p>
            <div style="margin-top:15px;">
                <button class="retro-btn" onclick="playActionSound(); startCraftHost()">
                    > CREATE
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="hideHostPrompt()" style="font-size:8px;">
                    > BACK
                </button>
            </div>
        </div>
        <!-- JOIN ROOM PROMPT -->
        <div class="load-box" id="joinRoomPrompt" style="display:none;">
            <h1>JOIN ROOM</h1>
            <p style="font-size:7px; color:#888;">LOAD SAME SAVE AS HOST</p>
            <div style="margin-top:15px;">
                <button class="retro-btn" onclick="document.getElementById('joinSaveFileInput').click()" style="font-size:8px; background:#2a7;">
                    > LOAD SAVE FILE
                </button>
                <input type="file" id="joinSaveFileInput" accept=".json" style="display:none;" onchange="handleJoinSaveFile(event)">
                <p id="joinSaveStatus" style="font-size:6px; color:#888; margin-top:5px;">No file loaded</p>
            </div>
            <div style="margin-top:10px;">
                <input type="text" id="joinPlayerName" placeholder="YOUR NAME" maxlength="12" autocomplete="off"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;"
                    onkeydown="if(event.key==='Enter'){event.preventDefault();document.getElementById('joinRoomCode').focus();}">
            </div>
            <div style="margin-top:10px;">
                <input type="text" id="joinRoomCode" placeholder="ROOM CODE" maxlength="12" autocomplete="off"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;"
                    onkeydown="if(event.key==='Enter'){event.preventDefault();playActionSound();startCraftJoin();}">
            </div>
            <p style="font-size:6px; color:#666; margin-top:5px;">ENTER HOST'S ROOM CODE</p>
            <div style="margin-top:15px;">
                <button class="retro-btn" onclick="playActionSound(); startCraftJoin()">
                    > JOIN
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="hideJoinPrompt()" style="font-size:8px;">
                    > BACK
                </button>
            </div>
        </div>
        <div class="load-box" id="multiplayerPrompt" style="display:none;">
            <h1>MULTIPLAYER</h1>
            <p>- OPTIONAL -</p>
            <div style="margin-top:15px;">
                <input type="text" id="mpPlayerName" placeholder="YOUR NAME" maxlength="12"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;">
            </div>
            <div style="margin-top:10px;">
                <input type="text" id="mpRoomCode" placeholder="ROOM CODE" maxlength="12"
                    style="font-family:'Press Start 2P',monospace; font-size:10px; padding:10px; width:180px; text-align:center; background:#111; color:#fff; border:2px solid #fff;">
            </div>
            <p style="font-size:6px; color:#666; margin-top:8px;">LEAVE BLANK FOR SOLO</p>
            <div style="margin-top:15px;">
                <button class="retro-btn" onclick="playActionSound(); startAdventure()">
                    > START
                </button>
            </div>
            <div>
                <button class="retro-btn" onclick="hideMultiplayerPrompt()" style="font-size:8px;">
                    > BACK
                </button>
            </div>
        </div>
        <input type="file" id="fileInput" accept="image/*" onchange="loadTileset(event)" style="display:none;">
        <input type="file" id="projectFileInputWelcome" accept=".json" style="display:none;" onchange="loadSaveWithModeSelect(event)">
    </div>

    <!-- PHASE 2: COLLISION SETUP -->
    <div id="collisionPhase" class="phase">
        <div class="collision-header">
            <div>
                <h2>Step 1: Define Collision</h2>
                <span style="color:#888; font-size:12px;">Paint collision on tiles with brush</span>
            </div>
            <div>
                <label style="color:#aaa; margin-right:10px;">Tile Size:</label>
                <select id="gridSize" onchange="rebuildCollisionView()">
                    <option value="16" selected>16x16</option>
                    <option value="32">32x32</option>
                </select>
                <button onclick="finishCollisionSetup()" class="primary" style="margin-left:20px; padding:10px 25px;">
                    Done - Start Building →
                </button>
            </div>
        </div>
        <div class="collision-body">
            <div class="collision-sidebar">
                <div class="info">
                    <strong>Simple Tile Collision:</strong><br>
                    Left-click: Add collision<br>
                    Right-click: Remove collision<br>
                    Drag to paint multiple tiles
                </div>

                <h3>Tool</h3>
                <div class="tool-buttons">
                    <button id="collisionToolPaint" class="active" onclick="setCollisionTool('paint')">Add Collision</button>
                    <button id="collisionToolErase" onclick="setCollisionTool('erase')">Remove</button>
                    <button id="collisionToolSplit" onclick="setCollisionTool('split')" style="background:#0aa;">Depth Split</button>
                </div>

                <div id="splitControls" style="display:none; margin:10px 0; padding:10px; background:#1a3a3e; border-radius:5px;">
                    <div style="font-size:11px; color:#0ff; margin-bottom:5px;">Draw split line on tiles (drag to draw)</div>
                    <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                        <label style="font-size:11px; display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="checkbox" id="flatLineToggle" checked onchange="toggleFlatLineMode()">
                            <span>Flat Line</span>
                        </label>
                        <label style="font-size:11px; display:flex; align-items:center; gap:5px; cursor:pointer;" title="Flip: bottom covers player (for rocks, ledges)">
                            <input type="checkbox" id="splitFlipToggle" onchange="toggleSplitFlip()">
                            <span>Flip</span>
                        </label>
                        <span style="font-size:11px;">Y:</span>
                        <input type="number" id="splitYInput" value="8" min="0" max="16" style="width:50px; padding:3px;">
                        <button onclick="setSplitLineY()" style="padding:3px 8px; font-size:10px; background:#0aa;">Set Y</button>
                        <button onclick="clearSelectedSplit()" style="padding:3px 8px; font-size:10px; background:#a55;">Clear</button>
                    </div>
                    <div id="splitHelpText" style="font-size:10px; color:#888; margin-top:5px;">C = Canopy (top, covers player) | T = Trunk (bottom, Y-sorted)</div>
                </div>

                <h3>Brush Size (pixels)</h3>
                <div class="tool-buttons">
                    <button id="brush2" onclick="setBrushSize(2)">2</button>
                    <button id="brush4" class="active" onclick="setBrushSize(4)">4</button>
                    <button id="brush8" onclick="setBrushSize(8)">8</button>
                    <button id="brush16" onclick="setBrushSize(16)">16</button>
                </div>

                <h3>Brush Shape</h3>
                <div class="tool-buttons">
                    <button id="brushShapeSquare" class="active" onclick="setBrushShape('square')">■ Square</button>
                    <button id="brushShapeCircle" onclick="setBrushShape('circle')">● Circle</button>
                    <button id="brushShapeRect" onclick="setBrushShape('rect')">▬ Rect</button>
                </div>
                <div id="brushRectControls" style="display:none; margin-top:8px;">
                    <div style="display:flex; gap:10px; align-items:center;">
                        <label style="font-size:10px; color:#aaa;">W: <input type="number" id="brushRectW" value="8" min="1" max="32" style="width:40px;" onchange="updateBrushRect()"></label>
                        <label style="font-size:10px; color:#aaa;">H: <input type="number" id="brushRectH" value="4" min="1" max="32" style="width:40px;" onchange="updateBrushRect()"></label>
                    </div>
                </div>

                <h3>Zoom (Q/E or +/-)</h3>
                <div class="tool-buttons">
                    <button onclick="setCollisionZoom(2)">2x</button>
                    <button onclick="setCollisionZoom(4)">4x</button>
                    <button id="collisionZoom8" class="active" onclick="setCollisionZoom(6)">6x</button>
                    <button onclick="setCollisionZoom(8)">8x</button>
                </div>
                <div style="font-size:10px; color:#666; margin-top:5px;">Middle-click drag or Shift+drag to pan</div>

                <h3>Quick Actions</h3>
                <div class="tool-buttons">
                    <button onclick="selectAllCollision()">All Solid</button>
                    <button onclick="clearAllCollision()" class="danger">Clear All</button>
                </div>

                <h3 style="margin-top:20px;">Stats</h3>
                <div id="collisionStats" style="background:#111; padding:10px; border-radius:5px; font-size:12px; color:#888;">
                    0 tiles with collision
                </div>
            </div>

            <div class="collision-main">
                <canvas id="collisionTilesetCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- PHASE 3: BUILD -->
    <div id="buildPhase" class="phase">
        <div class="panel left-panel" id="leftPanel">
            <div class="mode-tabs-header">
                <button id="menuToggle" class="hamburger-btn" onclick="toggleModeMenu()">☰</button>
                <span id="currentModeLabel">Tools</span>
            </div>
            <div class="mode-tabs" id="modeTabs">
                <button id="tileMode" class="active" onclick="setMode('tile')">Tiles</button>
                <button id="playerMode" onclick="setMode('player')">Player</button>
                <button id="npcMode" onclick="setMode('npc')">NPCs</button>
                <button id="animPropMode" onclick="setMode('animProp')">Animated</button>
                <button id="soundMode" onclick="setMode('sound')">Sounds</button>
                <button id="lightingMode" onclick="setMode('lighting')">Lights</button>
                <button id="triggerMode" onclick="setMode('trigger')">Triggers</button>
                <button id="cameraMode" onclick="setMode('camera')">Camera</button>
                <button id="dialogMode" onclick="setMode('dialog')">Dialogs</button>
                <button id="itemMode" onclick="setMode('item')">Items</button>
                <button id="questMode" onclick="setMode('quest')">Quests</button>
            </div>

            <!-- TILE MODE -->
            <div id="tileModeContent">
                <!-- Hide during door animation mode -->
                <div id="tileNormalUI">
                    <h3>Transform</h3>
                    <div class="tool-buttons" style="margin-bottom:8px;">
                        <button id="rot0" class="retro-btn retro-cyan active" onclick="setRotation(0)">0°</button>
                        <button id="rot90" class="retro-btn retro-purple" onclick="setRotation(90)">90°</button>
                        <button id="rot180" class="retro-btn retro-orange" onclick="setRotation(180)">180°</button>
                        <button id="rot270" class="retro-btn retro-pink" onclick="setRotation(270)">270°</button>
                    </div>
                    <div class="tool-buttons" style="gap:8px;">
                        <button id="flipBtn" class="retro-btn retro-blue" onclick="toggleFlipH()" style="flex:1;">Flip H</button>
                        <button id="eraseBtn" class="retro-btn retro-red" onclick="toggleEraseMode()" style="flex:1;">Erase</button>
                    </div>
                </div>

                <h3>Tileset</h3>
                <div style="display:flex; gap:5px; margin-bottom:5px; align-items:center;">
                    <div class="tileset-picker" id="tilesetPicker">
                        <div class="tileset-picker-btn" onclick="toggleTilesetPicker()">
                            <img class="thumb" id="tilesetPickerThumb" src="">
                            <span class="name" id="tilesetPickerName">No tileset</span>
                            <span class="arrow">▼</span>
                        </div>
                        <div class="tileset-picker-dropdown" id="tilesetPickerDropdown">
                            <div id="tilesetDropdownControls" style="padding:8px; border-bottom:1px solid #444; display:flex; gap:8px; align-items:center;">
                                <input type="text" id="tilesetSearchInput" placeholder="Search..." oninput="filterTilesets(this.value)" style="flex:1; padding:5px 8px; background:#1a1a2a; color:#fff; border:1px solid #555; border-radius:4px; font-size:11px;">
                                <button id="tilesetSortBtn" onclick="toggleTilesetSort()" style="padding:4px 8px; font-size:10px; background:#555; border:none; border-radius:3px; cursor:pointer;" title="Toggle sort order">A-Z</button>
                            </div>
                            <div id="tilesetDropdownList" style="max-height:300px; overflow-y:auto;"></div>
                        </div>
                    </div>
                    <input type="file" id="addTilesetInput" accept="image/*" onchange="addTileset(event)" style="display:none;">
                    <button onclick="document.getElementById('addTilesetInput').click()" style="padding:5px 10px;" title="Add tileset">+</button>
                    <button onclick="deleteTileset()" style="padding:5px 10px; background:#a55;" title="Delete tileset">×</button>
                </div>
                <!-- Hide during door animation mode -->
                <div id="tileExtraButtons">
                    <div style="display:flex; gap:5px; margin-bottom:5px;">
                        <button id="tileSelectModeBtn" onclick="toggleTileSelectMode()" style="flex:1; background:#555;">Select Tiles</button>
                    </div>
                    <div style="display:flex; gap:5px; margin-bottom:5px;">
                        <button id="createObjectBtn" onclick="toggleCreateObjectMode()" style="flex:1; background:#4a7c59; font-weight:bold;">CREATE OBJECT</button>
                    </div>
                </div>
                <div class="tileset-container">
                    <canvas id="paintTilesetCanvas"></canvas>
                </div>

                <!-- Hide during door animation mode -->
                <div id="tileCopyCollision">
                    <div style="margin-top:10px; padding:10px; background:#1a2a1a; border-radius:6px; border:1px solid #3a5;">
                        <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                            <button id="copyFromMapBtn" onclick="startCopyFromMap()" class="retro-btn retro-green" style="flex:1;">Copy from Map</button>
                        </div>
                        <label style="display:flex; align-items:center; gap:6px; font-size:10px; color:#8c8; cursor:pointer;">
                            <input type="checkbox" id="copyAllLayers" style="accent-color:#5f8;">
                            Copy All Layers
                        </label>
                        <div id="copyModeInfo" style="display:none; font-size:10px; color:#5f8; margin-top:6px; text-align:center;">Click & drag on map to select area</div>
                    </div>

                    <button onclick="goBackToCollision()" class="retro-btn retro-purple" style="margin-top:15px; width:100%;">Edit Tile Collisions</button>
                </div>

                <h3 style="margin-top:15px;">Layers</h3>
                <div id="layerList"></div>
                <!-- Hide during door animation mode -->
                <div id="tileLayerAdd">
                    <button onclick="addLayer()" style="margin-top:5px;">+ Add Layer</button>
                </div>
            </div>

            <!-- PLAYER MODE -->
            <div id="playerModeContent" style="display:none;">
                <h3>Player Characters</h3>

                <div id="playerListContainer">
                    <div id="playerCharacterList" style="margin-bottom:10px;"></div>
                    <button onclick="openPlayerEditor()" style="width:100%;">+ Create Character</button>
                </div>

                <p style="font-size:10px; color:#666; margin-top:10px;">Create player sprite sheets with walk animations. Active character is used in test game.</p>

                <div style="margin-top:15px; padding:10px; background:#1a2a1a; border-radius:5px;">
                    <div style="display:flex; align-items:center; gap:10px;">
                        <canvas id="activePlayerPreview" width="64" height="64" style="border:2px solid #4f8; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                        <div>
                            <div style="font-size:11px; color:#8a8;">Active:</div>
                            <div id="activePlayerName" style="color:#4f8; font-size:13px; font-weight:bold;">Default Sprite</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- NPC MODE -->
            <div id="npcModeContent" style="display:none;">
                <h3>NPCs</h3>

                <div id="npcListContainer">
                    <div id="npcList" style="margin-bottom:10px;"></div>
                    <button onclick="openNpcEditor()" style="width:100%;">+ Create NPC</button>
                </div>

                <p style="font-size:10px; color:#666; margin-top:10px;">Select NPC from list, then click map to place.</p>

                <!-- Scale Slider (for placement) -->
                <div style="margin-top:10px; padding:8px; background:#1a2a1a; border-radius:4px; border:1px solid #4a4;">
                    <div style="display:flex; align-items:center; justify-content:space-between;">
                        <span style="font-size:11px; color:#aaa;">Placement Scale:</span>
                        <span id="npcPlacementScaleValue" style="font-size:10px; color:#4f4;">1.0x</span>
                    </div>
                    <input type="range" id="npcPlacementScale" min="0.5" max="3" value="1" step="0.1" oninput="updateNpcPlacementScaleDisplay()" style="width:100%;">
                </div>

                <h3 style="margin-top:15px;">Placed NPCs</h3>
                <div id="placedNpcList" style="max-height:120px; overflow-y:auto; font-size:11px; color:#888;">
                    No NPCs placed
                </div>

                <!-- Path Editor Panel (shown when NPC selected) -->
                <div id="npcPathPanel" style="display:none; margin-top:15px; padding:10px; background:#1a1a2e; border-radius:5px;">
                    <h3 style="margin-top:0;">Path for: <span id="npcPathName">NPC</span></h3>

                    <!-- Quest Chain Info (shown if NPC has quests) -->
                    <div id="npcQuestChainPanel" style="display:none; margin-bottom:10px; padding:8px; background:#2a2a1a; border:1px solid #fa0; border-radius:4px;">
                        <div style="font-size:11px; color:#fa0; font-weight:bold; margin-bottom:6px;">Quest Chain:</div>
                        <div id="npcQuestChainList" style="font-size:10px; color:#ddd;"></div>
                    </div>

                    <!-- Collapsible Settings Header -->
                    <div onclick="toggleNpcSettingsPanel()" style="cursor:pointer; background:#252540; border:2px solid #444; border-radius:4px; padding:8px; margin-bottom:8px; display:flex; justify-content:space-between; align-items:center;">
                        <span style="font-size:12px; color:#8af; font-weight:bold;">NPC Settings</span>
                        <span id="npcSettingsToggle" style="font-size:14px; color:#8af;">+</span>
                    </div>

                    <!-- Collapsible Settings Content -->
                    <div id="npcSettingsContent" style="display:none; border:1px solid #333; border-radius:4px; padding:8px; margin-bottom:10px; background:#151525;">
                        <div style="margin-bottom:10px;">
                            <div style="display:flex; gap:5px; margin-bottom:5px;">
                                <button id="npcDrawPathBtn" onclick="toggleNpcPathDrawing()" style="flex:1; background:#4a4;">Draw Path</button>
                                <button id="npcEditPathBtn" onclick="toggleNpcPathEditing()" style="flex:1; background:#47a;">Edit Path</button>
                            </div>
                            <p id="npcPathInfo" style="font-size:10px; color:#666; margin-top:5px;">Click tiles to add waypoints</p>
                        </div>

                        <div style="margin-bottom:10px;">
                            <label style="font-size:11px;">Trigger:</label>
                            <select id="npcTriggerType" onchange="updateNpcTrigger()" style="width:100%; margin-top:3px;">
                                <option value="loop">Loop (always walking)</option>
                                <option value="interact">On Interact (attack)</option>
                                <option value="timeDay">Time: Day only</option>
                                <option value="timeNight">Time: Night only</option>
                            </select>
                        </div>

                        <div style="margin-bottom:8px;">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <label style="font-size:11px;">Walk Speed:</label>
                                <span id="npcSpeedValue" style="font-size:10px; color:#4af;">3</span>
                            </div>
                            <input type="range" id="npcWalkSpeed" min="1" max="10" value="3" onchange="updateNpcSpeed()" style="width:100%;">
                        </div>
                        <div style="margin-bottom:10px;">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <label style="font-size:11px;">Anim Speed:</label>
                                <span id="npcAnimSpeedValue" style="font-size:10px; color:#4af;">8 fps</span>
                            </div>
                            <input type="range" id="npcAnimSpeed" min="1" max="24" value="8" onchange="updateNpcAnimSpeed()" style="width:100%;">
                        </div>

                        <!-- Enemy AI Settings -->
                        <div id="npcEnemySection" style="margin:10px 0; padding:8px; background:#2a1a1a; border:1px solid #a44; border-radius:4px;">
                            <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                <input type="checkbox" id="npcIsEnemy" onchange="updateNpcEnemy()">
                                <label for="npcIsEnemy" style="font-size:11px; color:#f88; cursor:pointer;">Enemy AI</label>
                            </div>
                            <div id="npcEnemyOptions" style="display:none;">
                                <!-- Vision Radius -->
                                <div style="margin-bottom:6px;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <label style="font-size:10px; color:#aaa;">Vision Radius:</label>
                                        <span id="npcVisionValue" style="font-size:10px; color:#f88;">5 tiles</span>
                                    </div>
                                    <input type="range" id="npcVisionRadius" min="1" max="15" value="5" onchange="updateNpcEnemy()" style="width:100%;">
                                </div>
                                <!-- Chase Speed -->
                                <div style="margin-bottom:6px;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <label style="font-size:10px; color:#aaa;">Chase Speed:</label>
                                        <span id="npcChaseSpeedValue" style="font-size:10px; color:#f88;">4</span>
                                    </div>
                                    <input type="range" id="npcChaseSpeed" min="1" max="10" value="4" onchange="updateNpcEnemy()" style="width:100%;">
                                </div>
                                <!-- Attack Mode -->
                                <div style="margin-bottom:6px;">
                                    <label style="font-size:10px; color:#aaa;">Attack Mode:</label>
                                    <select id="npcAttackMode" onchange="updateNpcEnemy()" style="width:100%; margin-top:2px; background:#1a1a2e; color:#fff; border:1px solid #555; padding:3px;">
                                        <option value="touch">Touch (contact damage)</option>
                                        <option value="lunge">Lunge (dash attack)</option>
                                    </select>
                                </div>
                                <!-- Damage Amount -->
                                <div style="margin-bottom:6px;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <label style="font-size:10px; color:#aaa;">Damage:</label>
                                        <span id="npcDamageValue" style="font-size:10px; color:#f88;">10</span>
                                    </div>
                                    <input type="range" id="npcDamage" min="5" max="50" value="10" step="5" onchange="updateNpcEnemy()" style="width:100%;">
                                </div>
                                <!-- Damage Cooldown -->
                                <div style="margin-bottom:6px;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <label style="font-size:10px; color:#aaa;">Attack Cooldown:</label>
                                        <span id="npcCooldownValue" style="font-size:10px; color:#f88;">1.0s</span>
                                    </div>
                                    <input type="range" id="npcAttackCooldown" min="0.5" max="3" value="1" step="0.25" onchange="updateNpcEnemy()" style="width:100%;">
                                </div>
                                <!-- Lunge Options (only shown for lunge mode) -->
                                <div id="npcLungeOptions" style="display:none; padding:6px; background:#1a1a2e; border-radius:4px; margin-bottom:6px;">
                                    <div style="margin-bottom:6px;">
                                        <div style="display:flex; justify-content:space-between; align-items:center;">
                                            <label style="font-size:10px; color:#aaa;">Lunge Range:</label>
                                            <span id="npcLungeRangeValue" style="font-size:10px; color:#f88;">2 tiles</span>
                                        </div>
                                        <input type="range" id="npcAttackRange" min="1" max="5" value="2" onchange="updateNpcEnemy()" style="width:100%;">
                                    </div>
                                    <div style="margin-bottom:4px;">
                                        <div style="display:flex; justify-content:space-between; align-items:center;">
                                            <label style="font-size:10px; color:#aaa;">Lunge Speed:</label>
                                            <span id="npcLungeSpeedValue" style="font-size:10px; color:#f88;">8</span>
                                        </div>
                                        <input type="range" id="npcLungeSpeed" min="4" max="16" value="8" onchange="updateNpcEnemy()" style="width:100%;">
                                    </div>
                                </div>
                                <!-- Post-Attack Slowdown -->
                                <div style="padding:6px; background:#2a1a2a; border-radius:4px; margin-bottom:6px;">
                                    <div style="font-size:10px; color:#aaa; margin-bottom:4px;">-- Post-Attack Slowdown --</div>
                                    <div style="margin-bottom:6px;">
                                        <div style="display:flex; justify-content:space-between; align-items:center;">
                                            <label style="font-size:10px; color:#aaa;">Slowdown %:</label>
                                            <span id="npcSlowdownValue" style="font-size:10px; color:#f88;">50%</span>
                                        </div>
                                        <input type="range" id="npcSlowdownPercent" min="0" max="100" value="50" step="10" onchange="updateNpcEnemy()" style="width:100%;">
                                    </div>
                                    <div style="margin-bottom:4px;">
                                        <div style="display:flex; justify-content:space-between; align-items:center;">
                                            <label style="font-size:10px; color:#aaa;">Slowdown Duration:</label>
                                            <span id="npcSlowdownDurationValue" style="font-size:10px; color:#f88;">0.5s</span>
                                        </div>
                                        <input type="range" id="npcSlowdownDuration" min="0" max="2" value="0.5" step="0.25" onchange="updateNpcEnemy()" style="width:100%;">
                                    </div>
                                </div>
                                <div style="font-size:9px; color:#888; margin-top:5px;">
                                    <span id="npcAttackModeDesc">Touch: deals damage on contact. Lunge: dashes at player when in range.</span>
                                </div>
                            </div>
                        </div>

                        <!-- NPC Scale -->
                        <div style="margin-bottom:8px; padding:6px; background:#1a2a1a; border:1px solid #4a4; border-radius:4px;">
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <label style="font-size:10px; color:#aaa;">NPC Scale:</label>
                                <span id="npcScaleValue" style="font-size:10px; color:#4f4;">1.0x</span>
                            </div>
                            <input type="range" id="npcScale" min="0.5" max="3" value="1" step="0.1" onchange="updateNpcScale()" style="width:100%;">
                        </div>

                        <div style="display:flex; gap:5px; margin-bottom:8px;">
                            <button id="npcPreviewPathBtn" onclick="toggleNpcPathPreview()" style="flex:1; background:#47a;">Preview</button>
                            <button onclick="clearNpcPath()" style="flex:1; background:#a55;">Clear Path</button>
                        </div>

                        <div id="npcWaypointList" style="margin-top:10px; font-size:10px; color:#888; max-height:150px; overflow-y:auto;">
                            No waypoints
                        </div>
                    </div>

                    <!-- Add Dialog Button - Retro Style -->
                    <button id="npcAddDialogBtn" class="retro-btn retro-purple" onclick="addDialogToSelectedNpc()" style="width:100%; margin-bottom:8px;">
                        + Dialog
                    </button>

                    <button onclick="deleteSelectedPlacedNpc()" style="width:100%; background:#a33;">Delete NPC</button>
                </div>
            </div>

            <!-- ANIMATED PROPS MODE -->
            <div id="animPropModeContent" style="display:none;">
                <!-- Static Objects Section -->
                <h3 style="color:#4a7c59; margin-bottom:10px; border-bottom:1px solid #4a7c59; padding-bottom:5px;">Static Objects</h3>
                <div id="staticObjList" style="display:flex; flex-wrap:wrap; gap:5px; margin-bottom:10px; max-height:200px; overflow-y:auto;"></div>
                <p style="color:#888; font-size:10px; margin-bottom:8px;">Use CREATE OBJECT in Tiles tab to add new objects from tileset selections.</p>

                <!-- Scale Slider for Static Objects -->
                <div id="staticObjPlacementControls" style="display:none; margin-bottom:15px; padding:8px; background:#1a2a35; border-radius:4px;">
                    <div style="display:flex; align-items:center; justify-content:space-between;">
                        <span style="font-size:11px; color:#aaa;">Scale:</span>
                        <span id="staticObjScaleValue" style="font-size:10px; color:#4a7c59;">1.0x</span>
                    </div>
                    <input type="range" id="staticObjScaleSlider" min="0.25" max="3" step="0.25" value="1"
                           oninput="updateStaticObjScale(this.value)" style="width:100%;">
                    <p style="font-size:9px; color:#666; margin-top:5px;">Click map to place. Right-click to remove.</p>
                </div>

                <hr style="margin:15px 0; border-color:#444;">

                <!-- Animated Props Section -->
                <h3>Animated Props</h3>

                <!-- Animated Prop List -->
                <div id="animPropListContainer">
                    <div id="animPropList" style="margin-bottom:10px;"></div>
                    <button onclick="openAnimPropEditor()" style="width:100%;">+ Create Animated Prop</button>
                </div>

                <!-- Scale Slider -->
                <div style="margin-top:10px; padding:8px; background:#1a2a35; border-radius:4px;">
                    <div style="display:flex; align-items:center; justify-content:space-between;">
                        <span style="font-size:11px; color:#aaa;">Scale:</span>
                        <span id="animPropScaleValue" style="font-size:10px; color:#4f4;">1.0x</span>
                    </div>
                    <input type="range" id="animPropScale" min="0.5" max="3" value="1" step="0.25" onchange="updateAnimPropScale()" oninput="updateAnimPropScale()" style="width:100%;">
                </div>

                <p style="font-size:10px; color:#666; margin-top:10px;">Select prop from list, then click map to place. Right-click to remove.</p>

                <!-- Edit Placed Props -->
                <div style="margin-top:10px;">
                    <button id="editAnimPropOnMapBtn" class="retro-btn retro-orange" onclick="toggleEditAnimPropMode()" style="width:100%;">
                        Edit Object on Map
                    </button>
                </div>

                <h3 style="margin-top:15px;">Layers</h3>
                <div id="animPropLayerList"></div>
                <button onclick="addLayer()" style="margin-top:5px;">+ Add Layer</button>
            </div>

            <!-- SOUND MODE -->
            <div id="soundModeContent" style="display:none;">
                <h3>Sounds</h3>

                <!-- Sound Library -->
                <div style="margin-bottom:15px;">
                    <div style="display:flex; gap:5px; align-items:center; margin-bottom:8px;">
                        <select id="soundSelect" onchange="switchSound()" style="flex:1;"></select>
                        <input type="file" id="soundInput" accept="audio/*" onchange="loadSound(event)" style="display:none;">
                        <button onclick="document.getElementById('soundInput').click()" style="padding:5px 10px;" title="Add Sound">+</button>
                    </div>
                    <div id="soundControls" style="display:none;">
                        <div style="display:flex; gap:5px; margin-bottom:8px;">
                            <button onclick="previewSound()" style="flex:1;">▶ Preview</button>
                            <button onclick="stopPreview()" style="flex:1;">■ Stop</button>
                        </div>
                        <div id="currentSoundInfo" style="font-size:10px; color:#888;"></div>
                    </div>
                    <div id="noSoundMessage" style="color:#888; font-size:11px; padding:10px; text-align:center;">
                        Click + to add sounds
                    </div>
                </div>

                <!-- Attach Mode -->
                <h4 style="margin:15px 0 8px 0; color:#4af;">Attach To:</h4>
                <div style="display:flex; gap:5px; margin-bottom:10px;">
                    <button id="soundAttachTile" class="active" onclick="setSoundAttachMode('tile')" style="flex:1;">Tile Position</button>
                    <button id="soundAttachPlayer" onclick="setSoundAttachMode('player')" style="flex:1;">Player Action</button>
                </div>

                <!-- Tile Mode Options -->
                <div id="tileSoundOptions">
                    <!-- Selection indicator -->
                    <div id="soundEditMode" style="background:#2a4a3a; padding:8px; border-radius:4px; margin-bottom:10px; display:none;">
                        <span style="color:#4f8;">Editing: <span id="editingSoundKey"></span></span>
                        <button onclick="deselectTileSound()" style="float:right; padding:2px 8px; font-size:10px;">Cancel</button>
                    </div>

                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Radius: <span id="soundRadiusVal">3</span> tiles
                        </label>
                        <input type="range" id="soundRadius" min="1" max="50" value="3" oninput="document.getElementById('soundRadiusVal').textContent=this.value" style="width:100%;">
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="soundLoop" checked> Loop continuously
                        </label>
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Volume: <span id="soundVolumeVal">50</span>%
                        </label>
                        <input type="range" id="soundVolume" min="0" max="100" value="50" oninput="document.getElementById('soundVolumeVal').textContent=this.value" style="width:100%;">
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Fade Distance: <span id="soundFadeVal">50</span>%
                        </label>
                        <input type="range" id="soundFade" min="0" max="100" value="50" oninput="document.getElementById('soundFadeVal').textContent=this.value" style="width:100%;">
                        <p style="font-size:9px; color:#555; margin-top:2px;">How much of radius is fade zone (0=abrupt, 100=full fade)</p>
                    </div>

                    <!-- Action buttons -->
                    <div style="display:flex; gap:5px; margin:10px 0;">
                        <button id="soundSaveBtn" onclick="saveSelectedSound()" style="flex:1; padding:8px; background:#4a7c59;">Save Changes</button>
                        <button onclick="deselectTileSound()" style="flex:1; padding:8px; background:#555;">New Sound</button>
                    </div>
                    <p style="font-size:10px; color:#666;">Click map to place new or select existing. Right-click to remove.</p>

                    <h4 style="margin:15px 0 8px 0; color:#4af;">Placed Sounds:</h4>
                    <div id="placedSoundsList" style="max-height:150px; overflow-y:auto; font-size:11px;"></div>
                </div>

                <!-- Player Mode Options -->
                <div id="playerSoundOptions" style="display:none;">
                    <div style="margin-bottom:10px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">Action:</label>
                        <select id="playerActionSelect" onchange="updatePlayerSoundUI()" style="width:100%;">
                            <option value="walk">Walk</option>
                            <option value="attack">Attack</option>
                        </select>
                    </div>
                    <div id="walkSoundSettings">
                        <div style="margin-bottom:8px;">
                            <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                                Step Interval: <span id="walkIntervalVal">200</span>ms
                            </label>
                            <input type="range" id="walkInterval" min="100" max="400" value="200" oninput="document.getElementById('walkIntervalVal').textContent=this.value" style="width:100%;">
                        </div>
                        <div style="margin-bottom:8px;">
                            <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                                Pitch Variation: <span id="walkPitchVal">10</span>%
                            </label>
                            <input type="range" id="walkPitch" min="0" max="30" value="10" oninput="document.getElementById('walkPitchVal').textContent=this.value" style="width:100%;">
                        </div>
                    </div>
                    <div id="attackSoundSettings" style="display:none;">
                        <div style="margin-bottom:8px;">
                            <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                                Pitch Variation: <span id="attackPitchVal">15</span>%
                            </label>
                            <input type="range" id="attackPitch" min="0" max="50" value="15" oninput="document.getElementById('attackPitchVal').textContent=this.value" style="width:100%;">
                            <p style="font-size:9px; color:#555; margin-top:2px;">Randomizes pitch each swing</p>
                        </div>
                        <div style="margin-bottom:8px;">
                            <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                                Length Variation: <span id="attackLengthVal">0</span>%
                            </label>
                            <input type="range" id="attackLength" min="0" max="50" value="0" oninput="document.getElementById('attackLengthVal').textContent=this.value" style="width:100%;">
                            <p style="font-size:9px; color:#555; margin-top:2px;">Randomizes how much of sound plays (0=full)</p>
                        </div>
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Volume: <span id="playerSoundVolumeVal">50</span>%
                        </label>
                        <input type="range" id="playerSoundVolume" min="0" max="100" value="50" oninput="document.getElementById('playerSoundVolumeVal').textContent=this.value" style="width:100%;">
                    </div>
                    <button onclick="assignPlayerSound()" style="width:100%; margin-top:5px;">Assign Selected Sound</button>

                    <h4 style="margin:15px 0 8px 0; color:#4af;">Current Assignments:</h4>
                    <div id="playerSoundAssignments" style="font-size:11px; color:#aaa;">
                        <div>Walk: <span id="walkSoundName">None</span></div>
                        <div>Attack: <span id="attackSoundName">None</span></div>
                    </div>
                </div>
            </div>

            <!-- LIGHTING MODE -->
            <div id="lightingModeContent" style="display:none;">
                <h3>Lighting</h3>

                <!-- Preview Toggle -->
                <button id="lightingPreviewBtn" onclick="toggleLightingPreview()" style="width:100%; padding:10px; margin-bottom:10px; background:#2a5a8a; font-weight:bold;">
                    Toggle Darkness: OFF
                </button>
                <div id="previewDarknessRow" style="display:none; margin-bottom:15px;">
                    <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                        Darkness Level: <span id="previewDarknessVal">70</span>%
                    </label>
                    <input type="range" id="previewDarknessSlider" min="0" max="100" step="5" value="70" oninput="document.getElementById('previewDarknessVal').textContent=this.value; renderMap();" style="width:100%;">
                </div>

                <!-- Player Light -->
                <div style="margin-bottom:15px; padding:10px; background:#2a2a1a; border-radius:4px;">
                    <h4 style="margin:0 0 10px 0; color:#4af;">Player Torch</h4>
                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="playerLight" onchange="updateLightingSettings()"> Player carries light
                        </label>
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Light Radius: <span id="playerLightRadiusVal">4</span> tiles
                        </label>
                        <input type="range" id="playerLightRadius" min="1" max="10" value="4" oninput="document.getElementById('playerLightRadiusVal').textContent=this.value; updateLightingSettings();" style="width:100%;">
                    </div>
                </div>

                <!-- Point Lights -->
                <div style="margin-bottom:15px; padding:10px; background:#2a1a2a; border-radius:4px;">
                    <h4 style="margin:0 0 10px 0; color:#4af;">Point Lights</h4>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Light Radius: <span id="pointLightRadiusVal">3</span> tiles
                        </label>
                        <input type="range" id="pointLightRadius" min="1" max="10" value="3" oninput="document.getElementById('pointLightRadiusVal').textContent=this.value" style="width:100%;">
                    </div>
                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="pointLightFlicker" onchange="document.getElementById('pointFlickerIntensityRow').style.display = this.checked ? 'block' : 'none'"> Flicker effect
                        </label>
                        <div id="pointFlickerIntensityRow" style="display:none; margin-top:5px;">
                            <label style="display:block; font-size:10px; color:#888; margin-bottom:2px;">
                                Flicker Intensity: <span id="pointFlickerIntensityVal">0.1</span>
                            </label>
                            <input type="range" id="pointFlickerIntensity" min="0.05" max="0.5" step="0.05" value="0.1" oninput="document.getElementById('pointFlickerIntensityVal').textContent=this.value" style="width:100%;">
                        </div>
                    </div>
                    <p style="font-size:10px; color:#666;">Click map to place lights. Right-click to remove.</p>

                    <h4 style="margin:15px 0 8px 0; color:#4af;">Placed Lights:</h4>
                    <div id="placedLightsList" style="max-height:150px; overflow-y:auto; font-size:11px;"></div>
                </div>

                <!-- Polygon Lights -->
                <div style="margin-bottom:15px; padding:10px; background:#1a2a2a; border-radius:4px; border:2px solid #0aa;">
                    <h4 style="margin:0 0 10px 0; color:#0ff;">Polygon Lights</h4>
                    <p style="font-size:10px; color:#888; margin-bottom:10px;">Draw custom light shapes by placing points</p>

                    <div style="display:flex; gap:5px; margin-bottom:10px;">
                        <button id="polyLightDrawBtn" onclick="togglePolyLightDraw()" class="retro-btn" style="flex:1; background:#0aa; color:#000; font-size:11px;">
                            DRAW POLYGON
                        </button>
                        <button onclick="finishPolyLight()" class="retro-btn" style="flex:1; background:#4a4; font-size:11px;">
                            FINISH
                        </button>
                    </div>

                    <div id="polyLightDrawStatus" style="font-size:10px; color:#0ff; margin-bottom:10px; display:none;">
                        Click to place points. Press FINISH or right-click to complete.
                    </div>

                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Light Intensity: <span id="polyLightIntensityVal">0.8</span>
                        </label>
                        <input type="range" id="polyLightIntensity" min="0.1" max="1" step="0.1" value="0.8" oninput="document.getElementById('polyLightIntensityVal').textContent=this.value" style="width:100%;">
                    </div>

                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="polyLightFlicker" onchange="document.getElementById('polyFlickerIntensityRow').style.display = this.checked ? 'block' : 'none'"> Flicker effect
                        </label>
                        <div id="polyFlickerIntensityRow" style="display:none; margin-top:5px;">
                            <label style="display:block; font-size:10px; color:#888; margin-bottom:2px;">
                                Flicker Intensity: <span id="polyFlickerIntensityVal">0.2</span>
                            </label>
                            <input type="range" id="polyFlickerIntensity" min="0.05" max="0.5" step="0.05" value="0.2" oninput="document.getElementById('polyFlickerIntensityVal').textContent=this.value" style="width:100%;">
                        </div>
                    </div>

                    <h4 style="margin:15px 0 8px 0; color:#0ff;">Polygon Lights:</h4>
                    <div id="placedPolyLightsList" style="max-height:120px; overflow-y:auto; font-size:11px;"></div>
                </div>
            </div>

            <!-- TRIGGER MODE -->
            <div id="triggerModeContent" style="display:none;">
                <h3>Map Triggers</h3>

                <!-- Current Map Selector -->
                <div style="background:#1a2a3a; padding:10px; border-radius:4px; margin-bottom:15px;">
                    <label style="font-size:11px; color:#aaa; display:block; margin-bottom:5px;">Current Map:</label>
                    <select id="currentMapSelect" style="width:100%; padding:6px; margin-bottom:8px;" onchange="switchToMap(this.value)">
                        <option value="main">main</option>
                    </select>
                    <div style="display:flex; gap:5px;">
                        <button onclick="promptNewMap()" style="flex:1; padding:6px;">+ New</button>
                        <button onclick="promptRenameMap()" style="flex:1; padding:6px; background:#668;">Rename</button>
                        <button onclick="promptDeleteMap()" style="flex:1; padding:6px; background:#a33;">Delete</button>
                    </div>
                </div>

                <!-- Trigger List -->
                <div style="background:#222; padding:10px; border-radius:4px; margin-bottom:15px;">
                    <h4 style="margin:0 0 8px 0; color:#f4f;">Triggers on this map:</h4>
                    <div id="triggerList" style="max-height:150px; overflow-y:auto; font-size:11px;">
                        <div style="color:#666; text-align:center; padding:10px;">No triggers placed</div>
                    </div>
                </div>

                <!-- Help text -->
                <div style="background:#1a1a2e; padding:12px; border-radius:4px; margin-bottom:15px;">
                    <p style="font-size:12px; color:#aaa; text-align:center; line-height:1.5; margin:0;">
                        <b style="color:#4af;">Click & drag</b> on map to place door<br>
                        <b style="color:#f4f;">Right-click</b> to remove<br>
                        <b style="color:#0f0;">Drag green boxes</b> to move spawns
                    </p>
                </div>
            </div>

            <!-- CAMERA MODE -->
            <div id="cameraModeContent" style="display:none;">
                <h3>Camera Settings</h3>

                <!-- Current Map -->
                <div style="background:#1a2a3a; padding:10px; border-radius:4px; margin-bottom:15px;">
                    <label style="font-size:11px; color:#aaa; display:block; margin-bottom:5px;">Current Map:</label>
                    <select id="cameraMapSelect" style="width:100%; padding:6px;" onchange="switchToMap(this.value)">
                        <option value="main">main</option>
                    </select>
                </div>

                <!-- Explanation -->
                <div style="background:#1a1a2e; padding:12px; border-radius:4px; margin-bottom:15px;">
                    <p style="font-size:12px; color:#ccc; line-height:1.6; margin:0 0 10px 0;">
                        <b>Camera Bounds</b> restrict where the camera can move during gameplay.
                        The camera will stay within the bounds you set, preventing players from seeing outside the play area.
                    </p>
                    <p style="font-size:11px; color:#aaa; line-height:1.5; margin:0;">
                        Each map can have its own camera bounds. If no bounds are set, the camera freely follows the player.
                    </p>
                </div>

                <!-- Camera Bounds Tool -->
                <div style="background:#2a2a2a; padding:12px; border-radius:4px; margin-bottom:15px;">
                    <h4 style="margin:0 0 10px 0; color:#fa0;">Bounds Area</h4>
                    <div id="cameraBoundsInfo" style="font-size:12px; color:#aaa; margin-bottom:10px; padding:8px; background:#1a1a1a; border-radius:4px;">
                        No bounds (camera follows player)
                    </div>
                    <div style="display:flex; gap:8px;">
                        <button id="setCameraBoundsBtn" onclick="toggleCameraBoundsMode()" style="flex:1; padding:8px; background:#484; font-size:13px;">Set Bounds</button>
                        <button onclick="clearCameraBounds()" style="padding:8px 12px; background:#644; font-size:13px;">Clear</button>
                    </div>
                </div>

                <!-- Instructions -->
                <div style="background:#222; padding:12px; border-radius:4px;">
                    <h4 style="margin:0 0 8px 0; color:#888;">How to use:</h4>
                    <ol style="margin:0; padding-left:20px; font-size:11px; color:#aaa; line-height:1.8;">
                        <li>Click <b style="color:#8f8;">Set Bounds</b></li>
                        <li>Drag on the map to select an area</li>
                        <li>Drag again to expand the bounds</li>
                        <li>Click <b style="color:#8f8;">Done</b> when finished</li>
                    </ol>
                </div>
            </div>

            <!-- DIALOG MODE -->
            <div id="dialogModeContent" style="display:none;">
                <h3>Dialog System</h3>

                <!-- Dialog List -->
                <div style="background:#1a2a3a; padding:10px; border-radius:4px; margin-bottom:15px;">
                    <label style="font-size:11px; color:#aaa; display:block; margin-bottom:8px;">Your Dialogs:</label>
                    <div id="dialogList" style="max-height:300px; overflow-y:auto; margin-bottom:10px;">
                        <div style="color:#666; font-size:12px; text-align:center; padding:20px;">No dialogs created yet</div>
                    </div>
                    <button onclick="openDialogEditor(-1)" style="width:100%; padding:8px; background:#484;">+ New Dialog</button>
                </div>

                <!-- Quick Instructions -->
                <div style="background:#222; padding:12px; border-radius:4px; margin-bottom:15px;">
                    <p style="font-size:11px; color:#aaa; line-height:1.6; margin:0;">
                        Create dialogs here, then attach them to <b style="color:#88f;">NPCs</b> or <b style="color:#fa0;">Triggers</b> to use them in your game.
                    </p>
                </div>

                <!-- Click to Place Instructions -->
                <div style="background:#222; padding:12px; border-radius:4px; margin-bottom:15px;">
                    <p style="font-size:11px; color:#aaa; line-height:1.6; margin:0;">
                        <b style="color:#8f8;">1.</b> Click a dialog above to select it<br>
                        <b style="color:#8f8;">2.</b> Click on <b style="color:#88f;">NPC</b> to attach dialog<br>
                        <b style="color:#8f8;">3.</b> Or click <b style="color:#fa0;">tile</b> to place a sign<br>
                        <b style="color:#f88;">Right-click</b> to remove/detach
                    </p>
                </div>

                <!-- NPC Dialog Trigger Type -->
                <div style="background:#1a1a2e; padding:10px; border-radius:4px; margin-bottom:15px;">
                    <label style="font-size:10px; color:#888;">NPC Dialog Trigger:</label>
                    <select id="dialogNpcTrigger" style="width:100%; padding:6px; margin-top:4px;">
                        <option value="interact">Press A to talk</option>
                        <option value="auto">Auto (walk near)</option>
                    </select>
                </div>

                <!-- Placed Dialog Tiles List -->
                <div style="background:#2a1a1a; padding:10px; border-radius:4px;">
                    <h4 style="margin:0 0 8px 0; font-size:11px; color:#fa0;">Placed Signs</h4>
                    <div id="placedDialogTilesList" style="max-height:100px; overflow-y:auto;">
                        <div style="color:#666; font-size:11px; text-align:center; padding:10px;">No dialog tiles placed</div>
                    </div>
                </div>
            </div>

            <!-- ITEMS MODE -->
            <div id="itemModeContent" style="display:none;">
                <h3>Items</h3>

                <!-- Item List -->
                <div id="itemListContainer">
                    <div id="itemList" style="margin-bottom:10px;"></div>
                    <button onclick="openItemEditor()" style="width:100%;">+ Create Item</button>
                </div>

                <!-- Layer Selector for Items -->
                <div style="margin-top:10px; padding:8px; background:#1a1a2a; border-radius:4px;">
                    <label style="font-size:11px; color:#aaa;">Place on Layer:</label>
                    <select id="itemPlacementLayer" style="width:100%; margin-top:3px; padding:5px;">
                        <option value="0">Layer 1</option>
                    </select>
                </div>

                <p style="font-size:10px; color:#666; margin-top:10px;">Select item, choose layer, click map to place. Right-click to remove.</p>
                <p style="font-size:10px; color:#4af; margin-top:5px;">Press A near item to pick up.</p>

                <!-- Placed Items List -->
                <div style="background:#1a2a1a; padding:10px; border-radius:4px; margin-top:15px;">
                    <h4 style="margin:0 0 8px 0; font-size:11px; color:#4f8;">Placed Items</h4>
                    <div id="placedItemsList" style="max-height:150px; overflow-y:auto;">
                        <div style="color:#666; font-size:11px; text-align:center; padding:10px;">No items placed</div>
                    </div>
                </div>

            </div>

            <!-- QUESTS MODE -->
            <div id="questModeContent" style="display:none;">
                <h3>Quests</h3>

                <!-- Quest List -->
                <div id="questList" class="item-list" style="max-height:150px; overflow-y:auto; margin-bottom:10px;">
                    <div style="color:#666; font-size:11px; text-align:center; padding:10px;">No quests created</div>
                </div>
                <button onclick="addNewQuest()" class="retro-btn" style="width:100%; background:linear-gradient(135deg, #a8f, #84f);">+ NEW QUEST</button>

                <!-- Quest Editor (shown when quest selected) -->
                <div id="questEditorPanel" style="display:none; margin-top:15px;">
                    <div style="margin-bottom:10px;">
                        <label style="font-size:10px; color:#888;">Quest Name:</label>
                        <input type="text" id="questName" onchange="updateQuestField('name', this.value)" style="width:100%;">
                    </div>

                    <div style="margin-bottom:10px;">
                        <label style="font-size:10px; color:#888;">Description:</label>
                        <textarea id="questDescription" onchange="updateQuestField('description', this.value)" style="width:100%; height:50px;"></textarea>
                    </div>

                    <!-- Quest Giver NPCs -->
                    <div style="margin-bottom:10px;">
                        <label style="font-size:10px; color:#888;">Given by NPC: <span id="questGiverName" style="color:#0ff;">(None)</span></label>
                        <button id="setQuestGiverBtn" onclick="toggleSetQuestGiver()" class="retro-btn" style="width:100%; margin-top:4px; background:linear-gradient(135deg, #fa0, #f80); color:#000; font-size:9px;">
                            CLICK NPC TO SET QUEST GIVER
                        </button>
                        <div id="questGiverStatus" style="font-size:10px; color:#fa0; margin-top:3px;"></div>
                    </div>

                    <div style="margin-bottom:10px;">
                        <label style="font-size:10px; color:#888;">Turn in to NPC: <span id="questTurnInName" style="color:#0ff;">(Same as giver)</span></label>
                        <button id="setQuestTurnInBtn" onclick="toggleSetQuestTurnIn()" class="retro-btn" style="width:100%; margin-top:4px; background:linear-gradient(135deg, #4a4, #282); color:#fff; font-size:9px;">
                            CLICK NPC TO SET TURN-IN
                        </button>
                        <div id="questTurnInStatus" style="font-size:10px; color:#4a4; margin-top:3px;"></div>
                    </div>

                    <!-- Quest Options -->
                    <div style="margin-bottom:10px; display:flex; gap:10px;">
                        <label style="font-size:10px; color:#888;">
                            <input type="checkbox" id="questAutoStart" onchange="updateQuestField('autoStart', this.checked)">
                            Auto-start
                        </label>
                        <label style="font-size:10px; color:#888;">
                            <input type="checkbox" id="questRepeatable" onchange="updateQuestField('isRepeatable', this.checked)">
                            Repeatable
                        </label>
                    </div>

                    <!-- Quest Dialogs Section -->
                    <div style="background:linear-gradient(135deg, #2a1a3a, #1a2a3a); padding:10px; border-radius:6px; margin-bottom:10px; border:2px solid #a8f;">
                        <div style="display:flex; align-items:center; margin-bottom:10px;">
                            <span style="font-size:12px; color:#a8f; font-weight:bold; text-shadow:0 0 10px #a8f;">QUEST DIALOGS</span>
                        </div>

                        <!-- Start Quest Dialog -->
                        <div style="margin-bottom:8px;">
                            <label style="font-size:10px; color:#0ff;">Offer Quest:</label>
                            <div style="display:flex; gap:4px;">
                                <select id="questStartDialog" onchange="updateQuestField('startDialogId', this.value)" style="flex:1; font-size:10px;"></select>
                                <button onclick="openDialogPickerForQuest('start')" class="retro-btn" style="padding:2px 6px; font-size:9px; background:#0af;">+</button>
                            </div>
                        </div>

                        <!-- Active Quest Dialog -->
                        <div style="margin-bottom:8px;">
                            <label style="font-size:10px; color:#fa0;">While Active:</label>
                            <div style="display:flex; gap:4px;">
                                <select id="questActiveDialog" onchange="updateQuestField('activeDialogId', this.value)" style="flex:1; font-size:10px;"></select>
                                <button onclick="openDialogPickerForQuest('active')" class="retro-btn" style="padding:2px 6px; font-size:9px; background:#f80;">+</button>
                            </div>
                        </div>

                        <!-- Complete Quest Dialog -->
                        <div style="margin-bottom:5px;">
                            <label style="font-size:10px; color:#4f4;">Turn In:</label>
                            <div style="display:flex; gap:4px;">
                                <select id="questCompleteDialog" onchange="updateQuestField('completeDialogId', this.value)" style="flex:1; font-size:10px;"></select>
                                <button onclick="openDialogPickerForQuest('complete')" class="retro-btn" style="padding:2px 6px; font-size:9px; background:#4a4;">+</button>
                            </div>
                        </div>

                        <div style="font-size:9px; color:#888; margin-top:8px; text-align:center;">
                            Dialogs shown when player talks to quest NPC
                        </div>
                    </div>

                    <!-- Add Condition -->
                    <div style="background:#1a1a2e; padding:10px; border-radius:4px; margin-bottom:10px;">
                        <label style="font-size:10px; color:#888;">Add Condition:</label>
                        <select id="conditionType" style="width:100%; margin-bottom:8px;">
                            <option value="kill">Kill Enemy</option>
                            <option value="talk">Talk to NPC</option>
                            <option value="visit">Visit Location</option>
                            <option value="hasItem">Has Item</option>
                        </select>
                        <button id="setConditionBtn" onclick="toggleSetCondition()" class="retro-btn" style="width:100%; background:linear-gradient(135deg, #0ff, #a8f); color:#000;">
                            SET CONDITION
                        </button>
                        <div id="conditionStatus" style="font-size:10px; color:#0ff; margin-top:5px;"></div>
                    </div>

                    <!-- Conditions List -->
                    <div style="background:#252540; padding:8px; border-radius:4px; margin-bottom:10px;">
                        <label style="font-size:10px; color:#888;">Conditions:</label>
                        <div id="questConditions" style="min-height:30px;">
                            <div style="color:#666; font-size:10px;">No conditions</div>
                        </div>
                    </div>

                    <!-- Prerequisites (requires specific quests completed) -->
                    <div style="background:#2a2a1a; padding:8px; border-radius:4px; margin-bottom:10px; border:1px solid #a80;">
                        <label style="font-size:10px; color:#fa0; font-weight:bold;">Prerequisites:</label>
                        <div style="font-size:9px; color:#888; margin-bottom:5px;">This quest unlocks after these quests are completed:</div>
                        <div id="questPrereqList" style="min-height:20px; margin-bottom:8px;">
                            <div style="color:#666; font-size:10px;">None (available from start)</div>
                        </div>
                        <div style="display:flex; gap:4px;">
                            <select id="questPrereqSelect" style="flex:1; font-size:10px;">
                                <option value="">Select quest...</option>
                            </select>
                            <button onclick="addQuestPrerequisite()" class="retro-btn" style="padding:2px 8px; font-size:9px; background:#fa0; color:#000;">Add</button>
                        </div>
                    </div>

                    <!-- Rewards -->
                    <div style="background:#1a2a1a; padding:8px; border-radius:4px; margin-bottom:10px;">
                        <label style="font-size:10px; color:#888;">Rewards:</label>
                        <div id="questRewards" style="min-height:30px;">
                            <div style="color:#666; font-size:10px;">No rewards</div>
                        </div>
                        <button onclick="addQuestReward()" class="retro-btn retro-green" style="font-size:8px; padding:4px 8px; margin-top:5px;">+ Give Item</button>
                    </div>

                    <button onclick="deleteCurrentQuest()" class="retro-btn retro-red" style="width:100%;">DELETE QUEST</button>
                </div>
            </div>
        </div>

        <div class="resize-handle" id="sidebarResize"></div>

        <div class="map-panel">
            <div class="toolbar" id="mainToolbar">
                <!-- Mode Tabs in Toolbar -->
                <div class="toolbar-modes">
                    <button id="tileMode2" class="toolbar-mode active" onclick="setMode('tile')">Tiles</button>
                    <button id="playerMode2" onclick="setMode('player')">Player</button>
                    <button id="npcMode2" onclick="setMode('npc')">NPCs</button>
                    <button id="animPropMode2" onclick="setMode('animProp')">Anim</button>
                    <button id="soundMode2" onclick="setMode('sound')">Sound</button>
                    <button id="lightingMode2" onclick="setMode('lighting')">Light</button>
                    <button id="triggerMode2" onclick="setMode('trigger')">Trig</button>
                    <button id="cameraMode2" onclick="setMode('camera')">Cam</button>
                    <button id="dialogMode2" onclick="setMode('dialog')">Dialog</button>
                    <button id="itemMode2" onclick="setMode('item')">Items</button>
                    <button id="questMode2" onclick="setMode('quest')">Quest</button>
                </div>

                <!-- Map Selector in Toolbar -->
                <div style="display:flex; align-items:center; gap:5px; margin-left:10px;">
                    <span style="font-size:11px; color:#888;">Map:</span>
                    <select id="toolbarMapSelect" style="padding:4px 8px; background:#333; color:#fff; border:1px solid #555; border-radius:3px; font-size:11px;" onchange="switchToMap(this.value)">
                        <option value="main">main</option>
                    </select>
                    <button onclick="promptNewMap()" style="padding:4px 8px; background:#4a4; color:#fff; border:none; border-radius:3px; font-size:11px; cursor:pointer;" title="Add new map">+</button>
                </div>

                <div class="toolbar-separator"></div>

                <!-- Tools Dropdown -->
                <div class="tools-dropdown">
                    <button class="tools-toggle" onclick="toggleToolsMenu()">⚙ Tools ▼</button>
                    <div class="tools-menu" id="toolsMenu">
                        <div id="coopStatusInMenu" class="coop-status-menu" style="display:none;"></div>
                        <button onclick="clearMap()">Clear Map</button>
                        <button onclick="downloadProject()">Save</button>
                        <button onclick="document.getElementById('projectFileInput').click()">Load</button>
                        <button onclick="exportConfig()">Export</button>
                        <button onclick="showStorageInfo()">Storage</button>
                        <button onclick="showRoomInfo()">Room Info</button>
                        <div class="tools-menu-separator"></div>
                        <div class="tools-menu-zoom">
                            <span>Zoom:</span>
                            <button onclick="zoomOut()">-</button>
                            <span id="zoomLevel">2x</span>
                            <button onclick="zoomIn()">+</button>
                        </div>
                        <div class="tools-menu-separator"></div>
                        <div class="tools-menu-theme">
                            <span>UI Theme:</span>
                            <div class="theme-swatches">
                                <button class="theme-swatch" style="background:#1a1a1a;" onclick="setUITheme('#1a1a1a')" title="Dark Grey"></button>
                                <button class="theme-swatch" style="background:#0a0a0a;" onclick="setUITheme('#0a0a0a')" title="Black"></button>
                                <button class="theme-swatch" style="background:#1a1a2e;" onclick="setUITheme('#1a1a2e')" title="Purple"></button>
                                <button class="theme-swatch" style="background:#1a2a1a;" onclick="setUITheme('#1a2a1a')" title="Green"></button>
                                <button class="theme-swatch" style="background:#2a1a1a;" onclick="setUITheme('#2a1a1a')" title="Red"></button>
                                <button class="theme-swatch" style="background:#1a2a2a;" onclick="setUITheme('#1a2a2a')" title="Cyan"></button>
                                <button class="theme-swatch" style="background:#2a2a1a;" onclick="setUITheme('#2a2a1a')" title="Yellow"></button>
                                <button class="theme-swatch" style="background:#2a1a2a;" onclick="setUITheme('#2a1a2a')" title="Magenta"></button>
                            </div>
                            <input type="color" id="customThemeColor" value="#1a1a1a" onchange="setUITheme(this.value)" title="Custom color" style="width:100%;height:24px;margin-top:5px;cursor:pointer;border:1px solid #444;">
                        </div>
                    </div>
                </div>
                <input type="file" id="projectFileInput" accept=".json" style="display:none;" onchange="uploadProject(event)">

                <!-- Zoom Controls (always visible) -->
                <div class="toolbar-zoom" style="display:flex; align-items:center; gap:3px; margin-left:10px;">
                    <button onclick="zoomOut()" style="padding:3px 8px; font-size:14px;">-</button>
                    <span id="zoomLevelToolbar" style="color:#888; font-size:11px; min-width:25px; text-align:center;">2x</span>
                    <button onclick="zoomIn()" style="padding:3px 8px; font-size:14px;">+</button>
                </div>

                <button id="grabToolBtn" onclick="toggleGrabTool()" class="toolbar-grab">Grab</button>

                <div class="toolbar-spacer"></div>

                <!-- Spawn Point Button -->
                <button id="setSpawnBtn" onclick="toggleSetSpawnMode()" class="spawn-btn">SPAWN</button>

                <!-- Test Map - Special Button -->
                <button onclick="testMap()" class="test-map-btn">▶ PLAY</button>

                <span id="toolHint" class="toolbar-hint">R:rotate | I:flip | E:erase</span>
            </div>
            <!-- Door Animation Panel (in toolbar area) -->
            <div id="doorAnimPanel" style="display:none; background:#1a1a2e; padding:12px 20px; border-bottom:2px solid #f90;">
                <div id="doorAnimSelectMode" style="display:none;">
                    <span style="color:#f90; font-weight:bold; margin-right:15px;">DOOR ANIM: Select tiles to swap</span>
                    <span style="color:#aaa; margin-right:15px;">Click tiles that change when door opens</span>
                    <button onclick="finishTileSelection()" style="background:#4a4; padding:8px 20px; font-weight:bold;">DONE - Paint Replacements</button>
                </div>
                <div id="doorAnimPaintMode" style="display:none;">
                    <span style="color:#4af; font-weight:bold; margin-right:15px;">DOOR ANIM: Paint replacement tiles</span>
                    <span style="color:#aaa; margin-right:15px;">Use palette to paint (or leave empty to remove)</span>
                    <button onclick="finishAnimPainting()" style="background:#4a4; padding:8px 20px; font-weight:bold;">DONE - Save Animation</button>
                </div>
            </div>
            <div class="map-viewport" id="mapViewport">
                <!-- Expand buttons -->
                <button class="expand-btn expand-top" onclick="expandMap('top')" title="Expand up">+</button>
                <button class="expand-btn expand-bottom" onclick="expandMap('bottom')" title="Expand down">+</button>
                <button class="expand-btn expand-left" onclick="expandMap('left')" title="Expand left">+</button>
                <button class="expand-btn expand-right" onclick="expandMap('right')" title="Expand right">+</button>
                <canvas id="mapCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- State picker popup -->
    <div class="state-picker" id="statePicker">
        <h3 style="margin-bottom:10px;">Select State</h3>
        <div id="stateOptions"></div>
    </div>

    <!-- NPC Editor Modal -->
    <div class="anim-modal" id="npcModal">
        <div class="anim-modal-content">
            <!-- Sidebar -->
            <div class="anim-sidebar">
                <h2 style="margin-top:0;">NPC</h2>

                <!-- Step 1: Load Sprite Sheet -->
                <div style="margin-bottom:15px;">
                    <h3>1. Sprite Sheet</h3>
                    <input type="file" id="npcFileInput" accept="image/*" onchange="npcLoadSheet(event)" style="display:none;">
                    <button onclick="document.getElementById('npcFileInput').click()" style="width:100%;">Load Image</button>
                    <div id="npcFileName" style="font-size:11px; color:#4af; margin-top:5px;"></div>
                </div>

                <!-- Step 2: Frame Size -->
                <div id="npcFrameSection" style="margin-bottom:15px; display:none;">
                    <h3>2. Frame Size</h3>
                    <div style="display:flex; gap:5px; flex-wrap:wrap; margin-bottom:8px;">
                        <button onclick="npcSetFrameSize(16,16)" style="padding:4px 8px; font-size:11px;">16x16</button>
                        <button onclick="npcSetFrameSize(16,32)" style="padding:4px 8px; font-size:11px;">16x32</button>
                        <button onclick="npcSetFrameSize(32,32)" style="padding:4px 8px; font-size:11px;">32x32</button>
                        <button onclick="npcSetFrameSize(32,64)" style="padding:4px 8px; font-size:11px;">32x64</button>
                        <button onclick="npcSetFrameSize(48,48)" style="padding:4px 8px; font-size:11px;">48x48</button>
                        <button onclick="npcResetGrid()" style="padding:4px 8px; font-size:11px; background:#a55;">Reset</button>
                    </div>
                    <div style="font-size:11px; color:#888;" id="npcGridInfo"></div>
                </div>

                <!-- Step 3: Animation Selection -->
                <div id="npcAnimSection" style="margin-bottom:15px; display:none;">
                    <h3>3. Select Animation</h3>
                    <div id="npcAnimButtons" style="display:flex; flex-direction:column; gap:5px;">
                        <div style="display:flex; gap:4px;">
                            <button id="npcAnimDown" onclick="npcSelectAnim('walkDown')" class="active" style="flex:1; padding:6px; font-size:11px;">↓ Walk</button>
                            <button id="npcAnimUp" onclick="npcSelectAnim('walkUp')" style="flex:1; padding:6px; font-size:11px;">↑ Walk</button>
                            <button id="npcAnimLeft" onclick="npcSelectAnim('walkLeft')" style="flex:1; padding:6px; font-size:11px;">← Walk</button>
                            <button id="npcAnimRight" onclick="npcSelectAnim('walkRight')" style="flex:1; padding:6px; font-size:11px;">→ Walk</button>
                        </div>
                        <button id="npcAnimIdle" onclick="npcSelectAnim('idle')" style="padding:6px; font-size:11px;">Idle</button>
                        <div style="border-top:1px solid #555; margin:5px 0; padding-top:5px;">
                            <div style="font-size:10px; color:#f88; margin-bottom:5px;">-- Attack Animations (Enemy NPCs) --</div>
                            <div style="display:flex; gap:4px;">
                                <button id="npcAnimAttackDown" onclick="npcSelectAnim('attackDown')" style="flex:1; padding:6px; font-size:11px; background:#744;">↓ Atk</button>
                                <button id="npcAnimAttackUp" onclick="npcSelectAnim('attackUp')" style="flex:1; padding:6px; font-size:11px; background:#744;">↑ Atk</button>
                                <button id="npcAnimAttackLeft" onclick="npcSelectAnim('attackLeft')" style="flex:1; padding:6px; font-size:11px; background:#744;">← Atk</button>
                                <button id="npcAnimAttackRight" onclick="npcSelectAnim('attackRight')" style="flex:1; padding:6px; font-size:11px; background:#744;">→ Atk</button>
                            </div>
                        </div>
                    </div>
                    <!-- Custom animations list -->
                    <div id="npcCustomAnimList" style="margin-top:8px;"></div>
                    <!-- Add custom animation -->
                    <div style="display:flex; gap:5px; margin-top:8px;">
                        <input type="text" id="npcCustomAnimName" placeholder="e.g. swing, dance" style="flex:1; padding:4px; font-size:11px;">
                        <button onclick="npcAddCustomAnim()" style="padding:4px 8px; font-size:11px; background:#4a4;">+ Add</button>
                    </div>
                    <p style="font-size:10px; color:#666; margin-top:8px;">Select animation type, then click frames on sprite sheet</p>
                </div>

                <!-- Step 4: Name -->
                <div id="npcNameSection" style="margin-bottom:15px; display:none;">
                    <h3>4. Name</h3>
                    <input type="text" id="npcNameInput" placeholder="e.g. villager, guard" style="width:100%;">
                </div>

                <!-- Step 5: Collision Box -->
                <div id="npcCollisionSection" style="margin-bottom:15px; display:none;">
                    <h3>5. Collision Box</h3>
                    <button onclick="openNpcCollisionEditor()" style="width:100%; padding:10px; background:#a55; font-size:12px;">
                        Edit Collision Box
                    </button>
                    <div id="npcCollisionStatus" style="font-size:10px; color:#888; margin-top:5px;">
                        No collision box set
                    </div>
                </div>

                <!-- Step 6: Shadow Settings -->
                <div id="npcShadowSection" style="margin-bottom:15px; display:none;">
                    <h3>6. Shadow</h3>
                    <div style="margin-bottom:8px;">
                        <label style="font-size:10px; color:#888;">X Offset: <span id="npcShadowOffsetXVal">0</span>px</label>
                        <input type="range" id="npcShadowOffsetXSlider" min="-20" max="20" value="0" oninput="updateNpcShadowPreview()" style="width:100%;">
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="font-size:10px; color:#888;">Y Offset: <span id="npcShadowOffsetVal">4</span>px</label>
                        <input type="range" id="npcShadowOffsetSlider" min="0" max="20" value="4" oninput="updateNpcShadowPreview()" style="width:100%;">
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="font-size:10px; color:#888;">Width: <span id="npcShadowWidthVal">35</span>%</label>
                        <input type="range" id="npcShadowWidthSlider" min="10" max="60" value="35" oninput="updateNpcShadowPreview()" style="width:100%;">
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="font-size:10px; color:#888;">Height: <span id="npcShadowHeightVal">12</span>%</label>
                        <input type="range" id="npcShadowHeightSlider" min="5" max="25" value="12" oninput="updateNpcShadowPreview()" style="width:100%;">
                    </div>
                    <p style="font-size:9px; color:#555;">Adjust shadow position and size under NPC sprite.</p>
                </div>

                <!-- Actions -->
                <div style="margin-top:auto;">
                    <button onclick="npcSave()" style="width:100%; background:#4af; color:#000; margin-bottom:10px;">Save NPC</button>
                    <button onclick="npcCancel()" style="width:100%; background:#a55;">Cancel</button>
                </div>
            </div>

            <!-- Main Area -->
            <div class="anim-main">
                <div class="anim-header">
                    <h2>Sprite Sheet</h2>
                    <span style="color:#888; font-size:12px;">Click frames to add to current animation</span>
                    <div style="display:flex; align-items:center; gap:5px; margin-left:auto;">
                        <span style="color:#888; font-size:11px;">Zoom:</span>
                        <button onclick="npcZoomOut()" style="padding:2px 8px; font-size:14px;">-</button>
                        <span id="npcZoomLevel" style="color:#4af; font-size:11px; min-width:35px; text-align:center;">3x</span>
                        <button onclick="npcZoomIn()" style="padding:2px 8px; font-size:14px;">+</button>
                    </div>
                </div>

                <div class="anim-canvas-area">
                    <canvas id="npcEditorCanvas"></canvas>
                </div>

                <!-- Bottom Bar: Animation Frames -->
                <div class="anim-frames-bar">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span><strong id="npcCurrentAnimName" style="color:#4af;">Walk Down</strong>: <span id="npcFrameCount">0</span> frames</span>
                        <div style="display:flex; align-items:center; gap:15px;">
                            <!-- Live Preview (larger) -->
                            <div style="display:flex; align-items:center; gap:10px;">
                                <canvas id="npcLivePreview" width="96" height="96" style="border:2px solid #4af; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                                <div style="font-size:11px;">
                                    <div style="display:flex; align-items:center; gap:5px;">
                                        <span style="color:#888;">Speed:</span>
                                        <input type="range" id="npcSpeedSlider" min="1" max="24" value="8" style="width:80px;" oninput="npcUpdateSpeed()">
                                        <span id="npcSpeedLabel" style="color:#4af; min-width:35px;">8 fps</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:5px; margin-top:5px;">
                                        <label style="color:#888; cursor:pointer;"><input type="checkbox" id="npcPingPong" onchange="npcUpdatePingPong()"> Ping-Pong</label>
                                    </div>
                                </div>
                            </div>
                            <button id="npcMirrorBtn" onclick="npcToggleMirror()" style="background:#555; padding:5px 10px; font-size:11px; border:1px solid #888;">Mirror</button>
                            <button onclick="npcClearCurrentAnim()" style="background:#a55; padding:5px 10px; font-size:11px;">Clear</button>
                        </div>
                    </div>
                    <div class="anim-frames-list" id="npcFramesList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- NPC Collision Box Editor Modal -->
    <div id="npcCollisionModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.9); z-index:10001; justify-content:center; align-items:center;">
        <div style="background:#1a1a2e; border:2px solid #0ff; border-radius:12px; padding:20px; width:420px; max-width:90vw;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                <h2 style="margin:0; color:#0ff;">Collision Box</h2>
                <button onclick="closeNpcCollisionEditor()" style="background:none; border:none; color:#fff; font-size:24px; cursor:pointer;">&times;</button>
            </div>

            <!-- Large animated preview with outline -->
            <div style="display:flex; justify-content:center; margin-bottom:15px;">
                <canvas id="collisionPreviewCanvas" width="200" height="200" style="border:2px solid #444; border-radius:8px; background:#222; image-rendering:pixelated;"></canvas>
            </div>

            <!-- Inset sliders - shrink from each edge -->
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:15px;">
                <div>
                    <label style="color:#888; font-size:10px;">Inset Top: <span id="insetTopVal">0</span>px</label>
                    <input type="range" id="insetTop" min="0" max="100" value="0" oninput="updateCollisionInsets()" style="width:100%;">
                </div>
                <div>
                    <label style="color:#888; font-size:10px;">Inset Bottom: <span id="insetBottomVal">0</span>px</label>
                    <input type="range" id="insetBottom" min="0" max="100" value="0" oninput="updateCollisionInsets()" style="width:100%;">
                </div>
                <div>
                    <label style="color:#888; font-size:10px;">Inset Left: <span id="insetLeftVal">0</span>px</label>
                    <input type="range" id="insetLeft" min="0" max="100" value="0" oninput="updateCollisionInsets()" style="width:100%;">
                </div>
                <div>
                    <label style="color:#888; font-size:10px;">Inset Right: <span id="insetRightVal">0</span>px</label>
                    <input type="range" id="insetRight" min="0" max="100" value="0" oninput="updateCollisionInsets()" style="width:100%;">
                </div>
            </div>

            <!-- Animation selector -->
            <div style="margin-bottom:15px;">
                <label style="color:#888; font-size:10px;">Preview:</label>
                <div style="display:flex; gap:5px; margin-top:5px; flex-wrap:wrap;">
                    <button id="collisionDirIdle" onclick="setCollisionPreviewDir('idle')" class="retro-btn" style="padding:4px 10px; font-size:10px;">Idle</button>
                    <button id="collisionDirDown" onclick="setCollisionPreviewDir('down')" class="retro-btn active" style="padding:4px 10px; font-size:10px;">Down</button>
                    <button id="collisionDirUp" onclick="setCollisionPreviewDir('up')" class="retro-btn" style="padding:4px 10px; font-size:10px;">Up</button>
                    <button id="collisionDirLeft" onclick="setCollisionPreviewDir('left')" class="retro-btn" style="padding:4px 10px; font-size:10px;">Left</button>
                    <button id="collisionDirRight" onclick="setCollisionPreviewDir('right')" class="retro-btn" style="padding:4px 10px; font-size:10px;">Right</button>
                </div>
            </div>

            <!-- Collision box info -->
            <div id="collisionBoxInfo" style="font-size:11px; color:#0ff; text-align:center; margin-bottom:15px;">
                Full sprite (no insets)
            </div>

            <!-- Buttons -->
            <div style="display:flex; gap:10px;">
                <button onclick="resetCollisionInsets()" class="retro-btn" style="flex:1; padding:10px; font-size:12px;">Reset</button>
                <button onclick="applyNpcCollisionBox()" class="retro-btn retro-cyan" style="flex:1; padding:10px; font-size:12px;">Apply</button>
            </div>
        </div>
    </div>

    <!-- Pratt Warning Modal -->
    <div id="prattModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.9); z-index:10000; justify-content:center; align-items:center;">
        <div class="pratt-box">
            <div class="pratt-border"></div>
            <div class="pratt-content">
                <div class="pratt-icon">!</div>
                <h2 class="pratt-title">HEY <span style="color:#f84;">P</span><span style="color:#ff0;">R</span><span style="color:#4f8;">A</span><span style="color:#4ff;">T</span><span style="color:#f4f;">T</span>!</h2>
                <div class="pratt-subtitle">It's not broken!</div>
                <div class="pratt-message">Your tiles are rotated <span id="prattDegrees" class="pratt-highlight">90°</span> AND <span class="pratt-highlight">flipped</span>.</div>
                <div class="pratt-warning">This combo can look... interesting</div>
                <div class="pratt-buttons">
                    <button onclick="prattConfirm(true)" class="pratt-btn pratt-btn-yes">PLACE IT!</button>
                    <button onclick="prattConfirm(false)" class="pratt-btn pratt-btn-no">NAH</button>
                </div>
                <div class="pratt-footer">won't bug you again until you change it</div>
            </div>
        </div>
    </div>
    <style>
        .pratt-box {
            position: relative;
            animation: prattSlide 0.3s ease-out;
        }
        .pratt-border {
            position: absolute;
            inset: -4px;
            background: linear-gradient(45deg, #f84, #ff0, #4f8, #4ff, #f4f, #f84);
            background-size: 400% 400%;
            animation: prattRainbow 3s linear infinite;
            border-radius: 12px;
        }
        .pratt-content {
            position: relative;
            background: #111;
            padding: 25px 35px;
            border-radius: 8px;
            text-align: center;
            min-width: 320px;
        }
        .pratt-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }
        .pratt-title {
            font-size: 24px;
            font-weight: bold;
            margin: 0 0 12px 0;
            letter-spacing: 4px;
        }
        .pratt-subtitle {
            color: #4f8;
            font-size: 16px;
            margin-bottom: 15px;
        }
        .pratt-message {
            color: #ccc;
            font-size: 14px;
            margin-bottom: 8px;
        }
        .pratt-highlight {
            color: #f4f;
            font-weight: bold;
        }
        .pratt-warning {
            color: #fa0;
            font-size: 13px;
            margin-bottom: 20px;
        }
        .pratt-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        .pratt-btn {
            padding: 10px 30px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        .pratt-btn:hover {
            transform: scale(1.05);
        }
        .pratt-btn:active {
            transform: scale(0.95);
        }
        .pratt-btn-yes {
            background: linear-gradient(180deg, #4a4 0%, #282 100%);
            color: #fff;
            box-shadow: 0 4px 0 #151, 0 0 20px #4f84;
        }
        .pratt-btn-no {
            background: linear-gradient(180deg, #555 0%, #333 100%);
            color: #aaa;
            box-shadow: 0 4px 0 #222;
        }
        .pratt-footer {
            color: #555;
            font-size: 10px;
            margin-top: 15px;
            font-style: italic;
        }
        @keyframes prattSlide {
            0% { transform: translateY(-30px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        @keyframes prattRainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 400% 50%; }
        }

        /* Player Animation Buttons - Retro Style */
        .player-anim-btn {
            border: 2px solid #333;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.1s ease;
            text-shadow: 1px 1px 0 rgba(0,0,0,0.5);
            position: relative;
        }
        .player-anim-btn:hover {
            transform: translateY(-1px);
            filter: brightness(1.2);
        }
        .player-anim-btn:active {
            transform: translateY(1px);
        }
        .player-anim-btn.has-frames::after {
            content: '';
            position: absolute;
            top: -3px;
            right: -3px;
            background: #4f8;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 2px solid #111;
        }

        /* Walk buttons - Green */
        .player-anim-btn.walk-btn {
            background: linear-gradient(180deg, #3a5 0%, #283 100%);
            border-color: #4c7;
            color: #cfc;
        }
        .player-anim-btn.walk-btn.active {
            background: linear-gradient(180deg, #5f8 0%, #3a5 100%);
            border-color: #8fc;
            box-shadow: 0 0 10px #4f8, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Idle buttons - Cyan */
        .player-anim-btn.idle-btn {
            background: linear-gradient(180deg, #357 0%, #235 100%);
            border-color: #58a;
            color: #adf;
        }
        .player-anim-btn.idle-btn.active {
            background: linear-gradient(180deg, #5af 0%, #38d 100%);
            border-color: #8df;
            box-shadow: 0 0 10px #4af, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Attack buttons - Red */
        .player-anim-btn.attack-btn {
            background: linear-gradient(180deg, #744 0%, #522 100%);
            border-color: #966;
            color: #fcc;
        }
        .player-anim-btn.attack-btn.active {
            background: linear-gradient(180deg, #f66 0%, #a44 100%);
            border-color: #f99;
            box-shadow: 0 0 10px #f44, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Interact buttons - Purple */
        .player-anim-btn.interact-btn {
            background: linear-gradient(180deg, #458 0%, #336 100%);
            border-color: #68a;
            color: #cdf;
        }
        .player-anim-btn.interact-btn.active {
            background: linear-gradient(180deg, #8af 0%, #58c 100%);
            border-color: #adf;
            box-shadow: 0 0 10px #8af, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Death buttons - Dark Red */
        .player-anim-btn.death-btn {
            background: linear-gradient(180deg, #633 0%, #411 100%);
            border-color: #855;
            color: #faa;
        }
        .player-anim-btn.death-btn.active {
            background: linear-gradient(180deg, #c44 0%, #833 100%);
            border-color: #f66;
            box-shadow: 0 0 10px #f44, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Special buttons - Gold */
        .player-anim-btn.special-btn {
            background: linear-gradient(180deg, #754 0%, #532 100%);
            border-color: #a86;
            color: #fda;
        }
        .player-anim-btn.special-btn.active {
            background: linear-gradient(180deg, #fa4 0%, #c84 100%);
            border-color: #fc8;
            box-shadow: 0 0 10px #fa4, inset 0 0 5px rgba(255,255,255,0.3);
            color: #fff;
        }

        /* Category headers */
        .player-anim-category {
            font-size: 10px;
            font-weight: bold;
            padding: 4px 8px;
            margin: 8px 0 4px 0;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .player-anim-category.walk { background: #283; color: #8fc; }
        .player-anim-category.idle { background: #235; color: #8df; }
        .player-anim-category.attack { background: #522; color: #faa; }
        .player-anim-category.interact { background: #336; color: #adf; }
        .player-anim-category.death { background: #411; color: #f88; }
        .player-anim-category.special { background: #532; color: #fd8; }
    </style>

    <!-- Player Editor Modal -->
    <div class="anim-modal" id="playerModal">
        <div class="anim-modal-content">
            <!-- Sidebar -->
            <div class="anim-sidebar">
                <h2 style="margin-top:0;">Player Character</h2>

                <!-- Step 1: Load Sprite Sheet -->
                <div style="margin-bottom:15px;">
                    <h3>1. Sprite Sheets</h3>
                    <input type="file" id="playerFileInput" accept="image/*" onchange="playerLoadSheet(event)" style="display:none;">
                    <button onclick="document.getElementById('playerFileInput').click()" style="width:100%; background:#3a5;">+ Add Sheet</button>
                    <div id="playerSheetTabs" style="margin-top:8px; display:flex; flex-direction:column; gap:4px;"></div>
                    <div id="playerFileName" style="font-size:11px; color:#4f8; margin-top:5px;"></div>
                </div>

                <!-- Step 2: Frame Size -->
                <div id="playerFrameSection" style="margin-bottom:15px; display:none;">
                    <h3>2. Frame Size</h3>
                    <div style="display:flex; gap:5px; flex-wrap:wrap; margin-bottom:8px;">
                        <button onclick="playerSetFrameSize(16,16)" style="padding:4px 8px; font-size:11px;">16x16</button>
                        <button onclick="playerSetFrameSize(16,32)" style="padding:4px 8px; font-size:11px;">16x32</button>
                        <button onclick="playerSetFrameSize(32,32)" style="padding:4px 8px; font-size:11px;">32x32</button>
                        <button onclick="playerSetFrameSize(32,64)" style="padding:4px 8px; font-size:11px;">32x64</button>
                        <button onclick="playerSetFrameSize(64,64)" style="padding:4px 8px; font-size:11px;">64x64</button>
                        <button onclick="playerResetGrid()" style="padding:4px 8px; font-size:11px; background:#a55;">Reset</button>
                    </div>
                    <div style="font-size:11px; color:#888;" id="playerGridInfo"></div>
                </div>

                <!-- Step 3: Animation Selection -->
                <div id="playerAnimSection" style="margin-bottom:15px; display:none;">
                    <h3>3. Select Animation</h3>
                    <div id="playerAnimButtons" style="display:flex; flex-direction:column; gap:5px;">
                        <div class="player-anim-category walk">Walk</div>
                        <div style="display:flex; gap:4px;">
                            <button id="playerAnimDown" onclick="playerSelectAnim('walkDown')" class="player-anim-btn walk-btn active" style="flex:1; padding:6px; font-size:11px;">↓ Walk</button>
                            <button id="playerAnimUp" onclick="playerSelectAnim('walkUp')" class="player-anim-btn walk-btn" style="flex:1; padding:6px; font-size:11px;">↑ Walk</button>
                            <button id="playerAnimLeft" onclick="playerSelectAnim('walkLeft')" class="player-anim-btn walk-btn" style="flex:1; padding:6px; font-size:11px;">← Walk</button>
                            <button id="playerAnimRight" onclick="playerSelectAnim('walkRight')" class="player-anim-btn walk-btn" style="flex:1; padding:6px; font-size:11px;">→ Walk</button>
                        </div>
                        <div class="player-anim-category idle">Idle</div>
                        <button id="playerAnimIdle" onclick="playerSelectAnim('idle')" class="player-anim-btn idle-btn" style="padding:6px; font-size:11px;" title="Single idle for all directions">Idle (All)</button>
                        <div style="font-size:10px; color:#888; margin:3px 0;">or directional:</div>
                        <div style="display:flex; gap:4px;">
                            <button id="playerAnimIdleDown" onclick="playerSelectAnim('idleDown')" class="player-anim-btn idle-btn" style="flex:1; padding:5px; font-size:10px;">↓</button>
                            <button id="playerAnimIdleUp" onclick="playerSelectAnim('idleUp')" class="player-anim-btn idle-btn" style="flex:1; padding:5px; font-size:10px;">↑</button>
                            <button id="playerAnimIdleLeft" onclick="playerSelectAnim('idleLeft')" class="player-anim-btn idle-btn" style="flex:1; padding:5px; font-size:10px;">←</button>
                            <button id="playerAnimIdleRight" onclick="playerSelectAnim('idleRight')" class="player-anim-btn idle-btn" style="flex:1; padding:5px; font-size:10px;">→</button>
                        </div>
                        <div class="player-anim-category attack">Attack</div>
                        <div style="display:flex; gap:4px;">
                            <button id="playerAnimAttackDown" onclick="playerSelectAnim('attackDown')" class="player-anim-btn attack-btn" style="flex:1; padding:6px; font-size:11px;">↓ Atk</button>
                            <button id="playerAnimAttackUp" onclick="playerSelectAnim('attackUp')" class="player-anim-btn attack-btn" style="flex:1; padding:6px; font-size:11px;">↑ Atk</button>
                            <button id="playerAnimAttackLeft" onclick="playerSelectAnim('attackLeft')" class="player-anim-btn attack-btn" style="flex:1; padding:6px; font-size:11px;">← Atk</button>
                            <button id="playerAnimAttackRight" onclick="playerSelectAnim('attackRight')" class="player-anim-btn attack-btn" style="flex:1; padding:6px; font-size:11px;">→ Atk</button>
                        </div>
                        <div style="margin-top:5px; font-size:10px;">
                            <label style="color:#888;">Movement: </label>
                            <select id="playerAttackMovement" style="font-size:10px; padding:2px; background:#333; color:#fff; border:1px solid #555;">
                                <option value="stop">Stop</option>
                                <option value="slide">Slide then stop</option>
                                <option value="move">Keep moving</option>
                            </select>
                        </div>
                        <div id="playerHitboxSection" style="margin-top:5px; display:none; padding:8px; background:#2a1a2a; border:1px solid #606; border-radius:4px;">
                            <div style="font-size:10px; color:#c8f; font-weight:bold; margin-bottom:6px;">Attack Hitbox (Per Direction)</div>
                            <div style="display:flex; gap:3px; margin-bottom:6px;">
                                <button id="phbDirUp" onclick="setPlayerHitboxDir('up')" style="flex:1; padding:3px; font-size:9px;">↑</button>
                                <button id="phbDirDown" onclick="setPlayerHitboxDir('down')" class="active" style="flex:1; padding:3px; font-size:9px; background:#606;">↓</button>
                                <button id="phbDirLeft" onclick="setPlayerHitboxDir('left')" style="flex:1; padding:3px; font-size:9px;">←</button>
                                <button id="phbDirRight" onclick="setPlayerHitboxDir('right')" style="flex:1; padding:3px; font-size:9px;">→</button>
                            </div>
                            <div style="margin-bottom:4px;">
                                <label style="font-size:9px; color:#888;">Range: <span id="playerHitboxRangeVal">40</span>px</label>
                                <input type="range" id="playerHitboxRange" min="10" max="120" value="40" oninput="updatePlayerHitboxShape()" style="width:100%;">
                            </div>
                            <div style="margin-bottom:4px;">
                                <label style="font-size:9px; color:#888;">Width: <span id="playerHitboxWidthVal">60</span>°</label>
                                <input type="range" id="playerHitboxWidth" min="20" max="180" value="60" oninput="updatePlayerHitboxShape()" style="width:100%;">
                            </div>
                            <div style="margin-bottom:4px;">
                                <label style="font-size:9px; color:#888;">Offset X: <span id="playerHitboxOffsetXVal">0</span>px</label>
                                <input type="range" id="playerHitboxOffsetX" min="-50" max="50" value="0" oninput="updatePlayerHitboxShape()" style="width:100%;">
                            </div>
                            <div style="margin-bottom:4px;">
                                <label style="font-size:9px; color:#888;">Offset Y: <span id="playerHitboxOffsetYVal">0</span>px</label>
                                <input type="range" id="playerHitboxOffsetY" min="-50" max="50" value="0" oninput="updatePlayerHitboxShape()" style="width:100%;">
                            </div>
                            <button onclick="copyPlayerHitboxToAll()" style="width:100%; padding:3px; font-size:9px; background:#464; margin-top:4px;">Copy to All Directions</button>
                            <p style="font-size:8px; color:#888; margin:4px 0 0 0;">Adjust hitbox per direction. Test with C key.</p>
                        </div>
                        <div class="player-anim-category interact">Interact</div>
                        <button id="playerAnimInteract" onclick="playerSelectAnim('interact')" class="player-anim-btn interact-btn" style="padding:6px; font-size:11px;">Interact</button>
                        <div class="player-anim-category death">Death</div>
                        <button id="playerAnimDeath" onclick="playerSelectAnim('death')" class="player-anim-btn death-btn" style="padding:6px; font-size:11px;">Death</button>
                        <!-- Game Over Sound Selection -->
                        <div style="margin:8px 0; padding:6px; background:#2a1a2a; border:1px solid #644; border-radius:4px;">
                            <label style="font-size:10px; color:#f88;">Game Over Sound:</label>
                            <select id="playerGameOverSound" onchange="playerUpdateGameOverSound()" style="width:100%; margin-top:4px; background:#1a1a2e; color:#fff; border:1px solid #555; padding:4px; font-size:11px;">
                                <option value="-1">None</option>
                            </select>
                            <button onclick="playerPreviewGameOverSound()" style="width:100%; margin-top:4px; padding:4px; font-size:10px; background:#644;">Preview Sound</button>
                        </div>
                        <div class="player-anim-category special">Receive Item</div>
                        <button id="playerAnimReceivedItem" onclick="playerSelectAnim('receivedItem')" class="player-anim-btn special-btn" style="padding:6px; font-size:11px;">Receive (All)</button>
                        <div style="display:flex; gap:2px; margin-top:2px;">
                            <button id="playerAnimReceiveItemDown" onclick="playerSelectAnim('receiveItemDown')" class="player-anim-btn special-btn" style="flex:1; padding:5px; font-size:10px;">↓</button>
                            <button id="playerAnimReceiveItemUp" onclick="playerSelectAnim('receiveItemUp')" class="player-anim-btn special-btn" style="flex:1; padding:5px; font-size:10px;">↑</button>
                            <button id="playerAnimReceiveItemLeft" onclick="playerSelectAnim('receiveItemLeft')" class="player-anim-btn special-btn" style="flex:1; padding:5px; font-size:10px;">←</button>
                            <button id="playerAnimReceiveItemRight" onclick="playerSelectAnim('receiveItemRight')" class="player-anim-btn special-btn" style="flex:1; padding:5px; font-size:10px;">→</button>
                        </div>
                    </div>
                    <!-- Custom animations list -->
                    <div id="playerCustomAnimList" style="margin-top:8px;"></div>
                    <!-- Add custom animation -->
                    <div style="display:flex; gap:5px; margin-top:8px;">
                        <input type="text" id="playerCustomAnimName" placeholder="e.g. roll, cast" style="flex:1; padding:4px; font-size:11px;">
                        <button onclick="playerAddCustomAnim()" style="padding:4px 8px; font-size:11px; background:#4a4;">+ Add</button>
                    </div>
                    <p style="font-size:10px; color:#666; margin-top:8px;">Drag on sprite sheet to select multi-tile frames</p>
                </div>

                <!-- Step 4: Name -->
                <div id="playerNameSection" style="margin-bottom:15px; display:none;">
                    <h3>4. Name</h3>
                    <input type="text" id="playerNameInput" placeholder="e.g. hero, knight" style="width:100%;">
                </div>

                <!-- Actions -->
                <div style="margin-top:auto;">
                    <button onclick="playerSave()" style="width:100%; background:#4f8; color:#000; margin-bottom:10px;">Save Character</button>
                    <button onclick="playerCancel()" style="width:100%; background:#a55;">Cancel</button>
                </div>
            </div>

            <!-- Main Area -->
            <div class="anim-main">
                <div class="anim-header">
                    <h2>Sprite Sheet</h2>
                    <span style="color:#888; font-size:12px;">Click frames to add to current animation</span>
                    <div style="display:flex; align-items:center; gap:5px; margin-left:auto;">
                        <span style="color:#888; font-size:11px;">Zoom:</span>
                        <button onclick="playerZoomOut()" style="padding:2px 8px; font-size:14px;">-</button>
                        <span id="playerZoomLevel" style="color:#4f8; font-size:11px; min-width:35px; text-align:center;">3x</span>
                        <button onclick="playerZoomIn()" style="padding:2px 8px; font-size:14px;">+</button>
                    </div>
                </div>

                <div class="anim-canvas-area">
                    <canvas id="playerEditorCanvas"></canvas>
                </div>

                <!-- Bottom Bar: Animation Frames -->
                <div class="anim-frames-bar">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span><strong id="playerCurrentAnimName" style="color:#4f8;">Walk Down</strong>: <span id="playerFrameCount">0</span> frames</span>
                        <div style="display:flex; align-items:center; gap:15px;">
                            <!-- Live Preview -->
                            <div style="display:flex; align-items:center; gap:10px;">
                                <canvas id="playerLivePreview" width="96" height="96" style="border:2px solid #4f8; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                                <div style="font-size:11px;">
                                    <div style="display:flex; align-items:center; gap:5px;">
                                        <span style="color:#888;">Speed:</span>
                                        <input type="range" id="playerSpeedSlider" min="1" max="24" value="8" style="width:80px;" oninput="playerUpdateSpeed()">
                                        <span id="playerSpeedLabel" style="color:#4f8; min-width:35px;">8 fps</span>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:5px; margin-top:5px;">
                                        <label style="color:#888; cursor:pointer;"><input type="checkbox" id="playerPingPong" onchange="playerUpdatePingPong()"> Ping-Pong</label>
                                    </div>
                                </div>
                            </div>
                            <button id="playerMirrorBtn" onclick="playerToggleMirror()" style="background:#555; padding:5px 10px; font-size:11px; border:1px solid #888;">Mirror</button>
                            <button onclick="playerClearCurrentAnim()" style="background:#a55; padding:5px 10px; font-size:11px;">Clear</button>
                        </div>
                    </div>
                    <div class="anim-frames-list" id="playerFramesList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Dialog Editor Modal -->
    <div class="anim-modal" id="dialogModal">
        <div class="anim-modal-content" style="width:900px; max-width:95vw;">
            <div style="display:flex; gap:20px; height:100%;">
                <!-- Left: Controls -->
                <div style="flex:0 0 220px; background:#1a1a2e; padding:15px; border-radius:8px; overflow-y:auto;">
                    <h2 style="margin-top:0; color:#88f; font-size:16px;">Dialog Editor</h2>

                    <!-- Dialog Name -->
                    <div style="margin-bottom:12px;">
                        <label style="font-size:10px; color:#aaa; display:block; margin-bottom:4px;">Dialog Name:</label>
                        <input type="text" id="dialogNameInput" placeholder="e.g. villager_greeting" style="width:100%; padding:6px; font-size:12px;">
                    </div>

                    <!-- Style Selection -->
                    <div style="margin-bottom:12px;">
                        <label style="font-size:10px; color:#aaa; display:block; margin-bottom:4px;">Style:</label>
                        <select id="dialogStyleSelect" style="width:100%; padding:6px;" onchange="updateDialogPreview()">
                            <option value="1">Classic NES</option>
                            <option value="2">Final Fantasy</option>
                            <option value="3">Pokemon</option>
                            <option value="4">Earthbound</option>
                            <option value="5">Chrono Trigger</option>
                            <option value="6">Modern Pixel</option>
                        </select>
                    </div>

                    <!-- Colors -->
                    <div style="margin-bottom:12px;">
                        <label style="font-size:10px; color:#aaa; display:block; margin-bottom:4px;">Colors:</label>
                        <div style="display:grid; grid-template-columns:1fr 1fr; gap:6px;">
                            <div>
                                <label style="font-size:9px; color:#666;">Background</label>
                                <input type="color" id="dialogBgColor" value="#000000" style="width:100%; height:24px;" onchange="updateDialogPreview()">
                            </div>
                            <div>
                                <label style="font-size:9px; color:#666;">Border</label>
                                <input type="color" id="dialogBorderColor" value="#ffffff" style="width:100%; height:24px;" onchange="updateDialogPreview()">
                            </div>
                            <div>
                                <label style="font-size:9px; color:#666;">Text</label>
                                <input type="color" id="dialogTextColor" value="#ffffff" style="width:100%; height:24px;" onchange="updateDialogPreview()">
                            </div>
                            <div>
                                <label style="font-size:9px; color:#666;">Accent</label>
                                <input type="color" id="dialogAccentColor" value="#ffffff" style="width:100%; height:24px;" onchange="updateDialogPreview()">
                            </div>
                        </div>
                    </div>

                    <!-- Size -->
                    <div style="margin-bottom:12px;">
                        <label style="font-size:10px; color:#aaa; display:block; margin-bottom:4px;">Size:</label>
                        <div style="display:flex; gap:6px;">
                            <div style="flex:1;">
                                <label style="font-size:9px; color:#666;">Width</label>
                                <input type="number" id="dialogWidth" value="280" min="100" max="500" style="width:100%; padding:4px;" onchange="updateDialogPreview()">
                            </div>
                            <div style="flex:1;">
                                <label style="font-size:9px; color:#666;">Height</label>
                                <input type="number" id="dialogHeight" value="80" min="50" max="200" style="width:100%; padding:4px;" onchange="updateDialogPreview()">
                            </div>
                        </div>
                    </div>

                    <!-- Buttons -->
                    <div style="display:flex; gap:6px; margin-top:15px;">
                        <button onclick="saveDialog()" style="flex:1; padding:8px; background:#484; font-size:12px;">Save</button>
                        <button onclick="closeDialogEditor()" style="flex:1; padding:8px; background:#644; font-size:12px;">Cancel</button>
                    </div>
                </div>

                <!-- Middle: Pages and Text Editor -->
                <div style="flex:0 0 280px; display:flex; flex-direction:column; gap:12px;">
                    <!-- Pages List -->
                    <div style="background:#1a1a2e; padding:12px; border-radius:8px;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                            <h3 style="margin:0; color:#fa0; font-size:13px;">Pages</h3>
                            <button onclick="addDialogPage()" style="padding:4px 8px; background:#484; font-size:11px;">+ Add</button>
                        </div>
                        <div id="dialogPagesList" style="display:flex; gap:6px; flex-wrap:wrap; max-height:50px; overflow-y:auto;">
                            <div class="dialog-page active" onclick="selectDialogPageEditor(0)">1</div>
                        </div>
                    </div>

                    <!-- Current Page Editor -->
                    <div style="background:#1a1a2e; padding:12px; border-radius:8px; flex:1;">
                        <div style="margin-bottom:8px;">
                            <label style="font-size:10px; color:#aaa; display:block; margin-bottom:4px;">Speaker Name:</label>
                            <input type="text" id="dialogSpeaker" placeholder="NPC name or leave empty" style="width:100%; padding:6px;" onkeyup="updateDialogPreview()">
                        </div>
                        <div>
                            <label style="font-size:10px; color:#aaa; display:block; margin-bottom:4px;">Text:</label>
                            <textarea id="dialogTextInput" rows="5" placeholder="Enter dialog text..." style="width:100%; padding:6px; resize:vertical;" onkeyup="updateDialogPreview()"></textarea>
                        </div>
                        <button onclick="removeCurrentDialogPage()" style="margin-top:6px; padding:4px 8px; background:#644; font-size:10px;">Delete Page</button>
                    </div>
                </div>

                <!-- Right: Preview (big and prominent) -->
                <div style="flex:1; background:#111; padding:20px; border-radius:8px; display:flex; flex-direction:column; align-items:center; justify-content:center; min-width:350px;">
                    <label style="font-size:12px; color:#888; display:block; margin-bottom:15px;">Live Preview</label>
                    <div style="background:#000; padding:20px; border-radius:4px; box-shadow:0 0 20px rgba(0,0,0,0.5);">
                        <canvas id="dialogPreviewCanvas" width="280" height="80" style="image-rendering:pixelated; display:block;"></canvas>
                    </div>
                    <div style="margin-top:15px; text-align:center;">
                        <span style="font-size:10px; color:#666;">Press A to advance</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Animated Prop Editor Modal -->
    <div class="anim-modal" id="animPropModal">
        <div class="anim-modal-content">
            <!-- Sidebar -->
            <div class="anim-sidebar">
                <h2 style="margin-top:0;">Animated Prop</h2>

                <!-- Step 1: Load Sprite Sheet -->
                <div style="margin-bottom:20px;">
                    <h3>1. Sprite Sheet</h3>
                    <input type="file" id="animPropFileInput" accept="image/*" onchange="animPropLoadSheet(event)">
                    <button onclick="document.getElementById('animPropFileInput').click()" style="width:100%;">Load Image</button>
                    <div id="animPropFileName" style="font-size:11px; color:#4af; margin-top:5px;"></div>
                </div>

                <!-- Step 2: Frame Size -->
                <div id="animPropFrameSection" style="margin-bottom:20px; display:none;">
                    <h3>2. Frame Size</h3>
                    <div style="display:flex; gap:10px; margin-bottom:10px;">
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Width:</label>
                            <input type="number" id="animPropFrameW" value="16" min="8" max="256" onchange="animPropUpdateGrid()" style="width:100%;">
                        </div>
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Height:</label>
                            <input type="number" id="animPropFrameH" value="16" min="8" max="256" onchange="animPropUpdateGrid()" style="width:100%;">
                        </div>
                    </div>
                    <div style="font-size:11px; color:#888;" id="animPropGridInfo"></div>
                </div>

                <!-- Step 3: Animation Type -->
                <div id="animPropTypeSection" style="margin-bottom:20px; display:none;">
                    <h3>3. Animation Type</h3>
                    <select id="animPropType" style="width:100%;" onchange="animPropTypeChanged()">
                        <option value="loop">Loop (continuous)</option>
                        <option value="interactive">Interactive (on trigger)</option>
                    </select>
                    <p style="font-size:10px; color:#666; margin-top:5px;">Adjust speed with slider in preview below</p>

                    <!-- Interact options (shown when type is 'interactive') -->
                    <div id="animPropInteractOptions" style="display:none; margin-top:10px; padding:10px; background:#1a2a35; border-radius:5px;">
                        <label style="display:flex; align-items:center; gap:8px; cursor:pointer; margin-bottom:8px;">
                            <input type="checkbox" id="animPropGiveItem" onchange="animPropGiveItemChanged()">
                            <span style="font-size:12px;">Give Item on Interact</span>
                        </label>
                        <div id="animPropItemSection" style="display:none;">
                            <label style="font-size:10px; color:#888;">Select Item:</label>
                            <select id="animPropItemSelect" style="width:100%; margin-top:4px;">
                                <option value="-1">-- No items defined --</option>
                            </select>
                            <p style="font-size:9px; color:#666; margin-top:4px;">Player receives this item when interacting (A key)</p>
                        </div>
                    </div>
                </div>

                <!-- Step 4: Collision & Depth -->
                <div id="animPropCollisionSection" style="margin-bottom:20px; display:none;">
                    <h3>4. Collision & Depth</h3>
                    <div style="display:flex; gap:5px; flex-wrap:wrap; margin-bottom:10px;">
                        <button id="animPropToolNone" class="active" onclick="setAnimPropTool('none')" style="padding:5px 8px; font-size:11px;">Select</button>
                        <button id="animPropToolCollision" onclick="setAnimPropTool('collision')" style="padding:5px 8px; font-size:11px; background:#a55;">Collision</button>
                        <button id="animPropToolErase" onclick="setAnimPropTool('erase')" style="padding:5px 8px; font-size:11px;">Erase</button>
                        <button id="animPropToolSplit" onclick="setAnimPropTool('split')" style="padding:5px 8px; font-size:11px; background:#0aa;">Split</button>
                    </div>

                    <!-- Brush Size for Collision -->
                    <div id="animPropBrushSection" style="display:none; margin-bottom:10px;">
                        <div style="margin-bottom:8px; padding:6px; background:#2a1a1a; border:1px solid #a55; border-radius:4px;">
                            <span style="font-size:10px; color:#aaa;">Click any frame to paint. Copy from:</span>
                            <select id="animPropCollisionFrameSelect" onchange="setAnimPropCollisionFrame(this.value)" style="margin-left:5px; padding:2px; font-size:10px;">
                                <option value="0">Frame 1</option>
                            </select>
                            <button onclick="copyCollisionToAllFrames()" style="margin-left:5px; padding:2px 6px; font-size:9px; background:#a55;">Copy to All</button>
                        </div>
                        <div style="margin-bottom:5px;">
                            <span style="font-size:10px; color:#aaa;">Shape:</span>
                            <button id="animPropShapeSquare" class="active" onclick="setAnimPropBrushShape('square')" style="padding:3px 6px; font-size:10px;">■ Square</button>
                            <button id="animPropShapeCircle" onclick="setAnimPropBrushShape('circle')" style="padding:3px 6px; font-size:10px;">● Circle</button>
                            <button id="animPropShapeRect" onclick="setAnimPropBrushShape('rect')" style="padding:3px 6px; font-size:10px;">▬ Rect</button>
                        </div>
                        <div id="animPropBrushSizeRow">
                            <span style="font-size:10px; color:#aaa;">Size:</span>
                            <button id="animPropBrush1" onclick="setAnimPropBrush(1)" style="padding:3px 6px; font-size:10px;">1</button>
                            <button id="animPropBrush2" onclick="setAnimPropBrush(2)" style="padding:3px 6px; font-size:10px;">2</button>
                            <button id="animPropBrush4" class="active" onclick="setAnimPropBrush(4)" style="padding:3px 6px; font-size:10px;">4</button>
                            <button id="animPropBrush8" onclick="setAnimPropBrush(8)" style="padding:3px 6px; font-size:10px;">8</button>
                        </div>
                        <div id="animPropRectSizeRow" style="display:none; margin-top:5px;">
                            <span style="font-size:10px; color:#aaa;">W:</span>
                            <input type="number" id="animPropRectW" value="8" min="2" max="32" style="width:40px; font-size:10px;" onchange="updateAnimPropRectSize()">
                            <span style="font-size:10px; color:#aaa; margin-left:5px;">H:</span>
                            <input type="number" id="animPropRectH" value="4" min="2" max="32" style="width:40px; font-size:10px;" onchange="updateAnimPropRectSize()">
                        </div>
                    </div>

                    <!-- Split Controls -->
                    <div id="animPropSplitControls" style="display:none; margin-bottom:10px; padding:8px; background:#1a3a3e; border-radius:5px;">
                        <div style="font-size:10px; color:#0ff; margin-bottom:5px;">Draw split line on tiles (drag to draw)</div>
                        <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                            <label style="font-size:10px; display:flex; align-items:center; gap:4px; cursor:pointer;">
                                <input type="checkbox" id="animPropFlatLine" checked>
                                <span>Flat Line</span>
                            </label>
                            <span style="font-size:10px;">Y:</span>
                            <input type="number" id="animPropSplitY" value="8" min="0" max="16" style="width:40px; padding:2px; font-size:10px;">
                            <button onclick="setAnimPropSplitY()" style="padding:2px 6px; font-size:9px; background:#0aa;">Set Y</button>
                            <button onclick="clearAnimPropSplit()" style="padding:2px 6px; font-size:9px; background:#a55;">Clear</button>
                        </div>
                        <div style="font-size:9px; color:#888; margin-top:4px;">C = Canopy (top) | T = Trunk (Y-sorted)</div>
                    </div>

                    <p style="font-size:10px; color:#666;">Paint on any frame. Collision/split data applies to all frames.</p>
                </div>

                <!-- Step 5: Name -->
                <div id="animPropNameSection" style="margin-bottom:20px; display:none;">
                    <h3>5. Name</h3>
                    <input type="text" id="animPropNameInput" placeholder="e.g. torch, chest, door" style="width:100%;">
                </div>

                <!-- Actions -->
                <div style="margin-top:auto;">
                    <button onclick="animPropSave()" style="width:100%; background:#4af; color:#000; margin-bottom:10px;">Save Prop</button>
                    <button onclick="animPropCancel()" style="width:100%; background:#a55;">Cancel</button>
                </div>
            </div>

            <!-- Main Area -->
            <div class="anim-main">
                <div class="anim-header">
                    <h2>Sprite Sheet</h2>
                    <span style="color:#888; font-size:12px;">Click or drag to select frames (multi-tile supported)</span>
                    <div style="display:flex; align-items:center; gap:5px; margin-left:auto;">
                        <span style="color:#888; font-size:11px;">Zoom:</span>
                        <button onclick="animPropZoomOut()" style="padding:2px 8px; font-size:14px;">-</button>
                        <span id="animPropZoomLevel" style="color:#4af; font-size:11px; min-width:35px; text-align:center;">3x</span>
                        <button onclick="animPropZoomIn()" style="padding:2px 8px; font-size:14px;">+</button>
                    </div>
                </div>

                <div class="anim-canvas-area">
                    <canvas id="animPropEditorCanvas"></canvas>
                </div>

                <!-- Bottom Bar: Animation Frames -->
                <div class="anim-frames-bar">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span>Animation Frames: <strong id="animPropFrameCount" style="color:#4af;">0</strong></span>
                        <div style="display:flex; align-items:center; gap:15px;">
                            <!-- Live Preview -->
                            <div style="display:flex; align-items:center; gap:8px;">
                                <canvas id="animPropLivePreview" width="48" height="48" style="border:2px solid #4af; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                                <div style="font-size:11px;">
                                    <div style="display:flex; align-items:center; gap:5px; margin-bottom:4px;">
                                        <span style="color:#888;">Speed:</span>
                                        <input type="range" id="animPropSpeedSlider" min="1" max="24" value="8" style="width:80px;" oninput="animPropUpdateSpeed()">
                                        <span id="animPropSpeedLabel" style="color:#4af; min-width:35px;">8 fps</span>
                                    </div>
                                </div>
                            </div>
                            <button onclick="animPropClearFrames()" style="background:#a55; padding:5px 10px; font-size:11px;">Clear</button>
                        </div>
                    </div>
                    <div class="anim-frames-list" id="animPropFramesList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Item Editor Modal -->
    <div class="anim-modal" id="itemModal">
        <div class="anim-modal-content">
            <!-- Sidebar -->
            <div class="anim-sidebar">
                <h2 style="margin-top:0;">Interactive Item</h2>

                <!-- Step 1: Load Sprite Sheet -->
                <div style="margin-bottom:20px;">
                    <h3>1. Sprite Sheet</h3>
                    <input type="file" id="itemFileInput" accept="image/*" onchange="itemLoadSheet(event)" style="display:none;">
                    <button onclick="document.getElementById('itemFileInput').click()" style="width:100%;">Load Image</button>
                    <div id="itemFileName" style="font-size:11px; color:#4f8; margin-top:5px;"></div>
                </div>

                <!-- Step 2: Frame Size -->
                <div id="itemFrameSection" style="margin-bottom:20px; display:none;">
                    <h3>2. Frame Size</h3>
                    <div style="display:flex; gap:10px; margin-bottom:10px;">
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Width:</label>
                            <input type="number" id="itemFrameW" value="16" min="8" max="256" onchange="itemUpdateGrid()" style="width:100%;">
                        </div>
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Height:</label>
                            <input type="number" id="itemFrameH" value="16" min="8" max="256" onchange="itemUpdateGrid()" style="width:100%;">
                        </div>
                    </div>
                    <div style="font-size:11px; color:#888;" id="itemGridInfo"></div>
                </div>

                <!-- Step 3: Idle Frame -->
                <div id="itemIdleSection" style="margin-bottom:20px; display:none;">
                    <h3>3. Idle Frame</h3>
                    <p style="font-size:10px; color:#666; margin-bottom:8px;">Which frame shows before player interacts</p>
                    <select id="itemIdleFrame" style="width:100%;">
                        <option value="0">Frame 1 (first)</option>
                    </select>
                </div>

                <!-- Step 4: Name -->
                <div id="itemNameSection" style="margin-bottom:20px; display:none;">
                    <h3>4. Name</h3>
                    <input type="text" id="itemNameInput" placeholder="e.g. chest, pot, crate" style="width:100%;">
                </div>

                <!-- Actions -->
                <div style="margin-top:auto;">
                    <button onclick="itemSave()" style="width:100%; background:#4f8; color:#000; margin-bottom:10px;">Save Item</button>
                    <button onclick="itemCancel()" style="width:100%; background:#a55;">Cancel</button>
                </div>
            </div>

            <!-- Main Area -->
            <div class="anim-main">
                <div class="anim-header">
                    <h2>Sprite Sheet</h2>
                    <span style="color:#888; font-size:12px;">Click frames in order: idle first, then animation sequence</span>
                    <div style="display:flex; align-items:center; gap:5px; margin-left:auto;">
                        <span style="color:#888; font-size:11px;">Zoom:</span>
                        <button onclick="itemZoomOut()" style="padding:2px 8px; font-size:14px;">-</button>
                        <span id="itemZoomLevel" style="color:#4f8; font-size:11px; min-width:35px; text-align:center;">3x</span>
                        <button onclick="itemZoomIn()" style="padding:2px 8px; font-size:14px;">+</button>
                    </div>
                </div>

                <div class="anim-canvas-area">
                    <canvas id="itemEditorCanvas"></canvas>
                </div>

                <!-- Bottom Bar: Animation Frames -->
                <div class="anim-frames-bar">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span>Animation Frames: <strong id="itemFrameCount" style="color:#4f8;">0</strong></span>
                        <div style="display:flex; align-items:center; gap:15px;">
                            <!-- Live Preview -->
                            <div style="display:flex; align-items:center; gap:8px;">
                                <canvas id="itemLivePreview" width="48" height="48" style="border:2px solid #4f8; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                                <div style="font-size:11px;">
                                    <div style="display:flex; align-items:center; gap:5px;">
                                        <span style="color:#888;">Speed:</span>
                                        <input type="range" id="itemSpeedSlider" min="1" max="24" value="8" style="width:80px;" oninput="itemUpdateSpeed()">
                                        <span id="itemSpeedLabel" style="color:#4f8; min-width:35px;">8 fps</span>
                                    </div>
                                </div>
                            </div>
                            <button onclick="itemClearFrames()" style="background:#a55; padding:5px 10px; font-size:11px;">Clear</button>
                        </div>
                    </div>
                    <div class="anim-frames-list" id="itemFramesList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Door Target Map Modal -->
    <div id="doorMapModal" style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.8); z-index:10000; justify-content:center; align-items:center;">
        <div style="background:#2a2a2a; padding:20px; border-radius:8px; min-width:300px; border:2px solid #4af;">
            <h3 style="margin:0 0 15px 0; color:#4af;">Door <span id="doorModalNumber">1</span></h3>

            <div id="doorMapSelectDiv">
                <div style="margin-bottom:15px;">
                    <label style="display:block; margin-bottom:5px; color:#aaa;">Target map:</label>
                    <select id="doorMapSelect" style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555;">
                    </select>
                </div>

                <div style="margin-bottom:15px;">
                    <label style="display:block; margin-bottom:5px; color:#aaa;">Or create new map:</label>
                    <input type="text" id="doorNewMapName" placeholder="Enter new map name..." style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555; box-sizing:border-box;">
                </div>
            </div>

            <div style="margin-bottom:15px; padding-top:15px; border-top:1px solid #444;">
                <label style="display:block; margin-bottom:5px; color:#aaa;">Door Type:</label>
                <select id="doorModalType" onchange="updateDoorModalOptions()" style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555;">
                    <option value="walkover">Walk Over (auto)</option>
                    <option value="interact">Interact (press button)</option>
                    <option value="external">External Link (to another HTML)</option>
                </select>
            </div>

            <!-- External options (shown only for external type) -->
            <div id="externalOptions" style="display:none; margin-bottom:15px; background:#1a2a3a; padding:10px; border-radius:4px;">
                <label style="display:block; margin-bottom:8px; color:#0ff; font-weight:bold;">Destination:</label>
                <select id="externalDestination" style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555;">
                    <option value="tavern/test-3d-tavern.html">Tavern (3D)</option>
                </select>
                <p style="margin:8px 0 0 0; font-size:11px; color:#888;">Player will be transported to this location</p>
            </div>

            <!-- Walkover options (shown only for walkover type) -->
            <div id="walkoverOptions" style="margin-bottom:15px; background:#222; padding:10px; border-radius:4px;">
                <label style="display:block; margin-bottom:8px; color:#4af; font-weight:bold;">Walk-Out Settings:</label>

                <div style="margin-bottom:10px;">
                    <label style="display:flex; align-items:center; gap:8px; color:#fff; cursor:pointer;">
                        <input type="checkbox" id="useWalkOutPoint" onchange="toggleWalkOutMode()" style="width:18px; height:18px;">
                        <span>Set walk-out destination (click on map)</span>
                    </label>
                    <p style="margin:5px 0 0 26px; font-size:11px; color:#888;">Player auto-walks to this point before fade</p>
                </div>

                <div id="walkDirectionOptions">
                    <label style="display:block; margin-bottom:5px; color:#aaa;">Or walk direction:</label>
                    <div style="display:flex; gap:5px; margin-bottom:10px;">
                        <button type="button" onclick="setWalkDirection('up')" id="walkDirUp" style="flex:1; padding:8px; background:#444; border:2px solid #555; color:#fff; cursor:pointer;">↑</button>
                        <button type="button" onclick="setWalkDirection('down')" id="walkDirDown" style="flex:1; padding:8px; background:#444; border:2px solid #555; color:#fff; cursor:pointer;">↓</button>
                        <button type="button" onclick="setWalkDirection('left')" id="walkDirLeft" style="flex:1; padding:8px; background:#444; border:2px solid #555; color:#fff; cursor:pointer;">←</button>
                        <button type="button" onclick="setWalkDirection('right')" id="walkDirRight" style="flex:1; padding:8px; background:#444; border:2px solid #555; color:#fff; cursor:pointer;">→</button>
                    </div>
                    <label style="display:block; margin-bottom:5px; color:#aaa;">Walk Duration (seconds):</label>
                    <input type="number" id="doorWalkDuration" value="0.5" min="0.1" max="5" step="0.1" style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555; box-sizing:border-box;">
                </div>
            </div>

            <!-- Interact options (shown only for interact type) -->
            <div id="interactOptions" style="display:none; margin-bottom:15px; background:#222; padding:10px; border-radius:4px;">
                <label style="display:block; margin-bottom:8px; color:#f84; font-weight:bold;">Door Animation:</label>
                <div style="margin-bottom:10px;">
                    <label style="display:flex; align-items:center; gap:8px; color:#fff; cursor:pointer;">
                        <input type="checkbox" id="useDoorAnimation" style="width:18px; height:18px;">
                        <span>Animate door tiles (paint after placing)</span>
                    </label>
                    <p style="margin:5px 0 0 26px; font-size:11px; color:#888;">Selected tiles will disappear when door opens</p>
                </div>
            </div>

            <div style="margin-bottom:15px;">
                <label style="display:block; margin-bottom:5px; color:#aaa;">Fade Duration (seconds, 0 = instant):</label>
                <input type="number" id="doorFadeDuration" value="0.5" min="0" max="3" step="0.1" style="width:100%; padding:8px; font-size:14px; background:#333; color:#fff; border:1px solid #555; box-sizing:border-box;">
            </div>

            <div style="display:flex; gap:10px; justify-content:flex-end;">
                <button onclick="closeDoorMapModal()" style="padding:8px 16px; background:#555; color:#fff;">Cancel</button>
                <button id="doorModalConfirmBtn" onclick="confirmDoorMapModal()" style="padding:8px 16px; background:#4af; color:#000; font-weight:bold;">Set Spawn →</button>
            </div>
        </div>
    </div>

    <script>
        // ===== GLOBALS =====
        let currentPhase = 'load'; // 'load', 'collision', 'build'
        let gridSize = 16;
        let zoom = 2;
        let mapCols = 40;
        let mapRows = 30;

        let tilesetImg = null;
        let tilesets = []; // Array of { name, img, data } for multiple tilesets
        let currentTilesetIndex = 0;
        let tilesetSortOrder = 'added'; // 'added' or 'alpha'
        let tilesetSearchTerm = '';
        let tileCollisions = {}; // "tilesetIndex:x,y" -> [{x,y}, ...]
        let selectedTileData = null;
        let selectionStart = null; // For multi-tile selection
        let selectedTiles = []; // Array of {x, y} for multi-tile selection
        let hoverMapPos = null; // Current hover position on map for preview
        let tileRotation = 0; // 0, 90, 180, 270 degrees
        let tileFlippedH = false; // Flip tile horizontally
        let prattWarningShown = false; // Track if flip+rotation warning was shown
        let eraseMode = false; // Erase tiles instead of painting

        // Layers
        let layers = []; // Array of layer data, each layer is a 2D array like map
        let currentLayer = 0;
        let layerVisibility = []; // Which layers are visible
        let layerNames = []; // Custom names for layers

        // Player layer (for visualization - uneditable, undeletable)
        let playerLayerIndex = 1; // Which layer position the player appears at
        let playerPreviewPos = { x: 5, y: 5 }; // Position on map for player preview
        let spawnMapName = 'main'; // Which map the initial spawn is on
        let playerPreviewVisible = true;
        let setSpawnMode = false; // For setting player spawn position

        // Brush settings
        let brushPainting = false;
        let brushErasing = false;
        let collisionZoom = 6;
        let collisionTool = 'paint'; // 'paint' or 'erase'
        let brushSize = 4; // Brush size in pixels
        let brushShape = 'square'; // 'square', 'circle', 'rect'
        let brushRectW = 8;
        let brushRectH = 4;
        let brushPreviewPos = null; // { x, y } for cyan preview
        let modifiedCollisionKeys = new Set(); // Track modified tiles for sync

        // Pixel collision masks per tile
        let collisionMasks = {}; // "x,y" -> 2D array of booleans

        // Depth split lines for Y-sorting (trunk vs canopy)
        let tileSplitLines = {}; // "tilesetIndex:x,y" -> array of Y values per column (freeform line)
        let tileSplitLineFlipped = {}; // "tilesetIndex:x,y" -> boolean (true = bottom covers player, false = top covers player)
        let selectedSplitTile = null; // {x, y, tilesetIndex} - currently selected tile for splitting
        let draggingSplitLine = false; // true when dragging the split line
        let flatLineMode = true; // when true, split lines are always horizontal
        let modifiedSplitKey = null; // Track current split line being modified for sync

        // Panning
        let collisionPanX = 0;
        let collisionPanY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;

        let mode = 'tile';
        let currentMapName = 'main'; // Current map name (for multi-map support)
        let maps = {}; // All maps data: { 'main': {layers, tileCollisions, ...}, 'dungeon1': {...} }
        let placedTriggers = []; // Map transition triggers: { x, y, mapName, targetMap, targetX, targetY, type, ... }
        let settingSpawnPoint = false; // True when clicking to set trigger spawn point
        let spawnSourceMap = null; // Map we came from when setting spawn
        let draggingSpawnTrigger = null; // Trigger being dragged (to move spawn point)
        let pendingTriggerForSpawn = null; // Trigger we're setting spawn for (green box follows mouse)
        let triggerDragStart = null; // Start position for drag-to-create trigger {x, y}
        let triggerDragEnd = null; // End position for drag-to-create trigger {x, y}
        let pendingTriggerWidth = 1; // Width of trigger being created
        let pendingTriggerHeight = 1; // Height of trigger being created

        // Player sprite (embedded as base64)
        let playerSpriteData = null; // Base64 data URL of player sprite
        let playerSpriteImg = null; // Image object for preview

        // Player character system (multiple characters with animations)
        let playerCharacters = []; // Array of { name, spriteData, frameWidth, frameHeight, animations, fps }
        let activePlayerIndex = -1; // Which character is active (-1 = use default sprite)

        // Player editor state
        let playerEditorSheets = []; // Array of { image, data, name }
        let playerCurrentSheetIndex = 0;
        let playerEditorFrameW = 64;
        let playerEditorFrameH = 64;
        let playerEditorZoom = 3;
        let playerEditorEditingIndex = -1; // -1 = new, >= 0 = editing existing
        let playerAnimations = { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], idleDown: [], idleUp: [], idleLeft: [], idleRight: [], attackDown: [], attackUp: [], attackLeft: [], attackRight: [], interact: [], death: [], receivedItem: [], receiveItemDown: [], receiveItemUp: [], receiveItemLeft: [], receiveItemRight: [] };
        let playerCurrentAnim = 'walkDown';
        let playerPreviewPlaying = false;
        let playerPreviewInterval = null;
        let playerPreviewFrame = 0;
        let playerAnimFpsList = {}; // Per-animation FPS: { walkDown: 8, death: 1, ... }
        let playerPingPong = false;
        let playerPreviewDirection = 1; // 1 = forward, -1 = backward for ping-pong
        let playerAnimMirrors = {}; // { walkLeft: true } - animations to render flipped horizontally
        let playerAttackMovement = 'stop'; // 'stop', 'slide', 'move' - player movement during attack
        // Shape-based attack hitbox per direction (triangle/cone)
        let playerHitboxRange = { up: 35, down: 35, left: 35, right: 30 };
        let playerHitboxWidth = { up: 90, down: 90, left: 90, right: 90 };
        let playerHitboxOffsetY = { up: 15, down: -15, left: 0, right: 0 };
        let playerHitboxOffsetX = { up: 0, down: 0, left: 15, right: -15 }; // Horizontal offset
        let playerGameOverSoundIndex = -1; // Index of game over sound (-1 = none, 0+ = builtin, 100+ = project sounds)

        // Built-in game over sounds
        const builtinGameOverSounds = [
            { name: 'Game Over 1', file: 'game-over-417465.mp3' },
            { name: 'Game Over 2 (Arcade)', file: 'game-over-arcade-6435.mp3' }
        ];
        let builtinGameOverAudios = [null, null]; // Lazy-loaded audio elements
        // Player drag-selection for multi-tile frames
        let playerFrameDragging = false;
        let playerFrameDragStart = null;
        let playerFrameDragEnd = null;

        // Copy from map mode
        let copyMode = false;
        let copyStart = null;
        let copyEnd = null;
        let copiedTiles = null; // 2D array of copied tile data (or 3D if all layers)
        let copiedAllLayers = false; // Whether copiedTiles contains all layers

        // Multiple props system - array of prop images like tilesets
        let props = []; // Array of { name, img, data, collisionMasks }
        let currentPropIndex = -1;
        let propImage = null; // Current prop image (shortcut)
        let propImageData = null; // Current prop data (shortcut)
        let propSelection = null; // {x, y, width, height}
        let propCollisionMasks = {}; // Current prop's collision masks
        let propTool = 'select'; // 'select', 'collision', 'erase'
        let propBrushSize = 4;
        let propPainting = false;

        // Animated Props System
        let animatedProps = []; // Array of animated prop definitions { name, spriteData, frameWidth, frameHeight, frames: [{x,y,w,h},...], type: 'loop'|'interactive', fps }
        let currentAnimPropIndex = -1;
        let currentAnimPropScale = 1; // Scale for placing animated props
        let editAnimPropOnMapMode = false; // Edit mode for clicking placed props to adjust timing
        let animPropSpriteSheet = null; // Current sprite sheet Image
        let animPropSpriteData = null; // Current sprite data URL
        let animPropFrames = []; // Frames being edited
        let animPropPreviewPlaying = false;
        let animPropPreviewFrame = 0;
        let animPropPreviewInterval = null;
        let placedAnimProps = []; // Animated props placed on map: { propIndex, x, y, layer } (grid coords like tiles)
        // Drag selection for multi-tile frames
        let animPropDragStart = null; // {gridX, gridY}
        let animPropDragEnd = null; // {gridX, gridY}
        let animPropIsDragging = false;
        // Animation state for placed props in editor
        let placedAnimPropFrames = {}; // key: "x,y,layer" -> { frame: 0, timer: 0 }
        let editorAnimInterval = null;

        // Static Objects System (tiles saved as reusable props)
        let staticObjects = [];           // { name, spriteData, width, height, tilesetIndex, sourceTiles, sourceOrigin, _spriteImg }
        let placedStaticObjects = [];     // { objIndex, x, y, mapName, scale }
        let currentStaticObjIndex = -1;
        let staticObjPlacementScale = 1.0;
        let createObjectMode = false;

        // Items System (interactive props like chests)
        let items = []; // Array of item definitions { name, spriteData, frameWidth, frameHeight, frames: [{x,y,w,h},...], fps, idleFrame }
        let currentItemIndex = -1;
        let itemSpriteSheet = null; // Current sprite sheet Image
        let itemSpriteData = null; // Current sprite data URL
        let itemFrames = []; // Frames being edited
        let itemPreviewPlaying = false;
        let itemPreviewFrame = 0;
        let itemPreviewInterval = null;
        let placedItems = []; // Items placed on map: { itemIndex, x, y, layer, mapName, used: false }
        // Drag selection for multi-tile frames
        let itemDragStart = null;
        let itemDragEnd = null;
        let itemIsDragging = false;
        // Animation state for placed items in editor
        let placedItemFrames = {}; // key: "x,y,layer,map" -> { frame: 0, timer: 0, playing: false }

        // Quest System (builder side)
        let quests = [];
        let selectedQuestIndex = -1;
        let settingConditionMode = false;
        let settingConditionType = null;

        // NPC System
        let npcs = []; // Array of NPC definitions { name, spriteData, frameWidth, frameHeight, animations: {...}, fps }
        let currentNpcIndex = -1;
        let placedNpcs = []; // NPCs placed on map: { npcIndex, x, y, path: [{x,y},...], trigger, speed }
        let selectedPlacedNpcIndex = -1; // Currently selected placed NPC for editing
        let npcPathDrawing = false; // Currently drawing a path
        let npcPathEditing = false; // Currently editing/moving waypoints
        let npcDraggingWaypoint = -1; // Index of waypoint being dragged (-1 = none)
        let npcEditorImage = null;

        // NPC Path Preview
        let npcPathPreviewActive = false;
        let npcPreviewAnimId = null;
        let npcPreviewState = null; // { x, y, waypointIndex, direction, frame, frameTimer }
        let npcEditorData = null;
        let npcEditorFrameW = 16;
        let npcEditorFrameH = 16;
        let npcEditorEditingIndex = -1;
        let npcEditorZoom = 3; // Zoom level for sprite sheet display
        let npcTool = 'none'; // 'none', 'collision', 'erase', 'split'
        let npcBrushSize = 4;
        let npcBrushShape = 'square'; // 'square', 'circle', 'rect'
        let npcBrushRectW = 8; // Width for rectangle brush
        let npcBrushRectH = 4; // Height for rectangle brush
        let npcBrushPreviewPos = null; // {x, y} for cursor preview
        let npcCollisionMask = null; // 2D array for collision pixels
        let npcSplitLine = null; // Y value for depth split
        let npcPainting = false;
        let npcFrames = []; // Frames being edited

        // NPC frame drag selection (for multi-tile frames)
        let npcFrameDragStart = null;   // {gridX, gridY}
        let npcFrameDragEnd = null;     // {gridX, gridY}
        let npcFrameDragging = false;
        let npcPreviewPlaying = false;
        let npcPreviewFrame = 0;
        let npcPreviewInterval = null;
        let npcPingPong = false;
        let npcPreviewDirection = 1; // 1 = forward, -1 = backward for ping-pong

        // Dialog System
        let dialogs = []; // Array of dialog configurations { name, style, colors, pages: [{speaker, text}], ... }
        let placedDialogTiles = []; // Dialog tiles (signs): { x, y, mapName, dialogIndex }
        let currentDialogIndex = -1;
        let currentDialogTileIndex = -1; // Selected dialog for tile placement
        let dialogEditorOpen = false;

        // Sound System
        let sounds = []; // Array of { name, data, duration, type: 'ambient'|'action' }
        let currentSoundIndex = -1;
        let soundAttachMode = 'tile'; // 'tile' or 'player'
        let tileSounds = {}; // "x,y" -> { soundIndex, radius, loop, volume, fadePercent }
        let playerSounds = {
            walk: { soundIndex: -1, interval: 200, volume: 0.5, pitchVariation: 0.1 },
            attack: { soundIndex: -1, volume: 0.7, pitchVariation: 0.15, lengthVariation: 0 }
        };
        let previewAudio = null; // For sound preview playback
        let selectedTileSoundKey = null; // Currently selected tile sound for editing

        // Lighting System (Classic 2D - no WebGL)
        let lightingSettings = {
            playerLight: false,
            playerLightRadius: 4
        };
        let pointLights = {};  // "mapName:x,y" -> { radius, flicker }
        let polyLights = [];   // Array of { mapName, points: [{x,y}], intensity, flicker }
        let polyLightDrawing = false;  // True when drawing a polygon light
        let polyLightPoints = [];      // Current polygon being drawn

        let map = [];

        // Canvas refs
        const collisionTilesetCanvas = document.getElementById('collisionTilesetCanvas');
        const collisionTilesetCtx = collisionTilesetCanvas.getContext('2d');
        const paintTilesetCanvas = document.getElementById('paintTilesetCanvas');
        const paintTilesetCtx = paintTilesetCanvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        const propTilesetCanvas = document.getElementById('propTilesetCanvas');
        const propTilesetCtx = propTilesetCanvas ? propTilesetCanvas.getContext('2d') : null;

        // ===== PROP TOOLS =====
        function setPropTool(tool) {
            propTool = tool;
            document.getElementById('propToolSelect').classList.remove('active');
            document.getElementById('propToolCollision').classList.remove('active');
            document.getElementById('propToolErase').classList.remove('active');
            document.getElementById('propTool' + tool.charAt(0).toUpperCase() + tool.slice(1)).classList.add('active');

            // Show/hide brush controls
            document.getElementById('propBrushControls').style.display =
                (tool === 'collision' || tool === 'erase') ? 'block' : 'none';

            // Update cursor
            if (propTilesetCanvas) propTilesetCanvas.style.cursor = (tool === 'select') ? 'crosshair' : 'cell';

            drawPropTileset();
        }

        function setPropBrushSize(size) {
            propBrushSize = size;
            document.querySelectorAll('[id^="propBrush"]').forEach(b => b.classList.remove('active'));
            document.getElementById('propBrush' + size).classList.add('active');
        }

        // ===== PHASE MANAGEMENT =====
        let keepLoadPhaseVisible = false; // Flag to keep loading screen visible during adventure mode
        function setPhase(phase) {
            currentPhase = phase;
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('active'));
            document.getElementById(phase + 'Phase').classList.add('active');
            // Keep loadPhase visible if flag is set (adventure mode loading)
            if (keepLoadPhaseVisible) {
                document.getElementById('loadPhase').classList.add('active');
            }

            // Start/stop editor animation loop based on phase
            if (phase === 'build') {
                startEditorAnimLoop();
            } else {
                stopEditorAnimLoop();
            }
        }

        // Animation loop for animated props in the editor
        function startEditorAnimLoop() {
            if (editorAnimInterval) return;
            editorAnimInterval = setInterval(() => {
                let needsRender = false;

                // Scan all layers for animTile cells
                for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {
                    const layer = layers[layerIdx];
                    if (!layer) continue;

                    for (let y = 0; y < layer.length; y++) {
                        if (!layer[y]) continue;
                        for (let x = 0; x < layer[y].length; x++) {
                            const cell = layer[y][x];
                            if (!cell || cell.type !== 'animTile') continue;

                            const prop = animatedProps[cell.propIndex];
                            if (!prop || !prop.frames || prop.frames.length <= 1) continue;
                            if (prop.type !== 'loop') continue;

                            const key = x + ',' + y + ',' + layerIdx;
                            if (!placedAnimPropFrames[key]) {
                                placedAnimPropFrames[key] = { frame: 0, timer: 0, waiting: false, waitTimer: 0, playCount: 0 };
                            }
                            const state = placedAnimPropFrames[key];
                            const instanceSpeed = cell.instanceSpeed || 1;
                            const fps = (prop.fps || 8) * instanceSpeed;
                            const frameDelay = Math.round(60 / fps);
                            // Use instance settings if set, otherwise fall back to prop defaults
                            const playMode = cell.instancePlayMode || prop.playMode || 'loop';
                            const waitTime = ((cell.instanceWaitTime !== undefined ? cell.instanceWaitTime : prop.waitTime) || 2) * 60;
                            const targetPlayCount = cell.instancePlayCount || 1;

                            // Handle timed mode - wait between animation cycles
                            if (playMode === 'timed' && state.waiting) {
                                state.waitTimer++;
                                if (state.waitTimer >= waitTime) {
                                    state.waiting = false;
                                    state.waitTimer = 0;
                                    state.frame = 0;
                                    state.playCount = 0;
                                }
                                continue;
                            }

                            state.timer++;
                            if (state.timer >= frameDelay) {
                                state.timer = 0;
                                state.frame++;

                                // Handle end of animation
                                if (state.frame >= prop.frames.length) {
                                    if (playMode === 'loop') {
                                        state.frame = 0; // Loop forever
                                    } else if (playMode === 'timed') {
                                        state.playCount++;
                                        if (state.playCount >= targetPlayCount) {
                                            // Played enough times, now wait
                                            state.frame = 0;
                                            state.waiting = true;
                                            state.waitTimer = 0;
                                        } else {
                                            state.frame = 0; // Play again
                                        }
                                    } else {
                                        state.frame = 0; // Default: loop
                                    }
                                }
                                needsRender = true;
                            }
                        }
                    }
                }

                if (needsRender) renderMap();
            }, 1000 / 60); // 60fps update
        }

        function stopEditorAnimLoop() {
            if (editorAnimInterval) {
                clearInterval(editorAnimInterval);
                editorAnimInterval = null;
            }
        }

        // ===== LOAD PHASE =====
        function loadTileset(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Add as first tileset
                    tilesets = [{ name: file.name, img: img, data: e.target.result }];
                    currentTilesetIndex = 0;
                    tilesetImg = img;
                    updateTilesetDropdown();
                    setPhase('collision');
                    rebuildCollisionView();
                    // Broadcast to other builders
                    broadcastEdit({ editType: 'addTileset', name: file.name, data: e.target.result });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function addTileset(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    tilesets.push({ name: file.name, img: img, data: e.target.result });
                    currentTilesetIndex = tilesets.length - 1;
                    tilesetImg = img;
                    updateTilesetDropdown();
                    drawPaintTileset();
                    drawPropTileset();
                    // Broadcast to other builders
                    broadcastEdit({ editType: 'addTileset', name: file.name, data: e.target.result });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = ''; // Reset input so same file can be selected again
        }

        function switchTileset() {
            // Legacy function - now handled by selectTilesetFromPicker
            if (tilesets[currentTilesetIndex]) {
                tilesetImg = tilesets[currentTilesetIndex].img;
            }
            selectedTileData = null;
            selectedTiles = [];
            drawPaintTileset();
            drawPropTileset();
            renderMap();
        }

        function updateTilesetDropdown() {
            // Update the picker button with current tileset
            const thumb = document.getElementById('tilesetPickerThumb');
            const name = document.getElementById('tilesetPickerName');
            const dropdownList = document.getElementById('tilesetDropdownList');
            const sortBtn = document.getElementById('tilesetSortBtn');

            if (!thumb || !name || !dropdownList) return;

            if (tilesets.length > 0 && tilesets[currentTilesetIndex]) {
                const ts = tilesets[currentTilesetIndex];
                thumb.src = ts.data || '';
                thumb.style.display = ts.data ? 'block' : 'none';
                name.textContent = ts.name || 'Untitled';
            } else {
                thumb.src = '';
                thumb.style.display = 'none';
                name.textContent = 'No tileset';
            }

            // Update sort button text
            if (sortBtn) {
                sortBtn.textContent = tilesetSortOrder === 'alpha' ? 'A-Z' : '1-2-3';
                sortBtn.title = tilesetSortOrder === 'alpha' ? 'Sorted alphabetically (click for order added)' : 'Sorted by order added (click for alphabetical)';
            }

            // Create array with original indices
            let tilesetsWithIndex = tilesets.map((ts, i) => ({ ts, originalIndex: i }));

            // Filter by search term
            if (tilesetSearchTerm) {
                const term = tilesetSearchTerm.toLowerCase();
                tilesetsWithIndex = tilesetsWithIndex.filter(item =>
                    (item.ts.name || '').toLowerCase().includes(term)
                );
            }

            // Sort by order
            if (tilesetSortOrder === 'alpha') {
                tilesetsWithIndex.sort((a, b) =>
                    (a.ts.name || '').localeCompare(b.ts.name || '')
                );
            }

            // Build dropdown items
            dropdownList.innerHTML = '';
            tilesetsWithIndex.forEach(({ ts, originalIndex }) => {
                const item = document.createElement('div');
                item.className = 'tileset-picker-item' + (originalIndex === currentTilesetIndex ? ' selected' : '');
                item.onclick = () => selectTilesetFromPicker(originalIndex);

                const itemThumb = document.createElement('img');
                itemThumb.className = 'thumb';
                itemThumb.src = ts.data || '';

                const info = document.createElement('div');
                info.className = 'info';

                const itemName = document.createElement('div');
                itemName.className = 'name';
                itemName.textContent = ts.name || 'Untitled';

                const size = document.createElement('div');
                size.className = 'size';
                if (ts.img) {
                    size.textContent = ts.img.width + ' x ' + ts.img.height + ' px';
                }

                info.appendChild(itemName);
                info.appendChild(size);
                item.appendChild(itemThumb);
                item.appendChild(info);
                dropdownList.appendChild(item);
            });

            if (tilesetsWithIndex.length === 0 && tilesetSearchTerm) {
                dropdownList.innerHTML = '<div style="padding:10px; color:#888; text-align:center; font-size:11px;">No matching tilesets</div>';
            }
        }

        function filterTilesets(term) {
            tilesetSearchTerm = term;
            updateTilesetDropdown();
        }

        function toggleTilesetSort() {
            tilesetSortOrder = tilesetSortOrder === 'added' ? 'alpha' : 'added';
            updateTilesetDropdown();
        }

        function toggleTilesetPicker() {
            const dropdown = document.getElementById('tilesetPickerDropdown');
            if (dropdown) {
                dropdown.classList.toggle('open');
            }
        }

        function selectTilesetFromPicker(index) {
            currentTilesetIndex = index;
            tilesetImg = tilesets[currentTilesetIndex].img;
            selectedTileData = null;
            selectedTiles = [];

            // Close dropdown
            const dropdown = document.getElementById('tilesetPickerDropdown');
            if (dropdown) dropdown.classList.remove('open');

            // Update UI
            updateTilesetDropdown();
            drawPaintTileset();
            drawPropTileset();
            renderMap();
        }

        // Close tileset picker when clicking outside
        document.addEventListener('click', function(e) {
            const picker = document.getElementById('tilesetPicker');
            const dropdown = document.getElementById('tilesetPickerDropdown');
            if (picker && dropdown && !picker.contains(e.target)) {
                dropdown.classList.remove('open');
            }
        });

        function deleteTileset(fromNetwork = false, networkTilesetIndex = null) {
            const tilesetIndexToDelete = fromNetwork ? networkTilesetIndex : currentTilesetIndex;

            if (tilesets.length === 0) {
                if (!fromNetwork) alert('No tileset to delete');
                return;
            }
            if (tilesets.length === 1) {
                if (!fromNetwork) alert('Cannot delete the only tileset. Add another one first.');
                return;
            }

            const tileset = tilesets[tilesetIndexToDelete];
            if (!fromNetwork && !confirm('Delete tileset "' + tileset.name + '"?\n\nTiles from this tileset on the map will become empty.')) return;

            // Remove tiles from map that use this tileset
            layers.forEach(layer => {
                for (let y = 0; y < layer.length; y++) {
                    for (let x = 0; x < layer[y].length; x++) {
                        const tile = layer[y][x];
                        if (tile && tile.tilesetIndex === tilesetIndexToDelete) {
                            layer[y][x] = null;
                        } else if (tile && tile.tilesetIndex > tilesetIndexToDelete) {
                            // Adjust indices for tilesets after the deleted one
                            tile.tilesetIndex--;
                        }
                    }
                }
            });

            // Remove collision data for this tileset
            const keysToDelete = [];
            for (const key in tileCollisions) {
                const [tsIdx] = key.split(':');
                if (parseInt(tsIdx) === tilesetIndexToDelete) {
                    keysToDelete.push(key);
                }
            }
            keysToDelete.forEach(key => delete tileCollisions[key]);

            // Update collision keys for tilesets after deleted one
            const updatedCollisions = {};
            for (const key in tileCollisions) {
                const [tsIdx, coords] = key.split(':');
                const idx = parseInt(tsIdx);
                if (idx > tilesetIndexToDelete) {
                    updatedCollisions[(idx - 1) + ':' + coords] = tileCollisions[key];
                } else {
                    updatedCollisions[key] = tileCollisions[key];
                }
            }
            tileCollisions = updatedCollisions;

            // Broadcast before modifying tilesets array (need to send original index)
            if (!fromNetwork) {
                broadcastEdit({ editType: 'deleteTileset', index: tilesetIndexToDelete });
            }

            // Remove the tileset
            tilesets.splice(tilesetIndexToDelete, 1);

            // Update current index
            if (currentTilesetIndex >= tilesets.length) {
                currentTilesetIndex = tilesets.length - 1;
            }
            if (tilesets.length > 0) {
                tilesetImg = tilesets[currentTilesetIndex].img;
            }

            // Update UI
            updateTilesetDropdown();
            selectedTileData = null;
            selectedTiles = [];
            drawPaintTileset();
            renderMap();
        }

        // ===== PLAYER SPRITE =====
        function loadPlayerSprite(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                playerSpriteData = e.target.result;
                playerSpriteImg = new Image();
                playerSpriteImg.onload = () => {
                    // Update preview
                    const preview = document.getElementById('playerSpritePreview');
                    const ctx = preview.getContext('2d');
                    ctx.clearRect(0, 0, 48, 48);
                    ctx.imageSmoothingEnabled = false;
                    // Draw first frame (assuming 64x64 frames, top-left)
                    ctx.drawImage(playerSpriteImg, 0, 0, 64, 64, 0, 0, 48, 48);
                    document.getElementById('playerSpriteInfo').textContent =
                        file.name + ' (' + playerSpriteImg.naturalWidth + 'x' + playerSpriteImg.naturalHeight + ')';
                };
                playerSpriteImg.src = playerSpriteData;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function updatePlayerSpritePreview() {
            const preview = document.getElementById('playerSpritePreview');
            if (!preview) return;
            const ctx = preview.getContext('2d');
            ctx.clearRect(0, 0, 48, 48);

            if (playerSpriteImg && playerSpriteImg.complete && playerSpriteImg.naturalWidth > 0) {
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(playerSpriteImg, 0, 0, 64, 64, 0, 0, 48, 48);
            }
        }

        // ===== COLLISION PHASE =====
        function rebuildCollisionView() {
            gridSize = parseInt(document.getElementById('gridSize').value);
            drawCollisionTileset();
            updateCollisionStats();
        }

        function drawCollisionTileset() {
            if (!tilesetImg) return;

            collisionTilesetCanvas.width = tilesetImg.naturalWidth * collisionZoom;
            collisionTilesetCanvas.height = tilesetImg.naturalHeight * collisionZoom;

            collisionTilesetCtx.imageSmoothingEnabled = false;
            collisionTilesetCtx.drawImage(tilesetImg, 0, 0, collisionTilesetCanvas.width, collisionTilesetCanvas.height);

            // Grid
            collisionTilesetCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            const cols = Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = Math.floor(tilesetImg.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(x * gridSize * collisionZoom, 0);
                collisionTilesetCtx.lineTo(x * gridSize * collisionZoom, collisionTilesetCanvas.height);
                collisionTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(0, y * gridSize * collisionZoom);
                collisionTilesetCtx.lineTo(collisionTilesetCanvas.width, y * gridSize * collisionZoom);
                collisionTilesetCtx.stroke();
            }

            // Draw pixel collision masks (only for current tileset)
            collisionTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            const keyPrefix = currentTilesetIndex + ':';
            for (let key in collisionMasks) {
                // Only show collisions for current tileset
                if (!key.startsWith(keyPrefix)) continue;

                const mask = collisionMasks[key];
                if (!mask) continue;

                // Parse key format: "tilesetIndex:x,y"
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                for (let py = 0; py < gridSize; py++) {
                    for (let px = 0; px < gridSize; px++) {
                        if (mask[py] && mask[py][px]) {
                            collisionTilesetCtx.fillRect(
                                (tx + px) * collisionZoom,
                                (ty + py) * collisionZoom,
                                collisionZoom,
                                collisionZoom
                            );
                        }
                    }
                }
            }

            // Draw depth split lines (cyan freeform lines)
            collisionTilesetCtx.strokeStyle = '#0ff';
            collisionTilesetCtx.lineWidth = 2;
            for (let key in tileSplitLines) {
                if (!key.startsWith(keyPrefix)) continue;

                const splitYArray = tileSplitLines[key];
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                // Draw freeform line connecting all column Y values
                collisionTilesetCtx.beginPath();
                for (let col = 0; col < gridSize; col++) {
                    const splitY = Array.isArray(splitYArray) ? splitYArray[col] : splitYArray;
                    const lineX = (tx + col + 0.5) * collisionZoom;
                    const lineY = (ty + splitY) * collisionZoom;
                    if (col === 0) {
                        collisionTilesetCtx.moveTo(lineX, lineY);
                    } else {
                        collisionTilesetCtx.lineTo(lineX, lineY);
                    }
                }
                collisionTilesetCtx.stroke();

                // Fill canopy region with semi-transparent cyan
                collisionTilesetCtx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(tx * collisionZoom, ty * collisionZoom);
                for (let col = 0; col < gridSize; col++) {
                    const splitY = Array.isArray(splitYArray) ? splitYArray[col] : splitYArray;
                    const lineX = (tx + col + 0.5) * collisionZoom;
                    const lineY = (ty + splitY) * collisionZoom;
                    collisionTilesetCtx.lineTo(lineX, lineY);
                }
                collisionTilesetCtx.lineTo((tx + gridSize) * collisionZoom, ty * collisionZoom);
                collisionTilesetCtx.closePath();
                collisionTilesetCtx.fill();

                // Draw "C" for canopy and "T" for trunk (swap if flipped)
                const avgSplitY = Array.isArray(splitYArray)
                    ? splitYArray.reduce((a, b) => a + b, 0) / splitYArray.length
                    : splitYArray;
                const isFlipped = tileSplitLineFlipped[key];
                collisionTilesetCtx.fillStyle = isFlipped ? '#fa0' : '#0ff';
                collisionTilesetCtx.font = (collisionZoom * 2) + 'px sans-serif';
                collisionTilesetCtx.textAlign = 'center';
                // Top label position
                const topY = (ty + avgSplitY / 2) * collisionZoom;
                // Bottom label position
                const bottomY = (ty + avgSplitY + (gridSize - avgSplitY) / 2) * collisionZoom;
                const centerX = tx * collisionZoom + gridSize * collisionZoom / 2;
                if (isFlipped) {
                    // Flipped: T on top (Y-sorted), C on bottom (covers player)
                    collisionTilesetCtx.fillText('T', centerX, topY);
                    collisionTilesetCtx.fillText('C', centerX, bottomY);
                } else {
                    // Normal: C on top (covers player), T on bottom (Y-sorted)
                    collisionTilesetCtx.fillText('C', centerX, topY);
                    collisionTilesetCtx.fillText('T', centerX, bottomY);
                }
            }

            // Highlight selected split tile
            if (selectedSplitTile && collisionTool === 'split') {
                collisionTilesetCtx.strokeStyle = '#ff0';
                collisionTilesetCtx.lineWidth = 3;
                collisionTilesetCtx.strokeRect(
                    selectedSplitTile.x * collisionZoom,
                    selectedSplitTile.y * collisionZoom,
                    gridSize * collisionZoom,
                    gridSize * collisionZoom
                );
            }

            // Draw cyan brush preview
            if (brushPreviewPos && (collisionTool === 'paint' || collisionTool === 'erase')) {
                const bx = brushPreviewPos.x;
                const by = brushPreviewPos.y;
                collisionTilesetCtx.strokeStyle = collisionTool === 'erase' ? '#ff0' : '#0ff';
                collisionTilesetCtx.lineWidth = 2;
                collisionTilesetCtx.setLineDash([4, 4]);

                if (brushShape === 'square') {
                    const half = Math.floor(brushSize / 2);
                    collisionTilesetCtx.strokeRect(
                        (bx - half) * collisionZoom,
                        (by - half) * collisionZoom,
                        brushSize * collisionZoom,
                        brushSize * collisionZoom
                    );
                } else if (brushShape === 'circle') {
                    const radius = (brushSize / 2) * collisionZoom;
                    collisionTilesetCtx.beginPath();
                    collisionTilesetCtx.arc(bx * collisionZoom, by * collisionZoom, radius, 0, Math.PI * 2);
                    collisionTilesetCtx.stroke();
                } else if (brushShape === 'rect') {
                    const halfW = Math.floor(brushRectW / 2);
                    const halfH = Math.floor(brushRectH / 2);
                    collisionTilesetCtx.strokeRect(
                        (bx - halfW) * collisionZoom,
                        (by - halfH) * collisionZoom,
                        brushRectW * collisionZoom,
                        brushRectH * collisionZoom
                    );
                }

                collisionTilesetCtx.setLineDash([]);
            }
        }

        function setCollisionZoom(z) {
            collisionZoom = z;
            document.querySelectorAll('[id^="collisionZoom"]').forEach(b => b.classList.remove('active'));
            const btn = document.querySelector(`[onclick="setCollisionZoom(${z})"]`);
            if (btn) btn.classList.add('active');
            drawCollisionTileset();
        }

        function setCollisionTool(tool) {
            collisionTool = tool;
            document.getElementById('collisionToolPaint').classList.toggle('active', tool === 'paint');
            document.getElementById('collisionToolErase').classList.toggle('active', tool === 'erase');
            document.getElementById('collisionToolSplit').classList.toggle('active', tool === 'split');

            // Show/hide split controls
            document.getElementById('splitControls').style.display = tool === 'split' ? 'block' : 'none';

            // Update cursor based on tool
            if (tool === 'split') {
                collisionTilesetCanvas.style.cursor = 'pointer';
            } else if (tool === 'erase') {
                collisionTilesetCanvas.style.cursor = 'not-allowed';
            } else {
                collisionTilesetCanvas.style.cursor = 'crosshair';
            }

            // Clear split selection when switching away
            if (tool !== 'split') {
                selectedSplitTile = null;
            }

            drawCollisionTileset();
        }

        function setBrushSize(size) {
            brushSize = size;
            document.querySelectorAll('[id^="brush"]').forEach(b => b.classList.remove('active'));
            document.getElementById('brush' + size).classList.add('active');
            drawCollisionTileset();
        }

        function setBrushShape(shape) {
            brushShape = shape;
            document.getElementById('brushShapeSquare').classList.remove('active');
            document.getElementById('brushShapeCircle').classList.remove('active');
            document.getElementById('brushShapeRect').classList.remove('active');
            document.getElementById('brushShape' + shape.charAt(0).toUpperCase() + shape.slice(1)).classList.add('active');
            document.getElementById('brushRectControls').style.display = shape === 'rect' ? 'block' : 'none';
            drawCollisionTileset();
        }

        function updateBrushRect() {
            brushRectW = parseInt(document.getElementById('brushRectW').value) || 8;
            brushRectH = parseInt(document.getElementById('brushRectH').value) || 4;
            drawCollisionTileset();
        }

        function updateCollisionStats() {
            // Only count collisions for current tileset
            const keyPrefix = currentTilesetIndex + ':';
            const count = Object.keys(tileCollisions).filter(k => k.startsWith(keyPrefix) && tileCollisions[k]).length;
            document.getElementById('collisionStats').textContent = count + ' tiles with collision (tileset ' + currentTilesetIndex + ')';
        }

        function selectAllCollision(fromNetwork = false) {
            if (!tilesetImg && !fromNetwork) return;
            const cols = fromNetwork ? 100 : Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = fromNetwork ? 100 : Math.floor(tilesetImg.naturalHeight / gridSize);
            const tilesetIdx = fromNetwork ? arguments[1] : currentTilesetIndex;

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const tileX = col * gridSize;
                    const tileY = row * gridSize;
                    const key = tilesetIdx + ':' + tileX + ',' + tileY;
                    tileCollisions[key] = true;
                }
            }

            if (!fromNetwork) {
                broadcastEdit({ editType: 'selectAllCollision', tilesetIndex: currentTilesetIndex });
            }
            drawCollisionTileset();
            updateCollisionStats();
        }

        function clearAllCollision(fromNetwork = false, tilesetIdx = null) {
            if (!fromNetwork && !confirm('Clear all collision for current tileset?')) return;
            const keyPrefix = (fromNetwork ? tilesetIdx : currentTilesetIndex) + ':';
            for (let key in tileCollisions) {
                if (key.startsWith(keyPrefix)) {
                    delete tileCollisions[key];
                }
            }
            for (let key in collisionMasks) {
                if (key.startsWith(keyPrefix)) {
                    delete collisionMasks[key];
                }
            }
            if (!fromNetwork) {
                broadcastEdit({ editType: 'clearAllCollision', tilesetIndex: currentTilesetIndex });
            }
            drawCollisionTileset();
            updateCollisionStats();
        }

        // Collision canvas mouse events - pixel brush painting + pan
        collisionTilesetCanvas.addEventListener('mousedown', (e) => {
            e.preventDefault();

            // Middle mouse or shift+left = pan
            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                isPanning = true;
                panStartX = e.clientX + collisionPanX;
                panStartY = e.clientY + collisionPanY;
                collisionTilesetCanvas.style.cursor = 'grabbing';
                return;
            }

            // Handle split tool mode
            if (collisionTool === 'split' && e.button === 0) {
                handleSplitClick(e);
                return;
            }

            if (e.button === 0) {
                brushPainting = true;
                paintCollisionAt(e, collisionTool === 'paint');
            } else if (e.button === 2) {
                brushErasing = true;
                paintCollisionAt(e, false);
            }
        });

        collisionTilesetCanvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                collisionPanX = panStartX - e.clientX;
                collisionPanY = panStartY - e.clientY;
                updateCollisionScroll();
                return;
            }

            // Handle dragging split line
            if (draggingSplitLine && selectedSplitTile) {
                handleSplitDrag(e);
                return;
            }

            if (brushPainting) paintCollisionAt(e, collisionTool === 'paint');
            if (brushErasing) paintCollisionAt(e, false);

            // Update brush preview position
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);
            brushPreviewPos = { x: px, y: py };
            if (!brushPainting && !brushErasing && collisionTool !== 'split') {
                drawCollisionTileset();
            }
        });

        collisionTilesetCanvas.addEventListener('mouseleave', () => {
            brushPreviewPos = null;
            drawCollisionTileset();
        });

        collisionTilesetCanvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                collisionTilesetCanvas.style.cursor = collisionTool === 'split' ? 'pointer' : 'crosshair';
            }
            // Sync split line on drag end
            if (draggingSplitLine && modifiedSplitKey && tileSplitLines[modifiedSplitKey]) {
                console.log('[SYNC] Broadcasting splitLine:', modifiedSplitKey, 'line:', tileSplitLines[modifiedSplitKey]);
                broadcastEdit({ editType: 'splitLine', key: modifiedSplitKey, mask: tileSplitLines[modifiedSplitKey] });
                modifiedSplitKey = null;
            }
            draggingSplitLine = false;
            // Sync modified collision data
            if ((brushPainting || brushErasing) && modifiedCollisionKeys.size > 0) {
                syncModifiedCollisions();
            }
            brushPainting = false;
            brushErasing = false;
        });

        collisionTilesetCanvas.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                collisionTilesetCanvas.style.cursor = 'crosshair';
            }
            // Sync modified collision data
            if ((brushPainting || brushErasing) && modifiedCollisionKeys.size > 0) {
                syncModifiedCollisions();
            }
            brushPainting = false;
            brushErasing = false;
        });

        function syncModifiedCollisions() {
            // Send collision updates to other builders
            modifiedCollisionKeys.forEach(key => {
                if (tileCollisions[key]) {
                    broadcastEdit({ editType: 'collision', key: key, value: true });
                    if (collisionMasks[key]) {
                        broadcastEdit({ editType: 'collisionMask', key: key, mask: collisionMasks[key] });
                    }
                } else {
                    broadcastEdit({ editType: 'collision', key: key, value: false });
                }
            });
            modifiedCollisionKeys.clear();
        }

        collisionTilesetCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Touch support for collision canvas (mobile/iPad)
        collisionTilesetCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling while drawing
            const touch = e.touches[0];

            // Handle split tool mode
            if (collisionTool === 'split') {
                handleSplitClickTouch(touch);
                return;
            }

            // Start painting collision
            brushPainting = true;
            paintCollisionAtTouch(touch, collisionTool === 'paint');
        }, { passive: false });

        collisionTilesetCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling while drawing
            const touch = e.touches[0];

            // Handle dragging split line
            if (draggingSplitLine && selectedSplitTile) {
                handleSplitDragTouch(touch);
                return;
            }

            if (brushPainting) paintCollisionAtTouch(touch, collisionTool === 'paint');
        }, { passive: false });

        collisionTilesetCanvas.addEventListener('touchend', () => {
            // Sync split line on drag end
            if (draggingSplitLine && modifiedSplitKey && tileSplitLines[modifiedSplitKey]) {
                console.log('[SYNC] Broadcasting splitLine:', modifiedSplitKey, 'line:', tileSplitLines[modifiedSplitKey]);
                broadcastEdit({ editType: 'splitLine', key: modifiedSplitKey, mask: tileSplitLines[modifiedSplitKey] });
                modifiedSplitKey = null;
            }
            draggingSplitLine = false;
            if ((brushPainting || brushErasing) && modifiedCollisionKeys.size > 0) {
                syncModifiedCollisions();
            }
            brushPainting = false;
            brushErasing = false;
        });

        collisionTilesetCanvas.addEventListener('touchcancel', () => {
            // Sync split line on drag end
            if (draggingSplitLine && modifiedSplitKey && tileSplitLines[modifiedSplitKey]) {
                console.log('[SYNC] Broadcasting splitLine:', modifiedSplitKey, 'line:', tileSplitLines[modifiedSplitKey]);
                broadcastEdit({ editType: 'splitLine', key: modifiedSplitKey, mask: tileSplitLines[modifiedSplitKey] });
                modifiedSplitKey = null;
            }
            draggingSplitLine = false;
            if ((brushPainting || brushErasing) && modifiedCollisionKeys.size > 0) {
                syncModifiedCollisions();
            }
            brushPainting = false;
            brushErasing = false;
        });

        // Touch versions of paint/split functions
        function paintCollisionAtTouch(touch, addCollision) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((touch.clientX - rect.left) / collisionZoom);
            const py = Math.floor((touch.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;
            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;

            if (!collisionMasks[key]) {
                collisionMasks[key] = Array(gridSize).fill(null).map(() => Array(gridSize).fill(false));
            }

            const localX = px - tileX;
            const localY = py - tileY;
            const halfBrush = Math.floor(brushSize / 2);

            for (let by = -halfBrush; by <= halfBrush; by++) {
                for (let bx = -halfBrush; bx <= halfBrush; bx++) {
                    const targetX = localX + bx;
                    const targetY = localY + by;
                    if (targetX >= 0 && targetX < gridSize && targetY >= 0 && targetY < gridSize) {
                        collisionMasks[key][targetY][targetX] = addCollision;
                    }
                }
            }

            // Update tileCollisions
            let hasCollision = false;
            for (let y = 0; y < gridSize && !hasCollision; y++) {
                for (let x = 0; x < gridSize && !hasCollision; x++) {
                    if (collisionMasks[key][y][x]) hasCollision = true;
                }
            }
            if (hasCollision) {
                tileCollisions[key] = true;
            } else {
                delete tileCollisions[key];
                delete collisionMasks[key];
            }

            // Track for sync
            modifiedCollisionKeys.add(key);

            drawCollisionTileset();
            updateCollisionStats();
        }

        function handleSplitClickTouch(touch) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((touch.clientX - rect.left) / collisionZoom);
            const py = Math.floor((touch.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;

            selectedSplitTile = { x: tileX, y: tileY, tilesetIndex: currentTilesetIndex };
            draggingSplitLine = true;

            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;
            modifiedSplitKey = key; // Track for sync

            // Update flip checkbox to reflect this tile's state
            const isFlipped = tileSplitLineFlipped[key] || false;
            document.getElementById('splitFlipToggle').checked = isFlipped;
            updateSplitHelpText(isFlipped);

            const localY = py - tileY;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            if (flatLineMode) {
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                document.getElementById('splitYInput').value = clampedY;
            } else {
                if (!tileSplitLines[key]) {
                    const defaultY = parseInt(document.getElementById('splitYInput').value) || Math.floor(gridSize / 2);
                    tileSplitLines[key] = new Array(gridSize).fill(defaultY);
                }
                const localX = px - tileX;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            document.getElementById('splitYInput').max = gridSize;
            drawCollisionTileset();
        }

        function handleSplitDragTouch(touch) {
            if (!selectedSplitTile || !draggingSplitLine) return;

            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((touch.clientX - rect.left) / collisionZoom);
            const py = Math.floor((touch.clientY - rect.top) / collisionZoom);

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            if (!tileSplitLines[key]) return;

            const localY = py - selectedSplitTile.y;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            if (flatLineMode) {
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                document.getElementById('splitYInput').value = clampedY;
            } else {
                const localX = px - selectedSplitTile.x;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            // Update modifiedSplitKey to ensure it stays in sync
            modifiedSplitKey = key;

            drawCollisionTileset();
        }

        // Paint collision pixels with brush
        function paintCollisionAt(e, addCollision) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            // Find which tile this pixel is in
            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;
            // Include tileset index in key so each tileset has separate collisions
            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;

            // Get or create mask for this tile
            if (!collisionMasks[key]) {
                collisionMasks[key] = [];
                for (let y = 0; y < gridSize; y++) {
                    collisionMasks[key][y] = new Array(gridSize).fill(false);
                }
            }
            const mask = collisionMasks[key];

            // Paint pixels with brush based on shape
            const half = Math.floor(brushSize / 2);
            const localX = px - tileX;
            const localY = py - tileY;

            if (brushShape === 'square') {
                for (let dy = -half; dy < half; dy++) {
                    for (let dx = -half; dx < half; dx++) {
                        const mx = localX + dx;
                        const my = localY + dy;
                        if (mx >= 0 && mx < gridSize && my >= 0 && my < gridSize) {
                            mask[my][mx] = addCollision;
                        }
                    }
                }
            } else if (brushShape === 'circle') {
                const radius = brushSize / 2;
                const radiusSq = radius * radius;
                for (let dy = -Math.ceil(radius); dy <= Math.ceil(radius); dy++) {
                    for (let dx = -Math.ceil(radius); dx <= Math.ceil(radius); dx++) {
                        if (dx * dx + dy * dy <= radiusSq) {
                            const mx = localX + dx;
                            const my = localY + dy;
                            if (mx >= 0 && mx < gridSize && my >= 0 && my < gridSize) {
                                mask[my][mx] = addCollision;
                            }
                        }
                    }
                }
            } else if (brushShape === 'rect') {
                const halfW = Math.floor(brushRectW / 2);
                const halfH = Math.floor(brushRectH / 2);
                for (let dy = -halfH; dy < halfH; dy++) {
                    for (let dx = -halfW; dx < halfW; dx++) {
                        const mx = localX + dx;
                        const my = localY + dy;
                        if (mx >= 0 && mx < gridSize && my >= 0 && my < gridSize) {
                            mask[my][mx] = addCollision;
                        }
                    }
                }
            }

            // Update tileCollisions (true if any pixel is set)
            let hasCollision = false;
            for (let y = 0; y < gridSize && !hasCollision; y++) {
                for (let x = 0; x < gridSize && !hasCollision; x++) {
                    if (mask[y][x]) hasCollision = true;
                }
            }
            if (hasCollision) {
                tileCollisions[key] = true;
            } else {
                delete tileCollisions[key];
                delete collisionMasks[key];
            }

            // Track for sync on mouseup
            modifiedCollisionKeys.add(key);

            drawCollisionTileset();
            updateCollisionStats();
        }

        // ===== DEPTH SPLIT FUNCTIONS =====
        // tileSplitLines stores an array of Y values per column for freeform lines
        // Format: "tilesetIndex:x,y" -> [y0, y1, y2, ..., y15] (one Y per column)

        function toggleFlatLineMode() {
            flatLineMode = document.getElementById('flatLineToggle').checked;
        }

        function toggleSplitFlip() {
            if (!selectedSplitTile) return;
            const key = selectedSplitTile.tilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            const isFlipped = document.getElementById('splitFlipToggle').checked;
            if (isFlipped) {
                tileSplitLineFlipped[key] = true;
            } else {
                delete tileSplitLineFlipped[key];
            }
            // Update help text
            updateSplitHelpText(isFlipped);
            // Broadcast the change
            broadcastEdit({ editType: 'splitLineFlip', key: key, flipped: isFlipped });
            drawCollisionTileset();
        }

        function updateSplitHelpText(isFlipped) {
            const helpText = document.getElementById('splitHelpText');
            if (helpText) {
                if (isFlipped) {
                    helpText.textContent = 'T = Trunk (top, Y-sorted) | C = Canopy (bottom, covers player)';
                    helpText.style.color = '#fa0';
                } else {
                    helpText.textContent = 'C = Canopy (top, covers player) | T = Trunk (bottom, Y-sorted)';
                    helpText.style.color = '#888';
                }
            }
        }

        function handleSplitClick(e) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            // Find which tile was clicked
            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;

            // Select this tile for splitting
            selectedSplitTile = { x: tileX, y: tileY, tilesetIndex: currentTilesetIndex };
            draggingSplitLine = true;

            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;
            modifiedSplitKey = key; // Track for sync

            // Update flip checkbox to reflect this tile's state
            const isFlipped = tileSplitLineFlipped[key] || false;
            document.getElementById('splitFlipToggle').checked = isFlipped;
            updateSplitHelpText(isFlipped);

            // Calculate local Y position within the tile
            const localY = py - tileY;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            // Initialize or set split line
            if (flatLineMode) {
                // Flat line mode: set entire line to clicked Y
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                // Update the Y input to show current value
                document.getElementById('splitYInput').value = clampedY;
            } else {
                // Freeform mode: initialize if doesn't exist, then set clicked column
                if (!tileSplitLines[key]) {
                    const defaultY = parseInt(document.getElementById('splitYInput').value) || Math.floor(gridSize / 2);
                    tileSplitLines[key] = new Array(gridSize).fill(defaultY);
                }
                const localX = px - tileX;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            // Update UI
            document.getElementById('splitYInput').max = gridSize;

            drawCollisionTileset();
        }

        function handleSplitDrag(e) {
            if (!selectedSplitTile || !draggingSplitLine) return;

            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            if (!tileSplitLines[key]) return;

            // Calculate local position within the tile
            const localY = py - selectedSplitTile.y;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            if (flatLineMode) {
                // Flat line mode: set entire line to current Y
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                document.getElementById('splitYInput').value = clampedY;
            } else {
                // Freeform mode: set only this column
                const localX = px - selectedSplitTile.x;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            // Update modifiedSplitKey to ensure it stays in sync
            modifiedSplitKey = key;

            drawCollisionTileset();
        }

        function setSplitLineY() {
            // Set a flat horizontal line at the specified Y
            if (!selectedSplitTile) {
                alert('Click a tile first to select it');
                return;
            }

            const splitY = parseInt(document.getElementById('splitYInput').value) || Math.floor(gridSize / 2);
            const clampedY = Math.max(0, Math.min(gridSize, splitY));

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            tileSplitLines[key] = new Array(gridSize).fill(clampedY);
            broadcastEdit({ editType: 'splitLine', key: key, mask: tileSplitLines[key] });

            drawCollisionTileset();
        }

        function clearSelectedSplit() {
            if (!selectedSplitTile) return;

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            delete tileSplitLines[key];
            delete tileSplitLineFlipped[key];
            broadcastEdit({ editType: 'clearSplitLine', key: key });
            selectedSplitTile = null;
            // Reset flip checkbox
            document.getElementById('splitFlipToggle').checked = false;
            updateSplitHelpText(false);

            drawCollisionTileset();
        }

        // Keyboard controls for build phase
        document.addEventListener('keydown', (e) => {
            // Ignore shortcuts when typing in input fields
            const tag = e.target.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || e.target.isContentEditable) return;

            if (currentPhase === 'build') {
                if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    rotateNext();
                }
                if (e.key === 'i' || e.key === 'I') {
                    e.preventDefault();
                    toggleFlipH();
                }
                if (e.key === 'e' || e.key === 'E') {
                    e.preventDefault();
                    toggleEraseMode();
                }
            }
        });

        // Keyboard controls for collision painter
        document.addEventListener('keydown', (e) => {
            // Ignore shortcuts when typing in input fields
            const tag = e.target.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || e.target.isContentEditable) return;

            if (currentPhase !== 'collision') return;

            // Zoom with Q/E or +/-
            if (e.key === 'e' || e.key === 'E' || e.key === '=' || e.key === '+') {
                e.preventDefault();
                if (collisionZoom < 12) setCollisionZoom(collisionZoom + 1);
                return;
            }
            if (e.key === 'q' || e.key === 'Q' || e.key === '-' || e.key === '_') {
                e.preventDefault();
                if (collisionZoom > 1) setCollisionZoom(collisionZoom - 1);
                return;
            }

            // Arrow keys to pan
            const panSpeed = 50;
            let moved = false;

            if (e.key === 'ArrowLeft') { collisionPanX -= panSpeed; moved = true; }
            if (e.key === 'ArrowRight') { collisionPanX += panSpeed; moved = true; }
            if (e.key === 'ArrowUp') { collisionPanY -= panSpeed; moved = true; }
            if (e.key === 'ArrowDown') { collisionPanY += panSpeed; moved = true; }

            if (moved) {
                e.preventDefault();
                updateCollisionScroll();
            }
        });

        function updateCollisionScroll() {
            const container = document.querySelector('.collision-main');
            // Clamp pan values
            const maxX = Math.max(0, collisionTilesetCanvas.width - container.clientWidth);
            const maxY = Math.max(0, collisionTilesetCanvas.height - container.clientHeight);
            collisionPanX = Math.max(0, Math.min(maxX, collisionPanX));
            collisionPanY = Math.max(0, Math.min(maxY, collisionPanY));

            container.scrollLeft = collisionPanX;
            container.scrollTop = collisionPanY;
        }

        let mapInitialized = false;

        function finishCollisionSetup() {
            // Only initialize map if it hasn't been created yet
            if (!mapInitialized) {
                initMap();
                mapInitialized = true;
            }
            setPhase('build');
            drawPaintTileset();
            renderMap();
            updateAnimPropListDisplay();
        }

        function goBackToCollision() {
            setPhase('collision');
            rebuildCollisionView();
        }

        // ===== BUILD PHASE =====
        function initMap() {
            // Initialize with one layer
            layers = [createEmptyLayer()];
            layerVisibility = [true];
            layerNames = [''];
            currentLayer = 0;
            map = layers[0]; // map points to current layer for compatibility
            renderLayerList();
        }

        function createEmptyLayer() {
            const layer = [];
            for (let y = 0; y < mapRows; y++) {
                layer[y] = [];
                for (let x = 0; x < mapCols; x++) {
                    layer[y][x] = null;
                }
            }
            return layer;
        }

        function addLayer(fromNetwork = false) {
            layers.push(createEmptyLayer());
            layerVisibility.push(true);
            layerNames.push('');
            currentLayer = layers.length - 1;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();

            // Broadcast to other builders
            if (!fromNetwork) {
                broadcastEdit({ editType: 'addLayer', mapName: currentMapName });
            }
        }

        function selectLayer(index) {
            currentLayer = index;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function toggleLayerVisibility(index) {
            layerVisibility[index] = !layerVisibility[index];
            renderLayerList();
            renderMap();
        }

        function deleteLayer(index, fromNetwork = false) {
            if (layers.length <= 1) return alert('Need at least one layer');
            if (!fromNetwork) {
                const layerLabel = layerNames[index] ? `"${layerNames[index]}"` : `Layer ${index}`;
                if (!confirm('Delete ' + layerLabel + '?')) return;
            }
            layers.splice(index, 1);
            layerVisibility.splice(index, 1);
            layerNames.splice(index, 1);
            if (currentLayer >= layers.length) currentLayer = layers.length - 1;
            map = layers[currentLayer];
            if (!fromNetwork) {
                broadcastEdit({ editType: 'deleteLayer', index: index, mapName: currentMapName });
            }
            renderLayerList();
            renderMap();
        }

        function moveLayerUp(index, fromNetwork = false) {
            if (index <= 0) return;
            [layers[index], layers[index-1]] = [layers[index-1], layers[index]];
            [layerVisibility[index], layerVisibility[index-1]] = [layerVisibility[index-1], layerVisibility[index]];
            [layerNames[index], layerNames[index-1]] = [layerNames[index-1], layerNames[index]];
            if (currentLayer === index) currentLayer--;
            else if (currentLayer === index - 1) currentLayer++;
            map = layers[currentLayer];
            if (!fromNetwork) {
                broadcastEdit({ editType: 'moveLayerUp', index: index, mapName: currentMapName });
            }
            renderLayerList();
            renderMap();
        }

        function moveLayerDown(index, fromNetwork = false) {
            if (index >= layers.length - 1) return;
            [layers[index], layers[index+1]] = [layers[index+1], layers[index]];
            [layerVisibility[index], layerVisibility[index+1]] = [layerVisibility[index+1], layerVisibility[index]];
            [layerNames[index], layerNames[index+1]] = [layerNames[index+1], layerNames[index]];
            if (currentLayer === index) currentLayer++;
            else if (currentLayer === index + 1) currentLayer--;
            map = layers[currentLayer];
            if (!fromNetwork) {
                broadcastEdit({ editType: 'moveLayerDown', index: index, mapName: currentMapName });
            }
            renderLayerList();
            renderMap();
        }

        function renderLayerList() {
            // Render to both layer lists (tileset mode and animProp mode)
            const lists = [
                document.getElementById('layerList'),
                document.getElementById('animPropLayerList')
            ];

            for (const list of lists) {
                if (!list) continue;
                list.innerHTML = '';

                // Insert player layer row at the right position
                // Player layer is rendered BETWEEN layers[playerLayerIndex-1] and layers[playerLayerIndex]
                // So we need to show it after displaying layer playerLayerIndex-1

                for (let i = 0; i < layers.length; i++) {
                    // If this is where the player layer should appear, show it first
                    if (i === playerLayerIndex) {
                        list.appendChild(createPlayerLayerRow());
                    }

                    const div = document.createElement('div');
                    div.style.cssText = 'display:flex; align-items:center; gap:5px; padding:5px; margin:3px 0; background:' + (i === currentLayer ? '#4af' : '#333') + '; border-radius:4px; font-size:11px;';

                    const layerLabel = layerNames[i] ? `Layer ${i} (${layerNames[i]})` : `Layer ${i}`;

                    div.innerHTML = `
                        <input type="checkbox" ${layerVisibility[i] ? 'checked' : ''} onclick="toggleLayerVisibility(${i})" title="Visibility">
                        <span style="flex:1; cursor:pointer; color:${i === currentLayer ? '#000' : '#fff'};" onclick="selectLayer(${i})">${layerLabel}</span>
                        <button onclick="renameLayer(${i})" style="padding:2px 5px; font-size:10px;" title="Rename">✎</button>
                        <button onclick="moveLayerUp(${i})" style="padding:2px 5px; font-size:10px;">↑</button>
                        <button onclick="moveLayerDown(${i})" style="padding:2px 5px; font-size:10px;">↓</button>
                        <button onclick="deleteLayer(${i})" style="padding:2px 5px; font-size:10px; background:#a55;">X</button>
                    `;
                    list.appendChild(div);
                }

                // If player layer is at the end (beyond all layers)
                if (playerLayerIndex >= layers.length) {
                    list.appendChild(createPlayerLayerRow());
                }
            }
        }

        function createPlayerLayerRow() {
            const div = document.createElement('div');
            div.style.cssText = 'display:flex; align-items:center; gap:5px; padding:5px; margin:3px 0; background:#f0a; border-radius:4px; font-size:11px;';

            div.innerHTML = `
                <input type="checkbox" ${playerPreviewVisible ? 'checked' : ''} onclick="togglePlayerPreview()" title="Visibility">
                <span style="flex:1; color:#000;">🧍 PLAYER</span>
                <span style="color:#000; font-size:9px; opacity:0.7;">locked</span>
                <button onclick="movePlayerLayerUp()" style="padding:2px 5px; font-size:10px;">↑</button>
                <button onclick="movePlayerLayerDown()" style="padding:2px 5px; font-size:10px;">↓</button>
            `;
            return div;
        }

        function togglePlayerPreview() {
            playerPreviewVisible = !playerPreviewVisible;
            renderLayerList();
            renderMap();
        }

        function toggleSetSpawnMode() {
            setSpawnMode = !setSpawnMode;
            const btn = document.getElementById('setSpawnBtn');
            const canvas = document.getElementById('mapCanvas');

            if (setSpawnMode) {
                btn.classList.add('active');
                btn.textContent = 'CLICK MAP';
                canvas.style.cursor = 'crosshair';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'SPAWN';
                canvas.style.cursor = grabToolActive ? 'grab' : 'crosshair';
            }
        }

        function movePlayerLayerUp() {
            if (playerLayerIndex > 0) {
                playerLayerIndex--;
                renderLayerList();
                renderMap();
            }
        }

        function movePlayerLayerDown() {
            if (playerLayerIndex < layers.length) {
                playerLayerIndex++;
                renderLayerList();
                renderMap();
            }
        }

        function renameLayer(index, newName = null, fromNetwork = false) {
            if (!fromNetwork) {
                const currentName = layerNames[index] || '';
                newName = prompt('Enter nickname for Layer ' + index + ':', currentName);
            }
            if (newName !== null) {
                layerNames[index] = newName.trim ? newName.trim() : newName;
                if (!fromNetwork) {
                    broadcastEdit({ editType: 'renameLayer', index: index, name: layerNames[index], mapName: currentMapName });
                }
                renderLayerList();
            }
        }

        function setMode(m) {
            mode = m;
            // Turn off edit mode when switching away from animProp
            if (m !== 'animProp' && editAnimPropOnMapMode) {
                editAnimPropOnMapMode = false;
                const btn = document.getElementById('editAnimPropOnMapBtn');
                if (btn) {
                    btn.classList.remove('active');
                    btn.textContent = 'Edit Object on Map';
                }
            }
            // Sidebar tabs
            document.getElementById('tileMode').classList.toggle('active', m === 'tile');
            document.getElementById('playerMode').classList.toggle('active', m === 'player');
            document.getElementById('npcMode').classList.toggle('active', m === 'npc');
            document.getElementById('animPropMode').classList.toggle('active', m === 'animProp');
            document.getElementById('soundMode').classList.toggle('active', m === 'sound');
            document.getElementById('lightingMode').classList.toggle('active', m === 'lighting');
            document.getElementById('triggerMode').classList.toggle('active', m === 'trigger');
            document.getElementById('cameraMode').classList.toggle('active', m === 'camera');
            document.getElementById('dialogMode').classList.toggle('active', m === 'dialog');
            document.getElementById('itemMode').classList.toggle('active', m === 'item');
            document.getElementById('questMode').classList.toggle('active', m === 'quest');
            // Toolbar tabs
            document.getElementById('tileMode2').classList.toggle('active', m === 'tile');
            if (document.getElementById('playerMode2')) document.getElementById('playerMode2').classList.toggle('active', m === 'player');
            document.getElementById('npcMode2').classList.toggle('active', m === 'npc');
            document.getElementById('animPropMode2').classList.toggle('active', m === 'animProp');
            document.getElementById('soundMode2').classList.toggle('active', m === 'sound');
            document.getElementById('lightingMode2').classList.toggle('active', m === 'lighting');
            document.getElementById('triggerMode2').classList.toggle('active', m === 'trigger');
            document.getElementById('cameraMode2').classList.toggle('active', m === 'camera');
            document.getElementById('dialogMode2').classList.toggle('active', m === 'dialog');
            document.getElementById('itemMode2').classList.toggle('active', m === 'item');
            document.getElementById('questMode2').classList.toggle('active', m === 'quest');
            document.getElementById('tileModeContent').style.display = m === 'tile' ? 'block' : 'none';
            document.getElementById('playerModeContent').style.display = m === 'player' ? 'block' : 'none';
            document.getElementById('npcModeContent').style.display = m === 'npc' ? 'block' : 'none';
            document.getElementById('animPropModeContent').style.display = m === 'animProp' ? 'block' : 'none';
            document.getElementById('soundModeContent').style.display = m === 'sound' ? 'block' : 'none';
            document.getElementById('lightingModeContent').style.display = m === 'lighting' ? 'block' : 'none';
            document.getElementById('triggerModeContent').style.display = m === 'trigger' ? 'block' : 'none';
            document.getElementById('cameraModeContent').style.display = m === 'camera' ? 'block' : 'none';
            document.getElementById('dialogModeContent').style.display = m === 'dialog' ? 'block' : 'none';
            document.getElementById('itemModeContent').style.display = m === 'item' ? 'block' : 'none';
            document.getElementById('questModeContent').style.display = m === 'quest' ? 'block' : 'none';

            // Update mode label for mobile
            const labels = { tile: 'Tiles', player: 'Player', npc: 'NPCs', animProp: 'Animated', sound: 'Sounds', lighting: 'Lights', trigger: 'Triggers', camera: 'Camera', dialog: 'Dialogs', item: 'Items', quest: 'Quests' };
            document.getElementById('currentModeLabel').textContent = labels[m] || m;

            // Collapse menu on mobile after selection
            document.getElementById('modeTabs').classList.remove('expanded');

            // Update lists when switching modes
            if (m === 'player') updatePlayerList();
            if (m === 'npc') updateNpcList();
            if (m === 'trigger') {
                updateMapDropdowns();
                updateTriggerList();
            }
            if (m === 'camera') {
                updateMapDropdowns();
                updateCameraBoundsInfo();
            }
            if (m === 'dialog') {
                updateDialogList();
                updateDialogNpcDropdown();
            }
            if (m === 'item') {
                updateItemList();
                updateItemLayerDropdown();
            }
            if (m === 'quest') {
                renderQuestList();
                updateQuestNpcDropdowns();
            }

            // Redraw map to show appropriate overlays
            renderMap();
        }

        function toggleModeMenu() {
            document.getElementById('modeTabs').classList.toggle('expanded');
        }

        // Sidebar resize functionality
        (function() {
            const panel = document.getElementById('leftPanel');
            const handle = document.getElementById('sidebarResize');
            if (!panel || !handle) return;

            let isResizing = false;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                handle.classList.add('active');
                document.body.style.cursor = 'ew-resize';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const newWidth = e.clientX;
                if (newWidth >= 100 && newWidth <= 600) {
                    panel.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                isResizing = false;
                handle.classList.remove('active');
                document.body.style.cursor = '';
            });

            // Touch support for resize
            handle.addEventListener('touchstart', (e) => {
                isResizing = true;
                handle.classList.add('active');
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!isResizing) return;
                const touch = e.touches[0];
                const newWidth = touch.clientX;
                if (newWidth >= 100 && newWidth <= 600) {
                    panel.style.width = newWidth + 'px';
                }
            }, { passive: false });

            document.addEventListener('touchend', () => {
                isResizing = false;
                handle.classList.remove('active');
            });
        })();

        // ===== SOUND MANAGEMENT =====
        function loadSound(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const audio = new Audio(e.target.result);
                audio.addEventListener('loadedmetadata', function() {
                    sounds.push({
                        name: file.name,
                        data: e.target.result,
                        duration: audio.duration || 0,
                        type: 'ambient'
                    });
                    updateSoundDropdown();
                    currentSoundIndex = sounds.length - 1;
                    const selectEl = document.getElementById('soundSelect');
                    const controlsEl = document.getElementById('soundControls');
                    if (selectEl) selectEl.value = currentSoundIndex;
                    if (controlsEl) controlsEl.style.display = 'block';
                });
                audio.addEventListener('error', function() {
                    console.error('Failed to load audio metadata');
                    // Still add the sound even if metadata fails
                    sounds.push({
                        name: file.name,
                        data: e.target.result,
                        duration: 0,
                        type: 'ambient'
                    });
                    updateSoundDropdown();
                    currentSoundIndex = sounds.length - 1;
                    const selectEl = document.getElementById('soundSelect');
                    const controlsEl = document.getElementById('soundControls');
                    if (selectEl) selectEl.value = currentSoundIndex;
                    if (controlsEl) controlsEl.style.display = 'block';
                });
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function switchSound() {
            const selectEl = document.getElementById('soundSelect');
            const controlsEl = document.getElementById('soundControls');
            currentSoundIndex = selectEl ? parseInt(selectEl.value) : -1;
            if (controlsEl) controlsEl.style.display = currentSoundIndex >= 0 ? 'block' : 'none';
            stopPreview();
        }

        function updateSoundDropdown() {
            const select = document.getElementById('soundSelect');
            if (!select) return;
            select.innerHTML = '<option value="-1">-- Select Sound --</option>';
            sounds.forEach((sound, idx) => {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = sound.name;
                select.appendChild(opt);
            });
        }

        function previewSound() {
            if (currentSoundIndex < 0 || !sounds[currentSoundIndex]) return;
            stopPreview();
            previewAudio = new Audio(sounds[currentSoundIndex].data);
            const volumeEl = document.getElementById('soundVolume');
            previewAudio.volume = volumeEl ? volumeEl.value / 100 : 0.5;
            previewAudio.play();
        }

        function stopPreview() {
            if (previewAudio) {
                previewAudio.pause();
                previewAudio.currentTime = 0;
                previewAudio = null;
            }
        }

        function setSoundAttachMode(attachMode) {
            soundAttachMode = attachMode;
            const tileBtn = document.getElementById('soundAttachTile');
            const playerBtn = document.getElementById('soundAttachPlayer');
            const tileOpts = document.getElementById('tileSoundOptions');
            const playerOpts = document.getElementById('playerSoundOptions');
            if (tileBtn) tileBtn.classList.toggle('active', attachMode === 'tile');
            if (playerBtn) playerBtn.classList.toggle('active', attachMode === 'player');
            if (tileOpts) tileOpts.style.display = attachMode === 'tile' ? 'block' : 'none';
            if (playerOpts) playerOpts.style.display = attachMode === 'player' ? 'block' : 'none';
            renderMap();
        }

        function assignPlayerSound() {
            if (currentSoundIndex < 0) {
                alert('Select a sound first');
                return;
            }
            const actionEl = document.getElementById('playerActionSelect');
            const volumeEl = document.getElementById('playerSoundVolume');
            const intervalEl = document.getElementById('walkInterval');
            const walkPitchEl = document.getElementById('walkPitch');
            const attackPitchEl = document.getElementById('attackPitch');
            const attackLengthEl = document.getElementById('attackLength');

            const action = actionEl ? actionEl.value : 'walk';
            playerSounds[action].soundIndex = currentSoundIndex;
            playerSounds[action].volume = volumeEl ? volumeEl.value / 100 : 0.5;
            if (action === 'walk') {
                playerSounds.walk.interval = intervalEl ? parseInt(intervalEl.value) : 200;
                playerSounds.walk.pitchVariation = walkPitchEl ? parseInt(walkPitchEl.value) / 100 : 0.1;
            } else if (action === 'attack') {
                playerSounds.attack.pitchVariation = attackPitchEl ? parseInt(attackPitchEl.value) / 100 : 0.15;
                playerSounds.attack.lengthVariation = attackLengthEl ? parseInt(attackLengthEl.value) / 100 : 0;
            }
            updatePlayerSoundAssignments();
        }

        function updatePlayerSoundAssignments() {
            const container = document.getElementById('playerSoundAssignments');
            if (!container) return;
            let html = '';
            if (playerSounds.walk.soundIndex >= 0) {
                html += `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                    <span>Walk: ${sounds[playerSounds.walk.soundIndex]?.name || 'Unknown'}</span>
                    <button onclick="clearPlayerSound('walk')" style="background:#a33; border:none; color:#fff; padding:2px 6px; border-radius:3px; cursor:pointer; font-size:10px;">X</button>
                </div>`;
            }
            if (playerSounds.attack.soundIndex >= 0) {
                html += `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">
                    <span>Attack: ${sounds[playerSounds.attack.soundIndex]?.name || 'Unknown'}</span>
                    <button onclick="clearPlayerSound('attack')" style="background:#a33; border:none; color:#fff; padding:2px 6px; border-radius:3px; cursor:pointer; font-size:10px;">X</button>
                </div>`;
            }
            container.innerHTML = html || '<div style="color:#888;">None assigned</div>';
        }

        function clearPlayerSound(action) {
            if (action === 'walk') {
                playerSounds.walk.soundIndex = -1;
            } else if (action === 'attack') {
                playerSounds.attack.soundIndex = -1;
            }
            updatePlayerSoundAssignments();
        }

        function updatePlayerSoundUI() {
            const actionSelect = document.getElementById('playerActionSelect');
            const walkSettings = document.getElementById('walkSoundSettings');
            const attackSettings = document.getElementById('attackSoundSettings');
            if (!actionSelect) return;
            const action = actionSelect.value;
            if (walkSettings) walkSettings.style.display = action === 'walk' ? 'block' : 'none';
            if (attackSettings) attackSettings.style.display = action === 'attack' ? 'block' : 'none';

            // Update volume slider to current value for selected action
            const volumeSlider = document.getElementById('playerSoundVolume');
            const volumeVal = document.getElementById('playerSoundVolumeVal');
            if (action === 'walk' && playerSounds.walk.soundIndex >= 0) {
                const vol = Math.round((playerSounds.walk.volume || 0.5) * 100);
                if (volumeSlider) volumeSlider.value = vol;
                if (volumeVal) volumeVal.textContent = vol;
            } else if (action === 'attack' && playerSounds.attack.soundIndex >= 0) {
                const vol = Math.round((playerSounds.attack.volume || 0.7) * 100);
                if (volumeSlider) volumeSlider.value = vol;
                if (volumeVal) volumeVal.textContent = vol;
                // Update attack-specific sliders
                const pitchSlider = document.getElementById('attackPitch');
                const pitchVal = document.getElementById('attackPitchVal');
                const lengthSlider = document.getElementById('attackLength');
                const lengthVal = document.getElementById('attackLengthVal');
                if (pitchSlider) pitchSlider.value = playerSounds.attack.pitchVariation || 15;
                if (pitchVal) pitchVal.textContent = playerSounds.attack.pitchVariation || 15;
                if (lengthSlider) lengthSlider.value = playerSounds.attack.lengthVariation || 0;
                if (lengthVal) lengthVal.textContent = playerSounds.attack.lengthVariation || 0;
            }
        }

        function placeTileSound(gridX, gridY) {
            if (currentSoundIndex < 0) {
                alert('Select a sound first');
                return;
            }
            const radiusEl = document.getElementById('soundRadius');
            const loopEl = document.getElementById('soundLoop');
            const volumeEl = document.getElementById('soundVolume');
            const fadeEl = document.getElementById('soundFade');
            const key = `${currentMapName}:${gridX},${gridY}`;
            tileSounds[key] = {
                soundIndex: currentSoundIndex,
                radius: radiusEl ? parseInt(radiusEl.value) : 3,
                loop: loopEl ? loopEl.checked : true,
                volume: volumeEl ? volumeEl.value / 100 : 0.5,
                fadePercent: fadeEl ? parseInt(fadeEl.value) / 100 : 0.5
            };
            console.log('Placed tile sound:', key, tileSounds[key]);
            console.log('Total tile sounds:', Object.keys(tileSounds).length);
            // Broadcast to co-op builders
            broadcastEdit({ editType: 'tileSound', key: key, sound: tileSounds[key] });
            updatePlacedSoundsList();
            renderMap();
        }

        function removeTileSound(key) {
            delete tileSounds[key];
            // Broadcast to co-op builders
            broadcastEdit({ editType: 'removeTileSound', key: key });
            updatePlacedSoundsList();
            renderMap();
        }

        function updatePlacedSoundsList() {
            const container = document.getElementById('placedSoundsList');
            if (!container) return;
            const keys = Object.keys(tileSounds).filter(k => k.startsWith(currentMapName + ':'));
            if (keys.length === 0) {
                container.innerHTML = '<div style="color:#888;">No sounds placed</div>';
                return;
            }
            container.innerHTML = keys.map(key => {
                const ts = tileSounds[key];
                const coords = key.split(':')[1]; // Get "x,y" part after map name
                const soundName = sounds[ts.soundIndex]?.name || 'Unknown';
                const isSelected = key === selectedTileSoundKey;
                return `<div style="display:flex; justify-content:space-between; align-items:center; padding:4px; margin:2px 0; background:${isSelected ? '#4a7c59' : '#333'}; border-radius:3px; cursor:pointer;" onclick="selectTileSound('${key}')">
                    <span style="flex:1;">📍 ${coords}: ${soundName}</span>
                    <button onclick="event.stopPropagation(); removeTileSound('${key}')" style="padding:2px 6px;">×</button>
                </div>`;
            }).join('');
        }

        function selectTileSound(key) {
            if (!tileSounds[key]) return;
            selectedTileSoundKey = key;
            const ts = tileSounds[key];

            // Populate UI with current values
            const radiusEl = document.getElementById('soundRadius');
            const loopEl = document.getElementById('soundLoop');
            const volumeEl = document.getElementById('soundVolume');
            const fadeEl = document.getElementById('soundFade');
            const selectEl = document.getElementById('soundSelect');

            if (radiusEl) {
                radiusEl.value = ts.radius || 3;
                document.getElementById('soundRadiusVal').textContent = ts.radius || 3;
            }
            if (loopEl) loopEl.checked = ts.loop !== false;
            if (volumeEl) {
                volumeEl.value = (ts.volume || 0.5) * 100;
                document.getElementById('soundVolumeVal').textContent = Math.round((ts.volume || 0.5) * 100);
            }
            if (fadeEl) {
                fadeEl.value = (ts.fadePercent !== undefined ? ts.fadePercent : 0.5) * 100;
                document.getElementById('soundFadeVal').textContent = Math.round((ts.fadePercent !== undefined ? ts.fadePercent : 0.5) * 100);
            }
            if (selectEl) selectEl.value = ts.soundIndex;
            currentSoundIndex = ts.soundIndex;

            // Show edit mode indicator
            document.getElementById('soundEditMode').style.display = 'block';
            document.getElementById('editingSoundKey').textContent = key;

            updatePlacedSoundsList();
            renderMap();
        }

        function deselectTileSound() {
            selectedTileSoundKey = null;
            document.getElementById('soundEditMode').style.display = 'none';
            updatePlacedSoundsList();
            renderMap();
        }

        function saveSelectedSound() {
            if (!selectedTileSoundKey || !tileSounds[selectedTileSoundKey]) {
                alert('No sound selected to save');
                return;
            }
            if (currentSoundIndex < 0) {
                alert('Select a sound first');
                return;
            }

            const radiusEl = document.getElementById('soundRadius');
            const loopEl = document.getElementById('soundLoop');
            const volumeEl = document.getElementById('soundVolume');
            const fadeEl = document.getElementById('soundFade');

            tileSounds[selectedTileSoundKey] = {
                soundIndex: currentSoundIndex,
                radius: radiusEl ? parseInt(radiusEl.value) : 3,
                loop: loopEl ? loopEl.checked : true,
                volume: volumeEl ? volumeEl.value / 100 : 0.5,
                fadePercent: fadeEl ? parseInt(fadeEl.value) / 100 : 0.5
            };

            console.log('Updated tile sound:', selectedTileSoundKey, tileSounds[selectedTileSoundKey]);
            broadcastEdit({ editType: 'tileSound', key: selectedTileSoundKey, sound: tileSounds[selectedTileSoundKey] });
            updatePlacedSoundsList();
            renderMap();
        }

        // ===== LIGHTING MANAGEMENT =====
        let lightingPreviewEnabled = false;

        function toggleLightingPreview() {
            lightingPreviewEnabled = !lightingPreviewEnabled;
            const btn = document.getElementById('lightingPreviewBtn');
            if (btn) {
                btn.textContent = lightingPreviewEnabled ? 'Toggle Darkness: ON' : 'Toggle Darkness: OFF';
                btn.style.background = lightingPreviewEnabled ? '#5a8a2a' : '#2a5a8a';
            }
            // Show/hide darkness slider
            const darknessRow = document.getElementById('previewDarknessRow');
            if (darknessRow) {
                darknessRow.style.display = lightingPreviewEnabled ? 'block' : 'none';
            }
            renderMap();
        }

        function updateLightingSettings() {
            lightingSettings.playerLight = document.getElementById('playerLight').checked;
            lightingSettings.playerLightRadius = parseInt(document.getElementById('playerLightRadius').value);
            renderMap();
        }

        function placeLightAt(x, y) {
            const key = currentMapName + ':' + x + ',' + y;
            const radius = parseInt(document.getElementById('pointLightRadius').value) || 3;
            const flicker = document.getElementById('pointLightFlicker').checked;
            const flickerIntensity = flicker ? parseFloat(document.getElementById('pointFlickerIntensity').value) || 0.1 : 0;
            pointLights[key] = { radius, flicker, flickerIntensity };
            console.log('Placed light:', key, pointLights[key]);
            // Broadcast to co-op builders
            broadcastEdit({ editType: 'light', key: key, light: pointLights[key] });
            updatePlacedLightsList();
            renderMap();
        }

        function removeLightAt(x, y) {
            const key = currentMapName + ':' + x + ',' + y;
            if (pointLights[key]) {
                delete pointLights[key];
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeLight', key: key });
                updatePlacedLightsList();
                renderMap();
            }
        }

        function removeNearestLight(x, y) {
            // Find nearest light within 1.5 tiles
            let nearestKey = null;
            let nearestDist = 1.5;
            Object.keys(pointLights).forEach(key => {
                if (!key.startsWith(currentMapName + ':')) return;
                const coords = key.split(':')[1].split(',');
                const lx = parseFloat(coords[0]);
                const ly = parseFloat(coords[1]);
                const dist = Math.sqrt((x - lx) ** 2 + (y - ly) ** 2);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestKey = key;
                }
            });
            if (nearestKey) {
                delete pointLights[nearestKey];
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeLight', key: nearestKey });
                updatePlacedLightsList();
                renderMap();
            }
        }

        // ===== POLYGON LIGHTS =====
        function togglePolyLightDraw() {
            polyLightDrawing = !polyLightDrawing;
            const btn = document.getElementById('polyLightDrawBtn');
            const status = document.getElementById('polyLightDrawStatus');

            if (polyLightDrawing) {
                polyLightPoints = [];
                btn.textContent = 'CANCEL';
                btn.style.background = '#a33';
                status.style.display = 'block';
            } else {
                polyLightPoints = [];
                btn.textContent = 'DRAW POLYGON';
                btn.style.background = '#0aa';
                status.style.display = 'none';
            }
            renderMap();
        }

        function addPolyLightPoint(x, y) {
            if (!polyLightDrawing) return false;

            polyLightPoints.push({ x, y });
            renderMap();
            return true;
        }

        function finishPolyLight() {
            if (!polyLightDrawing || polyLightPoints.length < 3) {
                if (polyLightDrawing && polyLightPoints.length < 3) {
                    alert('Need at least 3 points to create a polygon light');
                }
                return;
            }

            const intensity = parseFloat(document.getElementById('polyLightIntensity').value) || 0.8;
            const flicker = document.getElementById('polyLightFlicker').checked;
            const flickerIntensity = flicker ? parseFloat(document.getElementById('polyFlickerIntensity').value) || 0.2 : 0;

            const newLight = {
                id: 'poly_' + Date.now(),
                mapName: currentMapName,
                points: JSON.parse(JSON.stringify(polyLightPoints)),
                intensity,
                flicker,
                flickerIntensity
            };

            polyLights.push(newLight);
            broadcastEdit({ editType: 'addPolyLight', light: newLight });

            // Reset drawing state
            polyLightDrawing = false;
            polyLightPoints = [];
            document.getElementById('polyLightDrawBtn').textContent = 'DRAW POLYGON';
            document.getElementById('polyLightDrawBtn').style.background = '#0aa';
            document.getElementById('polyLightDrawStatus').style.display = 'none';

            updatePolyLightsList();
            renderMap();
            console.log('[LIGHTS] Created polygon light:', newLight);
            console.log('[LIGHTS] Total polyLights now:', polyLights.length, polyLights);
        }

        function deletePolyLight(index) {
            if (index < 0 || index >= polyLights.length) return;
            const lightId = polyLights[index].id;
            polyLights.splice(index, 1);
            broadcastEdit({ editType: 'removePolyLight', lightId });
            updatePolyLightsList();
            renderMap();
        }

        function updatePolyLightsList() {
            const container = document.getElementById('placedPolyLightsList');
            if (!container) return;

            const mapLights = polyLights.filter(l => l.mapName === currentMapName);
            if (mapLights.length === 0) {
                container.innerHTML = '<div style="color:#888;">No polygon lights</div>';
                return;
            }

            container.innerHTML = mapLights.map((light, i) => {
                const globalIndex = polyLights.indexOf(light);
                return `<div style="display:flex; justify-content:space-between; align-items:center; padding:4px; margin:2px 0; background:#234; border-radius:3px;">
                    <span style="flex:1;">◇ ${light.points.length} pts (${(light.intensity * 100).toFixed(0)}%${light.flicker ? ', flicker' : ''})</span>
                    <button onclick="deletePolyLight(${globalIndex})" style="padding:2px 6px;">×</button>
                </div>`;
            }).join('');
        }

        function updatePlacedLightsList() {
            const container = document.getElementById('placedLightsList');
            if (!container) return;
            const keys = Object.keys(pointLights).filter(k => k.startsWith(currentMapName + ':'));
            if (keys.length === 0) {
                container.innerHTML = '<div style="color:#888;">No lights placed</div>';
                return;
            }
            container.innerHTML = keys.map(key => {
                const light = pointLights[key];
                const coords = key.split(':')[1];
                return `<div style="display:flex; justify-content:space-between; align-items:center; padding:4px; margin:2px 0; background:#333; border-radius:3px;">
                    <span style="flex:1;">💡 ${coords} (r=${light.radius}${light.flicker ? ', flicker' : ''})</span>
                    <button onclick="delete pointLights['${key}']; updatePlacedLightsList(); renderMap();" style="padding:2px 6px;">×</button>
                </div>`;
            }).join('');
        }

        function setRotation(deg) {
            tileRotation = deg;
            document.querySelectorAll('[id^="rot"]').forEach(b => b.classList.remove('active'));
            document.getElementById('rot' + deg).classList.add('active');
            updateSelectedPreview();
            renderMap(); // Update preview
            updateCursorIndicator();
            resetPrattWarning();
        }

        function rotateNext() {
            const rotations = [0, 90, 180, 270];
            const idx = rotations.indexOf(tileRotation);
            setRotation(rotations[(idx + 1) % 4]);
        }

        function toggleFlipH() {
            tileFlippedH = !tileFlippedH;
            updateFlipButton();
            updateSelectedTilePreview();
            renderMap();
            resetPrattWarning();
        }

        function updateFlipButton() {
            const btn = document.getElementById('flipBtn');
            if (btn) {
                if (tileFlippedH) {
                    btn.classList.add('active');
                    btn.innerHTML = 'FLIPPED';
                } else {
                    btn.classList.remove('active');
                    btn.innerHTML = 'Flip H';
                }
            }
            updateCursorIndicator();
        }

        // Pratt warning callback
        let prattPendingCallback = null;

        // Show Pratt warning when tiles are both rotated AND flipped
        function showPrattWarning() {
            if (prattWarningShown) return true; // Already shown, proceed
            if (tileRotation === 0 || !tileFlippedH) return true; // No warning needed

            // Show custom retro modal
            document.getElementById('prattDegrees').textContent = tileRotation + '°';
            document.getElementById('prattModal').style.display = 'flex';
            return false; // Block the action, will be handled by prattConfirm
        }

        function prattConfirm(proceed) {
            document.getElementById('prattModal').style.display = 'none';
            if (proceed) {
                prattWarningShown = true; // Don't ask again this session
                // User confirmed, trigger the paint action
                if (painting && selectedTileData) {
                    // Re-enable painting - the user confirmed
                    renderMap();
                }
            }
        }

        // Reset pratt warning when rotation or flip changes
        function resetPrattWarning() {
            prattWarningShown = false;
        }

        function toggleEraseMode() {
            eraseMode = !eraseMode;
            updateEraseButton();
        }

        function updateEraseButton() {
            const btn = document.getElementById('eraseBtn');
            if (btn) {
                if (eraseMode) {
                    btn.classList.add('active');
                    btn.innerHTML = 'ERASING';
                } else {
                    btn.classList.remove('active');
                    btn.innerHTML = 'Erase';
                }
            }
            updateCursorIndicator();
        }

        // Cursor indicator for active modes
        function updateCursorIndicator() {
            const indicator = document.getElementById('cursorIndicator');
            if (!indicator) return;

            let symbols = [];
            if (eraseMode) symbols.push('[X]');
            if (tileFlippedH) symbols.push('[FLIP]');
            if (tileRotation === 90) symbols.push('[90]');
            else if (tileRotation === 180) symbols.push('[180]');
            else if (tileRotation === 270) symbols.push('[270]');

            if (symbols.length > 0) {
                indicator.textContent = symbols.join(' ');
                indicator.style.display = 'block';
            } else {
                indicator.style.display = 'none';
            }
        }

        // Track mouse for cursor indicator
        document.addEventListener('mousemove', (e) => {
            const indicator = document.getElementById('cursorIndicator');
            if (indicator && indicator.style.display !== 'none') {
                indicator.style.left = (e.clientX + 20) + 'px';
                indicator.style.top = (e.clientY + 5) + 'px';
            }
        });

        // Draw a tile with rotation and optional horizontal flip
        function drawRotatedTile(ctx, img, srcX, srcY, srcSize, destX, destY, destSize, rotation, flipped) {
            ctx.save();
            ctx.translate(destX + destSize / 2, destY + destSize / 2);

            if (rotation !== 0) {
                ctx.rotate(rotation * Math.PI / 180);
            }
            if (flipped) {
                ctx.scale(-1, 1); // Flip horizontally
            }

            ctx.drawImage(img, srcX, srcY, srcSize, srcSize, -destSize / 2, -destSize / 2, destSize, destSize);
            ctx.restore();
        }

        // Draw player preview on map (uses actual sprite if loaded)
        function drawPlayerPreview(tileSize) {
            mapCtx.globalAlpha = 1;

            const px = playerPreviewPos.x * tileSize;
            const py = playerPreviewPos.y * tileSize;

            // Draw at ~1.7 tiles tall to match test game (playerScale default)
            const drawSize = tileSize * 1.7;

            // Draw the actual player sprite if available (idle frame = first 64x64)
            if (playerSpriteImg && playerSpriteImg.complete && playerSpriteImg.naturalWidth > 0) {
                // Draw idle frame (first frame, facing down)
                mapCtx.drawImage(playerSpriteImg, 0, 0, 64, 64, px, py, drawSize, drawSize);
            } else {
                // Fallback: simple placeholder
                mapCtx.fillStyle = '#f0a';
                mapCtx.fillRect(px + drawSize * 0.3, py + drawSize * 0.1, drawSize * 0.4, drawSize * 0.7);
                mapCtx.beginPath();
                mapCtx.arc(px + drawSize * 0.5, py + drawSize * 0.15, drawSize * 0.15, 0, Math.PI * 2);
                mapCtx.fill();
            }

            // Label
            mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
            mapCtx.font = '10px sans-serif';
            mapCtx.textAlign = 'center';
            const labelWidth = mapCtx.measureText('SPAWN').width + 6;
            mapCtx.fillRect(px + drawSize / 2 - labelWidth / 2, py - 14, labelWidth, 12);
            mapCtx.fillStyle = '#4f8';
            mapCtx.fillText('SPAWN', px + drawSize / 2, py - 4);

            // Spawn marker outline
            mapCtx.strokeStyle = '#4f8';
            mapCtx.lineWidth = 2;
            mapCtx.setLineDash([4, 4]);
            mapCtx.strokeRect(px - 2, py - 2, drawSize + 4, drawSize + 4);
            mapCtx.setLineDash([]);
        }

        function drawPaintTileset() {
            if (!tilesetImg) return;

            const displayZoom = 2;
            paintTilesetCanvas.width = tilesetImg.naturalWidth * displayZoom;
            paintTilesetCanvas.height = tilesetImg.naturalHeight * displayZoom;

            paintTilesetCtx.imageSmoothingEnabled = false;
            paintTilesetCtx.drawImage(tilesetImg, 0, 0, paintTilesetCanvas.width, paintTilesetCanvas.height);

            // Grid
            paintTilesetCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            const cols = Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = Math.floor(tilesetImg.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(x * gridSize * displayZoom, 0);
                paintTilesetCtx.lineTo(x * gridSize * displayZoom, paintTilesetCanvas.height);
                paintTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(0, y * gridSize * displayZoom);
                paintTilesetCtx.lineTo(paintTilesetCanvas.width, y * gridSize * displayZoom);
                paintTilesetCtx.stroke();
            }

            // Mark collision tiles
            for (let key in tileCollisions) {
                if (tileCollisions[key] && tileCollisions[key].length >= 3) {
                    const [tx, ty] = key.split(',').map(Number);
                    paintTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.25)';
                    paintTilesetCtx.fillRect(tx * displayZoom, ty * displayZoom, gridSize * displayZoom, gridSize * displayZoom);
                }
            }

            // Mark tiles with depth split lines (cyan indicator)
            const keyPrefix = currentTilesetIndex + ':';
            for (let key in tileSplitLines) {
                if (!key.startsWith(keyPrefix)) continue;

                const splitY = tileSplitLines[key];
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                // Draw cyan horizontal line
                paintTilesetCtx.strokeStyle = '#0ff';
                paintTilesetCtx.lineWidth = 2;
                const lineY = (ty + splitY) * displayZoom;
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(tx * displayZoom, lineY);
                paintTilesetCtx.lineTo((tx + gridSize) * displayZoom, lineY);
                paintTilesetCtx.stroke();

                // Draw small cyan dot in corner to indicate split tile
                paintTilesetCtx.fillStyle = '#0ff';
                paintTilesetCtx.beginPath();
                paintTilesetCtx.arc(tx * displayZoom + 6, ty * displayZoom + 6, 4, 0, Math.PI * 2);
                paintTilesetCtx.fill();
            }

            // Highlight selected tiles
            if (selectedTileData) {
                paintTilesetCtx.strokeStyle = '#0f0';
                paintTilesetCtx.lineWidth = 3;
                const w = (selectedTileData.width || 1) * gridSize * displayZoom;
                const h = (selectedTileData.height || 1) * gridSize * displayZoom;
                paintTilesetCtx.strokeRect(
                    selectedTileData.x * displayZoom,
                    selectedTileData.y * displayZoom,
                    w,
                    h
                );
                paintTilesetCtx.lineWidth = 1;
            }
        }

        // Multi-tile selection on tileset
        let tilesetSelecting = false;
        let tileSelectModeActive = false;

        function toggleTileSelectMode() {
            tileSelectModeActive = !tileSelectModeActive;
            const btn = document.getElementById('tileSelectModeBtn');
            const canvas = document.getElementById('paintTilesetCanvas');

            if (tileSelectModeActive) {
                btn.style.background = '#4af';
                btn.style.color = '#000';
                btn.textContent = 'Select Mode ON';
                canvas.style.touchAction = 'none';
            } else {
                btn.style.background = '#555';
                btn.style.color = 'white';
                btn.textContent = 'Select Tiles';
                canvas.style.touchAction = 'manipulation';
            }
        }

        // ========== CREATE OBJECT MODE ==========
        function toggleCreateObjectMode() {
            if (!createObjectMode) {
                // Enter create object mode
                createObjectMode = true;
                tileSelectModeActive = true;
                selectedTiles = [];
                selectedTileData = null;

                const selectBtn = document.getElementById('tileSelectModeBtn');
                if (selectBtn) {
                    selectBtn.style.background = '#4af';
                    selectBtn.style.color = '#000';
                    selectBtn.textContent = 'Select Mode ON';
                }
            } else {
                // Finish - create object from selection
                if (selectedTileData && selectedTiles.length > 0) {
                    createStaticObjectFromSelection();
                } else {
                    alert('Please select tiles from the tileset first.');
                }

                // Exit mode
                createObjectMode = false;
                tileSelectModeActive = false;

                const selectBtn = document.getElementById('tileSelectModeBtn');
                if (selectBtn) {
                    selectBtn.style.background = '#555';
                    selectBtn.style.color = 'white';
                    selectBtn.textContent = 'Select Tiles';
                }
            }
            updateCreateObjectButton();
        }

        function updateCreateObjectButton() {
            const btn = document.getElementById('createObjectBtn');
            if (!btn) return;

            if (createObjectMode) {
                if (selectedTileData && selectedTiles.length > 0) {
                    btn.textContent = 'FINISH';
                    btn.style.background = '#c9a227';
                    btn.style.color = '#000';
                } else {
                    btn.textContent = 'SELECT TILES...';
                    btn.style.background = '#666';
                    btn.style.color = '#fff';
                }
            } else {
                btn.textContent = 'CREATE OBJECT';
                btn.style.background = '#4a7c59';
                btn.style.color = '#fff';
            }
        }

        function updateStaticObjScale(value) {
            staticObjPlacementScale = parseFloat(value);
            const label = document.getElementById('staticObjScaleValue');
            if (label) label.textContent = staticObjPlacementScale.toFixed(2).replace(/\.?0+$/, '') + 'x';
        }

        function createStaticObjectFromSelection() {
            if (!selectedTileData || currentTilesetIndex < 0) {
                alert('No tiles selected.');
                return;
            }

            const tileset = tilesets[currentTilesetIndex];
            const img = tileset.img || tileset._img;
            if (!img) {
                alert('Tileset image not loaded.');
                return;
            }

            // Extract tile region to canvas
            // Note: selectedTileData.x/y are already in pixels, width/height are in tile counts
            const pixelX = selectedTileData.x;
            const pixelY = selectedTileData.y;
            const pixelW = selectedTileData.width * gridSize;
            const pixelH = selectedTileData.height * gridSize;

            const canvas = document.createElement('canvas');
            canvas.width = pixelW;
            canvas.height = pixelH;
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, pixelX, pixelY, pixelW, pixelH, 0, 0, pixelW, pixelH);

            const spriteData = canvas.toDataURL('image/png');

            // Prompt for name
            const name = prompt('Name this object:', 'Object ' + (staticObjects.length + 1));
            if (!name || name.trim() === '') return;

            // Store source tiles for collision inheritance
            const sourceTiles = selectedTiles.map(t => ({ x: t.x, y: t.y }));

            // Create static object
            const obj = {
                name: name.trim(),
                spriteData: spriteData,
                width: selectedTileData.width,
                height: selectedTileData.height,
                tilesetIndex: currentTilesetIndex,
                sourceTiles: sourceTiles,
                sourceOrigin: { x: selectedTileData.x, y: selectedTileData.y },
                _spriteImg: new Image()
            };
            obj._spriteImg.src = spriteData;

            staticObjects.push(obj);

            // Broadcast for multiplayer
            broadcastEdit({
                editType: 'addStaticObj',
                obj: {
                    name: obj.name,
                    spriteData: obj.spriteData,
                    width: obj.width,
                    height: obj.height,
                    tilesetIndex: obj.tilesetIndex,
                    sourceTiles: obj.sourceTiles,
                    sourceOrigin: obj.sourceOrigin
                }
            });

            // Clear selection
            selectedTiles = [];
            selectedTileData = null;

            // Update UI
            updateStaticObjectsList();

            // Switch to props tab and select the new object
            setMode('animProp');
            selectStaticObject(staticObjects.length - 1);

            console.log('[STATIC OBJ] Created:', obj.name, 'from tileset', obj.tilesetIndex);
        }

        function placeStaticObjectAt(gridX, gridY) {
            if (gridX < 0 || gridY < 0 || gridX >= mapCols || gridY >= mapRows) return;
            if (currentStaticObjIndex < 0 || !staticObjects[currentStaticObjIndex]) return;

            // Store grid coordinates (like items do)
            const placed = {
                objIndex: currentStaticObjIndex,
                x: gridX,
                y: gridY,
                mapName: currentMapName,
                scale: staticObjPlacementScale
            };

            placedStaticObjects.push(placed);

            broadcastEdit({
                editType: 'placeStaticObj',
                placed: placed
            });

            renderMap();
            console.log('[STATIC OBJ] Placed at', gridX, gridY, 'scale:', staticObjPlacementScale);
        }

        function removeStaticObjectAt(gridX, gridY) {
            // Search from top to bottom (last placed = on top)
            for (let i = placedStaticObjects.length - 1; i >= 0; i--) {
                const placed = placedStaticObjects[i];
                if (placed.mapName !== currentMapName) continue;

                const obj = staticObjects[placed.objIndex];
                if (!obj) continue;

                const scale = placed.scale || 1;
                const w = obj.width * scale;
                const h = obj.height * scale;

                // placed.x/y are grid coords
                if (gridX >= placed.x && gridX < placed.x + w &&
                    gridY >= placed.y && gridY < placed.y + h) {

                    broadcastEdit({
                        editType: 'removeStaticObjPlacement',
                        x: placed.x,
                        y: placed.y,
                        mapName: placed.mapName
                    });

                    placedStaticObjects.splice(i, 1);
                    renderMap();
                    console.log('[STATIC OBJ] Removed at grid', placed.x, placed.y);
                    return;
                }
            }
        }

        paintTilesetCanvas.addEventListener('mousedown', (e) => {
            if (mode !== 'tile') return;
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            selectionStart = { x, y };
            tilesetSelecting = true;
        });

        paintTilesetCanvas.addEventListener('mousemove', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            updateTileSelection(e);
        });

        paintTilesetCanvas.addEventListener('mouseup', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            updateTileSelection(e);
            tilesetSelecting = false;
        });

        // Touch support for tileset selection (only when select mode is active)
        paintTilesetCanvas.addEventListener('touchstart', (e) => {
            if (mode !== 'tile') return;
            if (!tileSelectModeActive) return; // Allow scrolling when select mode is off
            e.preventDefault();
            const touch = e.touches[0];
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((touch.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((touch.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            selectionStart = { x, y };
            tilesetSelecting = true;
        }, { passive: false });

        paintTilesetCanvas.addEventListener('touchmove', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            if (!tileSelectModeActive) return;
            e.preventDefault();
            updateTileSelectionTouch(e.touches[0]);
        }, { passive: false });

        paintTilesetCanvas.addEventListener('touchend', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            tilesetSelecting = false;
        });

        function updateTileSelectionTouch(touch) {
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((touch.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((touch.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            const minX = Math.min(selectionStart.x, x);
            const minY = Math.min(selectionStart.y, y);
            const maxX = Math.max(selectionStart.x, x);
            const maxY = Math.max(selectionStart.y, y);

            selectedTiles = [];
            for (let ty = minY; ty <= maxY; ty += gridSize) {
                for (let tx = minX; tx <= maxX; tx += gridSize) {
                    selectedTiles.push({ x: tx, y: ty });
                }
            }

            const selWidth = (maxX - minX) / gridSize + 1;
            const selHeight = (maxY - minY) / gridSize + 1;

            selectedTileData = { x: minX, y: minY, width: selWidth, height: selHeight };
            drawPaintTileset();
        }

        function updateTileSelection(e) {
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            // Calculate selection rectangle
            const minX = Math.min(selectionStart.x, x);
            const minY = Math.min(selectionStart.y, y);
            const maxX = Math.max(selectionStart.x, x);
            const maxY = Math.max(selectionStart.y, y);

            // Build array of selected tiles
            selectedTiles = [];
            for (let ty = minY; ty <= maxY; ty += gridSize) {
                for (let tx = minX; tx <= maxX; tx += gridSize) {
                    selectedTiles.push({ x: tx, y: ty });
                }
            }

            // Calculate selection dimensions
            const selWidth = (maxX - minX) / gridSize + 1;
            const selHeight = (maxY - minY) / gridSize + 1;

            // Store selection bounds for painting
            selectedTileData = { x: minX, y: minY, width: selWidth, height: selHeight };
            drawPaintTileset();

            // Update CREATE OBJECT button when tiles selected
            if (createObjectMode) {
                updateCreateObjectButton();
            }
        }

        function updateSelectedPreview() {
            // Preview removed
        }

        function updateSelectedTilePreview() {
            // Preview removed
        }

        // Map painting
        let painting = false;
        let erasing = false;

        mapCanvas.addEventListener('mousedown', (e) => {
            // Skip painting when grab tool is active
            if (grabToolActive) return;

            e.preventDefault();
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((e.clientX - rect.left) / tileSize);
            const y = Math.floor((e.clientY - rect.top) / tileSize);

            // DEBUG: Ctrl+Shift+Click to mark position (in pixel coords like game uses)
            if (e.ctrlKey && e.shiftKey) {
                const pixelX = (e.clientX - rect.left) / zoom;
                const pixelY = (e.clientY - rect.top) / zoom;
                window.debugClickPos = { x: Math.round(pixelX), y: Math.round(pixelY) };
                console.log('[DEBUG] Marked position:', window.debugClickPos, 'tile:', x, y);
                renderMap();
                return;
            }

            // Check if in door animation tile selection mode (only on correct map)
            if (selectingAnimTiles && pendingAnimTrigger && doorAnimMapName === currentMapName && e.button === 0) {
                // Toggle tile selection
                toggleAnimTileSelection(x, y);
                return;
            }

            // In door animation painting mode, let normal tile painting handle clicks
            // (Done button is now HTML, not on canvas)

            // Set spawn mode - click anywhere to place player spawn
            if (setSpawnMode) {
                playerPreviewPos.x = x;
                playerPreviewPos.y = y;
                spawnMapName = currentMapName; // Record which map spawn is on
                playerPreviewVisible = true;
                toggleSetSpawnMode(); // Turn off set spawn mode after placing
                renderMap();
                return;
            }

            // Quest condition setting mode - click to set condition target
            if (settingConditionMode) {
                if (handleMapClickForCondition(x, y)) {
                    return;
                }
            }

            // Quest giver/turn-in NPC setting mode
            if (settingQuestGiverMode || settingQuestTurnInMode) {
                if (handleMapClickForQuestNpc(x, y)) {
                    return;
                }
            }

            if (copyMode) {
                // Start copy selection
                copyStart = { x, y };
                copyEnd = { x, y };
                renderMap();
                return;
            }

            // Animated prop mode - click to place, right-click to remove (no dragging)
            if (mode === 'animProp') {
                // Static object placement/removal takes priority
                if (currentStaticObjIndex >= 0 && staticObjects[currentStaticObjIndex]) {
                    if (e.button === 0) {
                        placeStaticObjectAt(x, y);
                    } else if (e.button === 2) {
                        removeStaticObjectAt(x, y);
                    }
                    return;
                }
                // Edit mode - click on placed props to edit their timing
                if (editAnimPropOnMapMode && e.button === 0) {
                    const propInfo = findAnimPropAt(x, y);
                    if (propInfo) {
                        openAnimPropEditPopup(propInfo);
                        return;
                    }
                }
                if (e.button === 0 && currentAnimPropIndex >= 0 && !editAnimPropOnMapMode) {
                    placeAnimPropAt(x, y);
                } else if (e.button === 2) {
                    removeAnimPropAt(x, y);
                }
                return;
            }

            // Item mode - click to place interactive item, right-click to remove
            // Also handle clicking on interactive anim props to assign items
            if (mode === 'item') {
                // Check if clicking on an interactive anim prop (chest with giveItem)
                const clickedPropIdx = findInteractivePropAt(x, y);
                if (clickedPropIdx >= 0 && e.button === 0) {
                    // Open item assignment for this prop instance
                    openPropItemAssignment(clickedPropIdx);
                    return;
                }

                if (e.button === 0 && currentItemIndex >= 0) {
                    placeItemAt(x, y);
                } else if (e.button === 2) {
                    removeItemAt(x, y);
                }
                return;
            }

            // Sound mode - click to place/select tile sound, right-click to remove
            if (mode === 'sound' && soundAttachMode === 'tile') {
                const key = `${currentMapName}:${x},${y}`;
                if (e.button === 0) {
                    // If clicking on existing sound, select it for editing
                    if (tileSounds[key]) {
                        selectTileSound(key);
                    } else if (selectedTileSoundKey) {
                        // If a sound is selected and clicking empty tile, deselect
                        deselectTileSound();
                    } else {
                        // Place new sound
                        placeTileSound(x, y);
                    }
                } else if (e.button === 2) {
                    if (selectedTileSoundKey === key) {
                        deselectTileSound();
                    }
                    removeTileSound(key);
                }
                return;
            }

            // Lighting mode - click to place point lights (free placement), right-click to remove
            if (mode === 'lighting') {
                // Use float coordinates for free placement (not grid-snapped)
                const freeX = (e.clientX - rect.left) / tileSize;
                const freeY = (e.clientY - rect.top) / tileSize;

                // Polygon light drawing mode
                if (polyLightDrawing) {
                    if (e.button === 0) {
                        addPolyLightPoint(freeX, freeY);
                    } else if (e.button === 2) {
                        // Right-click finishes polygon
                        finishPolyLight();
                    }
                    return;
                }

                // Normal point light placement
                if (e.button === 0) {
                    placeLightAt(freeX.toFixed(2), freeY.toFixed(2));
                } else if (e.button === 2) {
                    // Find and remove nearest light within 1 tile
                    removeNearestLight(freeX, freeY);
                }
                return;
            }

            // Trigger mode - click to place triggers, right-click to remove, drag green spawns
            if (mode === 'trigger') {
                console.log('[CLICK DEBUG] Trigger mode click at', x, y, 'button:', e.button);
                console.log('[CLICK DEBUG] settingSpawnPoint:', settingSpawnPoint, 'settingWalkOutPoint:', settingWalkOutPoint);

                // Check if we're setting walk-out point (before spawn)
                if (settingWalkOutPoint && e.button === 0) {
                    console.log('[CLICK DEBUG] Calling setWalkOutPointAt');
                    setWalkOutPointAt(x, y);
                    return;
                }

                // Check if we're setting spawn point
                if (settingSpawnPoint && e.button === 0) {
                    console.log('[CLICK DEBUG] Calling setSpawnPointAt');
                    setSpawnPointAt(x, y);
                    return;
                }

                // Check if clicking on a green spawn box (incoming trigger)
                if (e.button === 0) {
                    const incomingTriggers = placedTriggers.filter(t => t.targetMap === currentMapName && t.targetX !== null && t.targetY !== null);
                    for (const trigger of incomingTriggers) {
                        if (x === trigger.targetX && y === trigger.targetY) {
                            // Start dragging this spawn
                            draggingSpawnTrigger = trigger;
                            console.log('[DRAG] Started dragging spawn for Door', trigger.doorNumber);
                            return;
                        }
                    }
                    // Start drag to create trigger area
                    triggerDragStart = { x, y };
                    triggerDragEnd = { x, y };
                    renderMap();
                } else if (e.button === 2) {
                    removeTriggerAt(x, y);
                }
                return;
            }

            // Camera mode - click and drag to set camera bounds
            if (mode === 'camera') {
                if (settingCameraBounds && e.button === 0) {
                    cameraBoundsDragStart = { x, y };
                    cameraBoundsDragEnd = { x, y };
                    renderMap();
                }
                return;
            }

            // Dialog mode - click NPC to attach dialog, or click tile to place sign
            if (mode === 'dialog') {
                if (e.button === 0) {
                    // Check if clicking on an NPC first
                    const npcIdx = findPlacedNpcAt(x, y);
                    if (npcIdx >= 0) {
                        // Attach dialog to this NPC
                        if (currentDialogTileIndex >= 0) {
                            const triggerType = document.getElementById('dialogNpcTrigger')?.value || 'interact';
                            placedNpcs[npcIdx].dialogIndex = currentDialogTileIndex;
                            placedNpcs[npcIdx].dialogTrigger = triggerType;
                            broadcastEdit({ editType: 'attachNpcDialog', npcIndex: npcIdx, dialogIndex: currentDialogTileIndex, dialogTrigger: triggerType });
                            updateDialogNpcDropdown();
                            renderMap();
                        } else {
                            alert('Select a dialog first by clicking it in the list');
                        }
                    } else {
                        // Place dialog tile (sign)
                        placeDialogTileAt(x, y);
                    }
                } else if (e.button === 2) {
                    // Right-click: remove dialog tile or detach from NPC
                    const npcIdx = findPlacedNpcAt(x, y);
                    if (npcIdx >= 0 && placedNpcs[npcIdx].dialogIndex >= 0) {
                        // Detach dialog from NPC
                        placedNpcs[npcIdx].dialogIndex = -1;
                        delete placedNpcs[npcIdx].dialogTrigger;
                        broadcastEdit({ editType: 'attachNpcDialog', npcIndex: npcIdx, dialogIndex: -1 });
                        updateDialogNpcDropdown();
                        renderMap();
                    } else {
                        removeDialogTileAt(x, y);
                    }
                }
                return;
            }

            // NPC mode - place, select, draw path, or edit path
            if (mode === 'npc') {
                if (npcPathEditing && selectedPlacedNpcIndex >= 0) {
                    // Editing path - drag waypoints
                    const placed = placedNpcs[selectedPlacedNpcIndex];
                    if (placed && placed.path) {
                        if (e.button === 0) {
                            // Find closest waypoint to click
                            const waypointIdx = findNearestWaypoint(x, y, placed.path);
                            if (waypointIdx >= 0) {
                                npcDraggingWaypoint = waypointIdx;
                            }
                        } else if (e.button === 2) {
                            // Right-click to delete waypoint
                            const waypointIdx = findNearestWaypoint(x, y, placed.path);
                            if (waypointIdx >= 0) {
                                placed.path.splice(waypointIdx, 1);
                                updateNpcWaypointList();
                                renderMap();
                            }
                        }
                    }
                } else if (npcPathDrawing && selectedPlacedNpcIndex >= 0) {
                    // Drawing path - add waypoint
                    if (e.button === 0) {
                        addNpcWaypoint(x, y);
                    } else if (e.button === 2) {
                        // Right-click removes last waypoint
                        removeLastNpcWaypoint();
                    }
                } else if (e.button === 0) {
                    // Check if clicking on existing placed NPC
                    const clickedNpcIdx = findPlacedNpcAt(x, y);
                    if (clickedNpcIdx >= 0) {
                        selectPlacedNpc(clickedNpcIdx);
                    } else if (currentNpcIndex >= 0) {
                        // Place new NPC
                        placeNpcAt(x, y);
                    }
                } else if (e.button === 2) {
                    // Right-click to remove placed NPC
                    removeNpcAt(x, y);
                }
                return;
            }

            if (e.button === 0) {
                if (eraseMode) {
                    erasing = true;
                } else {
                    painting = true;
                }
                paintAt(x, y);
            }
            if (e.button === 2) {
                erasing = true;
                paintAt(x, y);
            }
        });

        mapCanvas.addEventListener('mousemove', (e) => {
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((e.clientX - rect.left) / tileSize);
            const y = Math.floor((e.clientY - rect.top) / tileSize);

            if (copyMode && copyStart) {
                // Update copy selection
                copyEnd = { x, y };
                renderMap();
                return;
            }

            // Handle spawn point dragging (green boxes)
            if (draggingSpawnTrigger && mode === 'trigger') {
                draggingSpawnTrigger.targetX = x;
                draggingSpawnTrigger.targetY = y;
                renderMap();
                return;
            }

            // Handle trigger area dragging (creating multi-tile triggers)
            if (triggerDragStart && mode === 'trigger') {
                triggerDragEnd = { x, y };
                renderMap();
                return;
            }

            // Handle camera bounds dragging
            if (cameraBoundsDragStart && settingCameraBounds) {
                cameraBoundsDragEnd = { x, y };
                renderMap();
                return;
            }

            // Handle waypoint dragging
            if (npcDraggingWaypoint >= 0 && selectedPlacedNpcIndex >= 0) {
                const placed = placedNpcs[selectedPlacedNpcIndex];
                if (placed && placed.path && placed.path[npcDraggingWaypoint]) {
                    placed.path[npcDraggingWaypoint].x = x;
                    placed.path[npcDraggingWaypoint].y = y;
                    updateNpcWaypointList();
                    renderMap();
                }
                return;
            }

            // Update hover position for preview
            if (hoverMapPos?.x !== x || hoverMapPos?.y !== y) {
                hoverMapPos = { x, y };
                renderMap();
            }

            if (painting || erasing) {
                paintAt(x, y);
            }
        });

        mapCanvas.addEventListener('mouseleave', () => {
            hoverMapPos = null;
            renderMap();
        });

        window.addEventListener('mouseup', (e) => {
            // Stop dragging spawn points
            if (draggingSpawnTrigger) {
                console.log('[DRAG] Stopped dragging spawn for Door', draggingSpawnTrigger.doorNumber,
                    'new position:', draggingSpawnTrigger.targetX, draggingSpawnTrigger.targetY);
                // Sync the trigger update
                const triggerIndex = placedTriggers.indexOf(draggingSpawnTrigger);
                if (triggerIndex >= 0) {
                    broadcastEdit({ editType: 'updateTrigger', index: triggerIndex, trigger: draggingSpawnTrigger });
                }
                draggingSpawnTrigger = null;
                renderMap();
            }

            // Finish trigger area drag - create multi-tile trigger
            if (triggerDragStart && triggerDragEnd) {
                const x1 = Math.min(triggerDragStart.x, triggerDragEnd.x);
                const y1 = Math.min(triggerDragStart.y, triggerDragEnd.y);
                const x2 = Math.max(triggerDragStart.x, triggerDragEnd.x);
                const y2 = Math.max(triggerDragStart.y, triggerDragEnd.y);
                const width = x2 - x1 + 1;
                const height = y2 - y1 + 1;

                // Store dimensions and show modal
                pendingTriggerWidth = width;
                pendingTriggerHeight = height;
                placeTriggerAt(x1, y1);

                triggerDragStart = null;
                triggerDragEnd = null;
                renderMap();
            }

            // Finish camera bounds drag
            if (cameraBoundsDragStart && cameraBoundsDragEnd && settingCameraBounds) {
                setCameraBoundsFromDrag();
            }

            if (copyMode && copyStart && copyEnd) {
                // Finish copy selection
                finishCopyFromMap();
            }
            // End painting/erasing stroke
            painting = false;
            erasing = false;
            // Stop waypoint dragging and broadcast if we were dragging
            if (npcDraggingWaypoint >= 0 && selectedPlacedNpcIndex >= 0) {
                const placed = placedNpcs[selectedPlacedNpcIndex];
                if (placed) {
                    broadcastEdit({ editType: 'updatePlacedNpc', index: selectedPlacedNpcIndex, npc: placed });
                }
            }
            npcDraggingWaypoint = -1;
        });
        mapCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Touch support for mobile
        mapCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((touch.clientX - rect.left) / tileSize);
            const y = Math.floor((touch.clientY - rect.top) / tileSize);

            // Set spawn mode - touch to place player spawn
            if (setSpawnMode) {
                playerPreviewPos.x = x;
                playerPreviewPos.y = y;
                spawnMapName = currentMapName; // Record which map spawn is on
                playerPreviewVisible = true;
                toggleSetSpawnMode();
                renderMap();
                return;
            }

            // Copy mode - touch to start selection
            if (copyMode) {
                copyStart = { x, y };
                copyEnd = { x, y };
                renderMap();
                return;
            }

            // Static object mode - click to place
            if (mode === 'animProp' && currentStaticObjIndex >= 0 && staticObjects[currentStaticObjIndex]) {
                placeStaticObjectAt(x, y);
                return;
            }

            // Animated prop mode
            if (mode === 'animProp' && currentAnimPropIndex >= 0) {
                placeAnimPropAt(x, y);
                return;
            }

            // Sound mode
            if (mode === 'sound' && soundAttachMode === 'tile') {
                const key = `${currentMapName}:${x},${y}`;
                if (tileSounds[key]) {
                    selectTileSound(key);
                } else if (!selectedTileSoundKey) {
                    placeTileSound(x, y);
                }
                renderMap();
                return;
            }

            // Default: paint tiles
            if (eraseMode) {
                erasing = true;
            } else {
                painting = true;
            }
            hoverMapPos = { x, y };
            paintAt(x, y);
            renderMap();
        }, { passive: false });

        mapCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((touch.clientX - rect.left) / tileSize);
            const y = Math.floor((touch.clientY - rect.top) / tileSize);

            // Copy mode - update selection
            if (copyMode && copyStart) {
                copyEnd = { x, y };
                renderMap();
                return;
            }

            if (hoverMapPos?.x !== x || hoverMapPos?.y !== y) {
                hoverMapPos = { x, y };
                renderMap();
            }

            if (painting || erasing) {
                paintAt(x, y);
            }
        }, { passive: false });

        mapCanvas.addEventListener('touchend', (e) => {
            // Copy mode - finish selection
            if (copyMode && copyStart && copyEnd) {
                finishCopyFromMap();
                return;
            }

            painting = false;
            erasing = false;
            hoverMapPos = null;
            renderMap();
        });

        // Animated prop placement helpers - stores directly in layer like tiles
        // Supports multi-tile props based on frame size
        // Properly rotates the entire object shape, not just individual tiles
        function placeAnimPropAt(x, y) {
            if (x < 0 || y < 0 || x >= mapCols || y >= mapRows) return;
            if (!layers[currentLayer]) return;
            if (currentAnimPropIndex < 0 || !animatedProps[currentAnimPropIndex]) return;

            const prop = animatedProps[currentAnimPropIndex];
            const frames = prop.frames || [];
            if (frames.length === 0) return;

            // Calculate how many tiles this prop spans based on first frame size
            const frame = frames[0];
            const origW = Math.ceil(frame.w / gridSize);
            const origH = Math.ceil(frame.h / gridSize);

            // Determine placed dimensions based on rotation (90/270 swap W and H)
            const rot = tileRotation;
            const placedW = (rot === 90 || rot === 270) ? origH : origW;
            const placedH = (rot === 90 || rot === 270) ? origW : origH;

            // Place tiles with proper rotation mapping
            for (let ty = 0; ty < origH; ty++) {
                for (let tx = 0; tx < origW; tx++) {
                    // Calculate rotated position on map
                    let placedTx, placedTy;
                    if (rot === 0) {
                        placedTx = tx;
                        placedTy = ty;
                    } else if (rot === 90) {
                        // 90° CW: (tx, ty) -> (origH - 1 - ty, tx)
                        placedTx = origH - 1 - ty;
                        placedTy = tx;
                    } else if (rot === 180) {
                        // 180°: (tx, ty) -> (origW - 1 - tx, origH - 1 - ty)
                        placedTx = origW - 1 - tx;
                        placedTy = origH - 1 - ty;
                    } else { // 270
                        // 270° CW: (tx, ty) -> (ty, origW - 1 - tx)
                        placedTx = ty;
                        placedTy = origW - 1 - tx;
                    }

                    const px = x + placedTx;
                    const py = y + placedTy;
                    if (px < 0 || py < 0 || px >= mapCols || py >= mapRows) continue;

                    if (!layers[currentLayer][py]) layers[currentLayer][py] = [];

                    // Store original source offset (for sprite lookup), rotation, and scale
                    layers[currentLayer][py][px] = {
                        type: 'animTile',
                        propIndex: currentAnimPropIndex,
                        offsetX: tx,  // Original source tile X (for sprite lookup)
                        offsetY: ty,  // Original source tile Y (for sprite lookup)
                        tilesW: origW,  // Original prop size
                        tilesH: origH,
                        placedW: placedW,  // Placed size (after rotation)
                        placedH: placedH,
                        rotation: rot,
                        scale: currentAnimPropScale  // Scale factor
                    };
                    // Broadcast to co-op builders
                    broadcastEdit({ editType: 'tile', layer: currentLayer, x: px, y: py, cell: layers[currentLayer][py][px], mapName: currentMapName });
                }
            }
            renderMap();
        }

        function removeAnimPropAt(x, y) {
            if (x < 0 || y < 0 || x >= mapCols || y >= mapRows) return;
            if (!layers[currentLayer] || !layers[currentLayer][y]) return;

            const cell = layers[currentLayer][y][x];
            if (cell && cell.type === 'animTile') {
                // Remove all tiles of this multi-tile prop
                const rot = cell.rotation || 0;
                const origW = cell.tilesW || 1;
                const origH = cell.tilesH || 1;
                const offsetX = cell.offsetX || 0;
                const offsetY = cell.offsetY || 0;

                // Calculate placed offset based on rotation (reverse of placement)
                let placedOffX, placedOffY;
                if (rot === 0) {
                    placedOffX = offsetX;
                    placedOffY = offsetY;
                } else if (rot === 90) {
                    placedOffX = origH - 1 - offsetY;
                    placedOffY = offsetX;
                } else if (rot === 180) {
                    placedOffX = origW - 1 - offsetX;
                    placedOffY = origH - 1 - offsetY;
                } else { // 270
                    placedOffX = offsetY;
                    placedOffY = origW - 1 - offsetX;
                }

                // Find origin (top-left of placed object)
                const originX = x - placedOffX;
                const originY = y - placedOffY;

                // Get placed dimensions
                const placedW = (rot === 90 || rot === 270) ? origH : origW;
                const placedH = (rot === 90 || rot === 270) ? origW : origH;

                // Remove all tiles in the placed rectangle
                for (let py = 0; py < placedH; py++) {
                    for (let px = 0; px < placedW; px++) {
                        const mapX = originX + px;
                        const mapY = originY + py;
                        if (mapX < 0 || mapY < 0 || mapX >= mapCols || mapY >= mapRows) continue;
                        if (layers[currentLayer][mapY]) {
                            layers[currentLayer][mapY][mapX] = null;
                            // Broadcast to co-op builders
                            broadcastEdit({ editType: 'eraseTile', layer: currentLayer, x: mapX, y: mapY, mapName: currentMapName });
                        }
                    }
                }
            }
            renderMap();
        }

        // Copy from map functions
        function startCopyFromMap() {
            copyMode = true;
            copyStart = null;
            copyEnd = null;
            copiedTiles = null;
            document.getElementById('copyFromMapBtn').classList.add('active');
            document.getElementById('copyFromMapBtn').textContent = 'Selecting...';
            document.getElementById('copyModeInfo').style.display = 'inline';
            mapCanvas.style.cursor = 'copy';
        }

        function finishCopyFromMap() {
            if (!copyStart || !copyEnd) {
                cancelCopyMode();
                return;
            }

            const minX = Math.min(copyStart.x, copyEnd.x);
            const maxX = Math.max(copyStart.x, copyEnd.x);
            const minY = Math.min(copyStart.y, copyEnd.y);
            const maxY = Math.max(copyStart.y, copyEnd.y);

            const width = maxX - minX + 1;
            const height = maxY - minY + 1;

            // Check if copying all layers
            copiedAllLayers = document.getElementById('copyAllLayers').checked;

            if (copiedAllLayers) {
                // Copy tiles from ALL layers - 3D array [layer][y][x]
                copiedTiles = [];
                for (let li = 0; li < layers.length; li++) {
                    copiedTiles[li] = [];
                    for (let dy = 0; dy < height; dy++) {
                        copiedTiles[li][dy] = [];
                        for (let dx = 0; dx < width; dx++) {
                            const mx = minX + dx;
                            const my = minY + dy;
                            if (my >= 0 && my < mapRows && mx >= 0 && mx < mapCols && layers[li] && layers[li][my]) {
                                copiedTiles[li][dy][dx] = layers[li][my][mx] ? { ...layers[li][my][mx] } : null;
                            } else {
                                copiedTiles[li][dy][dx] = null;
                            }
                        }
                    }
                }
            } else {
                // Copy tiles from current layer only - 2D array [y][x]
                copiedTiles = [];
                for (let dy = 0; dy < height; dy++) {
                    copiedTiles[dy] = [];
                    for (let dx = 0; dx < width; dx++) {
                        const mx = minX + dx;
                        const my = minY + dy;
                        if (my >= 0 && my < mapRows && mx >= 0 && mx < mapCols) {
                            copiedTiles[dy][dx] = map[my][mx] ? { ...map[my][mx] } : null;
                        } else {
                            copiedTiles[dy][dx] = null;
                        }
                    }
                }
            }

            // Set as selected tile data for painting
            selectedTileData = {
                isCopied: true,
                width: width,
                height: height
            };

            // Reset flip when copying from map (copied tiles have their own transforms)
            tileFlippedH = false;
            updateFlipButton();

            // Update preview
            updateCopiedPreview();

            // Exit copy mode
            copyMode = false;
            copyStart = null;
            copyEnd = null;
            document.getElementById('copyFromMapBtn').classList.remove('active');
            document.getElementById('copyFromMapBtn').textContent = 'Copy from Map';
            document.getElementById('copyModeInfo').style.display = 'none';
            mapCanvas.style.cursor = 'crosshair';
            renderMap();
        }

        function cancelCopyMode() {
            copyMode = false;
            copyStart = null;
            copyEnd = null;
            document.getElementById('copyFromMapBtn').classList.remove('active');
            document.getElementById('copyFromMapBtn').textContent = 'Copy from Map';
            document.getElementById('copyModeInfo').style.display = 'none';
            mapCanvas.style.cursor = 'crosshair';
            renderMap();
        }

        function updateCopiedPreview() {
            if (!copiedTiles || copiedTiles.length === 0) return;

            const previewCanvas = document.getElementById('selectedTile');
            if (!previewCanvas) return;
            const previewCtx = previewCanvas.getContext('2d');
            const previewSize = 48;

            // Calculate dimensions based on whether all layers were copied
            let width, height;
            if (copiedAllLayers) {
                // 3D array [layer][y][x]
                height = copiedTiles[0]?.length || 0;
                width = copiedTiles[0]?.[0]?.length || 0;
            } else {
                // 2D array [y][x]
                height = copiedTiles.length;
                width = copiedTiles[0]?.length || 0;
            }

            if (width === 0 || height === 0) return;

            const tilePreviewSize = Math.min(previewSize / width, previewSize / height, 16);

            previewCanvas.width = previewSize;
            previewCanvas.height = previewSize;

            previewCtx.fillStyle = '#333';
            previewCtx.fillRect(0, 0, previewSize, previewSize);
            previewCtx.imageSmoothingEnabled = false;

            if (copiedAllLayers) {
                // Draw all layers composite
                for (let li = 0; li < copiedTiles.length; li++) {
                    for (let dy = 0; dy < height; dy++) {
                        for (let dx = 0; dx < width; dx++) {
                            const cell = copiedTiles[li] && copiedTiles[li][dy] && copiedTiles[li][dy][dx];
                            if (cell) {
                                const px = dx * tilePreviewSize;
                                const py = dy * tilePreviewSize;

                                if (cell.type === 'tile') {
                                    const cellTileset = tilesets[cell.tilesetIndex || 0]?.img || tilesetImg;
                                    if (cellTileset) {
                                        previewCtx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tilePreviewSize, tilePreviewSize);
                                    }
                                } else if (cell.type === 'prop' && propImage) {
                                    previewCtx.drawImage(propImage, cell.x, cell.y, gridSize, gridSize, px, py, tilePreviewSize, tilePreviewSize);
                                }
                            }
                        }
                    }
                }
            } else {
                // Single layer preview
                for (let dy = 0; dy < height; dy++) {
                    for (let dx = 0; dx < width; dx++) {
                        const cell = copiedTiles[dy] && copiedTiles[dy][dx];
                        if (cell) {
                            const px = dx * tilePreviewSize;
                            const py = dy * tilePreviewSize;

                            if (cell.type === 'tile') {
                                const cellTileset = tilesets[cell.tilesetIndex || 0]?.img || tilesetImg;
                                if (cellTileset) {
                                    previewCtx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tilePreviewSize, tilePreviewSize);
                                }
                            } else if (cell.type === 'prop' && propImage) {
                                previewCtx.drawImage(propImage, cell.x, cell.y, gridSize, gridSize, px, py, tilePreviewSize, tilePreviewSize);
                            }
                        }
                    }
                }
            }

            const layerInfo = copiedAllLayers ? ' (all layers)' : '';
            document.getElementById('selectedInfo').textContent = width + 'x' + height + layerInfo;
            document.getElementById('selectedInfo').style.color = copiedAllLayers ? '#5f8' : '#fff';
            document.getElementById('selectedCollisionInfo').textContent = 'From map';
        }

        function paintAt(x, y) {
            // During door animation painting, only allow painting on selected tiles (matching layer)
            if (paintingAnimTiles) {
                const isSelectedTile = selectedAnimTiles.some(t => t.x === x && t.y === y && t.layer === currentLayer);
                if (!isSelectedTile) {
                    return; // Block painting outside selected area
                }
            }

            if (!selectedTileData) {
                if (erasing && x >= 0 && x < mapCols && y >= 0 && y < mapRows) {
                    map[y][x] = null;
                    // Broadcast erase to co-op builders
                    broadcastEdit({ editType: 'eraseTile', layer: currentLayer, x: x, y: y, mapName: currentMapName });
                    renderMap();
                }
                return;
            }

            const selW = selectedTileData.width || 1;
            const selH = selectedTileData.height || 1;

            if (erasing) {
                // Erase area matching selection size
                for (let dy = 0; dy < selH; dy++) {
                    for (let dx = 0; dx < selW; dx++) {
                        const mx = x + dx;
                        const my = y + dy;
                        if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                            map[my][mx] = null;
                            // Broadcast erase to co-op builders
                            broadcastEdit({ editType: 'eraseTile', layer: currentLayer, x: mx, y: my, mapName: currentMapName });
                        }
                    }
                }
            } else if (painting) {
                // Check for flip+rotation combo (Pratt warning)
                if (!selectedTileData.isCopied && !selectedTileData.isProp && tileRotation !== 0 && tileFlippedH) {
                    if (!showPrattWarning()) {
                        return; // User cancelled
                    }
                }
                // Check if painting with copied tiles
                if (selectedTileData.isCopied && copiedTiles) {
                    if (copiedAllLayers) {
                        // Paint copied tiles to ALL layers
                        for (let li = 0; li < copiedTiles.length && li < layers.length; li++) {
                            for (let dy = 0; dy < selH; dy++) {
                                for (let dx = 0; dx < selW; dx++) {
                                    const mx = x + dx;
                                    const my = y + dy;

                                    // Auto-expand map if painting at or beyond edge
                                    if (my >= mapRows - 2) expandMapRows();
                                    if (mx >= mapCols - 2) expandMapCols();

                                    if (mx >= 0 && my >= 0 && mx < mapCols && my < mapRows) {
                                        const srcCell = copiedTiles[li] && copiedTiles[li][dy] && copiedTiles[li][dy][dx];
                                        if (srcCell) {
                                            if (!layers[li][my]) layers[li][my] = [];
                                            layers[li][my][mx] = { ...srcCell };
                                            // Broadcast tile to co-op builders
                                            broadcastEdit({ editType: 'tile', layer: li, x: mx, y: my, cell: layers[li][my][mx], mapName: currentMapName });
                                        }
                                    }
                                }
                            }
                        }
                        // Clear after pasting all layers (one-time paste)
                        copiedTiles = null;
                        copiedAllLayers = false;
                        selectedTileData = null;
                    } else {
                        // Paint copied tiles to current layer only (can paste multiple times)
                        for (let dy = 0; dy < selH; dy++) {
                            for (let dx = 0; dx < selW; dx++) {
                                const mx = x + dx;
                                const my = y + dy;

                                // Auto-expand map if painting at or beyond edge
                                if (my >= mapRows - 2) expandMapRows();
                                if (mx >= mapCols - 2) expandMapCols();

                                if (mx >= 0 && my >= 0 && mx < mapCols && my < mapRows) {
                                    const srcCell = copiedTiles[dy] && copiedTiles[dy][dx];
                                    if (srcCell) {
                                        map[my][mx] = { ...srcCell };
                                        // Broadcast tile to co-op builders
                                        broadcastEdit({ editType: 'tile', layer: currentLayer, x: mx, y: my, cell: map[my][mx], mapName: currentMapName });
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Paint from tileset selection
                    for (let dy = 0; dy < selH; dy++) {
                        for (let dx = 0; dx < selW; dx++) {
                            const mx = x + dx;
                            const my = y + dy;

                            // Auto-expand map if painting at or beyond edge
                            if (my >= mapRows - 2) expandMapRows();
                            if (mx >= mapCols - 2) expandMapCols();

                            if (mx >= 0 && my >= 0 && mx < mapCols && my < mapRows) {
                                // When flipped, mirror the source tile positions horizontally
                                const srcDx = tileFlippedH ? (selW - 1 - dx) : dx;
                                const tileX = selectedTileData.x + srcDx * gridSize;
                                const tileY = selectedTileData.y + dy * gridSize;

                                if (selectedTileData.isProp) {
                                    // Paint as prop with propIndex (collision is painted separately in prop panel)
                                    map[my][mx] = { type: 'prop', x: tileX, y: tileY, propIndex: currentPropIndex };
                                } else {
                                    // Paint as tile with rotation and flip
                                    map[my][mx] = { type: 'tile', x: tileX, y: tileY, rotation: tileRotation, flipped: tileFlippedH, tilesetIndex: currentTilesetIndex };
                                }
                                // Broadcast tile to co-op builders
                                broadcastEdit({ editType: 'tile', layer: currentLayer, x: mx, y: my, cell: map[my][mx], mapName: currentMapName });
                            }
                        }
                    }
                }
            }
            renderMap();
        }

        function renderMap() {
            const tileSize = gridSize * zoom;
            mapCanvas.width = mapCols * tileSize;
            mapCanvas.height = mapRows * tileSize;

            // Background
            mapCtx.fillStyle = '#1a1a1a';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    if ((x + y) % 2 === 0) {
                        mapCtx.fillStyle = '#222';
                        mapCtx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }

            // Grid
            mapCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            for (let x = 0; x <= mapCols; x++) {
                mapCtx.beginPath();
                mapCtx.moveTo(x * tileSize, 0);
                mapCtx.lineTo(x * tileSize, mapCanvas.height);
                mapCtx.stroke();
            }
            for (let y = 0; y <= mapRows; y++) {
                mapCtx.beginPath();
                mapCtx.moveTo(0, y * tileSize);
                mapCtx.lineTo(mapCanvas.width, y * tileSize);
                mapCtx.stroke();
            }

            // Draw all visible layers (bottom to top)
            if (tilesetImg) {
                mapCtx.imageSmoothingEnabled = false;

                for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {
                    // Draw player preview at the right layer position (only on spawn map)
                    if (layerIdx === playerLayerIndex && playerPreviewVisible && currentMapName === spawnMapName) {
                        drawPlayerPreview(tileSize);
                    }

                    if (!layerVisibility[layerIdx]) continue;

                    const layerData = layers[layerIdx];
                    // Dim non-current layers slightly
                    mapCtx.globalAlpha = (layerIdx === currentLayer) ? 1 : 0.7;

                    for (let y = 0; y < mapRows; y++) {
                        for (let x = 0; x < mapCols; x++) {
                            const cell = layerData[y] && layerData[y][x];
                            if (!cell) continue;

                            const px = x * tileSize;
                            const py = y * tileSize;

                            if (cell.type === 'tile') {
                                // Use the correct tileset for this tile
                                const cellTileset = tilesets[cell.tilesetIndex || 0]?.img || tilesetImg;
                                drawRotatedTile(mapCtx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize, cell.rotation || 0, cell.flipped || false);

                                // Show collision only on current layer
                                if (layerIdx === currentLayer) {
                                    // Include tileset index in collision key lookup
                                    const tilesetIdx = cell.tilesetIndex || 0;
                                    const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                                    const collision = tileCollisions[key];
                                    if (collision && collision.length >= 3) {
                                        const scale = tileSize / gridSize;
                                        mapCtx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                                        mapCtx.beginPath();
                                        mapCtx.moveTo(px + collision[0].x * scale, py + collision[0].y * scale);
                                        for (let i = 1; i < collision.length; i++) {
                                            mapCtx.lineTo(px + collision[i].x * scale, py + collision[i].y * scale);
                                        }
                                        mapCtx.closePath();
                                        mapCtx.fill();
                                    }
                                }
                            } else if (cell.type === 'prop') {
                                // Draw prop from the correct prop image
                                const propIdx = cell.propIndex || 0;
                                const propImg = props[propIdx]?.img;
                                if (propImg) {
                                    mapCtx.drawImage(propImg, cell.x, cell.y, gridSize, gridSize, px, py, tileSize, tileSize);
                                }
                            } else if (cell.type === 'animTile') {
                                // Animated tile - cycles through frames (supports multi-tile)
                                const prop = animatedProps[cell.propIndex];
                                if (prop && prop._spriteImg && prop.frames && prop.frames.length > 0) {
                                    // Use origin tile's position for animation sync
                                    const originX = x - (cell.offsetX || 0);
                                    const originY = y - (cell.offsetY || 0);
                                    const key = originX + ',' + originY + ',' + layerIdx;
                                    const animState = placedAnimPropFrames[key] || { frame: 0 };
                                    const frameIdx = animState.frame % prop.frames.length;
                                    const frame = prop.frames[frameIdx];

                                    // Draw only this tile's portion of the frame
                                    const offsetX = cell.offsetX || 0;
                                    const offsetY = cell.offsetY || 0;
                                    const srcX = frame.x + offsetX * gridSize;
                                    const srcY = frame.y + offsetY * gridSize;

                                    // Apply scale factor - scale from prop's origin, not each tile's center
                                    const propScale = cell.scale || 1;
                                    const scaledTileSize = tileSize * propScale;

                                    // Calculate prop's total size to find proper scale origin
                                    const tilesW = cell.tilesW || 1;
                                    const tilesH = cell.tilesH || 1;
                                    const propWidth = tilesW * tileSize;
                                    const propHeight = tilesH * tileSize;
                                    const scaledPropWidth = propWidth * propScale;
                                    const scaledPropHeight = propHeight * propScale;

                                    // Scale offset from prop's center
                                    const propCenterOffsetX = (scaledPropWidth - propWidth) / 2;
                                    const propCenterOffsetY = (scaledPropHeight - propHeight) / 2;

                                    // This tile's position relative to origin
                                    const tileOffsetX = offsetX * tileSize;
                                    const tileOffsetY = offsetY * tileSize;

                                    // Scale tile offset from prop origin
                                    const scaledTileOffsetX = tileOffsetX * propScale;
                                    const scaledTileOffsetY = tileOffsetY * propScale;

                                    // Origin tile's screen position
                                    const originPx = originX * tileSize;
                                    const originPy = originY * tileSize;

                                    // Draw position: origin - center offset + scaled tile offset
                                    const drawX = originPx - propCenterOffsetX + scaledTileOffsetX;
                                    const drawY = originPy - propCenterOffsetY + scaledTileOffsetY;

                                    mapCtx.imageSmoothingEnabled = false;
                                    // Draw with rotation support
                                    const rot = cell.rotation || 0;
                                    if (rot === 0) {
                                        mapCtx.drawImage(prop._spriteImg, srcX, srcY, gridSize, gridSize, drawX, drawY, scaledTileSize, scaledTileSize);
                                    } else {
                                        mapCtx.save();
                                        const propCenterX = originPx + propWidth / 2;
                                        const propCenterY = originPy + propHeight / 2;
                                        mapCtx.translate(propCenterX, propCenterY);
                                        mapCtx.rotate(rot * Math.PI / 180);
                                        const rotDrawX = -scaledPropWidth / 2 + scaledTileOffsetX;
                                        const rotDrawY = -scaledPropHeight / 2 + scaledTileOffsetY;
                                        mapCtx.drawImage(prop._spriteImg, srcX, srcY, gridSize, gridSize, rotDrawX, rotDrawY, scaledTileSize, scaledTileSize);
                                        mapCtx.restore();
                                    }

                                    // Show label in animProp mode (only on origin tile)
                                    if (mode === 'animProp' && offsetX === 0 && offsetY === 0) {
                                        mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
                                        mapCtx.font = '10px sans-serif';
                                        mapCtx.textAlign = 'center';
                                        const nameWidth = mapCtx.measureText(prop.name).width + 4;
                                        mapCtx.fillRect(px + tileSize / 2 - nameWidth / 2, py - 14, nameWidth, 14);
                                        mapCtx.fillStyle = '#fff';
                                        mapCtx.fillText(prop.name, px + tileSize / 2, py - 3);
                                    }
                                }
                            }
                        }
                    }
                }

                // Draw player preview at end if it's beyond all layers (only on spawn map)
                if (playerLayerIndex >= layers.length && playerPreviewVisible && currentMapName === spawnMapName) {
                    drawPlayerPreview(tileSize);
                }

                mapCtx.globalAlpha = 1;
            }

            // Draw copy selection rectangle if in copy mode
            if (copyMode && copyStart && copyEnd) {
                const minX = Math.min(copyStart.x, copyEnd.x);
                const maxX = Math.max(copyStart.x, copyEnd.x);
                const minY = Math.min(copyStart.y, copyEnd.y);
                const maxY = Math.max(copyStart.y, copyEnd.y);

                mapCtx.fillStyle = 'rgba(74, 175, 255, 0.3)';
                mapCtx.fillRect(minX * tileSize, minY * tileSize, (maxX - minX + 1) * tileSize, (maxY - minY + 1) * tileSize);

                mapCtx.strokeStyle = '#4af';
                mapCtx.lineWidth = 3;
                mapCtx.setLineDash([5, 5]);
                mapCtx.strokeRect(minX * tileSize, minY * tileSize, (maxX - minX + 1) * tileSize, (maxY - minY + 1) * tileSize);
                mapCtx.setLineDash([]);
            }

            // Draw transparent preview of selected tiles at hover position
            // Skip when in animProp mode (animProp has its own preview)
            if (hoverMapPos && selectedTileData && !copyMode && mode !== 'animProp') {
                mapCtx.globalAlpha = 0.5;
                const selW = selectedTileData.width || 1;
                const selH = selectedTileData.height || 1;

                // Check if using copied tiles
                if (selectedTileData.isCopied && copiedTiles) {
                    // Draw preview of copied tiles
                    if (copiedAllLayers) {
                        // Draw all layers preview (composite)
                        for (let li = 0; li < copiedTiles.length; li++) {
                            for (let dy = 0; dy < selH; dy++) {
                                for (let dx = 0; dx < selW; dx++) {
                                    const mx = hoverMapPos.x + dx;
                                    const my = hoverMapPos.y + dy;
                                    if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                                        const srcCell = copiedTiles[li] && copiedTiles[li][dy] && copiedTiles[li][dy][dx];
                                        if (srcCell) {
                                            const px = mx * tileSize;
                                            const py = my * tileSize;
                                            if (srcCell.type === 'tile') {
                                                const cellTileset = tilesets[srcCell.tilesetIndex || 0]?.img || tilesetImg;
                                                if (cellTileset) {
                                                    drawRotatedTile(mapCtx, cellTileset, srcCell.x, srcCell.y, gridSize, px, py, tileSize, srcCell.rotation || 0, srcCell.inverted || false);
                                                }
                                            } else if (srcCell.type === 'prop') {
                                                const propIdx = srcCell.propIndex || 0;
                                                const propImg = props[propIdx]?.img;
                                                if (propImg) {
                                                    mapCtx.drawImage(propImg, srcCell.x, srcCell.y, gridSize, gridSize, px, py, tileSize, tileSize);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        // Single layer preview
                        for (let dy = 0; dy < selH; dy++) {
                            for (let dx = 0; dx < selW; dx++) {
                                const mx = hoverMapPos.x + dx;
                                const my = hoverMapPos.y + dy;
                                if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                                    const srcCell = copiedTiles[dy] && copiedTiles[dy][dx];
                                    if (srcCell) {
                                        const px = mx * tileSize;
                                        const py = my * tileSize;
                                        if (srcCell.type === 'tile') {
                                            const cellTileset = tilesets[srcCell.tilesetIndex || 0]?.img || tilesetImg;
                                            if (cellTileset) {
                                                drawRotatedTile(mapCtx, cellTileset, srcCell.x, srcCell.y, gridSize, px, py, tileSize, srcCell.rotation || 0, srcCell.inverted || false);
                                            }
                                        } else if (srcCell.type === 'prop') {
                                            const propIdx = srcCell.propIndex || 0;
                                            const propImg = props[propIdx]?.img;
                                            if (propImg) {
                                                mapCtx.drawImage(propImg, srcCell.x, srcCell.y, gridSize, gridSize, px, py, tileSize, tileSize);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Draw preview from tileset/prop selection
                    const sourceImg = selectedTileData.isProp ? propImage : tilesetImg;

                    if (sourceImg) {
                        for (let dy = 0; dy < selH; dy++) {
                            for (let dx = 0; dx < selW; dx++) {
                                const mx = hoverMapPos.x + dx;
                                const my = hoverMapPos.y + dy;
                                if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                                    // Mirror source tile position when flipped
                                    const srcDx = tileFlippedH ? (selW - 1 - dx) : dx;
                                    const tileX = selectedTileData.x + srcDx * gridSize;
                                    const tileY = selectedTileData.y + dy * gridSize;
                                    const px = mx * tileSize;
                                    const py = my * tileSize;
                                    if (selectedTileData.isProp) {
                                        mapCtx.drawImage(sourceImg, tileX, tileY, gridSize, gridSize, px, py, tileSize, tileSize);
                                    } else {
                                        drawRotatedTile(mapCtx, sourceImg, tileX, tileY, gridSize, px, py, tileSize, tileRotation, tileFlippedH);
                                    }
                                }
                            }
                        }
                    }
                }

                // Draw outline
                mapCtx.globalAlpha = 1;
                mapCtx.strokeStyle = selectedTileData.isCopied ? '#ff0' : (selectedTileData.isProp ? '#4af' : '#0f0');
                mapCtx.lineWidth = 2;
                mapCtx.strokeRect(
                    hoverMapPos.x * tileSize,
                    hoverMapPos.y * tileSize,
                    selW * tileSize,
                    selH * tileSize
                );
            }

            // Draw static object placement preview when hovering
            if (mode === 'animProp' && hoverMapPos && currentStaticObjIndex >= 0 && !copyMode) {
                const obj = staticObjects[currentStaticObjIndex];
                if (obj && obj._spriteImg && obj._spriteImg.complete) {
                    const scale = staticObjPlacementScale;
                    const srcW = obj.width * gridSize;
                    const srcH = obj.height * gridSize;
                    // Use tileSize for canvas display
                    const drawW = obj.width * tileSize * scale;
                    const drawH = obj.height * tileSize * scale;
                    const drawX = hoverMapPos.x * tileSize;
                    const drawY = hoverMapPos.y * tileSize;

                    mapCtx.globalAlpha = 0.5;
                    mapCtx.imageSmoothingEnabled = false;
                    mapCtx.drawImage(obj._spriteImg, 0, 0, srcW, srcH, drawX, drawY, drawW, drawH);
                    mapCtx.globalAlpha = 1;

                    // Outline
                    mapCtx.strokeStyle = '#4a7c59';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(drawX, drawY, drawW, drawH);
                }
            }

            // Draw animated prop placement preview when hovering in animProp mode
            if (mode === 'animProp' && hoverMapPos && currentAnimPropIndex >= 0 && !copyMode) {
                const prop = animatedProps[currentAnimPropIndex];
                if (prop) {
                    const frames = prop.frames || [];
                    const spriteImg = prop._spriteImg;
                    const drawX = hoverMapPos.x * tileSize;
                    const drawY = hoverMapPos.y * tileSize;

                    mapCtx.globalAlpha = 0.5;
                    if (spriteImg && frames.length > 0) {
                        const frame = frames[0];
                        // Calculate how many tiles this prop spans
                        const origW = Math.ceil(frame.w / gridSize);
                        const origH = Math.ceil(frame.h / gridSize);
                        // Apply rotation to dimensions
                        const rot = tileRotation;
                        const placedW = (rot === 90 || rot === 270) ? origH : origW;
                        const placedH = (rot === 90 || rot === 270) ? origW : origH;
                        const drawW = placedW * tileSize;
                        const drawH = placedH * tileSize;

                        mapCtx.imageSmoothingEnabled = false;
                        // Draw with rotation
                        if (rot === 0) {
                            mapCtx.drawImage(spriteImg, frame.x, frame.y, frame.w, frame.h, drawX, drawY, origW * tileSize, origH * tileSize);
                        } else {
                            mapCtx.save();
                            mapCtx.translate(drawX + drawW / 2, drawY + drawH / 2);
                            mapCtx.rotate(rot * Math.PI / 180);
                            // After rotation, draw centered
                            mapCtx.drawImage(spriteImg, frame.x, frame.y, frame.w, frame.h, -origW * tileSize / 2, -origH * tileSize / 2, origW * tileSize, origH * tileSize);
                            mapCtx.restore();
                        }

                        mapCtx.globalAlpha = 1;
                        // Draw outline around full prop area
                        mapCtx.strokeStyle = '#f0a';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(drawX, drawY, drawW, drawH);
                    } else {
                        // Placeholder preview
                        mapCtx.fillStyle = '#f0a';
                        mapCtx.fillRect(drawX + 2, drawY + 2, tileSize - 4, tileSize - 4);
                        mapCtx.globalAlpha = 1;
                        mapCtx.strokeStyle = '#f0a';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(drawX, drawY, tileSize, tileSize);
                    }
                }
            }

            // Draw sound markers when in sound mode
            if (mode === 'sound' && tileSounds) {
                Object.keys(tileSounds).forEach(key => {
                    try {
                        // Filter by current map (keys are "mapName:x,y")
                        if (!key.startsWith(currentMapName + ':')) return;
                        const coords = key.split(':')[1];
                        const parts = coords.split(',');
                        const sx = parseInt(parts[0]) || 0;
                        const sy = parseInt(parts[1]) || 0;
                        const ts = tileSounds[key];
                        if (!ts) return;

                        const px = sx * tileSize + tileSize / 2;
                        const py = sy * tileSize + tileSize / 2;
                        const radius = ts.radius || 3;
                        const isSelected = key === selectedTileSoundKey;

                        // Draw radius circle (highlighted if selected)
                        mapCtx.strokeStyle = isSelected ? 'rgba(0, 255, 100, 0.8)' : 'rgba(255, 165, 0, 0.5)';
                        mapCtx.lineWidth = isSelected ? 3 : 2;
                        mapCtx.setLineDash(isSelected ? [] : [5, 5]);
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, radius * tileSize, 0, Math.PI * 2);
                        mapCtx.stroke();
                        mapCtx.setLineDash([]);

                        // Draw fade zone indicator if selected
                        if (isSelected && ts.fadePercent > 0) {
                            const fadeStartRadius = radius * (1 - ts.fadePercent);
                            mapCtx.strokeStyle = 'rgba(0, 255, 100, 0.4)';
                            mapCtx.lineWidth = 1;
                            mapCtx.setLineDash([3, 3]);
                            mapCtx.beginPath();
                            mapCtx.arc(px, py, fadeStartRadius * tileSize, 0, Math.PI * 2);
                            mapCtx.stroke();
                            mapCtx.setLineDash([]);
                        }

                        // Draw speaker icon (highlighted if selected)
                        mapCtx.fillStyle = isSelected ? '#0f8' : (ts.loop ? '#ffa500' : '#ff6600');
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, tileSize / 4, 0, Math.PI * 2);
                        mapCtx.fill();

                        // Sound wave icon
                        mapCtx.font = `${tileSize / 3}px sans-serif`;
                        mapCtx.textAlign = 'center';
                        mapCtx.textBaseline = 'middle';
                        mapCtx.fillStyle = '#fff';
                        mapCtx.fillText('🔊', px, py);
                    } catch (e) {
                        console.error('Error drawing sound marker:', key, e);
                    }
                });
            }

            // Draw light markers when in lighting mode (but hide guide UI when preview is on)
            if (mode === 'lighting' && pointLights && !lightingPreviewEnabled) {
                Object.keys(pointLights).forEach(key => {
                    try {
                        if (!key.startsWith(currentMapName + ':')) return;
                        const coords = key.split(':')[1];
                        const parts = coords.split(',');
                        const lx = parseInt(parts[0]) || 0;
                        const ly = parseInt(parts[1]) || 0;
                        const light = pointLights[key];
                        if (!light) return;

                        const px = lx * tileSize + tileSize / 2;
                        const py = ly * tileSize + tileSize / 2;
                        const radius = light.radius || 3;

                        // Draw light radius circle
                        mapCtx.strokeStyle = 'rgba(255, 220, 100, 0.6)';
                        mapCtx.lineWidth = 2;
                        mapCtx.setLineDash([5, 5]);
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, radius * tileSize, 0, Math.PI * 2);
                        mapCtx.stroke();
                        mapCtx.setLineDash([]);

                        // Draw light glow gradient preview
                        const gradient = mapCtx.createRadialGradient(px, py, 0, px, py, radius * tileSize);
                        gradient.addColorStop(0, 'rgba(255, 220, 100, 0.3)');
                        gradient.addColorStop(0.6, 'rgba(255, 200, 50, 0.1)');
                        gradient.addColorStop(1, 'rgba(255, 200, 50, 0)');
                        mapCtx.fillStyle = gradient;
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, radius * tileSize, 0, Math.PI * 2);
                        mapCtx.fill();

                        // Draw light bulb icon
                        mapCtx.fillStyle = light.flicker ? '#ffd700' : '#ffaa00';
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, tileSize / 4, 0, Math.PI * 2);
                        mapCtx.fill();

                        mapCtx.font = `${tileSize / 3}px sans-serif`;
                        mapCtx.textAlign = 'center';
                        mapCtx.textBaseline = 'middle';
                        mapCtx.fillStyle = '#fff';
                        mapCtx.fillText('💡', px, py);
                    } catch (e) {
                        console.error('Error drawing light marker:', key, e);
                    }
                });

                // Draw placed polygon lights (guide UI)
                polyLights.filter(pl => pl.mapName === currentMapName).forEach((poly, idx) => {
                    if (poly.points.length < 3) return;

                    // Draw filled polygon with light glow
                    mapCtx.fillStyle = 'rgba(255, 220, 100, ' + (poly.intensity * 0.3) + ')';
                    mapCtx.beginPath();
                    mapCtx.moveTo(poly.points[0].x * tileSize, poly.points[0].y * tileSize);
                    for (let i = 1; i < poly.points.length; i++) {
                        mapCtx.lineTo(poly.points[i].x * tileSize, poly.points[i].y * tileSize);
                    }
                    mapCtx.closePath();
                    mapCtx.fill();

                    // Draw outline
                    mapCtx.strokeStyle = poly.flicker ? '#ffd700' : '#ffaa00';
                    mapCtx.lineWidth = 2;
                    mapCtx.stroke();

                    // Draw vertex points
                    mapCtx.fillStyle = '#0ff';
                    poly.points.forEach(pt => {
                        mapCtx.beginPath();
                        mapCtx.arc(pt.x * tileSize, pt.y * tileSize, 4, 0, Math.PI * 2);
                        mapCtx.fill();
                    });
                });

                // Draw polygon being drawn (preview)
                if (polyLightDrawing && polyLightPoints.length > 0) {
                    // Draw preview lines
                    mapCtx.strokeStyle = '#0ff';
                    mapCtx.lineWidth = 2;
                    mapCtx.setLineDash([5, 5]);
                    mapCtx.beginPath();
                    mapCtx.moveTo(polyLightPoints[0].x * tileSize, polyLightPoints[0].y * tileSize);
                    for (let i = 1; i < polyLightPoints.length; i++) {
                        mapCtx.lineTo(polyLightPoints[i].x * tileSize, polyLightPoints[i].y * tileSize);
                    }
                    mapCtx.stroke();
                    mapCtx.setLineDash([]);

                    // Draw placed points
                    mapCtx.fillStyle = '#0ff';
                    polyLightPoints.forEach((pt, i) => {
                        mapCtx.beginPath();
                        mapCtx.arc(pt.x * tileSize, pt.y * tileSize, 6, 0, Math.PI * 2);
                        mapCtx.fill();

                        // Number the points
                        mapCtx.fillStyle = '#000';
                        mapCtx.font = '10px sans-serif';
                        mapCtx.textAlign = 'center';
                        mapCtx.textBaseline = 'middle';
                        mapCtx.fillText('' + (i + 1), pt.x * tileSize, pt.y * tileSize);
                        mapCtx.fillStyle = '#0ff';
                    });
                }
            }

            // Draw triggers when in trigger mode, camera bounds when in camera mode, dialog tiles when in dialog mode
            if (mode === 'trigger' || mode === 'camera' || mode === 'dialog') {
                // Show trigger drag preview (purple box while dragging)
                if (triggerDragStart && triggerDragEnd) {
                    const x1 = Math.min(triggerDragStart.x, triggerDragEnd.x);
                    const y1 = Math.min(triggerDragStart.y, triggerDragEnd.y);
                    const x2 = Math.max(triggerDragStart.x, triggerDragEnd.x);
                    const y2 = Math.max(triggerDragStart.y, triggerDragEnd.y);
                    const w = (x2 - x1 + 1) * tileSize;
                    const h = (y2 - y1 + 1) * tileSize;

                    mapCtx.fillStyle = 'rgba(255, 0, 255, 0.4)';
                    mapCtx.fillRect(x1 * tileSize, y1 * tileSize, w, h);
                    mapCtx.strokeStyle = '#f0f';
                    mapCtx.lineWidth = 3;
                    mapCtx.setLineDash([5, 5]);
                    mapCtx.strokeRect(x1 * tileSize, y1 * tileSize, w, h);
                    mapCtx.setLineDash([]);

                    // Show dimensions
                    mapCtx.fillStyle = '#fff';
                    mapCtx.font = 'bold 12px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    const dimText = (x2 - x1 + 1) + 'x' + (y2 - y1 + 1);
                    mapCtx.fillText(dimText, x1 * tileSize + w / 2, y1 * tileSize + h / 2);
                }

                // Show spawn point marker following mouse when setting spawn
                if (settingSpawnPoint && hoverMapPos) {
                    const hx = hoverMapPos.x * tileSize;
                    const hy = hoverMapPos.y * tileSize;

                    // Green spawn box follows mouse
                    mapCtx.fillStyle = 'rgba(0, 255, 100, 0.5)';
                    mapCtx.fillRect(hx, hy, tileSize, tileSize);
                    mapCtx.strokeStyle = '#0f0';
                    mapCtx.lineWidth = 3;
                    mapCtx.strokeRect(hx, hy, tileSize, tileSize);

                    // Label
                    mapCtx.fillStyle = '#fff';
                    mapCtx.font = 'bold 10px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    const doorNum = pendingTriggerForSpawn ? pendingTriggerForSpawn.doorNumber : '?';
                    mapCtx.fillText('Door ' + doorNum, hx + tileSize / 2, hy + tileSize / 2 - 6);
                    mapCtx.fillText('SPAWN', hx + tileSize / 2, hy + tileSize / 2 + 6);

                    // Draw instruction banner at top
                    mapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    mapCtx.fillRect(0, 0, mapCanvas.width, 30);
                    mapCtx.fillStyle = '#0f0';
                    mapCtx.font = 'bold 14px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.fillText('CLICK TO PLACE SPAWN FOR DOOR ' + doorNum, mapCanvas.width / 2, 18);
                }

                // Show walk-out point marker following mouse when setting walk-out
                if (settingWalkOutPoint && hoverMapPos) {
                    const hx = hoverMapPos.x * tileSize;
                    const hy = hoverMapPos.y * tileSize;

                    // Cyan walk-out box follows mouse
                    mapCtx.fillStyle = 'rgba(0, 255, 255, 0.5)';
                    mapCtx.fillRect(hx, hy, tileSize, tileSize);
                    mapCtx.strokeStyle = '#0ff';
                    mapCtx.lineWidth = 3;
                    mapCtx.strokeRect(hx, hy, tileSize, tileSize);

                    // Label
                    mapCtx.fillStyle = '#fff';
                    mapCtx.font = 'bold 10px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    const doorNum = pendingWalkOutTrigger ? pendingWalkOutTrigger.doorNumber : '?';
                    mapCtx.fillText('Door ' + doorNum, hx + tileSize / 2, hy + tileSize / 2 - 6);
                    mapCtx.fillText('WALK-OUT', hx + tileSize / 2, hy + tileSize / 2 + 6);

                    // Draw line from door trigger to cursor
                    if (pendingWalkOutTrigger) {
                        const startX = pendingWalkOutTrigger.x * tileSize + tileSize / 2;
                        const startY = pendingWalkOutTrigger.y * tileSize + tileSize / 2;
                        mapCtx.strokeStyle = '#0ff';
                        mapCtx.lineWidth = 2;
                        mapCtx.setLineDash([5, 5]);
                        mapCtx.beginPath();
                        mapCtx.moveTo(startX, startY);
                        mapCtx.lineTo(hx + tileSize / 2, hy + tileSize / 2);
                        mapCtx.stroke();
                        mapCtx.setLineDash([]);
                    }

                    // Draw instruction banner at top
                    mapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    mapCtx.fillRect(0, 0, mapCanvas.width, 30);
                    mapCtx.fillStyle = '#0ff';
                    mapCtx.font = 'bold 14px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.fillText('CLICK WHERE PLAYER WALKS TO BEFORE FADE (DOOR ' + doorNum + ')', mapCanvas.width / 2, 18);
                }

                // Draw triggers ON this map (purple boxes - where you enter)
                const currentTriggers = placedTriggers.filter(t => t.mapName === currentMapName);
                currentTriggers.forEach(trigger => {
                    const px = trigger.x * tileSize;
                    const py = trigger.y * tileSize;
                    const pw = (trigger.width || 1) * tileSize;
                    const ph = (trigger.height || 1) * tileSize;
                    const doorNum = trigger.doorNumber || 1;
                    const doorType = trigger.doorType || 'walkover';
                    const isExternal = doorType === 'external';

                    // Draw trigger zone fill (cyan for external, purple for internal)
                    mapCtx.fillStyle = isExternal ? 'rgba(0, 255, 255, 0.3)' : 'rgba(255, 100, 255, 0.3)';
                    mapCtx.fillRect(px, py, pw, ph);

                    // Draw border
                    mapCtx.strokeStyle = isExternal ? 'rgba(0, 255, 255, 0.8)' : 'rgba(255, 100, 255, 0.8)';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(px, py, pw, ph);

                    // Draw door number label with type indicator
                    mapCtx.fillStyle = '#fff';
                    mapCtx.font = 'bold 11px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    const typeLabel = doorType === 'interact' ? '[E]' : (isExternal ? '[EXT]' : '');
                    mapCtx.fillText('Door ' + doorNum + ' ' + typeLabel, px + pw / 2, py + ph / 2 - 5);

                    // Draw destination below
                    mapCtx.font = '9px monospace';
                    mapCtx.fillStyle = isExternal ? '#0ff' : '#f4f';
                    const destLabel = isExternal ? trigger.externalUrl : trigger.targetMap;
                    mapCtx.fillText('→ ' + destLabel, px + pw / 2, py + ph / 2 + 7);

                    // Draw walk-out point and line if set
                    if (trigger.walkOutX !== null && trigger.walkOutX !== undefined &&
                        trigger.walkOutY !== null && trigger.walkOutY !== undefined) {
                        const woX = trigger.walkOutX * tileSize;
                        const woY = trigger.walkOutY * tileSize;

                        // Draw dashed line from trigger center to walk-out
                        mapCtx.strokeStyle = '#0ff';
                        mapCtx.lineWidth = 2;
                        mapCtx.setLineDash([4, 4]);
                        mapCtx.beginPath();
                        mapCtx.moveTo(px + pw / 2, py + ph / 2);
                        mapCtx.lineTo(woX + tileSize / 2, woY + tileSize / 2);
                        mapCtx.stroke();
                        mapCtx.setLineDash([]);

                        // Draw cyan walk-out box
                        mapCtx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                        mapCtx.fillRect(woX, woY, tileSize, tileSize);
                        mapCtx.strokeStyle = '#0ff';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(woX, woY, tileSize, tileSize);

                        // Label
                        mapCtx.fillStyle = '#0ff';
                        mapCtx.font = 'bold 8px monospace';
                        mapCtx.textAlign = 'center';
                        mapCtx.textBaseline = 'middle';
                        mapCtx.fillText('WALK', woX + tileSize / 2, woY + tileSize / 2 - 4);
                        mapCtx.fillText('OUT', woX + tileSize / 2, woY + tileSize / 2 + 5);
                    }
                });

                // Draw spawn points TO this map (green boxes - where you exit/appear)
                // Only draw if spawn has been set (not null)
                const incomingTriggers = placedTriggers.filter(t => t.targetMap === currentMapName && t.targetX !== null && t.targetY !== null);
                incomingTriggers.forEach(trigger => {
                    const sx = trigger.targetX * tileSize;
                    const sy = trigger.targetY * tileSize;
                    const doorNum = trigger.doorNumber || 1;

                    // Green spawn box
                    mapCtx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    mapCtx.fillRect(sx, sy, tileSize, tileSize);
                    mapCtx.strokeStyle = '#0f0';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(sx, sy, tileSize, tileSize);

                    // Label: "Door X from [mapName]"
                    mapCtx.fillStyle = '#0f0';
                    mapCtx.font = 'bold 10px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    mapCtx.fillText('Door ' + doorNum, sx + tileSize / 2, sy + tileSize / 2 - 5);
                    mapCtx.font = '8px monospace';
                    mapCtx.fillText('from ' + trigger.mapName, sx + tileSize / 2, sy + tileSize / 2 + 6);
                });

                // Draw RETURN spawn points for external doors (cyan boxes - where you return from 3D)
                const externalReturns = placedTriggers.filter(t =>
                    t.doorType === 'external' &&
                    t.mapName === currentMapName &&
                    t.returnX !== null && t.returnY !== null
                );
                externalReturns.forEach(trigger => {
                    const sx = trigger.returnX * tileSize;
                    const sy = trigger.returnY * tileSize;
                    const doorNum = trigger.doorNumber || 1;

                    // Cyan return box
                    mapCtx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                    mapCtx.fillRect(sx, sy, tileSize, tileSize);
                    mapCtx.strokeStyle = '#0ff';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(sx, sy, tileSize, tileSize);

                    // Label: "Door X RETURN"
                    mapCtx.fillStyle = '#0ff';
                    mapCtx.font = 'bold 10px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    mapCtx.fillText('Door ' + doorNum, sx + tileSize / 2, sy + tileSize / 2 - 5);
                    mapCtx.font = '8px monospace';
                    mapCtx.fillText('RETURN', sx + tileSize / 2, sy + tileSize / 2 + 6);
                });

                // Draw dialog tiles (signs) - orange speech bubble markers
                const currentDialogTiles = placedDialogTiles.filter(t => t.mapName === currentMapName);
                currentDialogTiles.forEach(tile => {
                    const tx = tile.x * tileSize;
                    const ty = tile.y * tileSize;
                    const dialogName = dialogs[tile.dialogIndex]?.name || '?';

                    // Orange fill
                    mapCtx.fillStyle = 'rgba(255, 160, 0, 0.4)';
                    mapCtx.fillRect(tx, ty, tileSize, tileSize);

                    // Orange border
                    mapCtx.strokeStyle = '#fa0';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(tx, ty, tileSize, tileSize);

                    // Speech bubble icon (simple triangle + circle)
                    const cx = tx + tileSize / 2;
                    const cy = ty + tileSize / 2 - 3;
                    mapCtx.fillStyle = '#fff';
                    mapCtx.beginPath();
                    mapCtx.arc(cx, cy, tileSize / 4, 0, Math.PI * 2);
                    mapCtx.fill();
                    // Triangle pointer
                    mapCtx.beginPath();
                    mapCtx.moveTo(cx - 3, cy + tileSize / 4 - 2);
                    mapCtx.lineTo(cx - 6, cy + tileSize / 3 + 2);
                    mapCtx.lineTo(cx + 2, cy + tileSize / 4);
                    mapCtx.fill();

                    // Dialog name below
                    mapCtx.fillStyle = '#fa0';
                    mapCtx.font = '8px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'top';
                    mapCtx.fillText(dialogName.substring(0, 8), cx, ty + tileSize + 2);
                });

                // Draw camera bounds (yellow/orange border)
                if (cameraBounds) {
                    const bx = cameraBounds.x * tileSize;
                    const by = cameraBounds.y * tileSize;
                    const bw = cameraBounds.width * tileSize;
                    const bh = cameraBounds.height * tileSize;

                    // Semi-transparent fill outside bounds
                    mapCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    // Top
                    mapCtx.fillRect(0, 0, mapCanvas.width, by);
                    // Bottom
                    mapCtx.fillRect(0, by + bh, mapCanvas.width, mapCanvas.height - (by + bh));
                    // Left
                    mapCtx.fillRect(0, by, bx, bh);
                    // Right
                    mapCtx.fillRect(bx + bw, by, mapCanvas.width - (bx + bw), bh);

                    // Draw bounds border
                    mapCtx.strokeStyle = '#fa0';
                    mapCtx.lineWidth = 3;
                    mapCtx.setLineDash([8, 4]);
                    mapCtx.strokeRect(bx, by, bw, bh);
                    mapCtx.setLineDash([]);

                    // Label
                    mapCtx.fillStyle = '#fa0';
                    mapCtx.font = 'bold 11px monospace';
                    mapCtx.textAlign = 'left';
                    mapCtx.textBaseline = 'top';
                    mapCtx.fillText('CAMERA BOUNDS', bx + 5, by + 5);
                }

                // Draw camera bounds preview while dragging
                if (settingCameraBounds && cameraBoundsDragStart && cameraBoundsDragEnd) {
                    const x1 = Math.min(cameraBoundsDragStart.x, cameraBoundsDragEnd.x);
                    const y1 = Math.min(cameraBoundsDragStart.y, cameraBoundsDragEnd.y);
                    const x2 = Math.max(cameraBoundsDragStart.x, cameraBoundsDragEnd.x);
                    const y2 = Math.max(cameraBoundsDragStart.y, cameraBoundsDragEnd.y);
                    const w = (x2 - x1 + 1) * tileSize;
                    const h = (y2 - y1 + 1) * tileSize;

                    mapCtx.fillStyle = 'rgba(255, 170, 0, 0.2)';
                    mapCtx.fillRect(x1 * tileSize, y1 * tileSize, w, h);
                    mapCtx.strokeStyle = '#fa0';
                    mapCtx.lineWidth = 3;
                    mapCtx.strokeRect(x1 * tileSize, y1 * tileSize, w, h);

                    // Show dimensions
                    mapCtx.fillStyle = '#fff';
                    mapCtx.font = 'bold 12px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    mapCtx.fillText((x2 - x1 + 1) + 'x' + (y2 - y1 + 1) + ' tiles', x1 * tileSize + w / 2, y1 * tileSize + h / 2);
                }
            }

            // === DRAW DOOR ANIMATION SELECTED TILES (orange) ===
            // Draw regardless of mode so they show while in tile mode
            if ((selectingAnimTiles || paintingAnimTiles) && pendingAnimTrigger && doorAnimMapName === currentMapName) {
                // Highlight selected tiles with orange (only on current layer)
                selectedAnimTiles.forEach(tile => {
                    if (tile.layer !== currentLayer) return; // Only show on matching layer
                    const tx = tile.x * tileSize;
                    const ty = tile.y * tileSize;
                    mapCtx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                    mapCtx.fillRect(tx, ty, tileSize, tileSize);
                    mapCtx.strokeStyle = '#f60';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(tx, ty, tileSize, tileSize);
                });
            }

            // === DRAW PLACED NPCs AND PATHS ===
            if (mode === 'npc' || placedNpcs.length > 0) {
                const currentMapNpcs = placedNpcs.filter(p => p.mapName === currentMapName);

                currentMapNpcs.forEach((placed, idx) => {
                    const globalIdx = placedNpcs.indexOf(placed);
                    const npc = npcs[placed.npcIndex];
                    if (!npc) return;

                    const isSelected = globalIdx === selectedPlacedNpcIndex;

                    // Use preview position if preview is active for this NPC
                    const usePreview = npcPathPreviewActive && isSelected && npcPreviewState;
                    const drawX = usePreview ? npcPreviewState.x : placed.x;
                    const drawY = usePreview ? npcPreviewState.y : placed.y;
                    const px = drawX * tileSize;
                    const py = drawY * tileSize;

                    // Draw path if has waypoints (only in NPC mode, hide during preview)
                    if (placed.path && placed.path.length > 0 && mode === 'npc' && !npcPathPreviewActive) {
                        mapCtx.strokeStyle = isSelected ? '#4f4' : 'rgba(100, 255, 100, 0.5)';
                        mapCtx.lineWidth = isSelected ? 3 : 2;
                        mapCtx.setLineDash(isSelected ? [] : [5, 5]);

                        // Draw line from NPC to first waypoint
                        mapCtx.beginPath();
                        mapCtx.moveTo(px + tileSize / 2, py + tileSize / 2);

                        // Draw lines through all waypoints
                        placed.path.forEach((wp, i) => {
                            const wpx = wp.x * tileSize + tileSize / 2;
                            const wpy = wp.y * tileSize + tileSize / 2;
                            mapCtx.lineTo(wpx, wpy);
                        });

                        // If loop trigger, connect back to start
                        if (placed.trigger === 'loop') {
                            mapCtx.lineTo(px + tileSize / 2, py + tileSize / 2);
                        }

                        mapCtx.stroke();
                        mapCtx.setLineDash([]);

                        // Draw waypoint markers
                        placed.path.forEach((wp, i) => {
                            const wpx = wp.x * tileSize + tileSize / 2;
                            const wpy = wp.y * tileSize + tileSize / 2;

                            mapCtx.fillStyle = isSelected ? '#4f4' : 'rgba(100, 255, 100, 0.7)';
                            mapCtx.beginPath();
                            mapCtx.arc(wpx, wpy, 6, 0, Math.PI * 2);
                            mapCtx.fill();

                            // Number
                            mapCtx.fillStyle = '#000';
                            mapCtx.font = 'bold 10px sans-serif';
                            mapCtx.textAlign = 'center';
                            mapCtx.textBaseline = 'middle';
                            mapCtx.fillText((i + 1).toString(), wpx, wpy);
                        });
                    }

                    // Draw NPC sprite - use correct animation if previewing
                    const anims = npc.animations || {};
                    let anim;
                    let frameIdx = 0;

                    if (usePreview && npcPreviewState) {
                        // Use waypoint animation if idling, otherwise directional walk
                        const dirMap = { 'down': 'walkDown', 'up': 'walkUp', 'left': 'walkLeft', 'right': 'walkRight' };
                        if (npcPreviewState.waypointAnimation && npcPreviewState.waypointAnimation !== 'walk' &&
                            anims[npcPreviewState.waypointAnimation] && anims[npcPreviewState.waypointAnimation].length > 0) {
                            // Playing waypoint animation (idle, dance, etc.)
                            anim = anims[npcPreviewState.waypointAnimation];
                        } else {
                            // Walking animation
                            anim = (anims[dirMap[npcPreviewState.direction]]?.length > 0 ? anims[dirMap[npcPreviewState.direction]] : null) ||
                               (anims.walkDown?.length > 0 ? anims.walkDown : null) ||
                               (anims.idle?.length > 0 ? anims.idle : null) ||
                               Object.values(anims).find(a => a && a.length > 0);
                        }
                        frameIdx = npcPreviewState.frame % (anim ? anim.length : 1);
                    } else {
                        anim = (anims.walkDown?.length > 0 ? anims.walkDown : null) ||
                               (anims.idle?.length > 0 ? anims.idle : null) ||
                               Object.values(anims).find(a => a && a.length > 0);
                    }

                    if (npc.spriteData && anim && anim.length > 0) {
                        const frame = anim[frameIdx] || anim[0];
                        const img = npc._editorImg;

                        if (img && img.complete) {
                            mapCtx.imageSmoothingEnabled = false;

                            // Apply per-instance scale
                            const npcScale = placed.scale || 1;
                            const drawW = tileSize * npcScale;
                            const drawH = tileSize * npcScale;

                            // Draw NPC shadow
                            const shadowOffsetX = npc.shadowOffsetX ?? 0;
                            const shadowOffsetY = npc.shadowOffsetY ?? 4;
                            const shadowWidthRatio = npc.shadowWidth ?? 0.35;
                            const shadowHeightRatio = npc.shadowHeight ?? 0.12;
                            mapCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                            mapCtx.beginPath();
                            mapCtx.ellipse(
                                px + tileSize / 2 + shadowOffsetX,
                                py + tileSize - shadowOffsetY,
                                drawW * shadowWidthRatio,
                                drawW * shadowHeightRatio,
                                0, 0, Math.PI * 2
                            );
                            mapCtx.fill();
                            // Center larger/smaller NPCs on the tile
                            const offsetX = (tileSize - drawW) / 2;
                            const offsetY = tileSize - drawH; // Anchor at bottom

                            // Determine which animation key is being used for mirror check
                            let animKey = 'walkDown';
                            if (usePreview && npcPreviewState) {
                                if (npcPreviewState.waypointAnimation && npcPreviewState.waypointAnimation !== 'walk' &&
                                    anims[npcPreviewState.waypointAnimation] && anims[npcPreviewState.waypointAnimation].length > 0) {
                                    animKey = npcPreviewState.waypointAnimation;
                                } else {
                                    const dirMap = { 'down': 'walkDown', 'up': 'walkUp', 'left': 'walkLeft', 'right': 'walkRight' };
                                    animKey = dirMap[npcPreviewState.direction] || 'walkDown';
                                }
                            }
                            // Flip for mirrored animations OR left direction fallback
                            const animMirrors = npc.animMirrors || {};
                            const isMirrored = animMirrors[animKey];
                            const flipX = isMirrored || (usePreview && npcPreviewState && npcPreviewState.direction === 'left' && !anims.walkLeft?.length);
                            if (flipX) {
                                mapCtx.save();
                                mapCtx.translate(px + offsetX + drawW, py + offsetY);
                                mapCtx.scale(-1, 1);
                                mapCtx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, drawW, drawH);
                                mapCtx.restore();
                            } else {
                                mapCtx.drawImage(img, frame.x, frame.y, frame.w, frame.h, px + offsetX, py + offsetY, drawW, drawH);
                            }
                        } else {
                            // Load image if not cached
                            if (!npc._editorImg) {
                                npc._editorImg = new Image();
                                npc._editorImg.onload = () => renderMap();
                                npc._editorImg.src = npc.spriteData;
                            }
                            // Draw placeholder
                            mapCtx.fillStyle = '#a4f';
                            mapCtx.fillRect(px + 4, py + 4, tileSize - 8, tileSize - 8);
                        }
                    } else {
                        // No sprite - draw placeholder
                        mapCtx.fillStyle = '#a4f';
                        mapCtx.fillRect(px + 4, py + 4, tileSize - 8, tileSize - 8);
                    }

                    // Draw selection highlight
                    if (isSelected) {
                        mapCtx.strokeStyle = '#4f4';
                        mapCtx.lineWidth = 3;
                        mapCtx.strokeRect(px, py, tileSize, tileSize);
                    }

                    // Draw enemy AI radius circles when selected
                    if (isSelected && placed.isEnemy && mode === 'npc') {
                        const centerX = px + tileSize / 2;
                        const centerY = py + tileSize / 2;

                        // Vision radius (outer ring - yellow/orange)
                        const visionRadius = (placed.visionRadius || 5) * tileSize;
                        mapCtx.strokeStyle = 'rgba(255, 200, 50, 0.8)';
                        mapCtx.lineWidth = 2;
                        mapCtx.setLineDash([8, 4]);
                        mapCtx.beginPath();
                        mapCtx.arc(centerX, centerY, visionRadius, 0, Math.PI * 2);
                        mapCtx.stroke();
                        // Fill with transparent
                        mapCtx.fillStyle = 'rgba(255, 200, 50, 0.1)';
                        mapCtx.fill();

                        // Attack radius (inner ring - red)
                        const attackRadius = (placed.attackRange || 1) * tileSize;
                        mapCtx.strokeStyle = 'rgba(255, 80, 80, 0.9)';
                        mapCtx.lineWidth = 2;
                        mapCtx.setLineDash([4, 4]);
                        mapCtx.beginPath();
                        mapCtx.arc(centerX, centerY, attackRadius, 0, Math.PI * 2);
                        mapCtx.stroke();
                        // Fill with transparent red
                        mapCtx.fillStyle = 'rgba(255, 80, 80, 0.15)';
                        mapCtx.fill();

                        mapCtx.setLineDash([]);
                    }

                    // Draw NPC name label
                    if (mode === 'npc') {
                        mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
                        mapCtx.font = '10px sans-serif';
                        mapCtx.textAlign = 'center';
                        const nameWidth = mapCtx.measureText(npc.name).width + 4;
                        mapCtx.fillRect(px + tileSize / 2 - nameWidth / 2, py - 14, nameWidth, 14);
                        mapCtx.fillStyle = isSelected ? '#4f4' : '#fff';
                        mapCtx.fillText(npc.name, px + tileSize / 2, py - 3);
                    }

                    // Draw dialog indicator for NPCs with dialogs attached (in dialog or npc mode)
                    if ((mode === 'dialog' || mode === 'npc') && placed.dialogIndex >= 0) {
                        const iconX = px + tileSize - 12;
                        const iconY = py - 8;
                        // Speech bubble icon background
                        mapCtx.fillStyle = '#4af';
                        mapCtx.beginPath();
                        mapCtx.ellipse(iconX, iconY, 10, 8, 0, 0, Math.PI * 2);
                        mapCtx.fill();
                        // Triangle tail
                        mapCtx.beginPath();
                        mapCtx.moveTo(iconX - 4, iconY + 6);
                        mapCtx.lineTo(iconX - 8, iconY + 14);
                        mapCtx.lineTo(iconX + 2, iconY + 6);
                        mapCtx.fill();
                        // "..." dots
                        mapCtx.fillStyle = '#000';
                        mapCtx.beginPath();
                        mapCtx.arc(iconX - 4, iconY, 2, 0, Math.PI * 2);
                        mapCtx.arc(iconX, iconY, 2, 0, Math.PI * 2);
                        mapCtx.arc(iconX + 4, iconY, 2, 0, Math.PI * 2);
                        mapCtx.fill();
                    }
                });
            }

            // === DRAW PLACED ITEMS ===
            if (mode === 'item' || placedItems.length > 0) {
                const currentMapItems = placedItems.filter(p => !p.mapName || p.mapName === currentMapName);

                currentMapItems.forEach((placed, idx) => {
                    const item = items[placed.itemIndex];
                    if (!item || !item.frames || item.frames.length === 0) return;

                    const px = placed.x * tileSize;
                    const py = placed.y * tileSize;

                    // Get idle frame
                    const idleIdx = item.idleFrame || 0;
                    const frame = item.frames[idleIdx] || item.frames[0];

                    // Load/use sprite image
                    if (!item._spriteImg && item.spriteData) {
                        item._spriteImg = new Image();
                        item._spriteImg.src = item.spriteData;
                    }

                    if (item._spriteImg && item._spriteImg.complete) {
                        mapCtx.imageSmoothingEnabled = false;
                        const drawW = (item.frameWidth / gridSize) * tileSize;
                        const drawH = (item.frameHeight / gridSize) * tileSize;
                        mapCtx.drawImage(item._spriteImg,
                            frame.x, frame.y, frame.w, frame.h,
                            px, py, drawW, drawH
                        );
                    }

                    // Draw item highlight and label in item mode
                    if (mode === 'item') {
                        mapCtx.strokeStyle = '#4f8';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(px, py, tileSize, tileSize);

                        // Name label
                        mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
                        mapCtx.font = '10px sans-serif';
                        mapCtx.textAlign = 'center';
                        const nameWidth = mapCtx.measureText(item.name).width + 4;
                        mapCtx.fillRect(px + tileSize / 2 - nameWidth / 2, py - 14, nameWidth, 14);
                        mapCtx.fillStyle = '#4f8';
                        mapCtx.fillText(item.name, px + tileSize / 2, py - 3);
                    }
                });
            }

            // === DRAW PLACED STATIC OBJECTS ===
            placedStaticObjects.forEach(placed => {
                if (placed.mapName !== currentMapName) return;

                const obj = staticObjects[placed.objIndex];
                if (!obj || !obj._spriteImg || !obj._spriteImg.complete) return;

                const scale = placed.scale || 1;
                const srcW = obj.width * gridSize;
                const srcH = obj.height * gridSize;
                // Convert to canvas coordinates and apply scale
                const drawW = obj.width * tileSize * scale;
                const drawH = obj.height * tileSize * scale;

                // placed.x/y are in grid coordinates
                const drawX = placed.x * tileSize;
                const drawY = placed.y * tileSize;

                mapCtx.imageSmoothingEnabled = false;
                mapCtx.drawImage(
                    obj._spriteImg,
                    0, 0, srcW, srcH,
                    drawX, drawY, drawW, drawH
                );

                // Show outline in animProp mode
                if (mode === 'animProp') {
                    mapCtx.strokeStyle = '#4a7c59';
                    mapCtx.lineWidth = 2;
                    mapCtx.strokeRect(drawX, drawY, drawW, drawH);
                }
            });

            // === HIGHLIGHT INTERACTIVE ANIM PROPS IN ITEM MODE ===
            // Show animated props that have giveItem enabled so users can click to assign specific items
            if (mode === 'item') {
                placedAnimProps.forEach((placed, idx) => {
                    if (placed.mapName && placed.mapName !== currentMapName) return;
                    const prop = animatedProps[placed.propIndex];
                    if (!prop || !prop.giveItem) return;

                    // Calculate prop bounds
                    const frames = prop.frames || [];
                    if (frames.length === 0) return;
                    const frame = frames[0];
                    const tilesW = Math.ceil(frame.w / gridSize);
                    const tilesH = Math.ceil(frame.h / gridSize);

                    const px = placed.x * tileSize;
                    const py = placed.y * tileSize;
                    const pw = tilesW * tileSize;
                    const ph = tilesH * tileSize;

                    // Orange dashed border for interactive props
                    mapCtx.strokeStyle = '#fa0';
                    mapCtx.lineWidth = 3;
                    mapCtx.setLineDash([6, 4]);
                    mapCtx.strokeRect(px + 2, py + 2, pw - 4, ph - 4);
                    mapCtx.setLineDash([]);

                    // Get item name - instance override or default from prop
                    const hasInstanceItem = placed.instanceItemIndex !== undefined && placed.instanceItemIndex >= 0;
                    const itemIdx = hasInstanceItem ? placed.instanceItemIndex : prop.giveItemIndex;
                    const itemName = (itemIdx >= 0 && items[itemIdx]) ? items[itemIdx].name : 'No Item';

                    // Background for label
                    mapCtx.fillStyle = hasInstanceItem ? 'rgba(0, 200, 100, 0.8)' : 'rgba(255, 150, 0, 0.8)';
                    mapCtx.font = 'bold 10px sans-serif';
                    const labelText = hasInstanceItem ? '🎁 ' + itemName : '📦 ' + itemName;
                    const textWidth = mapCtx.measureText(labelText).width + 6;
                    mapCtx.fillRect(px + pw / 2 - textWidth / 2, py - 16, textWidth, 14);

                    // Item label text
                    mapCtx.fillStyle = '#fff';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'middle';
                    mapCtx.fillText(labelText, px + pw / 2, py - 9);

                    // "Click to set item" hint at bottom
                    mapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    mapCtx.font = '9px sans-serif';
                    const hintText = 'Click to set item';
                    const hintWidth = mapCtx.measureText(hintText).width + 4;
                    mapCtx.fillRect(px + pw / 2 - hintWidth / 2, py + ph + 2, hintWidth, 12);
                    mapCtx.fillStyle = '#fa0';
                    mapCtx.fillText(hintText, px + pw / 2, py + ph + 8);
                });
            }

            // === HIGHLIGHT ANIMATED PROPS IN EDIT MODE ===
            // Yellow highlight when "Edit Object on Map" is active in animProp mode
            if (mode === 'animProp' && editAnimPropOnMapMode) {
                // Scan all layers for animTiles and highlight them
                const highlightedOrigins = new Set(); // Track which props we've highlighted
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li];
                    if (!layer) continue;
                    for (let y = 0; y < mapRows; y++) {
                        if (!layer[y]) continue;
                        for (let x = 0; x < mapCols; x++) {
                            const cell = layer[y][x];
                            if (!cell || cell.type !== 'animTile') continue;

                            // Only highlight at origin to avoid duplicates
                            const originX = x - (cell.offsetX || 0);
                            const originY = y - (cell.offsetY || 0);
                            const originKey = originX + ',' + originY + ',' + li;
                            if (highlightedOrigins.has(originKey)) continue;
                            highlightedOrigins.add(originKey);

                            const prop = animatedProps[cell.propIndex];
                            if (!prop) continue;

                            // Calculate prop size
                            const tilesW = cell.tilesW || 1;
                            const tilesH = cell.tilesH || 1;
                            const px = originX * tileSize;
                            const py = originY * tileSize;
                            const pw = tilesW * tileSize;
                            const ph = tilesH * tileSize;

                            // Yellow highlight border
                            mapCtx.strokeStyle = '#ff0';
                            mapCtx.lineWidth = 3;
                            mapCtx.setLineDash([6, 4]);
                            mapCtx.strokeRect(px + 2, py + 2, pw - 4, ph - 4);
                            mapCtx.setLineDash([]);

                            // Show current mode label
                            const instanceMode = cell.instancePlayMode || 'default';
                            let modeLabel = instanceMode === 'default' ? 'Default' : (instanceMode === 'loop' ? 'Loop' : 'Timed');
                            if (instanceMode === 'timed') {
                                modeLabel += ' (' + (cell.instancePlayCount || 1) + 'x, ' + (cell.instanceWaitTime || 2) + 's)';
                            }

                            // Background for label
                            mapCtx.fillStyle = instanceMode === 'default' ? 'rgba(100, 100, 100, 0.8)' : 'rgba(255, 200, 0, 0.9)';
                            mapCtx.font = 'bold 9px sans-serif';
                            const textWidth = mapCtx.measureText(modeLabel).width + 6;
                            mapCtx.fillRect(px + pw / 2 - textWidth / 2, py - 14, textWidth, 12);

                            // Mode label text
                            mapCtx.fillStyle = '#000';
                            mapCtx.textAlign = 'center';
                            mapCtx.textBaseline = 'middle';
                            mapCtx.fillText(modeLabel, px + pw / 2, py - 8);

                            // "Click to edit" hint
                            mapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                            mapCtx.font = '8px sans-serif';
                            const hintText = 'Click to edit';
                            const hintWidth = mapCtx.measureText(hintText).width + 4;
                            mapCtx.fillRect(px + pw / 2 - hintWidth / 2, py + ph + 2, hintWidth, 10);
                            mapCtx.fillStyle = '#ff0';
                            mapCtx.fillText(hintText, px + pw / 2, py + ph + 7);
                        }
                    }
                }
            }

            // === LIGHTING PREVIEW OVERLAY ===
            if (lightingPreviewEnabled) {
                // Get darkness level from slider (0-100 -> 0-0.95)
                const darknessSlider = document.getElementById('previewDarknessSlider');
                const darknessLevel = darknessSlider ? parseInt(darknessSlider.value) / 100 * 0.95 : 0.7;

                if (darknessLevel > 0) {
                    // Create offscreen canvas for lighting
                    const lightCanvas = document.createElement('canvas');
                    lightCanvas.width = mapCanvas.width;
                    lightCanvas.height = mapCanvas.height;
                    const lightCtx = lightCanvas.getContext('2d');

                    // Fill with darkness (black with slider-controlled alpha)
                    lightCtx.fillStyle = 'rgba(0, 0, 20, ' + darknessLevel + ')';
                    lightCtx.fillRect(0, 0, lightCanvas.width, lightCanvas.height);

                    // Cut out point lights
                    lightCtx.globalCompositeOperation = 'destination-out';
                    Object.keys(pointLights).forEach(key => {
                        if (!key.startsWith(currentMapName + ':')) return;
                        const light = pointLights[key];
                        const coords = key.split(':')[1].split(',');
                        const lx = parseFloat(coords[0]);
                        const ly = parseFloat(coords[1]);
                        const px = lx * tileSize + tileSize / 2;
                        const py = ly * tileSize + tileSize / 2;
                        const radius = light.radius * tileSize;

                        const gradient = lightCtx.createRadialGradient(px, py, 0, px, py, radius);
                        gradient.addColorStop(0, 'rgba(255,255,255,1)');
                        gradient.addColorStop(0.6, 'rgba(255,255,255,0.5)');
                        gradient.addColorStop(1, 'rgba(255,255,255,0)');
                        lightCtx.fillStyle = gradient;
                        lightCtx.beginPath();
                        lightCtx.arc(px, py, radius, 0, Math.PI * 2);
                        lightCtx.fill();
                    });

                    // Cut out polygon lights
                    polyLights.filter(pl => pl.mapName === currentMapName).forEach(poly => {
                        if (poly.points.length < 3) return;
                        lightCtx.beginPath();
                        lightCtx.moveTo(poly.points[0].x * tileSize, poly.points[0].y * tileSize);
                        for (let i = 1; i < poly.points.length; i++) {
                            lightCtx.lineTo(poly.points[i].x * tileSize, poly.points[i].y * tileSize);
                        }
                        lightCtx.closePath();
                        lightCtx.fillStyle = 'rgba(255,255,255,' + (poly.intensity || 1) + ')';
                        lightCtx.fill();
                    });

                    // Draw lighting overlay on map
                    mapCtx.drawImage(lightCanvas, 0, 0);
                }
            }

            // === DRAW INITIAL SPAWN POINT MARKER ===
            // Only show on the map where spawn is set
            if (playerPreviewPos && currentMapName === spawnMapName) {
                const spawnX = playerPreviewPos.x * tileSize;
                const spawnY = playerPreviewPos.y * tileSize;

                // Green spawn box
                mapCtx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                mapCtx.fillRect(spawnX, spawnY, tileSize, tileSize);
                mapCtx.strokeStyle = '#0f0';
                mapCtx.lineWidth = 2;
                mapCtx.strokeRect(spawnX, spawnY, tileSize, tileSize);

                // Label: "SPAWN" and "from [mapName]"
                mapCtx.fillStyle = '#0f0';
                mapCtx.font = 'bold 10px monospace';
                mapCtx.textAlign = 'center';
                mapCtx.textBaseline = 'middle';
                mapCtx.fillText('START', spawnX + tileSize / 2, spawnY + tileSize / 2 - 6);
                mapCtx.font = '9px monospace';
                mapCtx.fillStyle = '#8f8';
                mapCtx.fillText('(' + playerPreviewPos.x + ',' + playerPreviewPos.y + ')', spawnX + tileSize / 2, spawnY + tileSize / 2 + 7);
            }

            // === DRAW GAME PLAYERS (visible to builder when co-op) ===
            if (gamePlayersInBuilder.size > 0) {
                // Same frame data as game test
                const idleFrames = {
                    down: [0, 1, 2],
                    up: [3, 4, 5],
                    right: [6, 7, 8],
                    left: [6, 7, 8]
                };
                const walkFrames = {
                    down: { row: 0, cols: [9, 10, 11, 12] },
                    up: { row: 0, cols: [13, 14, 15] },
                    right: { row: 1, cols: [1, 2, 3, 4] },
                    left: { row: 1, cols: [1, 2, 3, 4] }
                };

                gamePlayersInBuilder.forEach((gPlayer, id) => {
                    // Only show players on current map
                    if (gPlayer.currentMap !== currentMapName) return;

                    // Game coords are 4x builder coords (TILE_SCALE=2 + cameraZoom=2)
                    const px = (gPlayer.x / 4) * zoom;
                    const py = (gPlayer.y / 4) * zoom;

                    const frameWidth = 64;
                    const frameHeight = 64;
                    const drawSize = tileSize * 1.5;
                    const dir = gPlayer.direction || 'down';
                    const frame = gPlayer.frame || 0;

                    let row = 0;
                    let col = 0;
                    let flipX = dir === 'left';

                    if (gPlayer.animation === 'walk') {
                        const walk = walkFrames[dir];
                        row = walk.row;
                        col = walk.cols[frame % walk.cols.length];
                    } else {
                        row = 0;
                        col = idleFrames[dir][frame % idleFrames[dir].length];
                    }

                    if (playerSpriteImg && playerSpriteImg.complete && playerSpriteImg.naturalWidth > 0) {
                        // Draw shadow
                        mapCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        mapCtx.beginPath();
                        mapCtx.ellipse(px, py + drawSize * 0.4, drawSize * 0.3, drawSize * 0.1, 0, 0, Math.PI * 2);
                        mapCtx.fill();

                        // Draw sprite
                        mapCtx.save();
                        if (flipX) {
                            mapCtx.translate(px + drawSize / 2, py - drawSize / 2);
                            mapCtx.scale(-1, 1);
                            mapCtx.drawImage(playerSpriteImg,
                                col * frameWidth, row * frameHeight, frameWidth, frameHeight,
                                0, 0, drawSize, drawSize);
                        } else {
                            mapCtx.drawImage(playerSpriteImg,
                                col * frameWidth, row * frameHeight, frameWidth, frameHeight,
                                px - drawSize / 2, py - drawSize / 2, drawSize, drawSize);
                        }
                        mapCtx.restore();
                    } else {
                        // Fallback: simple colored circle with direction indicator
                        mapCtx.fillStyle = 'rgba(0, 255, 255, 0.8)';
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, 12 * zoom, 0, Math.PI * 2);
                        mapCtx.fill();
                        mapCtx.fillStyle = '#000';
                        mapCtx.font = '8px monospace';
                        mapCtx.textAlign = 'center';
                        mapCtx.fillText(dir[0], px, py + 3);
                    }

                    // Draw name above player
                    mapCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    mapCtx.font = 'bold ' + (10 * zoom) + 'px monospace';
                    mapCtx.textAlign = 'center';
                    mapCtx.textBaseline = 'bottom';
                    const nameWidth = mapCtx.measureText(gPlayer.name).width + 8;
                    mapCtx.fillRect(px - nameWidth / 2, py - drawSize / 2 - 16 * zoom, nameWidth, 14 * zoom);
                    mapCtx.fillStyle = '#0ff';
                    mapCtx.fillText(gPlayer.name, px, py - drawSize / 2 - 4 * zoom);
                });
            }

            // === DEBUG: Show click coords ===
            if (window.debugClickPos) {
                const dx = window.debugClickPos.x * zoom;
                const dy = window.debugClickPos.y * zoom;
                mapCtx.fillStyle = '#f0f';
                mapCtx.beginPath();
                mapCtx.arc(dx, dy, 8 * zoom, 0, Math.PI * 2);
                mapCtx.fill();
                mapCtx.fillStyle = '#fff';
                mapCtx.font = 'bold 12px monospace';
                mapCtx.textAlign = 'left';
                mapCtx.fillText('DEBUG: ' + window.debugClickPos.x + ',' + window.debugClickPos.y, dx + 10, dy);
            }

            // Update expand button positions after canvas resize
            positionExpandButtons();
        }

        // Zoom
        function updateZoomDisplay() {
            document.getElementById('zoomLevel').textContent = zoom + 'x';
            const toolbarZoom = document.getElementById('zoomLevelToolbar');
            if (toolbarZoom) toolbarZoom.textContent = zoom + 'x';
        }
        function zoomIn() { if (zoom < 4) { zoom++; updateZoomDisplay(); renderMap(); } }
        function zoomOut() { if (zoom > 1) { zoom--; updateZoomDisplay(); renderMap(); } }

        // Only zoom with scroll when grab tool is active
        document.getElementById('mapViewport').addEventListener('wheel', (e) => {
            if (grabToolActive) {
                e.preventDefault();
                if (e.deltaY < 0) zoomIn(); else zoomOut();
            }
        });

        function clearMap() { if (confirm('Clear entire map?')) { initMap(); mapInitialized = true; broadcastEdit({ editType: 'clearMap', mapName: currentMapName }); renderMap(); } }

        // ===== GRAB TOOL =====
        let grabToolActive = false;
        let grabbing = false;
        let grabStartX = 0;
        let grabStartY = 0;
        let grabScrollX = 0;
        let grabScrollY = 0;

        // Tools menu toggle
        function toggleToolsMenu() {
            const menu = document.getElementById('toolsMenu');
            menu.classList.toggle('open');
        }

        // UI Theme changer
        function setUITheme(color) {
            // Apply to panel and toolbar
            document.querySelectorAll('.panel').forEach(el => el.style.background = color);
            document.querySelectorAll('.toolbar').forEach(el => el.style.background = color);
            document.querySelectorAll('.tools-menu').forEach(el => el.style.background = color);

            // Update active swatch indicator
            document.querySelectorAll('.theme-swatch').forEach(el => {
                el.classList.toggle('active', el.style.background === color);
            });

            // Update color picker
            const picker = document.getElementById('customThemeColor');
            if (picker) picker.value = color;

            // Save to localStorage
            localStorage.setItem('builderUITheme', color);
        }

        // Load saved theme on startup
        (function loadSavedTheme() {
            const saved = localStorage.getItem('builderUITheme');
            if (saved) {
                setTimeout(() => setUITheme(saved), 100);
            }
        })();

        // Close tools menu when clicking outside
        document.addEventListener('click', function(e) {
            const dropdown = document.querySelector('.tools-dropdown');
            const menu = document.getElementById('toolsMenu');
            if (dropdown && menu && !dropdown.contains(e.target)) {
                menu.classList.remove('open');
            }
        });

        function toggleGrabTool() {
            grabToolActive = !grabToolActive;
            const btn = document.getElementById('grabToolBtn');
            const canvas = document.getElementById('mapCanvas');
            const hint = document.getElementById('toolHint');

            if (grabToolActive) {
                btn.classList.add('active');
                canvas.classList.add('grabbing');
                hint.textContent = 'Drag to pan | Scroll to zoom';
                // Clear selected tiles when grab tool is activated
                selectedTiles = [];
                document.getElementById('selectedInfo').textContent = 'No tile selected';
                document.getElementById('selectedInfo').style.color = '#888';
                document.getElementById('selectedCollisionInfo').textContent = 'Click tileset to select';
                const canvas = document.getElementById('selectedTile');
                if (canvas) canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
            } else {
                btn.classList.remove('active');
                canvas.classList.remove('grabbing');
                hint.textContent = 'R:rotate | I:flip | E:erase';
            }
        }

        // Grab/pan handlers
        const mapViewport = document.getElementById('mapViewport');

        mapCanvas.addEventListener('mousedown', (e) => {
            if (grabToolActive && e.button === 0) {
                grabbing = true;
                grabStartX = e.clientX;
                grabStartY = e.clientY;
                grabScrollX = mapViewport.scrollLeft;
                grabScrollY = mapViewport.scrollTop;
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (grabbing) {
                const dx = e.clientX - grabStartX;
                const dy = e.clientY - grabStartY;
                mapViewport.scrollLeft = grabScrollX - dx;
                mapViewport.scrollTop = grabScrollY - dy;
            }
        });

        document.addEventListener('mouseup', () => {
            grabbing = false;
        });

        // Touch support for grab tool (iPad/mobile)
        mapCanvas.addEventListener('touchstart', (e) => {
            if (grabToolActive && e.touches.length === 1) {
                grabbing = true;
                grabStartX = e.touches[0].clientX;
                grabStartY = e.touches[0].clientY;
                grabScrollX = mapViewport.scrollLeft;
                grabScrollY = mapViewport.scrollTop;
                e.preventDefault();
            }
        }, { passive: false });

        mapCanvas.addEventListener('touchmove', (e) => {
            if (grabbing && e.touches.length === 1) {
                const dx = e.touches[0].clientX - grabStartX;
                const dy = e.touches[0].clientY - grabStartY;
                mapViewport.scrollLeft = grabScrollX - dx;
                mapViewport.scrollTop = grabScrollY - dy;
                e.preventDefault();
            }
        }, { passive: false });

        mapCanvas.addEventListener('touchend', () => {
            grabbing = false;
        });

        mapCanvas.addEventListener('touchcancel', () => {
            grabbing = false;
        });

        // ===== EXPAND MAP =====
        function expandMap(direction, fromNetwork = false) {
            const expandAmount = 5; // Add 5 rows/cols at a time

            if (direction === 'right') {
                mapCols += expandAmount;
                layers.forEach(layer => {
                    for (let y = 0; y < layer.length; y++) {
                        for (let i = 0; i < expandAmount; i++) {
                            layer[y].push(null);
                        }
                    }
                });
            } else if (direction === 'left') {
                mapCols += expandAmount;
                layers.forEach(layer => {
                    for (let y = 0; y < layer.length; y++) {
                        for (let i = 0; i < expandAmount; i++) {
                            layer[y].unshift(null);
                        }
                    }
                });
                // Shift placed animated props
                placedAnimProps.forEach(ap => { if (!ap.mapName || ap.mapName === currentMapName) ap.x += expandAmount; });
                // Shift placed props
                placedProps.forEach(prop => { if (!prop.mapName || prop.mapName === currentMapName) prop.x += expandAmount; });
                // Shift placed NPCs
                placedNpcs.forEach(npc => { if (!npc.mapName || npc.mapName === currentMapName) { npc.x += expandAmount; if (npc.path) npc.path.forEach(wp => wp.x += expandAmount); } });
                // Shift placed items
                placedItems.forEach(item => { if (!item.mapName || item.mapName === currentMapName) item.x += expandAmount; });
                // Shift placed triggers
                placedTriggers.forEach(t => { if (!t.mapName || t.mapName === currentMapName) { t.x += expandAmount; if (t.targetMap === currentMapName) t.targetX += expandAmount; } });
            } else if (direction === 'bottom') {
                mapRows += expandAmount;
                layers.forEach(layer => {
                    for (let i = 0; i < expandAmount; i++) {
                        const newRow = [];
                        for (let x = 0; x < mapCols; x++) newRow.push(null);
                        layer.push(newRow);
                    }
                });
            } else if (direction === 'top') {
                mapRows += expandAmount;
                layers.forEach(layer => {
                    for (let i = 0; i < expandAmount; i++) {
                        const newRow = [];
                        for (let x = 0; x < mapCols; x++) newRow.push(null);
                        layer.unshift(newRow);
                    }
                });
                // Shift placed animated props
                placedAnimProps.forEach(ap => { if (!ap.mapName || ap.mapName === currentMapName) ap.y += expandAmount; });
                // Shift placed props
                placedProps.forEach(prop => { if (!prop.mapName || prop.mapName === currentMapName) prop.y += expandAmount; });
                // Shift placed NPCs
                placedNpcs.forEach(npc => { if (!npc.mapName || npc.mapName === currentMapName) { npc.y += expandAmount; if (npc.path) npc.path.forEach(wp => wp.y += expandAmount); } });
                // Shift placed items
                placedItems.forEach(item => { if (!item.mapName || item.mapName === currentMapName) item.y += expandAmount; });
                // Shift placed triggers
                placedTriggers.forEach(t => { if (!t.mapName || t.mapName === currentMapName) { t.y += expandAmount; if (t.targetMap === currentMapName) t.targetY += expandAmount; } });
            }

            if (!fromNetwork) {
                broadcastEdit({ editType: 'expandMap', direction: direction, mapName: currentMapName });
            }
            renderMap();
        }

        // Position expand buttons at map edges
        function positionExpandButtons() {
            const canvas = document.getElementById('mapCanvas');
            const viewport = document.getElementById('mapViewport');
            if (!canvas || !viewport) return;

            const padding = 40; // viewport padding
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            const topBtn = document.querySelector('.expand-top');
            const bottomBtn = document.querySelector('.expand-bottom');
            const leftBtn = document.querySelector('.expand-left');
            const rightBtn = document.querySelector('.expand-right');

            if (topBtn) {
                topBtn.style.left = (padding + canvasWidth / 2 - 30) + 'px';
            }
            if (bottomBtn) {
                bottomBtn.style.left = (padding + canvasWidth / 2 - 30) + 'px';
                bottomBtn.style.top = (padding + canvasHeight + 5) + 'px';
            }
            if (leftBtn) {
                leftBtn.style.top = (padding + canvasHeight / 2 - 30) + 'px';
            }
            if (rightBtn) {
                rightBtn.style.left = (padding + canvasWidth + 5) + 'px';
                rightBtn.style.top = (padding + canvasHeight / 2 - 30) + 'px';
            }
        }

        // ===== MULTIPLE PROPS SYSTEM =====
        // Props work just like tilesets - load images, select area, paint on map
        // Each prop has its own collision masks

        function loadPropImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Save current prop's collision masks before switching
                    if (currentPropIndex >= 0 && props[currentPropIndex]) {
                        props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
                    }

                    // Add new prop to array
                    const newProp = {
                        name: file.name,
                        img: img,
                        data: e.target.result,
                        collisionMasks: {}
                    };
                    props.push(newProp);
                    currentPropIndex = props.length - 1;

                    // Set current prop shortcuts
                    propImage = img;
                    propImageData = e.target.result;
                    propCollisionMasks = newProp.collisionMasks;
                    propSelection = null;

                    updatePropDropdown();
                    updatePropUI();
                    drawPropTileset();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function switchProp() {
            const select = document.getElementById('propSelect');
            const newIndex = parseInt(select.value);

            // Save current prop's collision masks
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Switch to new prop
            currentPropIndex = newIndex;
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                propImage = props[currentPropIndex].img;
                propImageData = props[currentPropIndex].data;
                propCollisionMasks = props[currentPropIndex].collisionMasks || {};
            } else {
                propImage = null;
                propImageData = null;
                propCollisionMasks = {};
            }

            propSelection = null;
            updatePropUI();
            drawPropTileset();
            renderMap();
        }

        function updatePropDropdown() {
            const select = document.getElementById('propSelect');
            if (!select) return;
            select.innerHTML = '';

            if (props.length === 0) {
                const opt = document.createElement('option');
                opt.value = -1;
                opt.textContent = 'No props loaded';
                select.appendChild(opt);
            } else {
                props.forEach((prop, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = prop.name;
                    if (i === currentPropIndex) opt.selected = true;
                    select.appendChild(opt);
                });
            }
        }

        function updatePropUI() {
            const propControls = document.getElementById('propControls');
            const noPropMessage = document.getElementById('noPropMessage');
            if (!propControls || !noPropMessage) return;
            const hasProps = props.length > 0 && currentPropIndex >= 0;
            propControls.style.display = hasProps ? 'block' : 'none';
            noPropMessage.style.display = hasProps ? 'none' : 'block';
        }

        function drawPropTileset() {
            if (!propTilesetCanvas || !propTilesetCtx) return;
            if (!propImage) {
                propTilesetCanvas.width = 200;
                propTilesetCanvas.height = 50;
                propTilesetCtx.fillStyle = '#333';
                propTilesetCtx.fillRect(0, 0, 200, 50);
                propTilesetCtx.fillStyle = '#888';
                propTilesetCtx.font = '12px sans-serif';
                propTilesetCtx.fillText('Load a prop image...', 20, 30);
                return;
            }

            const displayZoom = 3; // Larger zoom for easier collision painting
            propTilesetCanvas.width = propImage.naturalWidth * displayZoom;
            propTilesetCanvas.height = propImage.naturalHeight * displayZoom;

            propTilesetCtx.imageSmoothingEnabled = false;
            propTilesetCtx.drawImage(propImage, 0, 0, propTilesetCanvas.width, propTilesetCanvas.height);

            // Draw collision overlay (red pixels where collision is set)
            if (propTool === 'collision' || propTool === 'erase') {
                const cols = Math.floor(propImage.naturalWidth / gridSize);
                const rows = Math.floor(propImage.naturalHeight / gridSize);

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const tileX = col * gridSize;
                        const tileY = row * gridSize;
                        const key = tileX + ',' + tileY;
                        const mask = propCollisionMasks[key];

                        if (mask) {
                            for (let py = 0; py < gridSize; py++) {
                                for (let px = 0; px < gridSize; px++) {
                                    if (mask[py] && mask[py][px]) {
                                        propTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                                        propTilesetCtx.fillRect(
                                            (tileX + px) * displayZoom,
                                            (tileY + py) * displayZoom,
                                            displayZoom,
                                            displayZoom
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Grid
            propTilesetCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            const cols = Math.floor(propImage.naturalWidth / gridSize);
            const rows = Math.floor(propImage.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                propTilesetCtx.beginPath();
                propTilesetCtx.moveTo(x * gridSize * displayZoom, 0);
                propTilesetCtx.lineTo(x * gridSize * displayZoom, propTilesetCanvas.height);
                propTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                propTilesetCtx.beginPath();
                propTilesetCtx.moveTo(0, y * gridSize * displayZoom);
                propTilesetCtx.lineTo(propTilesetCanvas.width, y * gridSize * displayZoom);
                propTilesetCtx.stroke();
            }

            // Highlight selection (only in select mode)
            if (propSelection && propTool === 'select') {
                propTilesetCtx.fillStyle = 'rgba(74, 175, 255, 0.4)';
                propTilesetCtx.strokeStyle = '#4af';
                propTilesetCtx.lineWidth = 2;
                propTilesetCtx.fillRect(
                    propSelection.x * displayZoom,
                    propSelection.y * displayZoom,
                    propSelection.width * displayZoom,
                    propSelection.height * displayZoom
                );
                propTilesetCtx.strokeRect(
                    propSelection.x * displayZoom,
                    propSelection.y * displayZoom,
                    propSelection.width * displayZoom,
                    propSelection.height * displayZoom
                );
            }
        }

        // Prop tileset selection and collision painting
        let propSelectionStart = null;

        function paintPropCollisionAt(canvasX, canvasY, isErasing) {
            const displayZoom = 3;
            const imgX = Math.floor(canvasX / displayZoom);
            const imgY = Math.floor(canvasY / displayZoom);

            // Find which tile this pixel belongs to
            const tileCol = Math.floor(imgX / gridSize);
            const tileRow = Math.floor(imgY / gridSize);
            const tileX = tileCol * gridSize;
            const tileY = tileRow * gridSize;
            const key = tileX + ',' + tileY;

            // Initialize mask if needed
            if (!propCollisionMasks[key]) {
                propCollisionMasks[key] = [];
                for (let y = 0; y < gridSize; y++) {
                    propCollisionMasks[key][y] = new Array(gridSize).fill(false);
                }
            }

            // Paint with brush
            const halfBrush = Math.floor(propBrushSize / 2);
            for (let dy = -halfBrush; dy < halfBrush; dy++) {
                for (let dx = -halfBrush; dx < halfBrush; dx++) {
                    const px = imgX + dx;
                    const py = imgY + dy;

                    // Get the tile for this pixel
                    const ptileCol = Math.floor(px / gridSize);
                    const ptileRow = Math.floor(py / gridSize);
                    const ptileX = ptileCol * gridSize;
                    const ptileY = ptileRow * gridSize;
                    const pkey = ptileX + ',' + ptileY;

                    // Local coords within tile
                    const localX = px - ptileX;
                    const localY = py - ptileY;

                    if (localX >= 0 && localX < gridSize && localY >= 0 && localY < gridSize) {
                        if (!propCollisionMasks[pkey]) {
                            propCollisionMasks[pkey] = [];
                            for (let y = 0; y < gridSize; y++) {
                                propCollisionMasks[pkey][y] = new Array(gridSize).fill(false);
                            }
                        }
                        propCollisionMasks[pkey][localY][localX] = !isErasing;
                    }
                }
            }

            drawPropTileset();
        }

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mousedown', (e) => {
            if (!propImage) return;
            const rect = propTilesetCanvas.getBoundingClientRect();
            const displayZoom = 3;

            if (propTool === 'select') {
                // Tile selection mode
                const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
                const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;
                propSelectionStart = { x, y };
            } else {
                // Collision painting mode
                propPainting = true;
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                paintPropCollisionAt(canvasX, canvasY, propTool === 'erase');
            }
        });

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mousemove', (e) => {
            if (!propImage || !propPainting) return;
            if (propTool === 'collision' || propTool === 'erase') {
                const rect = propTilesetCanvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                paintPropCollisionAt(canvasX, canvasY, propTool === 'erase');
            }
        });

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mouseup', (e) => {
            if (!propImage) return;

            if (propTool === 'select' && propSelectionStart) {
                const rect = propTilesetCanvas.getBoundingClientRect();
                const displayZoom = 3;
                const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
                const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

                const minX = Math.min(propSelectionStart.x, x);
                const minY = Math.min(propSelectionStart.y, y);
                const maxX = Math.max(propSelectionStart.x, x) + gridSize;
                const maxY = Math.max(propSelectionStart.y, y) + gridSize;

                propSelection = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };

                // When in prop mode, set this as the selected tile data for painting
                if (mode === 'prop') {
                    selectedTileData = {
                        x: minX,
                        y: minY,
                        width: (maxX - minX) / gridSize,
                        height: (maxY - minY) / gridSize,
                        isProp: true // Flag to indicate this is from prop image
                    };
                }

                propSelectionStart = null;
                drawPropTileset();
            }

            propPainting = false;
        });

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mouseleave', () => {
            propPainting = false;
        });

        if (propTilesetCanvas) propTilesetCanvas.style.cursor = 'crosshair';

        // Expand map size
        function expandMapRows() {
            mapRows += 10;
            layers.forEach(layer => {
                while (layer.length < mapRows) {
                    layer.push(new Array(mapCols).fill(null));
                }
            });
        }

        function expandMapCols() {
            mapCols += 10;
            layers.forEach(layer => {
                layer.forEach((row, i) => {
                    if (row) {
                        while (row.length < mapCols) row.push(null);
                    }
                });
            });
        }

        // ===== NPC FUNCTIONS =====
        let npcCurrentAnim = 'walkDown'; // Currently selected animation type
        let npcAnimations = {}; // { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], attackDown: [], ... }
        let npcAnimMirrors = {}; // { walkLeft: true } - animations to render flipped horizontally

        function openNpcEditor(editIndex = -1) {
            // Check if someone else is already editing this NPC
            if (editIndex >= 0 && isBeingEdited('npc', editIndex)) {
                const editor = getEditor('npc', editIndex);
                if (!confirm(`"${editor}" is currently editing this NPC.\n\nEditing simultaneously may cause conflicts.\n\nOpen anyway?`)) {
                    return;
                }
            }

            npcStopPreview();
            npcEditorEditingIndex = editIndex;

            // Broadcast that we're editing this NPC
            if (editIndex >= 0) {
                startEditing('npc', editIndex);
            }

            npcCurrentAnim = 'walkDown';
            npcAnimations = { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], attackDown: [], attackUp: [], attackLeft: [], attackRight: [] };
            npcAnimMirrors = {}; // Reset mirror flags
            // Reset collision tool to Select mode
            npcTool = 'none';
            npcPainting = false;
            setNpcTool('none');

            if (editIndex >= 0 && npcs[editIndex]) {
                // Editing existing NPC
                const npc = npcs[editIndex];
                npcEditorFrameW = npc.frameWidth || 32;
                npcEditorFrameH = npc.frameHeight || 32;
                npcEditorData = npc.spriteData;
                document.getElementById('npcNameInput').value = npc.name;
                const fps = npc.fps || 8;
                document.getElementById('npcSpeedSlider').value = fps;
                document.getElementById('npcSpeedLabel').textContent = fps + ' fps';

                // Load animations
                if (npc.animations) {
                    npcAnimations = JSON.parse(JSON.stringify(npc.animations));
                }
                // Load mirror flags
                if (npc.animMirrors) {
                    npcAnimMirrors = JSON.parse(JSON.stringify(npc.animMirrors));
                }
                // Load ping-pong setting
                npcPingPong = npc.pingPong || false;
                document.getElementById('npcPingPong').checked = npcPingPong;

                // Load collision mask and split line
                npcSplitLine = npc.splitLine ?? null;

                if (npc.spriteData) {
                    npcEditorImage = new Image();
                    npcEditorImage.onload = () => {
                        document.getElementById('npcFrameSection').style.display = 'block';
                        document.getElementById('npcAnimSection').style.display = 'block';
                        document.getElementById('npcNameSection').style.display = 'block';
                        document.getElementById('npcCollisionSection').style.display = 'block';
                        document.getElementById('npcShadowSection').style.display = 'block';
                        // Load shadow settings from NPC
                        const shadowOffsetX = npc.shadowOffsetX ?? 0;
                        const shadowOffset = npc.shadowOffsetY ?? 4;
                        const shadowWidth = Math.round((npc.shadowWidth ?? 0.35) * 100);
                        const shadowHeight = Math.round((npc.shadowHeight ?? 0.12) * 100);
                        document.getElementById('npcShadowOffsetXSlider').value = shadowOffsetX;
                        document.getElementById('npcShadowOffsetXVal').textContent = shadowOffsetX;
                        document.getElementById('npcShadowOffsetSlider').value = shadowOffset;
                        document.getElementById('npcShadowOffsetVal').textContent = shadowOffset;
                        document.getElementById('npcShadowWidthSlider').value = shadowWidth;
                        document.getElementById('npcShadowWidthVal').textContent = shadowWidth;
                        document.getElementById('npcShadowHeightSlider').value = shadowHeight;
                        document.getElementById('npcShadowHeightVal').textContent = shadowHeight;
                        // Load collision insets (or migrate from old formats)
                        if (npc.collisionInsets) {
                            npcCollisionInsets = { ...npc.collisionInsets };
                        } else if (npc.collisionBox) {
                            // Migrate old collisionBox to insets
                            const frameW = npc.frameWidth || 32;
                            const frameH = npc.frameHeight || 32;
                            npcCollisionInsets = {
                                top: npc.collisionBox.y || 0,
                                bottom: frameH - (npc.collisionBox.y || 0) - (npc.collisionBox.height || frameH),
                                left: npc.collisionBox.x || 0,
                                right: frameW - (npc.collisionBox.x || 0) - (npc.collisionBox.width || frameW)
                            };
                        } else {
                            npcCollisionInsets = null;
                        }
                        // Update collision status display
                        const status = document.getElementById('npcCollisionStatus');
                        const ins = npcCollisionInsets;
                        if (ins && (ins.top > 0 || ins.bottom > 0 || ins.left > 0 || ins.right > 0)) {
                            const boxW = (npc.frameWidth || 32) - ins.left - ins.right;
                            const boxH = (npc.frameHeight || 32) - ins.top - ins.bottom;
                            status.textContent = `Box: ${boxW}x${boxH}px`;
                            status.style.color = '#0ff';
                        } else {
                            status.textContent = 'Full sprite';
                            status.style.color = '#888';
                        }
                        npcUpdateGrid();
                        npcDrawCanvas();
                        npcUpdateFramesList();
                        npcStartPreview();
                    };
                    npcEditorImage.src = npc.spriteData;
                    document.getElementById('npcFileName').textContent = 'Sprite loaded';
                }
            } else {
                // New NPC
                npcEditorImage = null;
                npcEditorData = null;
                npcEditorFrameW = 32;
                npcEditorFrameH = 32;
                npcCollisionBox = null;
                // Reset collision status display
                const status = document.getElementById('npcCollisionStatus');
                if (status) {
                    status.textContent = 'No collision box set';
                    status.style.color = '#888';
                }
                document.getElementById('npcNameInput').value = '';
                document.getElementById('npcSpeedSlider').value = 8;
                document.getElementById('npcSpeedLabel').textContent = '8 fps';
                npcPingPong = false;
                document.getElementById('npcPingPong').checked = false;
                document.getElementById('npcFileName').textContent = '';
                document.getElementById('npcFrameSection').style.display = 'none';
                document.getElementById('npcAnimSection').style.display = 'none';
                document.getElementById('npcNameSection').style.display = 'none';
                document.getElementById('npcCollisionSection').style.display = 'none';
                document.getElementById('npcShadowSection').style.display = 'none';
                // Reset shadow sliders to defaults
                document.getElementById('npcShadowOffsetXSlider').value = 0;
                document.getElementById('npcShadowOffsetXVal').textContent = '0';
                document.getElementById('npcShadowOffsetSlider').value = 4;
                document.getElementById('npcShadowOffsetVal').textContent = '4';
                document.getElementById('npcShadowWidthSlider').value = 35;
                document.getElementById('npcShadowWidthVal').textContent = '35';
                document.getElementById('npcShadowHeightSlider').value = 12;
                document.getElementById('npcShadowHeightVal').textContent = '12';
                // Clear canvases
                const previewCtx = document.getElementById('npcLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 96, 96);
                const editorCanvas = document.getElementById('npcEditorCanvas');
                const editorCtx = editorCanvas.getContext('2d');
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                const framesList = document.getElementById('npcFramesList');
                if (framesList) framesList.innerHTML = '';
                const fileInput = document.getElementById('npcFileInput');
                if (fileInput) fileInput.value = '';
            }

            npcSelectAnim('walkDown');
            document.getElementById('npcModal').classList.add('visible');
        }

        function npcLoadSheet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                npcEditorData = e.target.result;
                npcEditorImage = new Image();
                npcEditorImage.onload = () => {
                    document.getElementById('npcFileName').textContent = file.name + ' (' + npcEditorImage.naturalWidth + 'x' + npcEditorImage.naturalHeight + ')';
                    document.getElementById('npcFrameSection').style.display = 'block';
                    document.getElementById('npcAnimSection').style.display = 'block';
                    document.getElementById('npcNameSection').style.display = 'block';
                    document.getElementById('npcCollisionSection').style.display = 'block';
                    document.getElementById('npcShadowSection').style.display = 'block';
                    // Initialize collision mask for new image
                    const w = npcEditorImage.naturalWidth;
                    const h = npcEditorImage.naturalHeight;
                    npcCollisionMask = Array(h).fill(null).map(() => Array(w).fill(0));
                    npcSplitLine = null;
                    npcUpdateGrid();
                    npcDrawCanvas();
                };
                npcEditorImage.src = npcEditorData;
            };
            reader.readAsDataURL(file);
        }

        function npcSetFrameSize(w, h) {
            npcEditorFrameW = w;
            npcEditorFrameH = h;
            npcUpdateGrid();
            npcDrawCanvas();
        }

        function npcResetGrid() {
            npcEditorFrameW = 32;
            npcEditorFrameH = 32;
            npcUpdateGrid();
            npcDrawCanvas();
        }

        function npcUpdateGrid() {
            if (npcEditorImage) {
                const cols = Math.floor(npcEditorImage.naturalWidth / npcEditorFrameW);
                const rows = Math.floor(npcEditorImage.naturalHeight / npcEditorFrameH);
                document.getElementById('npcGridInfo').textContent = cols + ' cols x ' + rows + ' rows (' + npcEditorFrameW + 'x' + npcEditorFrameH + ')';
            }
            npcDrawCanvas();
        }

        function npcSelectAnim(animName) {
            npcCurrentAnim = animName;
            // Update all button states and show frame counts
            npcUpdateAnimButtons();
            // Update display
            const names = { walkDown: 'Walk Down', walkUp: 'Walk Up', walkLeft: 'Walk Left', walkRight: 'Walk Right', idle: 'Idle', attackDown: 'Attack Down', attackUp: 'Attack Up', attackLeft: 'Attack Left', attackRight: 'Attack Right' };
            document.getElementById('npcCurrentAnimName').textContent = names[animName] || animName;
            // Update mirror button state
            npcUpdateMirrorButton();
            npcDrawCanvas();
            npcUpdateFramesList();
            npcStartPreview();
        }

        function npcToggleMirror() {
            npcAnimMirrors[npcCurrentAnim] = !npcAnimMirrors[npcCurrentAnim];
            npcUpdateMirrorButton();
            npcStartPreview(); // Restart preview with new mirror state
        }

        function npcUpdateMirrorButton() {
            const btn = document.getElementById('npcMirrorBtn');
            if (npcAnimMirrors[npcCurrentAnim]) {
                btn.style.background = '#48f';
                btn.style.color = '#000';
                btn.style.borderColor = '#48f';
                btn.textContent = 'Mirrored';
            } else {
                btn.style.background = '#555';
                btn.style.color = '#fff';
                btn.style.borderColor = '#888';
                btn.textContent = 'Mirror';
            }
        }

        function npcUpdateAnimButtons() {
            const animMap = {
                'Down': 'walkDown',
                'Up': 'walkUp',
                'Left': 'walkLeft',
                'Right': 'walkRight',
                'Idle': 'idle',
                'AttackDown': 'attackDown',
                'AttackUp': 'attackUp',
                'AttackLeft': 'attackLeft',
                'AttackRight': 'attackRight'
            };
            const labels = {
                'Down': '↓ Walk',
                'Up': '↑ Walk',
                'Left': '← Walk',
                'Right': '→ Walk',
                'Idle': 'Idle',
                'AttackDown': '↓ Atk',
                'AttackUp': '↑ Atk',
                'AttackLeft': '← Atk',
                'AttackRight': '→ Atk'
            };
            const attackAnims = ['AttackDown', 'AttackUp', 'AttackLeft', 'AttackRight'];

            for (const [dir, animKey] of Object.entries(animMap)) {
                const btn = document.getElementById('npcAnim' + dir);
                if (btn) {
                    const frames = npcAnimations[animKey] || [];
                    const isActive = npcCurrentAnim === animKey;
                    const isAttack = attackAnims.includes(dir);
                    btn.classList.toggle('active', isActive);

                    // Show frame count and checkmark if has frames
                    if (frames.length > 0) {
                        btn.innerHTML = `✓ ${labels[dir]} <span style="color:#4f4;">(${frames.length})</span>`;
                        btn.style.background = isActive ? (isAttack ? '#844' : '#2a5a2a') : (isAttack ? '#633' : '#1a3a1a');
                    } else {
                        btn.innerHTML = labels[dir];
                        btn.style.background = isActive ? (isAttack ? '#955' : '#555') : (isAttack ? '#744' : '#333');
                    }
                }
            }
            // Update custom animations list
            npcUpdateCustomAnimList();
        }

        function npcAddCustomAnim() {
            const input = document.getElementById('npcCustomAnimName');
            const name = input.value.trim().toLowerCase().replace(/\s+/g, '_');
            if (!name) return;

            // Don't allow duplicates or reserved names
            const reserved = ['walkdown', 'walkup', 'walkleft', 'walkright', 'idle'];
            if (reserved.includes(name) || npcAnimations[name]) {
                alert('Animation "' + name + '" already exists');
                return;
            }

            // Create the new animation category
            npcAnimations[name] = [];
            input.value = '';

            // Select the new animation
            npcSelectAnim(name);
        }

        function npcUpdateCustomAnimList() {
            const container = document.getElementById('npcCustomAnimList');
            if (!container) return;

            // Get custom animations (not the default ones)
            const defaultAnims = ['walkDown', 'walkUp', 'walkLeft', 'walkRight', 'idle', 'attackDown', 'attackUp', 'attackLeft', 'attackRight'];
            const customAnims = Object.keys(npcAnimations).filter(k => !defaultAnims.includes(k));

            if (customAnims.length === 0) {
                container.innerHTML = '';
                return;
            }

            let html = '<div style="font-size:10px; color:#888; margin-bottom:3px;">Custom:</div>';
            html += '<div style="display:flex; flex-direction:column; gap:3px;">';
            customAnims.forEach(name => {
                const frames = npcAnimations[name] || [];
                const isActive = npcCurrentAnim === name;
                const hasFrames = frames.length > 0;
                const bgColor = isActive ? (hasFrames ? '#2a5a2a' : '#555') : (hasFrames ? '#1a3a1a' : '#333');
                html += `<div style="display:flex; gap:3px;">`;
                html += `<button onclick="npcSelectAnim('${name}')" style="flex:1; padding:4px; font-size:10px; background:${bgColor};">`;
                html += hasFrames ? `✓ ${name} <span style="color:#4f4;">(${frames.length})</span>` : name;
                html += `</button>`;
                html += `<button onclick="npcRemoveCustomAnim('${name}')" style="padding:4px 6px; font-size:10px; background:#a33;" title="Remove">×</button>`;
                html += `</div>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function npcRemoveCustomAnim(name) {
            if (!npcAnimations[name]) return;
            if (npcAnimations[name].length > 0) {
                if (!confirm('Delete "' + name + '" animation with ' + npcAnimations[name].length + ' frames?')) return;
            }
            delete npcAnimations[name];
            if (npcCurrentAnim === name) {
                npcSelectAnim('walkDown');
            } else {
                npcUpdateCustomAnimList();
            }
        }

        function setNpcTool(tool) {
            npcTool = tool;
            // Collision tools removed - now using collision box editor modal
            // Just update cursor
            const canvas = document.getElementById('npcEditorCanvas');
            if (canvas) canvas.style.cursor = 'crosshair';
        }

        function setNpcBrushSize(size) {
            npcBrushSize = parseInt(size);
            document.getElementById('npcBrushSizeVal').textContent = npcBrushSize;
            npcDrawCanvas(); // Redraw to update preview
        }

        function setNpcBrushShape(shape) {
            npcBrushShape = shape;
            document.querySelectorAll('[id^="npcShape"]').forEach(b => b.classList.remove('active'));
            document.getElementById('npcShape' + shape.charAt(0).toUpperCase() + shape.slice(1)).classList.add('active');
            // Show/hide rectangle controls
            document.getElementById('npcRectControls').style.display = shape === 'rect' ? 'block' : 'none';
            // Hide size slider for rect (uses W/H instead)
            document.getElementById('npcBrushSizeSlider').parentElement.style.display = shape === 'rect' ? 'none' : 'block';
            npcDrawCanvas();
        }

        function setNpcBrushRectW(w) {
            npcBrushRectW = parseInt(w);
            document.getElementById('npcBrushRectWVal').textContent = npcBrushRectW;
            npcDrawCanvas();
        }

        function setNpcBrushRectH(h) {
            npcBrushRectH = parseInt(h);
            document.getElementById('npcBrushRectHVal').textContent = npcBrushRectH;
            npcDrawCanvas();
        }

        function npcPaintCollision(x, y, erase) {
            if (!npcCollisionMask || !npcEditorImage) return;

            const value = erase ? 0 : 1;

            if (npcBrushShape === 'square') {
                const halfBrush = Math.floor(npcBrushSize / 2);
                for (let dy = -halfBrush; dy < halfBrush; dy++) {
                    for (let dx = -halfBrush; dx < halfBrush; dx++) {
                        const px = x + dx;
                        const py = y + dy;
                        if (py >= 0 && py < npcCollisionMask.length && px >= 0 && px < npcCollisionMask[0].length) {
                            npcCollisionMask[py][px] = value;
                        }
                    }
                }
            } else if (npcBrushShape === 'circle') {
                const radius = npcBrushSize / 2;
                const radiusSq = radius * radius;
                for (let dy = -Math.ceil(radius); dy <= Math.ceil(radius); dy++) {
                    for (let dx = -Math.ceil(radius); dx <= Math.ceil(radius); dx++) {
                        if (dx * dx + dy * dy <= radiusSq) {
                            const px = x + dx;
                            const py = y + dy;
                            if (py >= 0 && py < npcCollisionMask.length && px >= 0 && px < npcCollisionMask[0].length) {
                                npcCollisionMask[py][px] = value;
                            }
                        }
                    }
                }
            } else if (npcBrushShape === 'rect') {
                const halfW = Math.floor(npcBrushRectW / 2);
                const halfH = Math.floor(npcBrushRectH / 2);
                for (let dy = -halfH; dy < halfH; dy++) {
                    for (let dx = -halfW; dx < halfW; dx++) {
                        const px = x + dx;
                        const py = y + dy;
                        if (py >= 0 && py < npcCollisionMask.length && px >= 0 && px < npcCollisionMask[0].length) {
                            npcCollisionMask[py][px] = value;
                        }
                    }
                }
            }
        }

        function npcPaintSplit(x, y) {
            if (!npcEditorImage) return;
            // Split line is a single Y value for the entire sprite
            npcSplitLine = Math.max(0, Math.min(npcEditorFrameH, y));
        }

        function npcZoomIn() {
            npcEditorZoom = Math.min(6, npcEditorZoom + 1);
            document.getElementById('npcZoomLevel').textContent = npcEditorZoom + 'x';
            npcDrawCanvas();
        }

        function npcZoomOut() {
            npcEditorZoom = Math.max(1, npcEditorZoom - 1);
            document.getElementById('npcZoomLevel').textContent = npcEditorZoom + 'x';
            npcDrawCanvas();
        }

        function npcDrawCanvas() {
            const canvas = document.getElementById('npcEditorCanvas');
            const ctx = canvas.getContext('2d');

            if (!npcEditorImage) {
                canvas.width = 400;
                canvas.height = 300;
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.textAlign = 'center';
                ctx.font = '14px monospace';
                ctx.fillText('Load a sprite sheet to begin', canvas.width / 2, canvas.height / 2);
                return;
            }

            const scale = npcEditorZoom;
            canvas.width = npcEditorImage.naturalWidth * scale;
            canvas.height = npcEditorImage.naturalHeight * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(npcEditorImage, 0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;

            const fw = npcEditorFrameW * scale;
            const fh = npcEditorFrameH * scale;

            for (let x = 0; x <= canvas.width; x += fw) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += fh) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Highlight frames for current animation
            const currentFrames = npcAnimations[npcCurrentAnim] || [];
            currentFrames.forEach((frame, i) => {
                const sx = frame.x * scale;
                const sy = frame.y * scale;
                const sw = frame.w * scale;
                const sh = frame.h * scale;

                ctx.fillStyle = 'rgba(74, 170, 255, 0.3)';
                ctx.fillRect(sx, sy, sw, sh);
                ctx.strokeStyle = '#4af';
                ctx.lineWidth = 2;
                ctx.strokeRect(sx, sy, sw, sh);

                // Frame number
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText((i + 1).toString(), sx + sw / 2, sy + sh / 2 + 5);
            });

            // Draw drag selection preview
            if (npcFrameDragging && npcFrameDragStart && npcFrameDragEnd) {
                const startGX = Math.min(npcFrameDragStart.gridX, npcFrameDragEnd.gridX);
                const startGY = Math.min(npcFrameDragStart.gridY, npcFrameDragEnd.gridY);
                const endGX = Math.max(npcFrameDragStart.gridX, npcFrameDragEnd.gridX);
                const endGY = Math.max(npcFrameDragStart.gridY, npcFrameDragEnd.gridY);

                const dragX = startGX * npcEditorFrameW * scale;
                const dragY = startGY * npcEditorFrameH * scale;
                const dragW = (endGX - startGX + 1) * npcEditorFrameW * scale;
                const dragH = (endGY - startGY + 1) * npcEditorFrameH * scale;

                ctx.fillStyle = 'rgba(255, 200, 0, 0.3)';
                ctx.fillRect(dragX, dragY, dragW, dragH);
                ctx.strokeStyle = '#fc0';
                ctx.lineWidth = 3;
                ctx.strokeRect(dragX, dragY, dragW, dragH);
            }

            // Draw collision mask overlay
            if (npcCollisionMask && (npcTool === 'collision' || npcTool === 'erase' || npcTool === 'split' || npcTool === 'none')) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.35)';
                for (let py = 0; py < npcCollisionMask.length; py++) {
                    for (let px = 0; px < npcCollisionMask[py].length; px++) {
                        if (npcCollisionMask[py][px] === 1) {
                            ctx.fillRect(px * scale, py * scale, scale, scale);
                        }
                    }
                }
            }

            // Draw brush preview
            if (npcBrushPreviewPos && (npcTool === 'collision' || npcTool === 'erase')) {
                const bx = npcBrushPreviewPos.x;
                const by = npcBrushPreviewPos.y;
                ctx.strokeStyle = npcTool === 'erase' ? '#ff0' : '#0ff';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);

                if (npcBrushShape === 'square') {
                    const halfBrush = Math.floor(npcBrushSize / 2);
                    ctx.strokeRect(
                        (bx - halfBrush) * scale,
                        (by - halfBrush) * scale,
                        npcBrushSize * scale,
                        npcBrushSize * scale
                    );
                } else if (npcBrushShape === 'circle') {
                    const radius = (npcBrushSize / 2) * scale;
                    ctx.beginPath();
                    ctx.arc(bx * scale, by * scale, radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (npcBrushShape === 'rect') {
                    const halfW = Math.floor(npcBrushRectW / 2);
                    const halfH = Math.floor(npcBrushRectH / 2);
                    ctx.strokeRect(
                        (bx - halfW) * scale,
                        (by - halfH) * scale,
                        npcBrushRectW * scale,
                        npcBrushRectH * scale
                    );
                }
                ctx.setLineDash([]);

                // Draw size label near cursor
                ctx.fillStyle = npcTool === 'erase' ? '#ff0' : '#0ff';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'left';
                const sizeText = npcBrushShape === 'rect'
                    ? `${npcBrushRectW}x${npcBrushRectH}`
                    : `${npcBrushSize}px`;
                ctx.fillText(sizeText, (bx + 10) * scale, (by - 5) * scale);
            }

            // Draw split line
            if (npcSplitLine !== null) {
                const splitY = npcSplitLine * scale;
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(0, splitY);
                ctx.lineTo(canvas.width, splitY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label
                ctx.fillStyle = '#0f0';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'left';
                ctx.fillText('DEPTH SPLIT', 4, splitY - 4);
            }
        }

        function npcCanvasClick(e) {
            if (!npcEditorImage) return;

            const canvas = document.getElementById('npcEditorCanvas');
            const rect = canvas.getBoundingClientRect();
            const scale = npcEditorZoom;

            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const gridX = Math.floor(clickX / scale / npcEditorFrameW);
            const gridY = Math.floor(clickY / scale / npcEditorFrameH);

            const frameX = gridX * npcEditorFrameW;
            const frameY = gridY * npcEditorFrameH;

            // Initialize animation array if needed
            if (!npcAnimations[npcCurrentAnim]) {
                npcAnimations[npcCurrentAnim] = [];
            }

            const frames = npcAnimations[npcCurrentAnim];

            // Always add frame (allows same frame multiple times for animation)
            // Use right-click or frame list to remove frames
            frames.push({
                x: frameX,
                y: frameY,
                w: npcEditorFrameW,
                h: npcEditorFrameH
            });

            npcDrawCanvas();
            npcUpdateFramesList();
            npcUpdateAnimButtons();
            npcStartPreview();
        }

        function npcUpdateFramesList() {
            const container = document.getElementById('npcFramesList');
            const countEl = document.getElementById('npcFrameCount');
            const frames = npcAnimations[npcCurrentAnim] || [];

            countEl.textContent = frames.length;

            if (!npcEditorImage || frames.length === 0) {
                container.innerHTML = '<span style="color:#666;">Click frames on sprite sheet to add</span>';
                return;
            }

            container.innerHTML = '';
            frames.forEach((frame, i) => {
                const div = document.createElement('div');
                div.style.cssText = 'display:inline-block; margin:2px; cursor:pointer;';

                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = 40;
                thumbCanvas.height = 40;
                const thumbCtx = thumbCanvas.getContext('2d');
                thumbCtx.imageSmoothingEnabled = false;

                const scale = Math.min(40 / frame.w, 40 / frame.h);
                const dw = frame.w * scale;
                const dh = frame.h * scale;
                const dx = (40 - dw) / 2;
                const dy = (40 - dh) / 2;

                thumbCtx.drawImage(npcEditorImage, frame.x, frame.y, frame.w, frame.h, dx, dy, dw, dh);

                thumbCanvas.style.border = '2px solid #4af';
                thumbCanvas.style.borderRadius = '3px';
                thumbCanvas.title = 'Frame ' + (i + 1) + ' - Click to remove';
                thumbCanvas.onclick = () => {
                    npcAnimations[npcCurrentAnim].splice(i, 1);
                    npcDrawCanvas();
                    npcUpdateFramesList();
                    npcUpdateAnimButtons();
                };

                div.appendChild(thumbCanvas);
                container.appendChild(div);
            });
        }

        function npcUpdateSpeed() {
            const fps = parseInt(document.getElementById('npcSpeedSlider').value);
            document.getElementById('npcSpeedLabel').textContent = fps + ' fps';
            npcStartPreview();
        }

        function npcUpdatePingPong() {
            npcPingPong = document.getElementById('npcPingPong').checked;
            npcPreviewDirection = 1;
            npcStartPreview();
        }

        function updateNpcShadowPreview() {
            // Update slider labels
            const offsetXVal = document.getElementById('npcShadowOffsetXSlider').value;
            const offsetVal = document.getElementById('npcShadowOffsetSlider').value;
            const widthVal = document.getElementById('npcShadowWidthSlider').value;
            const heightVal = document.getElementById('npcShadowHeightSlider').value;
            document.getElementById('npcShadowOffsetXVal').textContent = offsetXVal;
            document.getElementById('npcShadowOffsetVal').textContent = offsetVal;
            document.getElementById('npcShadowWidthVal').textContent = widthVal;
            document.getElementById('npcShadowHeightVal').textContent = heightVal;
        }

        function npcStartPreview() {
            npcStopPreview();
            const frames = npcAnimations[npcCurrentAnim] || [];
            if (frames.length === 0 || !npcEditorImage) return;

            const fps = parseInt(document.getElementById('npcSpeedSlider').value) || 8;
            const isMirrored = npcAnimMirrors[npcCurrentAnim];
            npcPreviewFrame = 0;
            npcPreviewDirection = 1;
            npcPreviewPlaying = true;

            npcPreviewInterval = setInterval(() => {
                const canvas = document.getElementById('npcLivePreview');
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, 96, 96);

                // Draw light background so shadow is visible
                ctx.fillStyle = '#e8e8e8';
                ctx.fillRect(0, 0, 96, 96);

                if (frames.length > 0) {
                    const frame = frames[npcPreviewFrame];
                    const scale = Math.min(96 / frame.w, 96 / frame.h);
                    const dw = frame.w * scale;
                    const dh = frame.h * scale;
                    const dx = (96 - dw) / 2;
                    const dy = (96 - dh) / 2;

                    // Draw shadow preview using current slider values
                    const shadowOffsetX = parseInt(document.getElementById('npcShadowOffsetXSlider').value) || 0;
                    const shadowOffsetY = parseInt(document.getElementById('npcShadowOffsetSlider').value) || 4;
                    const shadowWidthRatio = (parseInt(document.getElementById('npcShadowWidthSlider').value) || 35) / 100;
                    const shadowHeightRatio = (parseInt(document.getElementById('npcShadowHeightSlider').value) || 12) / 100;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(
                        dx + dw / 2 + shadowOffsetX * scale,
                        dy + dh - shadowOffsetY * scale,
                        dw * shadowWidthRatio,
                        dw * shadowHeightRatio,
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();

                    // Apply mirror transform if enabled
                    if (isMirrored) {
                        ctx.save();
                        ctx.translate(96, 0);
                        ctx.scale(-1, 1);
                        ctx.drawImage(npcEditorImage, frame.x, frame.y, frame.w, frame.h, 96 - dx - dw, dy, dw, dh);
                        ctx.restore();
                    } else {
                        ctx.drawImage(npcEditorImage, frame.x, frame.y, frame.w, frame.h, dx, dy, dw, dh);
                    }

                    // Ping-pong or loop
                    if (npcPingPong && frames.length > 1) {
                        npcPreviewFrame += npcPreviewDirection;
                        if (npcPreviewFrame >= frames.length - 1) {
                            npcPreviewDirection = -1;
                        } else if (npcPreviewFrame <= 0) {
                            npcPreviewDirection = 1;
                        }
                    } else {
                        npcPreviewFrame = (npcPreviewFrame + 1) % frames.length;
                    }
                }
            }, 1000 / fps);
        }

        function npcStopPreview() {
            if (npcPreviewInterval) {
                clearInterval(npcPreviewInterval);
                npcPreviewInterval = null;
            }
            npcPreviewPlaying = false;
        }

        function npcClearCurrentAnim() {
            npcAnimations[npcCurrentAnim] = [];
            npcDrawCanvas();
            npcUpdateFramesList();
            npcStopPreview();
            const ctx = document.getElementById('npcLivePreview').getContext('2d');
            ctx.clearRect(0, 0, 96, 96);
        }

        // ============ Collision Box Editor (Inset-based) ============
        // Store insets (pixels to shrink from each edge) - simpler and matches debug draw exactly
        let npcCollisionInsets = null; // { top, bottom, left, right } in pixels
        let collisionPreviewDir = 'down';
        let collisionPreviewFrame = 0;
        let collisionPreviewAnimId = null;
        let collisionFrameInterval = null;

        function getCollisionFrameSize() {
            const anims = npcAnimations || {};
            const firstAnim = anims.walkDown || anims.idle || Object.values(anims).find(a => a && a.length > 0);
            const firstFrame = firstAnim && firstAnim[0];
            return {
                w: (firstFrame && firstFrame.w) || npcEditorFrameW || 32,
                h: (firstFrame && firstFrame.h) || npcEditorFrameH || 32
            };
        }

        function openNpcCollisionEditor() {
            if (!npcEditorImage) {
                alert('Please load an NPC sprite first');
                return;
            }
            // Initialize from current insets
            const insets = npcCollisionInsets || { top: 0, bottom: 0, left: 0, right: 0 };
            const frameSize = getCollisionFrameSize();

            // Set slider max values based on frame size
            document.getElementById('insetTop').max = Math.floor(frameSize.h / 2);
            document.getElementById('insetBottom').max = Math.floor(frameSize.h / 2);
            document.getElementById('insetLeft').max = Math.floor(frameSize.w / 2);
            document.getElementById('insetRight').max = Math.floor(frameSize.w / 2);

            // Set slider values
            document.getElementById('insetTop').value = insets.top;
            document.getElementById('insetBottom').value = insets.bottom;
            document.getElementById('insetLeft').value = insets.left;
            document.getElementById('insetRight').value = insets.right;

            document.getElementById('npcCollisionModal').style.display = 'flex';
            collisionPreviewDir = 'down';
            collisionPreviewFrame = 0;
            updateCollisionDirButtons();
            startCollisionPreviewLoop();
            updateCollisionInsets();
        }

        function closeNpcCollisionEditor() {
            document.getElementById('npcCollisionModal').style.display = 'none';
            stopCollisionPreviewLoop();
        }

        function setCollisionPreviewDir(dir) {
            collisionPreviewDir = dir;
            collisionPreviewFrame = 0;
            updateCollisionDirButtons();
        }

        function updateCollisionDirButtons() {
            ['idle', 'down', 'up', 'left', 'right'].forEach(d => {
                const btn = document.getElementById('collisionDir' + d.charAt(0).toUpperCase() + d.slice(1));
                if (btn) btn.classList.toggle('active', d === collisionPreviewDir);
            });
        }

        function startCollisionPreviewLoop() {
            stopCollisionPreviewLoop();
            const canvas = document.getElementById('collisionPreviewCanvas');
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            function loop() {
                ctx.clearRect(0, 0, 200, 200);
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, 200, 200);

                if (!npcEditorImage) {
                    collisionPreviewAnimId = requestAnimationFrame(loop);
                    return;
                }

                // Get animation frames for current direction
                let animKey = collisionPreviewDir === 'idle' ? 'idle' :
                    'walk' + collisionPreviewDir.charAt(0).toUpperCase() + collisionPreviewDir.slice(1);
                let frames = npcAnimations[animKey] || [];
                if (frames.length === 0) {
                    frames = npcAnimations.idle || npcAnimations.walkDown || [];
                    if (frames.length === 0) {
                        const anyAnim = Object.values(npcAnimations).find(a => a && a.length > 0);
                        if (anyAnim) frames = anyAnim;
                    }
                }
                if (frames.length === 0) {
                    collisionPreviewAnimId = requestAnimationFrame(loop);
                    return;
                }

                const frame = frames[collisionPreviewFrame % frames.length];
                const isMirrored = npcAnimMirrors[animKey] || false;
                const frameW = frame.w || npcEditorFrameW;
                const frameH = frame.h || npcEditorFrameH;

                // Calculate scale to fit in canvas
                const padding = 20;
                const maxSize = 200 - padding * 2;
                const scale = Math.min(maxSize / frameW, maxSize / frameH, 4);
                const drawW = frameW * scale;
                const drawH = frameH * scale;
                const drawX = (200 - drawW) / 2;
                const drawY = (200 - drawH) / 2;

                // Draw shadow
                const shadowOffsetX = parseInt(document.getElementById('npcShadowOffsetXSlider')?.value || 0);
                const shadowOffsetY = parseInt(document.getElementById('npcShadowOffsetSlider')?.value || 4);
                const shadowWidthRatio = (parseInt(document.getElementById('npcShadowWidthSlider')?.value || 35)) / 100;
                const shadowHeightRatio = (parseInt(document.getElementById('npcShadowHeightSlider')?.value || 12)) / 100;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.ellipse(100 + shadowOffsetX * scale, drawY + drawH - shadowOffsetY * scale, drawW * shadowWidthRatio, drawW * shadowHeightRatio, 0, 0, Math.PI * 2);
                ctx.fill();

                // Draw NPC frame
                ctx.save();
                if (isMirrored) {
                    ctx.translate(200, 0);
                    ctx.scale(-1, 1);
                    ctx.drawImage(npcEditorImage, frame.x, frame.y, frameW, frameH, 200 - drawX - drawW, drawY, drawW, drawH);
                } else {
                    ctx.drawImage(npcEditorImage, frame.x, frame.y, frameW, frameH, drawX, drawY, drawW, drawH);
                }
                ctx.restore();

                // Draw full sprite outline (dashed cyan - the "default" that works)
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.strokeRect(drawX, drawY, drawW, drawH);
                ctx.setLineDash([]);

                // Draw collision box with insets (solid cyan fill)
                const insets = npcCollisionInsets || { top: 0, bottom: 0, left: 0, right: 0 };
                const boxX = drawX + insets.left * scale;
                const boxY = drawY + insets.top * scale;
                const boxW = drawW - (insets.left + insets.right) * scale;
                const boxH = drawH - (insets.top + insets.bottom) * scale;

                if (boxW > 0 && boxH > 0) {
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.25)';
                    ctx.fillRect(boxX, boxY, boxW, boxH);
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(boxX, boxY, boxW, boxH);
                }

                collisionPreviewAnimId = requestAnimationFrame(loop);
            }

            loop();

            // Advance frame every 150ms
            collisionFrameInterval = setInterval(() => {
                let animKey = collisionPreviewDir === 'idle' ? 'idle' :
                    'walk' + collisionPreviewDir.charAt(0).toUpperCase() + collisionPreviewDir.slice(1);
                let frames = npcAnimations[animKey] || [];
                if (frames.length === 0) {
                    frames = npcAnimations.idle || npcAnimations.walkDown || Object.values(npcAnimations).find(a => a && a.length > 0) || [];
                }
                if (frames.length > 0) {
                    collisionPreviewFrame = (collisionPreviewFrame + 1) % frames.length;
                }
            }, 150);
        }

        function stopCollisionPreviewLoop() {
            if (collisionPreviewAnimId) {
                cancelAnimationFrame(collisionPreviewAnimId);
                collisionPreviewAnimId = null;
            }
            if (collisionFrameInterval) {
                clearInterval(collisionFrameInterval);
                collisionFrameInterval = null;
            }
        }

        // Update insets from sliders
        function updateCollisionInsets() {
            const top = parseInt(document.getElementById('insetTop').value) || 0;
            const bottom = parseInt(document.getElementById('insetBottom').value) || 0;
            const left = parseInt(document.getElementById('insetLeft').value) || 0;
            const right = parseInt(document.getElementById('insetRight').value) || 0;

            document.getElementById('insetTopVal').textContent = top;
            document.getElementById('insetBottomVal').textContent = bottom;
            document.getElementById('insetLeftVal').textContent = left;
            document.getElementById('insetRightVal').textContent = right;

            npcCollisionInsets = { top, bottom, left, right };

            // Update info text
            const info = document.getElementById('collisionBoxInfo');
            const frameSize = getCollisionFrameSize();
            const boxW = frameSize.w - left - right;
            const boxH = frameSize.h - top - bottom;

            if (top === 0 && bottom === 0 && left === 0 && right === 0) {
                info.textContent = 'Full sprite (no insets)';
                info.style.color = '#0ff';
            } else if (boxW <= 0 || boxH <= 0) {
                info.textContent = 'Box too small!';
                info.style.color = '#f44';
            } else {
                info.textContent = `Collision: ${boxW}x${boxH}px`;
                info.style.color = '#0ff';
            }
        }

        function resetCollisionInsets() {
            document.getElementById('insetTop').value = 0;
            document.getElementById('insetBottom').value = 0;
            document.getElementById('insetLeft').value = 0;
            document.getElementById('insetRight').value = 0;
            updateCollisionInsets();
        }

        function applyNpcCollisionBox() {
            // Update status in NPC editor
            const status = document.getElementById('npcCollisionStatus');
            const insets = npcCollisionInsets || { top: 0, bottom: 0, left: 0, right: 0 };
            if (insets.top > 0 || insets.bottom > 0 || insets.left > 0 || insets.right > 0) {
                const frameSize = getCollisionFrameSize();
                const boxW = frameSize.w - insets.left - insets.right;
                const boxH = frameSize.h - insets.top - insets.bottom;
                status.textContent = `Box: ${boxW}x${boxH}px`;
                status.style.color = '#0ff';
            } else {
                status.textContent = 'Full sprite';
                status.style.color = '#888';
            }
            closeNpcCollisionEditor();
        }
        // ============ End Collision Box Editor ============

        function npcSave() {
            const name = document.getElementById('npcNameInput').value.trim() || 'NPC ' + (npcs.length + 1);

            // Check if at least one animation has frames
            const hasFrames = Object.values(npcAnimations).some(arr => arr.length > 0);
            if (!hasFrames) {
                alert('Please select at least one frame for any animation');
                return;
            }

            const fps = parseInt(document.getElementById('npcSpeedSlider').value) || 8;

            // Read shadow settings from sliders
            const shadowOffsetX = parseInt(document.getElementById('npcShadowOffsetXSlider').value) || 0;
            const shadowOffsetY = parseInt(document.getElementById('npcShadowOffsetSlider').value) || 4;
            const shadowWidth = (parseInt(document.getElementById('npcShadowWidthSlider').value) || 35) / 100;
            const shadowHeight = (parseInt(document.getElementById('npcShadowHeightSlider').value) || 12) / 100;

            const npcData = {
                name: name,
                spriteData: npcEditorData,
                frameWidth: npcEditorFrameW,
                frameHeight: npcEditorFrameH,
                animations: JSON.parse(JSON.stringify(npcAnimations)),
                animMirrors: JSON.parse(JSON.stringify(npcAnimMirrors)),
                fps: fps,
                pingPong: npcPingPong,
                collisionInsets: npcCollisionInsets ? { ...npcCollisionInsets } : null,
                shadowOffsetX: shadowOffsetX,
                shadowOffsetY: shadowOffsetY,
                shadowWidth: shadowWidth,
                shadowHeight: shadowHeight
            };

            if (npcEditorEditingIndex >= 0) {
                npcs[npcEditorEditingIndex] = npcData;
                // Broadcast update to other builders
                broadcastEdit({ editType: 'updateNpc', index: npcEditorEditingIndex, npc: npcData });
            } else {
                npcs.push(npcData);
                currentNpcIndex = npcs.length - 1;
                // Broadcast new NPC to other builders
                broadcastEdit({ editType: 'addNpc', npc: npcData });
            }

            document.getElementById('npcModal').classList.remove('visible');
            npcStopPreview();
            stopEditing(); // Clear editing lock
            updateNpcList();
        }

        function npcCancel() {
            document.getElementById('npcModal').classList.remove('visible');
            npcStopPreview();
            stopEditing(); // Clear editing lock
        }

        function updateNpcList() {
            const container = document.getElementById('npcList');

            if (npcs.length === 0) {
                container.innerHTML = '<div style="color:#888; font-size:12px; padding:10px; text-align:center;">No NPCs created yet</div>';
                return;
            }

            container.innerHTML = '';
            npcs.forEach((npc, i) => {
                const div = document.createElement('div');
                div.style.cssText = 'display:flex; align-items:center; gap:8px; padding:5px; margin-bottom:5px; background:' + (i === currentNpcIndex ? '#2a5a8a' : '#333') + '; border-radius:4px; cursor:pointer;';

                // Thumbnail
                const thumb = document.createElement('canvas');
                thumb.width = 32;
                thumb.height = 32;
                thumb.style.cssText = 'border:1px solid #555; border-radius:3px; image-rendering:pixelated;';

                // Use first frame from walkDown or first available animation
                const anims = npc.animations || {};
                const firstAnim = (anims.walkDown?.length > 0 ? anims.walkDown : null) ||
                                  (anims.idle?.length > 0 ? anims.idle : null) ||
                                  Object.values(anims).find(a => a && a.length > 0);
                if (npc.spriteData && firstAnim && firstAnim.length > 0) {
                    const img = new Image();
                    img.onload = () => {
                        const ctx = thumb.getContext('2d');
                        ctx.imageSmoothingEnabled = false;
                        const frame = firstAnim[0];
                        const scale = Math.min(32 / frame.w, 32 / frame.h);
                        const dw = frame.w * scale;
                        const dh = frame.h * scale;
                        ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, (32-dw)/2, (32-dh)/2, dw, dh);
                    };
                    img.src = npc.spriteData;
                }

                // Name
                const nameSpan = document.createElement('span');
                nameSpan.textContent = npc.name;
                nameSpan.style.cssText = 'flex:1; font-size:12px;';

                // Edit button
                const editBtn = document.createElement('button');
                editBtn.textContent = '✎';
                editBtn.style.cssText = 'padding:2px 6px; font-size:11px; background:#666;';
                editBtn.onclick = (e) => { e.stopPropagation(); openNpcEditor(i); };

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = '×';
                delBtn.style.cssText = 'padding:2px 6px; font-size:11px; background:#a55;';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Delete NPC "' + npc.name + '"?')) {
                        npcs.splice(i, 1);
                        if (currentNpcIndex >= npcs.length) currentNpcIndex = npcs.length - 1;
                        updateNpcList();
                    }
                };

                div.onclick = () => {
                    currentNpcIndex = i;
                    updateNpcList();
                };

                div.appendChild(thumb);
                div.appendChild(nameSpan);
                div.appendChild(editBtn);
                div.appendChild(delBtn);
                container.appendChild(div);
            });
        }

        // ============ PLAYER CHARACTER EDITOR ============

        function openPlayerEditor(editIndex = -1) {
            // Check if someone else is already editing this player
            if (editIndex >= 0 && isBeingEdited('player', editIndex)) {
                const editor = getEditor('player', editIndex);
                if (!confirm(`"${editor}" is currently editing this player character.\n\nEditing simultaneously may cause conflicts.\n\nOpen anyway?`)) {
                    return;
                }
            }

            playerEditorEditingIndex = editIndex;

            // Broadcast that we're editing this player
            if (editIndex >= 0) {
                startEditing('player', editIndex);
            }

            playerEditorSheets = [];
            playerCurrentSheetIndex = 0;
            playerEditorFrameW = 64;
            playerEditorFrameH = 64;
            playerAnimations = { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], idleDown: [], idleUp: [], idleLeft: [], idleRight: [], attackDown: [], attackUp: [], attackLeft: [], attackRight: [], interact: [], death: [], receivedItem: [] };
            playerAnimMirrors = {}; // Reset mirror flags
            playerHitboxRange = 40; // Reset hitbox shape
            playerHitboxWidth = 60;
            playerHitboxOffsetY = 0;
            playerAttackMovement = 'stop'; // Reset attack movement
            playerGameOverSoundIndex = -1; // Reset game over sound
            playerCurrentAnim = 'walkDown';
            playerAnimFpsList = {}; // Reset per-animation FPS
            playerStopPreview();

            // Reset UI
            document.getElementById('playerFileName').textContent = '';
            document.getElementById('playerSheetTabs').innerHTML = '';
            document.getElementById('playerFrameSection').style.display = 'none';
            document.getElementById('playerAnimSection').style.display = 'none';
            document.getElementById('playerNameSection').style.display = 'none';
            document.getElementById('playerNameInput').value = '';
            document.getElementById('playerSpeedSlider').value = 8;
            document.getElementById('playerSpeedLabel').textContent = '8 fps';
            playerPingPong = false;
            document.getElementById('playerPingPong').checked = false;
            document.getElementById('playerAttackMovement').value = 'stop';
            document.getElementById('playerCustomAnimName').value = '';
            document.getElementById('playerCustomAnimList').innerHTML = '';

            // If editing existing character, load its data
            if (editIndex >= 0 && playerCharacters[editIndex]) {
                const char = playerCharacters[editIndex];
                playerEditorFrameW = char.frameWidth;
                playerEditorFrameH = char.frameHeight;
                playerAnimations = JSON.parse(JSON.stringify(char.animations));
                // Load per-animation FPS (support both old single fps and new per-anim fps)
                if (char.animFps && typeof char.animFps === 'object') {
                    playerAnimFpsList = JSON.parse(JSON.stringify(char.animFps));
                } else {
                    // Old format: single fps value - apply to all anims
                    const defaultFps = char.fps || 8;
                    playerAnimFpsList = {};
                    Object.keys(playerAnimations).forEach(k => {
                        playerAnimFpsList[k] = defaultFps;
                    });
                }

                document.getElementById('playerNameInput').value = char.name;
                const currentFps = playerAnimFpsList[playerCurrentAnim] || 8;
                document.getElementById('playerSpeedSlider').value = currentFps;
                document.getElementById('playerSpeedLabel').textContent = currentFps + ' fps';
                // Load ping-pong setting
                playerPingPong = char.pingPong || false;
                document.getElementById('playerPingPong').checked = playerPingPong;
                // Load mirror flags
                if (char.animMirrors) {
                    playerAnimMirrors = JSON.parse(JSON.stringify(char.animMirrors));
                }
                // Load attack movement setting
                if (char.attackMovement) {
                    playerAttackMovement = char.attackMovement;
                    document.getElementById('playerAttackMovement').value = playerAttackMovement;
                }
                // Load hitbox shape (per-direction or convert from old single-value)
                if (char.hitboxRange !== undefined) {
                    if (typeof char.hitboxRange === 'object') {
                        playerHitboxRange = char.hitboxRange;
                    } else {
                        const val = char.hitboxRange;
                        playerHitboxRange = { up: val, down: val, left: val, right: val };
                    }
                }
                if (char.hitboxWidth !== undefined) {
                    if (typeof char.hitboxWidth === 'object') {
                        playerHitboxWidth = char.hitboxWidth;
                    } else {
                        const val = char.hitboxWidth;
                        playerHitboxWidth = { up: val, down: val, left: val, right: val };
                    }
                }
                if (char.hitboxOffsetX !== undefined) {
                    if (typeof char.hitboxOffsetX === 'object') {
                        playerHitboxOffsetX = char.hitboxOffsetX;
                    } else {
                        const val = char.hitboxOffsetX;
                        playerHitboxOffsetX = { up: val, down: val, left: val, right: val };
                    }
                }
                if (char.hitboxOffsetY !== undefined) {
                    if (typeof char.hitboxOffsetY === 'object') {
                        playerHitboxOffsetY = char.hitboxOffsetY;
                    } else {
                        const val = char.hitboxOffsetY;
                        playerHitboxOffsetY = { up: val, down: val, left: val, right: val };
                    }
                }
                // Load game over sound index
                playerGameOverSoundIndex = char.gameOverSoundIndex !== undefined ? char.gameOverSoundIndex : -1;

                // Load sheets (support both new multi-sheet and old single-sheet format)
                const sheetsToLoad = char.spriteSheets || (char.spriteData ? [char.spriteData] : []);
                let loadedCount = 0;
                sheetsToLoad.forEach((sheetData, index) => {
                    const img = new Image();
                    img.onload = () => {
                        playerEditorSheets[index] = {
                            image: img,
                            data: sheetData,
                            name: 'Sheet ' + (index + 1)
                        };
                        loadedCount++;
                        if (loadedCount === sheetsToLoad.length) {
                            // All sheets loaded
                            playerCurrentSheetIndex = 0;
                            playerUpdateSheetTabs();
                            const sheet = playerGetCurrentSheet();
                            if (sheet) {
                                document.getElementById('playerFileName').textContent = 'Sheet 1: ' + sheet.image.naturalWidth + 'x' + sheet.image.naturalHeight;
                            }
                            document.getElementById('playerFrameSection').style.display = 'block';
                            document.getElementById('playerAnimSection').style.display = 'block';
                            document.getElementById('playerNameSection').style.display = 'block';
                            playerUpdateGrid();
                            playerDrawCanvas();
                            playerUpdateAnimButtons();
                            playerUpdateFramesList();
                            playerStartPreview();
                        }
                    };
                    img.src = sheetData;
                });
            }

            // Populate game over sound dropdown
            playerPopulateGameOverSoundDropdown();

            document.getElementById('playerModal').classList.add('visible');
        }

        function playerLoadSheet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const data = e.target.result;
                const img = new Image();
                img.onload = () => {
                    // Add to sheets array
                    const sheetName = file.name.replace(/\.[^/.]+$/, ''); // Remove extension
                    playerEditorSheets.push({
                        image: img,
                        data: data,
                        name: sheetName
                    });
                    playerCurrentSheetIndex = playerEditorSheets.length - 1;
                    playerUpdateSheetTabs();
                    document.getElementById('playerFileName').textContent = 'Sheet ' + (playerCurrentSheetIndex + 1) + ': ' + img.naturalWidth + 'x' + img.naturalHeight;
                    document.getElementById('playerFrameSection').style.display = 'block';
                    document.getElementById('playerAnimSection').style.display = 'block';
                    document.getElementById('playerNameSection').style.display = 'block';
                    playerUpdateGrid();
                    playerDrawCanvas();
                };
                img.src = data;
            };
            reader.readAsDataURL(file);
            // Reset file input so same file can be loaded again
            event.target.value = '';
        }

        function playerUpdateSheetTabs() {
            const container = document.getElementById('playerSheetTabs');
            container.innerHTML = '';
            playerEditorSheets.forEach((sheet, i) => {
                const tab = document.createElement('div');
                tab.style.cssText = 'display:flex; align-items:center; gap:5px;';
                const btn = document.createElement('button');
                btn.textContent = (i + 1) + '. ' + sheet.name;
                btn.style.cssText = 'flex:1; padding:5px 8px; font-size:11px; text-align:left; overflow:hidden; text-overflow:ellipsis;';
                if (i === playerCurrentSheetIndex) {
                    btn.style.background = '#4f8';
                    btn.style.color = '#000';
                }
                btn.onclick = () => playerSwitchSheet(i);
                tab.appendChild(btn);
                // Remove button (only if more than one sheet)
                if (playerEditorSheets.length > 1) {
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = 'X';
                    removeBtn.style.cssText = 'padding:5px 8px; font-size:11px; background:#a55;';
                    removeBtn.onclick = (e) => { e.stopPropagation(); playerRemoveSheet(i); };
                    tab.appendChild(removeBtn);
                }
                container.appendChild(tab);
            });
        }

        function playerSwitchSheet(index) {
            if (index < 0 || index >= playerEditorSheets.length) return;
            playerCurrentSheetIndex = index;
            const sheet = playerEditorSheets[index];
            document.getElementById('playerFileName').textContent = 'Sheet ' + (index + 1) + ': ' + sheet.image.naturalWidth + 'x' + sheet.image.naturalHeight;
            playerUpdateSheetTabs();
            playerUpdateGrid();
            playerDrawCanvas();
        }

        function playerRemoveSheet(index) {
            if (playerEditorSheets.length <= 1) return;
            // Remove frames that reference this sheet
            Object.keys(playerAnimations).forEach(animKey => {
                playerAnimations[animKey] = playerAnimations[animKey].filter(f => f.sheet !== index);
                // Update sheet indices for frames from higher sheets
                playerAnimations[animKey].forEach(f => {
                    if (f.sheet > index) f.sheet--;
                });
            });
            playerEditorSheets.splice(index, 1);
            if (playerCurrentSheetIndex >= playerEditorSheets.length) {
                playerCurrentSheetIndex = playerEditorSheets.length - 1;
            }
            playerUpdateSheetTabs();
            playerSwitchSheet(playerCurrentSheetIndex);
            playerUpdateAnimButtons();
            playerUpdateFramesList();
        }

        // Helper to get current sheet image
        function playerGetCurrentSheet() {
            if (playerEditorSheets.length === 0) return null;
            return playerEditorSheets[playerCurrentSheetIndex];
        }

        function playerSetFrameSize(w, h) {
            playerEditorFrameW = w;
            playerEditorFrameH = h;
            playerAnimations = { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], idleDown: [], idleUp: [], idleLeft: [], idleRight: [], attackDown: [], attackUp: [], attackLeft: [], attackRight: [], interact: [], death: [], receivedItem: [] };
            playerAnimMirrors = {};
            playerUpdateGrid();
            playerDrawCanvas();
            playerUpdateAnimButtons();
            playerUpdateMirrorButton();
            playerUpdateFramesList();
        }

        function playerResetGrid() {
            playerSetFrameSize(64, 64);
        }

        function playerUpdateGrid() {
            const sheet = playerGetCurrentSheet();
            if (!sheet) return;
            const cols = Math.floor(sheet.image.naturalWidth / playerEditorFrameW);
            const rows = Math.floor(sheet.image.naturalHeight / playerEditorFrameH);
            document.getElementById('playerGridInfo').textContent = playerEditorFrameW + 'x' + playerEditorFrameH + ' (' + cols + 'x' + rows + ' grid)';
        }

        function playerSelectAnim(animName) {
            playerCurrentAnim = animName;
            playerUpdateAnimButtons();
            playerUpdateMirrorButton();
            playerUpdateHitboxUI(); // Show/hide hitbox section based on anim type
            playerUpdateFramesList();
            // Update FPS slider to show this animation's FPS
            const fps = playerAnimFpsList[animName] || 8;
            document.getElementById('playerSpeedSlider').value = fps;
            document.getElementById('playerSpeedLabel').textContent = fps + ' fps';
            playerStartPreview();
        }

        function playerUpdateAnimButtons() {
            const names = {
                walkDown: 'Walk Down',
                walkUp: 'Walk Up',
                walkLeft: 'Walk Left',
                walkRight: 'Walk Right',
                idle: 'Idle (All)',
                idleDown: 'Idle Down',
                idleUp: 'Idle Up',
                idleLeft: 'Idle Left',
                idleRight: 'Idle Right',
                attackDown: 'Attack Down',
                attackUp: 'Attack Up',
                attackLeft: 'Attack Left',
                attackRight: 'Attack Right',
                interact: 'Interact',
                death: 'Death',
                receivedItem: 'Received Item'
            };

            // Walk buttons
            const walkBtnMap = {
                walkDown: 'playerAnimDown',
                walkUp: 'playerAnimUp',
                walkLeft: 'playerAnimLeft',
                walkRight: 'playerAnimRight'
            };
            Object.entries(walkBtnMap).forEach(([anim, btnId]) => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.toggle('active', playerCurrentAnim === anim);
                    const count = playerAnimations[anim]?.length || 0;
                    btn.classList.toggle('has-frames', count > 0);
                    let label = anim === 'walkDown' ? '↓ Walk' : anim === 'walkUp' ? '↑ Walk' : anim === 'walkLeft' ? '← Walk' : '→ Walk';
                    btn.textContent = label + (count > 0 ? ' (' + count + ')' : '');
                }
            });

            // Idle (All) button
            const idleAllBtn = document.getElementById('playerAnimIdle');
            if (idleAllBtn) {
                idleAllBtn.classList.toggle('active', playerCurrentAnim === 'idle');
                const count = playerAnimations['idle']?.length || 0;
                idleAllBtn.classList.toggle('has-frames', count > 0);
                idleAllBtn.textContent = 'Idle (All)' + (count > 0 ? ' (' + count + ')' : '');
            }

            // Directional idle buttons
            const idleBtnMap = {
                idleDown: 'playerAnimIdleDown',
                idleUp: 'playerAnimIdleUp',
                idleLeft: 'playerAnimIdleLeft',
                idleRight: 'playerAnimIdleRight'
            };
            Object.entries(idleBtnMap).forEach(([anim, btnId]) => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.toggle('active', playerCurrentAnim === anim);
                    const count = playerAnimations[anim]?.length || 0;
                    btn.classList.toggle('has-frames', count > 0);
                    let label = anim === 'idleDown' ? '↓' : anim === 'idleUp' ? '↑' : anim === 'idleLeft' ? '←' : '→';
                    btn.textContent = label + (count > 0 ? ' (' + count + ')' : '');
                }
            });

            // Attack buttons
            const attackBtnMap = {
                attackDown: 'playerAnimAttackDown',
                attackUp: 'playerAnimAttackUp',
                attackLeft: 'playerAnimAttackLeft',
                attackRight: 'playerAnimAttackRight'
            };
            Object.entries(attackBtnMap).forEach(([anim, btnId]) => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.toggle('active', playerCurrentAnim === anim);
                    const count = playerAnimations[anim]?.length || 0;
                    btn.classList.toggle('has-frames', count > 0);
                    let label = anim === 'attackDown' ? '↓ Atk' : anim === 'attackUp' ? '↑ Atk' : anim === 'attackLeft' ? '← Atk' : '→ Atk';
                    btn.textContent = label + (count > 0 ? ' (' + count + ')' : '');
                }
            });

            // Interact button
            const interactBtn = document.getElementById('playerAnimInteract');
            if (interactBtn) {
                interactBtn.classList.toggle('active', playerCurrentAnim === 'interact');
                const count = playerAnimations['interact']?.length || 0;
                interactBtn.classList.toggle('has-frames', count > 0);
                interactBtn.textContent = 'Interact' + (count > 0 ? ' (' + count + ')' : '');
            }

            // Death button
            const deathBtn = document.getElementById('playerAnimDeath');
            if (deathBtn) {
                deathBtn.classList.toggle('active', playerCurrentAnim === 'death');
                const count = playerAnimations['death']?.length || 0;
                deathBtn.classList.toggle('has-frames', count > 0);
                deathBtn.textContent = 'Death' + (count > 0 ? ' (' + count + ')' : '');
            }

            // Received Item button (All)
            const receivedItemBtn = document.getElementById('playerAnimReceivedItem');
            if (receivedItemBtn) {
                receivedItemBtn.classList.toggle('active', playerCurrentAnim === 'receivedItem');
                const count = playerAnimations['receivedItem']?.length || 0;
                receivedItemBtn.classList.toggle('has-frames', count > 0);
                receivedItemBtn.textContent = 'Receive (All)' + (count > 0 ? ' (' + count + ')' : '');
            }

            // Directional Receive Item buttons
            const receiveItemDirs = {
                receiveItemDown: 'playerAnimReceiveItemDown',
                receiveItemUp: 'playerAnimReceiveItemUp',
                receiveItemLeft: 'playerAnimReceiveItemLeft',
                receiveItemRight: 'playerAnimReceiveItemRight'
            };
            for (const [anim, btnId] of Object.entries(receiveItemDirs)) {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.toggle('active', playerCurrentAnim === anim);
                    const count = playerAnimations[anim]?.length || 0;
                    btn.classList.toggle('has-frames', count > 0);
                    const arrow = anim.includes('Down') ? '↓' : anim.includes('Up') ? '↑' : anim.includes('Left') ? '←' : '→';
                    btn.textContent = arrow + (count > 0 ? '(' + count + ')' : '');
                }
            }

            // Update custom animations list
            playerUpdateCustomAnimList();

            // Update current animation name display
            document.getElementById('playerCurrentAnimName').textContent = names[playerCurrentAnim] || playerCurrentAnim;
            document.getElementById('playerFrameCount').textContent = playerAnimations[playerCurrentAnim]?.length || 0;
        }

        function playerDrawCanvas() {
            const sheet = playerGetCurrentSheet();
            if (!sheet) return;

            const canvas = document.getElementById('playerEditorCanvas');
            const ctx = canvas.getContext('2d');
            const scale = playerEditorZoom;

            canvas.width = sheet.image.naturalWidth * scale;
            canvas.height = sheet.image.naturalHeight * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(sheet.image, 0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;

            const fw = playerEditorFrameW * scale;
            const fh = playerEditorFrameH * scale;

            for (let x = 0; x <= canvas.width; x += fw) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += fh) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Highlight frames in current animation (only those from current sheet)
            const frames = playerAnimations[playerCurrentAnim] || [];
            frames.forEach((frame, i) => {
                // Only highlight if frame is from current sheet (or no sheet specified for backwards compat)
                if (frame.sheet !== undefined && frame.sheet !== playerCurrentSheetIndex) {
                    return; // Skip frames from other sheets
                }
                const x = frame.x * scale;
                const y = frame.y * scale;
                const w = frame.w * scale;
                const h = frame.h * scale;

                ctx.fillStyle = 'rgba(74, 255, 136, 0.3)';
                ctx.fillRect(x, y, w, h);
                ctx.strokeStyle = '#4f8';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                // Frame number
                ctx.fillStyle = '#fff';
                ctx.font = 'bold ' + (12 * scale / 3) + 'px monospace';
                ctx.fillText(i + 1, x + 4, y + 14 * scale / 3);
            });

            // Draw drag selection preview
            if (playerFrameDragging && playerFrameDragStart && playerFrameDragEnd) {
                const startGX = Math.min(playerFrameDragStart.gridX, playerFrameDragEnd.gridX);
                const startGY = Math.min(playerFrameDragStart.gridY, playerFrameDragEnd.gridY);
                const endGX = Math.max(playerFrameDragStart.gridX, playerFrameDragEnd.gridX);
                const endGY = Math.max(playerFrameDragStart.gridY, playerFrameDragEnd.gridY);

                const selX = startGX * fw;
                const selY = startGY * fh;
                const selW = (endGX - startGX + 1) * fw;
                const selH = (endGY - startGY + 1) * fh;

                ctx.fillStyle = 'rgba(255, 200, 0, 0.4)';
                ctx.fillRect(selX, selY, selW, selH);
                ctx.strokeStyle = '#fc0';
                ctx.lineWidth = 3;
                ctx.strokeRect(selX, selY, selW, selH);
            }

            document.getElementById('playerZoomLevel').textContent = scale + 'x';
        }

        function playerZoomIn() {
            if (playerEditorZoom < 6) {
                playerEditorZoom++;
                playerDrawCanvas();
            }
        }

        function playerZoomOut() {
            if (playerEditorZoom > 1) {
                playerEditorZoom--;
                playerDrawCanvas();
            }
        }

        // Canvas drag-selection handlers for multi-tile frames
        (function() {
            const canvas = document.getElementById('playerEditorCanvas');

            canvas.addEventListener('mousedown', function(e) {
                if (playerEditorSheets.length === 0) return;

                const rect = this.getBoundingClientRect();
                const scale = playerEditorZoom;
                const clickX = (e.clientX - rect.left) / scale;
                const clickY = (e.clientY - rect.top) / scale;

                // Start drag for multi-tile selection
                const gridX = Math.floor(clickX / playerEditorFrameW);
                const gridY = Math.floor(clickY / playerEditorFrameH);
                playerFrameDragStart = { gridX, gridY };
                playerFrameDragEnd = { gridX, gridY };
                playerFrameDragging = true;
                playerDrawCanvas();
            });

            canvas.addEventListener('mousemove', function(e) {
                if (playerEditorSheets.length === 0) return;
                if (!playerFrameDragging) return;

                const rect = this.getBoundingClientRect();
                const scale = playerEditorZoom;
                const clickX = (e.clientX - rect.left) / scale;
                const clickY = (e.clientY - rect.top) / scale;

                const gridX = Math.floor(clickX / playerEditorFrameW);
                const gridY = Math.floor(clickY / playerEditorFrameH);
                playerFrameDragEnd = { gridX, gridY };
                playerDrawCanvas();
            });

            canvas.addEventListener('mouseup', function(e) {
                // Finalize frame drag selection
                if (playerFrameDragging && playerFrameDragStart && playerFrameDragEnd) {
                    // Calculate rectangle bounds (handle drag in any direction)
                    const startGX = Math.min(playerFrameDragStart.gridX, playerFrameDragEnd.gridX);
                    const startGY = Math.min(playerFrameDragStart.gridY, playerFrameDragEnd.gridY);
                    const endGX = Math.max(playerFrameDragStart.gridX, playerFrameDragEnd.gridX);
                    const endGY = Math.max(playerFrameDragStart.gridY, playerFrameDragEnd.gridY);

                    // Calculate frame in pixels
                    const frameX = startGX * playerEditorFrameW;
                    const frameY = startGY * playerEditorFrameH;
                    const frameW = (endGX - startGX + 1) * playerEditorFrameW;
                    const frameH = (endGY - startGY + 1) * playerEditorFrameH;

                    // Initialize animation array if needed
                    if (!playerAnimations[playerCurrentAnim]) {
                        playerAnimations[playerCurrentAnim] = [];
                    }

                    const frames = playerAnimations[playerCurrentAnim];

                    // Always add frame (allows same frame multiple times for animation)
                    // Use frame list to remove individual frames
                    frames.push({
                        x: frameX,
                        y: frameY,
                        w: frameW,
                        h: frameH,
                        sheet: playerCurrentSheetIndex
                    });

                    playerDrawCanvas();
                    playerUpdateAnimButtons();
                    playerUpdateFramesList();
                    playerStartPreview();
                }

                // Reset drag state
                playerFrameDragging = false;
                playerFrameDragStart = null;
                playerFrameDragEnd = null;
            });

            canvas.addEventListener('mouseleave', function(e) {
                // Cancel drag on mouse leave
                if (playerFrameDragging) {
                    playerFrameDragging = false;
                    playerFrameDragStart = null;
                    playerFrameDragEnd = null;
                    playerDrawCanvas();
                }
            });
        })();

        function playerUpdateFramesList() {
            const container = document.getElementById('playerFramesList');
            const frames = playerAnimations[playerCurrentAnim] || [];

            if (frames.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px;">Click on sprite sheet to add frames</div>';
                return;
            }

            container.innerHTML = '';
            frames.forEach((frame, i) => {
                const wrapper = document.createElement('div');
                wrapper.style.cssText = 'display:inline-block; position:relative;';

                const thumb = document.createElement('canvas');
                thumb.width = 48;
                thumb.height = 48;
                thumb.style.cssText = 'border:1px solid #4f8; border-radius:3px; background:#111; image-rendering:pixelated; cursor:pointer;';
                const sheetNum = (frame.sheet || 0) + 1;
                thumb.title = 'Frame ' + (i + 1) + ' (Sheet ' + sheetNum + ') - Click to remove';

                // Get correct sheet for this frame
                const sheetIndex = frame.sheet || 0;
                const sheet = playerEditorSheets[sheetIndex];
                if (sheet) {
                    const ctx = thumb.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    const scale = Math.min(46 / frame.w, 46 / frame.h);
                    const dw = frame.w * scale;
                    const dh = frame.h * scale;
                    ctx.drawImage(sheet.image, frame.x, frame.y, frame.w, frame.h, (48 - dw) / 2, (48 - dh) / 2, dw, dh);
                }

                thumb.onclick = () => {
                    frames.splice(i, 1);
                    playerDrawCanvas();
                    playerUpdateAnimButtons();
                    playerUpdateFramesList();
                    playerStartPreview();
                };

                wrapper.appendChild(thumb);

                // Show sheet number badge if multiple sheets
                if (playerEditorSheets.length > 1) {
                    const badge = document.createElement('div');
                    badge.textContent = sheetNum;
                    badge.style.cssText = 'position:absolute; top:-4px; right:-4px; background:#4af; color:#000; font-size:9px; font-weight:bold; width:14px; height:14px; border-radius:50%; display:flex; align-items:center; justify-content:center;';
                    wrapper.appendChild(badge);
                }

                container.appendChild(wrapper);
            });
        }

        function playerUpdateSpeed() {
            const fps = parseInt(document.getElementById('playerSpeedSlider').value);
            playerAnimFpsList[playerCurrentAnim] = fps;
            document.getElementById('playerSpeedLabel').textContent = fps + ' fps';
            if (playerPreviewPlaying) {
                playerStartPreview();
            }
        }

        // Get FPS for current animation (defaults to 8)
        function playerGetCurrentFps() {
            return playerAnimFpsList[playerCurrentAnim] || 8;
        }

        function playerUpdatePingPong() {
            playerPingPong = document.getElementById('playerPingPong').checked;
            playerPreviewDirection = 1;
            playerStartPreview();
        }

        function playerToggleMirror() {
            playerAnimMirrors[playerCurrentAnim] = !playerAnimMirrors[playerCurrentAnim];
            playerUpdateMirrorButton();
            playerStartPreview(); // Restart preview with new mirror state
        }

        function playerUpdateMirrorButton() {
            const btn = document.getElementById('playerMirrorBtn');
            if (playerAnimMirrors[playerCurrentAnim]) {
                btn.style.background = '#4f8';
                btn.style.color = '#000';
                btn.style.borderColor = '#4f8';
                btn.textContent = 'Mirrored';
            } else {
                btn.style.background = '#555';
                btn.style.color = '#fff';
                btn.style.borderColor = '#888';
                btn.textContent = 'Mirror';
            }
        }

        // Shape-based hitbox functions (per-direction)
        let playerHitboxEditDir = 'down';

        function setPlayerHitboxDir(dir) {
            playerHitboxEditDir = dir;
            document.querySelectorAll('[id^="phbDir"]').forEach(b => {
                b.classList.remove('active');
                b.style.background = '';
            });
            const btn = document.getElementById('phbDir' + dir.charAt(0).toUpperCase() + dir.slice(1));
            if (btn) {
                btn.classList.add('active');
                btn.style.background = '#606';
            }
            updatePlayerHitboxSliders();
        }

        function updatePlayerHitboxSliders() {
            const dir = playerHitboxEditDir;
            document.getElementById('playerHitboxRange').value = playerHitboxRange[dir] || 40;
            document.getElementById('playerHitboxWidth').value = playerHitboxWidth[dir] || 60;
            document.getElementById('playerHitboxOffsetX').value = playerHitboxOffsetX[dir] || 0;
            document.getElementById('playerHitboxOffsetY').value = playerHitboxOffsetY[dir] || 0;
            document.getElementById('playerHitboxRangeVal').textContent = playerHitboxRange[dir] || 40;
            document.getElementById('playerHitboxWidthVal').textContent = playerHitboxWidth[dir] || 60;
            document.getElementById('playerHitboxOffsetXVal').textContent = playerHitboxOffsetX[dir] || 0;
            document.getElementById('playerHitboxOffsetYVal').textContent = playerHitboxOffsetY[dir] || 0;
        }

        function updatePlayerHitboxShape() {
            const dir = playerHitboxEditDir;
            playerHitboxRange[dir] = parseInt(document.getElementById('playerHitboxRange').value);
            playerHitboxWidth[dir] = parseInt(document.getElementById('playerHitboxWidth').value);
            playerHitboxOffsetX[dir] = parseInt(document.getElementById('playerHitboxOffsetX').value);
            playerHitboxOffsetY[dir] = parseInt(document.getElementById('playerHitboxOffsetY').value);
            document.getElementById('playerHitboxRangeVal').textContent = playerHitboxRange[dir];
            document.getElementById('playerHitboxWidthVal').textContent = playerHitboxWidth[dir];
            document.getElementById('playerHitboxOffsetXVal').textContent = playerHitboxOffsetX[dir];
            document.getElementById('playerHitboxOffsetYVal').textContent = playerHitboxOffsetY[dir];
        }

        function copyPlayerHitboxToAll() {
            const dir = playerHitboxEditDir;
            ['up', 'down', 'left', 'right'].forEach(d => {
                playerHitboxRange[d] = playerHitboxRange[dir];
                playerHitboxWidth[d] = playerHitboxWidth[dir];
                playerHitboxOffsetX[d] = playerHitboxOffsetX[dir];
                playerHitboxOffsetY[d] = playerHitboxOffsetY[dir];
            });
            console.log('Copied ' + dir + ' hitbox to all directions');
        }

        function playerUpdateHitboxUI() {
            const section = document.getElementById('playerHitboxSection');
            const isAttackAnim = playerCurrentAnim.startsWith('attack');
            // Show hitbox section only for attack animations
            if (section) section.style.display = isAttackAnim ? 'block' : 'none';
            // Update slider values
            if (document.getElementById('playerHitboxRange')) {
                updatePlayerHitboxSliders();
            }
        }

        function playerStartPreview() {
            playerStopPreview();
            const frames = playerAnimations[playerCurrentAnim] || [];
            if (frames.length === 0 || playerEditorSheets.length === 0) return;

            playerPreviewPlaying = true;
            playerPreviewFrame = 0;
            playerPreviewDirection = 1;
            const isMirrored = playerAnimMirrors[playerCurrentAnim];

            const canvas = document.getElementById('playerLivePreview');
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            function drawFrame() {
                if (!playerPreviewPlaying) return;
                const frame = frames[playerPreviewFrame];
                // Get the correct sheet for this frame
                const sheetIndex = frame.sheet || 0;
                const sheet = playerEditorSheets[sheetIndex];
                if (!sheet) return;

                ctx.clearRect(0, 0, 96, 96);
                const scale = Math.min(94 / frame.w, 94 / frame.h);
                const dw = frame.w * scale;
                const dh = frame.h * scale;
                const dx = (96 - dw) / 2;
                const dy = (96 - dh) / 2;

                // Apply mirror transform if enabled
                if (isMirrored) {
                    ctx.save();
                    ctx.translate(96, 0);
                    ctx.scale(-1, 1);
                    ctx.drawImage(sheet.image, frame.x, frame.y, frame.w, frame.h, 96 - dx - dw, dy, dw, dh);
                    ctx.restore();
                } else {
                    ctx.drawImage(sheet.image, frame.x, frame.y, frame.w, frame.h, dx, dy, dw, dh);
                }

                // Ping-pong or loop
                if (playerPingPong && frames.length > 1) {
                    playerPreviewFrame += playerPreviewDirection;
                    if (playerPreviewFrame >= frames.length - 1) {
                        playerPreviewDirection = -1;
                    } else if (playerPreviewFrame <= 0) {
                        playerPreviewDirection = 1;
                    }
                } else {
                    playerPreviewFrame = (playerPreviewFrame + 1) % frames.length;
                }
            }

            drawFrame();
            playerPreviewInterval = setInterval(drawFrame, 1000 / playerGetCurrentFps());
        }

        function playerStopPreview() {
            playerPreviewPlaying = false;
            if (playerPreviewInterval) {
                clearInterval(playerPreviewInterval);
                playerPreviewInterval = null;
            }
        }

        function playerClearCurrentAnim() {
            playerAnimations[playerCurrentAnim] = [];
            playerDrawCanvas();
            playerUpdateAnimButtons();
            playerUpdateFramesList();
            playerStopPreview();
        }

        function playerAddCustomAnim() {
            const input = document.getElementById('playerCustomAnimName');
            const name = input.value.trim();
            if (!name) {
                alert('Enter an animation name');
                return;
            }
            // Reserved names
            const reserved = ['walkDown', 'walkUp', 'walkLeft', 'walkRight', 'idle', 'idleDown', 'idleUp', 'idleLeft', 'idleRight', 'attackDown', 'attackUp', 'attackLeft', 'attackRight', 'interact', 'death', 'receivedItem'];
            if (reserved.includes(name) || playerAnimations[name]) {
                alert('Animation "' + name + '" already exists or is reserved');
                return;
            }

            playerAnimations[name] = [];
            input.value = '';
            playerSelectAnim(name);
            playerUpdateCustomAnimList();
            playerUpdateAnimButtons();
        }

        function playerUpdateCustomAnimList() {
            const container = document.getElementById('playerCustomAnimList');
            if (!container) return;

            // Get custom animations (not the default ones)
            const reserved = ['walkDown', 'walkUp', 'walkLeft', 'walkRight', 'idle', 'idleDown', 'idleUp', 'idleLeft', 'idleRight', 'attackDown', 'attackUp', 'attackLeft', 'attackRight', 'interact', 'death', 'receivedItem'];
            const customAnims = Object.keys(playerAnimations).filter(k => !reserved.includes(k));

            if (customAnims.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = '<div style="font-size:10px; color:#a8f; margin-bottom:5px; border-top:1px solid #555; padding-top:5px;">-- Custom --</div>';
            customAnims.forEach(name => {
                const frames = playerAnimations[name] || [];
                const div = document.createElement('div');
                div.style.cssText = 'display:flex; gap:4px; margin-bottom:4px;';
                div.innerHTML = '<button id="playerAnimCustom_' + name + '" onclick="playerSelectAnim(\'' + name + '\')" style="flex:1; padding:4px 6px; font-size:10px; background:#648;">' + name + (frames.length > 0 ? ' (' + frames.length + ')' : '') + '</button>' +
                    '<button onclick="playerDeleteCustomAnim(\'' + name + '\')" style="padding:4px 6px; font-size:10px; background:#a44;">X</button>';
                container.appendChild(div);
            });
        }

        function playerDeleteCustomAnim(name) {
            if (!playerAnimations[name]) return;
            if (playerAnimations[name].length > 0) {
                if (!confirm('Delete "' + name + '" animation with ' + playerAnimations[name].length + ' frames?')) return;
            }
            delete playerAnimations[name];
            if (playerCurrentAnim === name) {
                playerSelectAnim('walkDown');
            }
            playerUpdateCustomAnimList();
            playerUpdateAnimButtons();
        }

        // Game Over Sound functions
        // Index scheme: -1 = none, 0-99 = builtin sounds, 100+ = project sounds (index - 100)
        function playerPopulateGameOverSoundDropdown() {
            const select = document.getElementById('playerGameOverSound');
            if (!select) return;
            select.innerHTML = '<option value="-1">None</option>';
            // Built-in game over sounds
            builtinGameOverSounds.forEach((sound, index) => {
                const opt = document.createElement('option');
                opt.value = index; // 0, 1, etc for builtin
                opt.textContent = '🎵 ' + sound.name;
                select.appendChild(opt);
            });
            // Project sounds
            if (sounds.length > 0) {
                const separator = document.createElement('option');
                separator.disabled = true;
                separator.textContent = '─── Project Sounds ───';
                select.appendChild(separator);
                sounds.forEach((sound, index) => {
                    const opt = document.createElement('option');
                    opt.value = 100 + index; // 100+ for project sounds
                    opt.textContent = sound.name;
                    select.appendChild(opt);
                });
            }
            select.value = playerGameOverSoundIndex;
        }

        function playerUpdateGameOverSound() {
            const select = document.getElementById('playerGameOverSound');
            playerGameOverSoundIndex = parseInt(select.value);
        }

        function playerPreviewGameOverSound() {
            if (playerGameOverSoundIndex < 0) {
                alert('No game over sound selected');
                return;
            }
            // Check if it's a builtin sound (0-99) or project sound (100+)
            if (playerGameOverSoundIndex < 100) {
                // Builtin sound - lazy load and play
                const builtinIndex = playerGameOverSoundIndex;
                if (builtinIndex >= 0 && builtinIndex < builtinGameOverSounds.length) {
                    if (!builtinGameOverAudios[builtinIndex]) {
                        builtinGameOverAudios[builtinIndex] = new Audio(builtinGameOverSounds[builtinIndex].file);
                    }
                    builtinGameOverAudios[builtinIndex].currentTime = 0;
                    builtinGameOverAudios[builtinIndex].play();
                }
            } else {
                // Project sound
                const projectIndex = playerGameOverSoundIndex - 100;
                if (projectIndex >= 0 && projectIndex < sounds.length) {
                    const sound = sounds[projectIndex];
                    if (sound && sound.audio) {
                        sound.audio.currentTime = 0;
                        sound.audio.play();
                    }
                }
            }
        }

        function playerSave() {
            const name = document.getElementById('playerNameInput').value.trim() || 'Player ' + (playerCharacters.length + 1);

            // Check if at least one animation has frames
            const hasFrames = Object.values(playerAnimations).some(a => a && a.length > 0);
            if (!hasFrames) {
                alert('Please add at least one animation frame');
                return;
            }

            // Save all sheets (array of base64 data)
            const sheetsData = playerEditorSheets.map(s => s.data);

            // Get attack movement setting from dropdown
            playerAttackMovement = document.getElementById('playerAttackMovement').value;

            const charData = {
                name: name,
                spriteData: sheetsData[0] || null, // Keep for backwards compatibility
                spriteSheets: sheetsData, // Array of all sheets
                frameWidth: playerEditorFrameW,
                frameHeight: playerEditorFrameH,
                animations: JSON.parse(JSON.stringify(playerAnimations)),
                animMirrors: JSON.parse(JSON.stringify(playerAnimMirrors)),
                hitboxRange: JSON.parse(JSON.stringify(playerHitboxRange)), // Per-direction range
                hitboxWidth: JSON.parse(JSON.stringify(playerHitboxWidth)), // Per-direction width
                hitboxOffsetX: JSON.parse(JSON.stringify(playerHitboxOffsetX)), // Per-direction X offset
                hitboxOffsetY: JSON.parse(JSON.stringify(playerHitboxOffsetY)), // Per-direction Y offset
                animFps: JSON.parse(JSON.stringify(playerAnimFpsList)), // Per-animation FPS
                fps: 8, // Keep for backwards compatibility
                pingPong: playerPingPong,
                attackMovement: playerAttackMovement, // 'stop', 'slide', 'move'
                gameOverSoundIndex: playerGameOverSoundIndex // Index of game over sound
            };

            if (playerEditorEditingIndex >= 0) {
                playerCharacters[playerEditorEditingIndex] = charData;
                broadcastEdit({ editType: 'updatePlayerCharacter', index: playerEditorEditingIndex, character: charData });
            } else {
                playerCharacters.push(charData);
                broadcastEdit({ editType: 'addPlayerCharacter', character: charData });
            }

            // If this is the first character, make it active
            if (playerCharacters.length === 1 && activePlayerIndex < 0) {
                setActivePlayer(0);
            }

            document.getElementById('playerModal').classList.remove('visible');
            playerStopPreview();
            stopEditing(); // Clear editing lock
            updatePlayerList();
        }

        function playerCancel() {
            document.getElementById('playerModal').classList.remove('visible');
            playerStopPreview();
            stopEditing(); // Clear editing lock
        }

        function updatePlayerList() {
            const container = document.getElementById('playerCharacterList');
            const activeNameEl = document.getElementById('activePlayerName');
            const previewCanvas = document.getElementById('activePlayerPreview');

            if (playerCharacters.length === 0) {
                container.innerHTML = '<div style="color:#888; font-size:12px; padding:10px; text-align:center;">No characters created yet</div>';
                activeNameEl.textContent = 'Default Sprite';
                // Draw default sprite preview
                if (previewCanvas && playerSpriteImg && playerSpriteImg.complete && playerSpriteImg.naturalWidth > 0) {
                    const ctx = previewCanvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;
                    ctx.clearRect(0, 0, 64, 64);
                    ctx.drawImage(playerSpriteImg, 0, 0, 64, 64, 0, 0, 64, 64);
                }
                return;
            }

            // Update active player name and preview
            if (activePlayerIndex >= 0 && playerCharacters[activePlayerIndex]) {
                const char = playerCharacters[activePlayerIndex];
                activeNameEl.textContent = char.name;
                // Draw active player preview
                if (previewCanvas && char.spriteData) {
                    const img = new Image();
                    img.onload = () => {
                        const ctx = previewCanvas.getContext('2d');
                        ctx.imageSmoothingEnabled = false;
                        ctx.clearRect(0, 0, 64, 64);
                        const anims = char.animations || {};
                        const frames = (anims.walkDown?.length > 0 ? anims.walkDown : null) ||
                                       (anims.idle?.length > 0 ? anims.idle : null) ||
                                       Object.values(anims).find(a => a && a.length > 0);
                        if (frames && frames.length > 0) {
                            const frame = frames[0];
                            const scale = Math.min(62 / frame.w, 62 / frame.h);
                            const dw = frame.w * scale;
                            const dh = frame.h * scale;
                            ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, (64 - dw) / 2, (64 - dh) / 2, dw, dh);
                        } else {
                            ctx.drawImage(img, 0, 0, char.frameWidth, char.frameHeight, 0, 0, 64, 64);
                        }
                    };
                    img.src = char.spriteData;
                }
            } else {
                activeNameEl.textContent = 'Default Sprite';
            }

            container.innerHTML = '';
            playerCharacters.forEach((char, i) => {
                const div = document.createElement('div');
                const isActive = i === activePlayerIndex;
                div.style.cssText = 'display:flex; align-items:center; gap:8px; padding:5px; margin-bottom:5px; background:' + (isActive ? '#2a5a3a' : '#333') + '; border-radius:4px; cursor:pointer;' + (isActive ? 'border:1px solid #4f8;' : '');

                // Thumbnail
                const thumb = document.createElement('canvas');
                thumb.width = 32;
                thumb.height = 32;
                thumb.style.cssText = 'border:1px solid #555; border-radius:3px; image-rendering:pixelated;';

                const anims = char.animations || {};
                const firstAnim = (anims.walkDown?.length > 0 ? anims.walkDown : null) ||
                                  (anims.idle?.length > 0 ? anims.idle : null) ||
                                  Object.values(anims).find(a => a && a.length > 0);
                if (char.spriteData && firstAnim && firstAnim.length > 0) {
                    const img = new Image();
                    img.onload = () => {
                        const ctx = thumb.getContext('2d');
                        ctx.imageSmoothingEnabled = false;
                        const frame = firstAnim[0];
                        const scale = Math.min(32 / frame.w, 32 / frame.h);
                        const dw = frame.w * scale;
                        const dh = frame.h * scale;
                        ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, (32 - dw) / 2, (32 - dh) / 2, dw, dh);
                    };
                    img.src = char.spriteData;
                }

                // Active indicator
                const indicator = document.createElement('span');
                indicator.textContent = isActive ? '*' : '';
                indicator.style.cssText = 'color:#4f8; font-weight:bold; width:12px;';

                // Name
                const nameSpan = document.createElement('span');
                nameSpan.textContent = char.name;
                nameSpan.style.cssText = 'flex:1; font-size:12px;';

                // Set Active button
                const activeBtn = document.createElement('button');
                activeBtn.textContent = isActive ? 'Active' : 'Use';
                activeBtn.style.cssText = 'padding:2px 6px; font-size:10px; background:' + (isActive ? '#4f8' : '#555') + '; color:' + (isActive ? '#000' : '#fff') + ';';
                activeBtn.onclick = (e) => { e.stopPropagation(); setActivePlayer(i); };

                // Edit button
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.style.cssText = 'padding:2px 6px; font-size:10px; background:#666;';
                editBtn.onclick = (e) => { e.stopPropagation(); openPlayerEditor(i); };

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = 'X';
                delBtn.style.cssText = 'padding:2px 6px; font-size:10px; background:#a55;';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Delete character "' + char.name + '"?')) {
                        deletePlayerCharacter(i);
                    }
                };

                div.onclick = () => setActivePlayer(i);

                div.appendChild(thumb);
                div.appendChild(indicator);
                div.appendChild(nameSpan);
                div.appendChild(activeBtn);
                div.appendChild(editBtn);
                div.appendChild(delBtn);
                container.appendChild(div);
            });
        }

        function setActivePlayer(index) {
            activePlayerIndex = index;
            updatePlayerList();
            broadcastEdit({ editType: 'setActivePlayer', index: index });
        }

        function deletePlayerCharacter(index) {
            playerCharacters.splice(index, 1);
            if (activePlayerIndex >= playerCharacters.length) {
                activePlayerIndex = playerCharacters.length - 1;
            }
            if (activePlayerIndex === index) {
                activePlayerIndex = playerCharacters.length > 0 ? 0 : -1;
            }
            updatePlayerList();
            broadcastEdit({ editType: 'deletePlayerCharacter', index: index });
        }

        // ============ END PLAYER CHARACTER EDITOR ============

        // Button click sounds for start screen
        const buttonNavSound = new Audio('sounds/button-press-382713.mp3'); // Navigation clicks
        buttonNavSound.volume = 0.5;
        const buttonActionSound = new Audio('sounds/button-select.mp3'); // Final action (join/build/start)
        buttonActionSound.volume = 0.5;

        function playButtonSound() {
            buttonNavSound.currentTime = 0;
            buttonNavSound.play().catch(() => {});
        }

        function playActionSound() {
            buttonActionSound.currentTime = 0;
            buttonActionSound.play().catch(() => {});
        }

        // Set up NPC canvas mouse handlers
        document.addEventListener('DOMContentLoaded', () => {
            // Add navigation sound to all retro-btn in loadPhase
            document.querySelectorAll('#loadPhase .retro-btn').forEach(btn => {
                btn.addEventListener('click', playButtonSound);
            });
            const npcCanvas = document.getElementById('npcEditorCanvas');
            if (npcCanvas) {
                npcCanvas.addEventListener('mousedown', function(e) {
                    if (!npcEditorImage) return;

                    const rect = this.getBoundingClientRect();
                    const scale = npcEditorZoom;
                    const clickX = (e.clientX - rect.left) / scale;
                    const clickY = (e.clientY - rect.top) / scale;

                    if (npcTool === 'collision' || npcTool === 'erase') {
                        npcPainting = true;
                        npcPaintCollision(Math.floor(clickX), Math.floor(clickY), npcTool === 'erase');
                        npcDrawCanvas();
                    } else if (npcTool === 'split') {
                        npcPainting = true;
                        npcPaintSplit(Math.floor(clickX), Math.floor(clickY));
                        npcDrawCanvas();
                    } else {
                        // Frame selection mode (npcTool === 'none') - start drag for multi-tile selection
                        const gridX = Math.floor(clickX / npcEditorFrameW);
                        const gridY = Math.floor(clickY / npcEditorFrameH);
                        npcFrameDragStart = { gridX, gridY };
                        npcFrameDragEnd = { gridX, gridY };
                        npcFrameDragging = true;
                        npcDrawCanvas();
                    }
                });

                npcCanvas.addEventListener('mousemove', function(e) {
                    if (!npcEditorImage) return;

                    const rect = this.getBoundingClientRect();
                    const scale = npcEditorZoom;
                    const clickX = (e.clientX - rect.left) / scale;
                    const clickY = (e.clientY - rect.top) / scale;

                    // Update brush preview position
                    if (npcTool === 'collision' || npcTool === 'erase') {
                        npcBrushPreviewPos = { x: Math.floor(clickX), y: Math.floor(clickY) };
                        if (!npcPainting) npcDrawCanvas(); // Redraw for preview
                    } else {
                        npcBrushPreviewPos = null;
                    }

                    // Handle frame drag selection
                    if (npcFrameDragging) {
                        const gridX = Math.floor(clickX / npcEditorFrameW);
                        const gridY = Math.floor(clickY / npcEditorFrameH);
                        npcFrameDragEnd = { gridX, gridY };
                        npcDrawCanvas();
                        return;
                    }

                    if (!npcPainting) return;

                    if (npcTool === 'collision' || npcTool === 'erase') {
                        npcPaintCollision(Math.floor(clickX), Math.floor(clickY), npcTool === 'erase');
                        npcDrawCanvas();
                    } else if (npcTool === 'split') {
                        npcPaintSplit(Math.floor(clickX), Math.floor(clickY));
                        npcDrawCanvas();
                    }
                });

                npcCanvas.addEventListener('mouseleave', function() {
                    npcBrushPreviewPos = null;
                    if (npcTool === 'collision' || npcTool === 'erase') {
                        npcDrawCanvas();
                    }
                });

                npcCanvas.addEventListener('mouseup', function(e) {
                    // Finalize frame drag selection
                    if (npcFrameDragging && npcFrameDragStart && npcFrameDragEnd) {
                        // Calculate rectangle bounds (handle drag in any direction)
                        const startGX = Math.min(npcFrameDragStart.gridX, npcFrameDragEnd.gridX);
                        const startGY = Math.min(npcFrameDragStart.gridY, npcFrameDragEnd.gridY);
                        const endGX = Math.max(npcFrameDragStart.gridX, npcFrameDragEnd.gridX);
                        const endGY = Math.max(npcFrameDragStart.gridY, npcFrameDragEnd.gridY);

                        // Calculate frame in pixels
                        const frameX = startGX * npcEditorFrameW;
                        const frameY = startGY * npcEditorFrameH;
                        const frameW = (endGX - startGX + 1) * npcEditorFrameW;
                        const frameH = (endGY - startGY + 1) * npcEditorFrameH;

                        // Initialize animation array if needed
                        if (!npcAnimations[npcCurrentAnim]) {
                            npcAnimations[npcCurrentAnim] = [];
                        }

                        const frames = npcAnimations[npcCurrentAnim];

                        // Always add frame (allows same frame multiple times for animation)
                        frames.push({
                            x: frameX,
                            y: frameY,
                            w: frameW,
                            h: frameH
                        });

                        npcDrawCanvas();
                        npcUpdateFramesList();
                        npcUpdateAnimButtons();
                        npcStartPreview();
                    }

                    // Reset drag state
                    npcFrameDragging = false;
                    npcFrameDragStart = null;
                    npcFrameDragEnd = null;
                    npcPainting = false;
                });

                npcCanvas.addEventListener('mouseleave', function(e) {
                    // Cancel drag on mouse leave
                    if (npcFrameDragging) {
                        npcFrameDragging = false;
                        npcFrameDragStart = null;
                        npcFrameDragEnd = null;
                        npcDrawCanvas();
                    }
                    npcPainting = false;
                });
            }
        });

        // ===== NPC PLACEMENT & PATH FUNCTIONS =====

        function placeNpcAt(x, y) {
            console.log('placeNpcAt called:', x, y, 'currentNpcIndex:', currentNpcIndex);
            if (currentNpcIndex < 0 || !npcs[currentNpcIndex]) {
                console.log('No NPC selected, cannot place');
                return;
            }

            // Check if there's already an NPC at this position
            const existing = placedNpcs.findIndex(p => p.x === x && p.y === y && p.mapName === currentMapName);
            if (existing >= 0) {
                // Select existing instead of placing new
                selectPlacedNpc(existing);
                return;
            }

            // Get current scale from placement slider (for new placement)
            const currentScale = parseFloat(document.getElementById('npcPlacementScale')?.value) || 1;

            const placed = {
                npcIndex: currentNpcIndex,
                mapName: currentMapName,
                x: x,
                y: y,
                path: [],
                trigger: 'loop',
                speed: 3,
                scale: currentScale,
                uid: 'npc_' + currentNpcIndex + '_' + Date.now() // Assign UID immediately for quest system
            };

            placedNpcs.push(placed);
            selectedPlacedNpcIndex = placedNpcs.length - 1;
            // Broadcast to co-op builders
            broadcastEdit({ editType: 'placeNpc', npc: placed, index: selectedPlacedNpcIndex });

            updatePlacedNpcList();
            showNpcPathPanel();
            renderMap();
        }

        function findPlacedNpcAt(x, y) {
            return placedNpcs.findIndex(p => p.x === x && p.y === y && p.mapName === currentMapName);
        }

        function selectPlacedNpc(index) {
            // Stop any running preview when selecting different NPC
            if (npcPathPreviewActive && index !== selectedPlacedNpcIndex) {
                stopNpcPathPreview();
            }

            selectedPlacedNpcIndex = index;
            npcPathDrawing = false;
            npcPathEditing = false;
            npcDraggingWaypoint = -1;
            updatePathDrawButton();

            const placed = placedNpcs[index];
            if (placed) {
                document.getElementById('npcTriggerType').value = placed.trigger || 'loop';
                document.getElementById('npcWalkSpeed').value = placed.speed || 3;
                document.getElementById('npcSpeedValue').textContent = placed.speed || 3;
                // Load animation speed (default to NPC's fps or 8)
                const npc = npcs[placed.npcIndex];
                const defaultFps = npc?.fps || 8;
                const animSpeed = placed.animSpeed || defaultFps;
                document.getElementById('npcAnimSpeed').value = animSpeed;
                document.getElementById('npcAnimSpeedValue').textContent = animSpeed + ' fps';
            }

            updatePlacedNpcList();
            showNpcPathPanel();
            renderMap();
        }

        function removeNpcAt(x, y) {
            const idx = findPlacedNpcAt(x, y);
            if (idx >= 0) {
                placedNpcs.splice(idx, 1);
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeNpc', index: idx });
                if (selectedPlacedNpcIndex === idx) {
                    selectedPlacedNpcIndex = -1;
                    hideNpcPathPanel();
                } else if (selectedPlacedNpcIndex > idx) {
                    selectedPlacedNpcIndex--;
                }
                updatePlacedNpcList();
                renderMap();
            }
        }

        function deleteSelectedPlacedNpc() {
            if (selectedPlacedNpcIndex >= 0) {
                const idx = selectedPlacedNpcIndex;
                placedNpcs.splice(selectedPlacedNpcIndex, 1);
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeNpc', index: idx });
                selectedPlacedNpcIndex = -1;
                npcPathDrawing = false;
                hideNpcPathPanel();
                updatePlacedNpcList();
                renderMap();
            }
        }

        function showNpcPathPanel() {
            const panel = document.getElementById('npcPathPanel');
            if (!panel) {
                console.error('npcPathPanel not found!');
                return;
            }
            panel.style.display = 'block';
            console.log('Path panel shown, selectedPlacedNpcIndex:', selectedPlacedNpcIndex);

            if (selectedPlacedNpcIndex >= 0) {
                const placed = placedNpcs[selectedPlacedNpcIndex];
                const npc = npcs[placed.npcIndex];
                document.getElementById('npcPathName').textContent = npc ? npc.name : 'NPC';
                updateNpcWaypointList();
                updatePathDrawButton();

                // Load enemy settings
                const isEnemy = placed.isEnemy || false;
                const attackMode = placed.attackMode || 'touch';
                document.getElementById('npcIsEnemy').checked = isEnemy;
                document.getElementById('npcEnemyOptions').style.display = isEnemy ? 'block' : 'none';
                document.getElementById('npcVisionRadius').value = placed.visionRadius || 5;
                document.getElementById('npcVisionValue').textContent = (placed.visionRadius || 5) + ' tiles';
                document.getElementById('npcChaseSpeed').value = placed.chaseSpeed || 4;
                document.getElementById('npcChaseSpeedValue').textContent = placed.chaseSpeed || 4;
                document.getElementById('npcAttackMode').value = attackMode;
                document.getElementById('npcDamage').value = placed.damage || 10;
                document.getElementById('npcDamageValue').textContent = placed.damage || 10;
                document.getElementById('npcAttackCooldown').value = placed.attackCooldown || 1;
                document.getElementById('npcCooldownValue').textContent = (placed.attackCooldown || 1).toFixed(1) + 's';
                document.getElementById('npcLungeOptions').style.display = attackMode === 'lunge' ? 'block' : 'none';
                document.getElementById('npcAttackRange').value = placed.attackRange || 2;
                document.getElementById('npcLungeRangeValue').textContent = (placed.attackRange || 2) + ' tiles';
                document.getElementById('npcLungeSpeed').value = placed.lungeSpeed || 8;
                document.getElementById('npcLungeSpeedValue').textContent = placed.lungeSpeed || 8;
                // Load slowdown settings
                document.getElementById('npcSlowdownPercent').value = placed.slowdownPercent !== undefined ? placed.slowdownPercent : 50;
                document.getElementById('npcSlowdownValue').textContent = (placed.slowdownPercent !== undefined ? placed.slowdownPercent : 50) + '%';
                document.getElementById('npcSlowdownDuration').value = placed.slowdownDuration !== undefined ? placed.slowdownDuration : 0.5;
                document.getElementById('npcSlowdownDurationValue').textContent = (placed.slowdownDuration !== undefined ? placed.slowdownDuration : 0.5).toFixed(2) + 's';

                // Load trigger and speed settings
                document.getElementById('npcTriggerType').value = placed.trigger || 'loop';
                document.getElementById('npcWalkSpeed').value = placed.speed || 3;
                document.getElementById('npcSpeedValue').textContent = placed.speed || 3;

                // Load scale setting
                document.getElementById('npcScale').value = placed.scale || 1;
                document.getElementById('npcScaleValue').textContent = (placed.scale || 1).toFixed(1) + 'x';

                // Show quest chain info for this NPC
                updateNpcQuestChainPanel(placed);
            }
        }

        function updateNpcQuestChainPanel(placed) {
            const panel = document.getElementById('npcQuestChainPanel');
            const list = document.getElementById('npcQuestChainList');
            if (!panel || !list) return;

            // Find all quests that reference this NPC
            const npcUid = placed.uid;
            if (!npcUid || !quests || quests.length === 0) {
                panel.style.display = 'none';
                return;
            }

            // Get quests where this NPC is the START NPC (these form the chain)
            const questsForNpc = [];
            quests.forEach((quest, index) => {
                if (quest.startNpcUid === npcUid) {
                    const roles = ['Start'];
                    if (quest.turnInNpcUid === npcUid) roles.push('Turn-in');
                    questsForNpc.push({
                        quest,
                        globalIndex: index,
                        roles: roles.join(' & ')
                    });
                } else if (quest.turnInNpcUid === npcUid) {
                    // Turn-in only (not part of this NPC's chain, just receives)
                    questsForNpc.push({
                        quest,
                        globalIndex: index,
                        roles: 'Turn-in only',
                        isTurnInOnly: true
                    });
                }
            });

            if (questsForNpc.length === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';

            // Separate chain quests from turn-in only
            const chainQuests = questsForNpc.filter(q => !q.isTurnInOnly);
            const turnInOnlyQuests = questsForNpc.filter(q => q.isTurnInOnly);

            let html = '';

            // Show chain quests with per-NPC order numbers
            if (chainQuests.length > 0) {
                html += chainQuests.map((q, i) => {
                    const orderBadge = chainQuests.length > 1 ?
                        `<span style="background:#fa0; color:#000; padding:1px 5px; border-radius:3px; font-weight:bold; margin-right:5px;">${i + 1}</span>` : '';
                    return `<div style="margin-bottom:4px; padding:4px; background:#333; border-radius:3px;">
                        ${orderBadge}<span style="color:#fff;">${q.quest.name || q.quest.id}</span>
                    </div>`;
                }).join('');
            }

            // Show turn-in only quests separately
            if (turnInOnlyQuests.length > 0) {
                html += `<div style="font-size:9px; color:#888; margin-top:6px;">Turn-in for:</div>`;
                html += turnInOnlyQuests.map(q => {
                    return `<div style="margin-bottom:2px; padding:3px; background:#2a2a3a; border-radius:3px; font-size:10px;">
                        <span style="color:#aaa;">${q.quest.name || q.quest.id}</span>
                    </div>`;
                }).join('');
            }

            if (chainQuests.length > 1) {
                html += `<div style="font-size:9px; color:#fa0; margin-top:6px; font-style:italic;">
                    Chain order: #1 triggers first, then #2, etc.
                </div>`;
            }

            list.innerHTML = html;
        }

        function updateNpcEnemy() {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];

            const isEnemy = document.getElementById('npcIsEnemy').checked;
            const visionRadius = parseInt(document.getElementById('npcVisionRadius').value) || 5;
            const chaseSpeed = parseInt(document.getElementById('npcChaseSpeed').value) || 4;
            const attackMode = document.getElementById('npcAttackMode').value || 'touch';
            const damage = parseInt(document.getElementById('npcDamage').value) || 10;
            const attackCooldown = parseFloat(document.getElementById('npcAttackCooldown').value) || 1;
            const attackRange = parseInt(document.getElementById('npcAttackRange').value) || 2;
            const lungeSpeed = parseInt(document.getElementById('npcLungeSpeed').value) || 8;
            const slowdownPercent = parseInt(document.getElementById('npcSlowdownPercent').value);
            const slowdownDuration = parseFloat(document.getElementById('npcSlowdownDuration').value);

            // Update UI labels
            document.getElementById('npcEnemyOptions').style.display = isEnemy ? 'block' : 'none';
            document.getElementById('npcVisionValue').textContent = visionRadius + ' tiles';
            document.getElementById('npcChaseSpeedValue').textContent = chaseSpeed;
            document.getElementById('npcDamageValue').textContent = damage;
            document.getElementById('npcCooldownValue').textContent = attackCooldown.toFixed(1) + 's';
            document.getElementById('npcLungeOptions').style.display = attackMode === 'lunge' ? 'block' : 'none';
            document.getElementById('npcLungeRangeValue').textContent = attackRange + ' tiles';
            document.getElementById('npcLungeSpeedValue').textContent = lungeSpeed;
            document.getElementById('npcSlowdownValue').textContent = slowdownPercent + '%';
            document.getElementById('npcSlowdownDurationValue').textContent = slowdownDuration.toFixed(2) + 's';

            // Update placed NPC data
            placed.isEnemy = isEnemy;
            placed.visionRadius = visionRadius;
            placed.chaseSpeed = chaseSpeed;
            placed.attackMode = attackMode;
            placed.damage = damage;
            placed.attackCooldown = attackCooldown;
            placed.attackRange = attackRange;
            placed.lungeSpeed = lungeSpeed;
            placed.slowdownPercent = slowdownPercent;
            placed.slowdownDuration = slowdownDuration;

            // Broadcast to live sync
            broadcastEdit({
                editType: 'updatePlacedNpc',
                index: selectedPlacedNpcIndex,
                npc: placed
            });

            renderMap();
        }

        function updateNpcScale() {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];

            const scale = parseFloat(document.getElementById('npcScale').value) || 1;
            document.getElementById('npcScaleValue').textContent = scale.toFixed(1) + 'x';

            placed.scale = scale;

            // Broadcast to live sync
            broadcastEdit({
                editType: 'updatePlacedNpc',
                index: selectedPlacedNpcIndex,
                npc: placed
            });

            renderMap();
        }

        // Update placement scale display (before placing)
        function updateNpcPlacementScaleDisplay() {
            const scale = parseFloat(document.getElementById('npcPlacementScale').value) || 1;
            document.getElementById('npcPlacementScaleValue').textContent = scale.toFixed(1) + 'x';
        }

        function hideNpcPathPanel() {
            document.getElementById('npcPathPanel').style.display = 'none';
            npcPathDrawing = false;
            updatePathDrawButton();
        }

        // Toggle NPC settings collapsible panel
        let npcSettingsExpanded = false;
        function toggleNpcSettingsPanel() {
            npcSettingsExpanded = !npcSettingsExpanded;
            const content = document.getElementById('npcSettingsContent');
            const toggle = document.getElementById('npcSettingsToggle');
            if (npcSettingsExpanded) {
                content.style.display = 'block';
                toggle.textContent = '-';
            } else {
                content.style.display = 'none';
                toggle.textContent = '+';
            }
        }

        function toggleNpcPathDrawing() {
            npcPathDrawing = !npcPathDrawing;
            if (npcPathDrawing) {
                npcPathEditing = false; // Disable edit mode when drawing
            }
            updatePathDrawButton();
        }

        function updatePathDrawButton() {
            const drawBtn = document.getElementById('npcDrawPathBtn');
            const editBtn = document.getElementById('npcEditPathBtn');
            const info = document.getElementById('npcPathInfo');

            if (npcPathDrawing) {
                drawBtn.textContent = 'Stop Drawing';
                drawBtn.style.background = '#a55';
                editBtn.style.background = '#47a';
                info.textContent = 'Click tiles to add waypoints. Right-click to undo.';
                info.style.color = '#4f4';
            } else if (npcPathEditing) {
                drawBtn.textContent = 'Draw Path';
                drawBtn.style.background = '#4a4';
                editBtn.textContent = 'Stop Editing';
                editBtn.style.background = '#a55';
                info.textContent = 'Drag waypoint markers to move them. Right-click to delete.';
                info.style.color = '#fa4';
            } else {
                drawBtn.textContent = 'Draw Path';
                drawBtn.style.background = '#4a4';
                editBtn.textContent = 'Edit Path';
                editBtn.style.background = '#47a';
                info.textContent = 'Click tiles to add waypoints';
                info.style.color = '#666';
            }
        }

        function toggleNpcPathEditing() {
            npcPathEditing = !npcPathEditing;
            if (npcPathEditing) {
                npcPathDrawing = false; // Disable draw mode when editing
            }
            npcDraggingWaypoint = -1;
            updatePathDrawButton();
        }

        // Find the nearest waypoint to a given position (within 1 tile distance)
        function findNearestWaypoint(x, y, path) {
            if (!path || path.length === 0) return -1;

            let nearest = -1;
            let minDist = 2; // Max distance of 2 tiles to select

            for (let i = 0; i < path.length; i++) {
                const wp = path[i];
                const dist = Math.abs(wp.x - x) + Math.abs(wp.y - y); // Manhattan distance
                if (dist < minDist) {
                    minDist = dist;
                    nearest = i;
                }
            }

            return nearest;
        }

        function addNpcWaypoint(x, y) {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (!placed.path) placed.path = [];

            // Don't add duplicate consecutive waypoints
            const last = placed.path[placed.path.length - 1];
            if (last && last.x === x && last.y === y) return;

            placed.path.push({ x, y });
            updateNpcWaypointList();
            renderMap();
            broadcastEdit({ editType: 'updatePlacedNpc', index: selectedPlacedNpcIndex, npc: placed });
        }

        function removeLastNpcWaypoint() {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (placed.path && placed.path.length > 0) {
                placed.path.pop();
                updateNpcWaypointList();
                renderMap();
                broadcastEdit({ editType: 'updatePlacedNpc', index: selectedPlacedNpcIndex, npc: placed });
            }
        }

        function clearNpcPath() {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            placed.path = [];
            updateNpcWaypointList();
            renderMap();
            broadcastEdit({ editType: 'updatePlacedNpc', index: selectedPlacedNpcIndex, npc: placed });
        }

        function updateNpcTrigger() {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];
            placed.trigger = document.getElementById('npcTriggerType').value;
            broadcastEdit({ editType: 'updatePlacedNpc', index: selectedPlacedNpcIndex, npc: placed });
        }

        function updateNpcSpeed() {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];
            const speed = parseInt(document.getElementById('npcWalkSpeed').value);
            placed.speed = speed;
            document.getElementById('npcSpeedValue').textContent = speed;
            broadcastEdit({ editType: 'updatePlacedNpc', index: selectedPlacedNpcIndex, npc: placed });
        }

        function updateNpcAnimSpeed() {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];
            const fps = parseInt(document.getElementById('npcAnimSpeed').value);
            placed.animSpeed = fps;
            document.getElementById('npcAnimSpeedValue').textContent = fps + ' fps';
            broadcastEdit({ editType: 'updatePlacedNpc', index: selectedPlacedNpcIndex, npc: placed });
        }

        function updateNpcWaypointList() {
            const container = document.getElementById('npcWaypointList');
            if (selectedPlacedNpcIndex < 0) {
                container.innerHTML = 'No NPC selected';
                return;
            }

            const placed = placedNpcs[selectedPlacedNpcIndex];
            const path = placed.path || [];

            if (path.length === 0) {
                container.innerHTML = 'No waypoints - click Draw Path then click map';
                return;
            }

            // Get available animations for this NPC
            const npc = npcs[placed.npcIndex];
            const customAnims = [];
            if (npc && npc.animations) {
                Object.keys(npc.animations).forEach(key => {
                    if (!['walkDown', 'walkUp', 'walkLeft', 'walkRight', 'idle', 'attackDown', 'attackUp', 'attackLeft', 'attackRight'].includes(key)) {
                        customAnims.push(key);
                    }
                });
            }

            // Show list of waypoints with clear action controls
            let html = '<strong>Waypoints:</strong><div style="margin-top:8px;">';
            path.forEach((wp, i) => {
                const duration = wp.idleTime || 0;
                const action = wp.animation || 'walk';
                const hasStop = duration > 0;

                html += `<div style="background:#1a1a2e; border-radius:4px; padding:6px; margin-bottom:6px; border-left:3px solid ${hasStop ? '#4af' : '#444'};">`;

                // Header row: waypoint number and position
                html += `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;">`;
                html += `<span style="font-weight:bold; color:#4af;">#${i + 1}</span>`;
                html += `<span style="color:#666; font-size:10px;">(${wp.x}, ${wp.y})</span>`;
                html += `</div>`;

                // Action row: what to do at this waypoint
                html += `<div style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;">`;

                // Action dropdown
                html += `<select id="wpAction${i}" style="font-size:11px; padding:3px; background:#333; border:1px solid #555; color:#fff; border-radius:3px;" onchange="setWaypointAction(${i}, this.value)">`;
                html += `<option value="walk"${action === 'walk' ? ' selected' : ''}>Walk through</option>`;
                html += `<option value="idle"${action === 'idle' ? ' selected' : ''}>Stop & Idle</option>`;
                customAnims.forEach(anim => {
                    html += `<option value="${anim}"${action === anim ? ' selected' : ''}>Stop & ${anim}</option>`;
                });
                html += `</select>`;

                // Duration (only show if not walking through)
                if (action !== 'walk') {
                    html += `<span style="color:#888; font-size:10px;">for</span>`;
                    html += `<input type="number" min="1" max="60" value="${duration || 2}" style="width:40px; padding:3px; font-size:11px; background:#333; border:1px solid #555; color:#fff; border-radius:3px; text-align:center;" onchange="setWaypointDuration(${i}, this.value)">`;
                    html += `<span style="color:#888; font-size:10px;">sec</span>`;
                }

                html += `</div>`;
                html += `</div>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        function setWaypointAction(index, action) {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (placed.path && placed.path[index]) {
                placed.path[index].animation = action;
                // If switching from walk to an action, set default duration
                if (action !== 'walk' && !placed.path[index].idleTime) {
                    placed.path[index].idleTime = 2; // Default 2 seconds
                }
                // If switching to walk, clear duration
                if (action === 'walk') {
                    placed.path[index].idleTime = 0;
                }
                updateNpcWaypointList(); // Refresh to show/hide duration
                broadcastEdit({ editType: 'updatePlacedNpc', index: selectedPlacedNpcIndex, npc: placed });
            }
        }

        function setWaypointDuration(index, value) {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (placed.path && placed.path[index]) {
                placed.path[index].idleTime = Math.max(1, parseFloat(value) || 2);
                broadcastEdit({ editType: 'updatePlacedNpc', index: selectedPlacedNpcIndex, npc: placed });
            }
        }

        function setWaypointIdle(index, value) {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (placed.path && placed.path[index]) {
                placed.path[index].idleTime = parseFloat(value) || 0;
                broadcastEdit({ editType: 'updatePlacedNpc', index: selectedPlacedNpcIndex, npc: placed });
            }
        }

        function setWaypointAnim(index, value) {
            if (selectedPlacedNpcIndex < 0) return;
            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (placed.path && placed.path[index]) {
                placed.path[index].animation = value || '';
                broadcastEdit({ editType: 'updatePlacedNpc', index: selectedPlacedNpcIndex, npc: placed });
            }
        }

        function updatePlacedNpcList() {
            const container = document.getElementById('placedNpcList');
            const currentMapNpcs = placedNpcs.filter(p => p.mapName === currentMapName);

            if (currentMapNpcs.length === 0) {
                container.innerHTML = 'No NPCs placed on this map';
                return;
            }

            container.innerHTML = '';
            currentMapNpcs.forEach((placed, localIdx) => {
                const globalIdx = placedNpcs.indexOf(placed);
                const npc = npcs[placed.npcIndex];
                const div = document.createElement('div');
                div.style.cssText = 'padding:4px; margin-bottom:3px; background:' +
                    (globalIdx === selectedPlacedNpcIndex ? '#2a5a8a' : '#333') +
                    '; border-radius:3px; cursor:pointer;';
                div.innerHTML = `<strong>${npc ? npc.name : 'Unknown'}</strong> at (${placed.x},${placed.y})` +
                    `<br><span style="font-size:9px; color:#888;">${placed.trigger} | ${placed.path?.length || 0} waypoints</span>`;
                div.onclick = () => selectPlacedNpc(globalIdx);
                container.appendChild(div);
            });
        }

        // ===== NPC PATH PREVIEW =====
        function toggleNpcPathPreview() {
            if (npcPathPreviewActive) {
                stopNpcPathPreview();
            } else {
                startNpcPathPreview();
            }
        }

        function startNpcPathPreview() {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (!placed.path || placed.path.length === 0) {
                alert('No path to preview. Draw a path first.');
                return;
            }

            npcPathPreviewActive = true;
            npcPreviewState = {
                x: placed.x,
                y: placed.y,
                waypointIndex: 0,
                direction: 'down',
                frame: 0,
                frameTimer: 0,
                idleUntil: 0,  // Timestamp when idle ends
                waypointAnimation: ''  // Current animation at waypoint
            };

            // Update button
            const btn = document.getElementById('npcPreviewPathBtn');
            btn.textContent = 'Edit';
            btn.style.background = '#a55';

            // Start animation loop
            npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
        }

        function stopNpcPathPreview() {
            npcPathPreviewActive = false;
            if (npcPreviewAnimId) {
                cancelAnimationFrame(npcPreviewAnimId);
                npcPreviewAnimId = null;
            }
            npcPreviewState = null;

            // Update button
            const btn = document.getElementById('npcPreviewPathBtn');
            if (btn) {
                btn.textContent = '▶ Preview';
                btn.style.background = '#47a';
            }

            renderMap();
        }

        let lastPreviewTime = 0;
        function npcPathPreviewLoop(timestamp) {
            if (!npcPathPreviewActive || selectedPlacedNpcIndex < 0) {
                stopNpcPathPreview();
                return;
            }

            const deltaTime = timestamp - lastPreviewTime;
            lastPreviewTime = timestamp;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            const path = placed.path || [];
            const speed = (placed.speed || 3) * 0.05; // Slower for editor preview

            if (path.length === 0) {
                stopNpcPathPreview();
                return;
            }

            // Check if currently idling at a waypoint
            if (npcPreviewState.idleUntil > 0) {
                if (timestamp < npcPreviewState.idleUntil) {
                    // Still idling - just animate, don't move
                    npcPreviewState.frameTimer++;
                    const npc = npcs[placed.npcIndex];
                    const fps = placed.animSpeed || npc?.fps || 8;
                    const animDelay = Math.max(1, Math.round(60 / fps));
                    if (npcPreviewState.frameTimer >= animDelay) {
                        npcPreviewState.frameTimer = 0;
                        npcPreviewState.frame = (npcPreviewState.frame + 1) % 4;
                    }
                    renderMap();
                    npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
                    return;
                } else {
                    // Idle complete - advance to next waypoint
                    npcPreviewState.idleUntil = 0;
                    npcPreviewState.waypointAnimation = '';
                    npcPreviewState.waypointIndex++;

                    // Check if path complete
                    if (npcPreviewState.waypointIndex >= path.length) {
                        npcPreviewState.waypointIndex = 0;
                        npcPreviewState.x = placed.x;
                        npcPreviewState.y = placed.y;
                    }
                    renderMap();
                    npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
                    return;
                }
            }

            // Get target waypoint
            const waypoint = path[npcPreviewState.waypointIndex];
            if (!waypoint) {
                // Loop back to start
                npcPreviewState.waypointIndex = 0;
                npcPreviewState.x = placed.x;
                npcPreviewState.y = placed.y;
                npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
                return;
            }

            // Move towards waypoint
            const dx = waypoint.x - npcPreviewState.x;
            const dy = waypoint.y - npcPreviewState.y;
            const dist = Math.hypot(dx, dy);

            if (dist < speed) {
                // Reached waypoint
                npcPreviewState.x = waypoint.x;
                npcPreviewState.y = waypoint.y;

                // Check for waypoint action (idle time, animation)
                let idleTime = waypoint.idleTime || 0;
                const wpAnim = waypoint.animation || '';

                // If animation is set but not "walk", ensure minimum idle time
                if (wpAnim && wpAnim !== 'walk' && wpAnim !== '' && idleTime <= 0) {
                    idleTime = 2;
                }

                if (idleTime > 0) {
                    // Start idling at this waypoint
                    npcPreviewState.idleUntil = timestamp + (idleTime * 1000);
                    npcPreviewState.waypointAnimation = wpAnim;
                    // Don't advance waypoint yet
                } else {
                    // No idle - advance immediately
                    npcPreviewState.waypointIndex++;
                    if (npcPreviewState.waypointIndex >= path.length) {
                        npcPreviewState.waypointIndex = 0;
                        npcPreviewState.x = placed.x;
                        npcPreviewState.y = placed.y;
                    }
                }
            } else {
                // Move
                npcPreviewState.x += (dx / dist) * speed;
                npcPreviewState.y += (dy / dist) * speed;

                // Set direction
                if (Math.abs(dx) > Math.abs(dy)) {
                    npcPreviewState.direction = dx > 0 ? 'right' : 'left';
                } else {
                    npcPreviewState.direction = dy > 0 ? 'down' : 'up';
                }
            }

            // Update animation frame
            npcPreviewState.frameTimer++;
            const npc = npcs[placed.npcIndex];
            const fps = placed.animSpeed || npc?.fps || 8;
            const animDelay = Math.max(1, Math.round(60 / fps));
            if (npcPreviewState.frameTimer >= animDelay) {
                npcPreviewState.frameTimer = 0;
                npcPreviewState.frame = (npcPreviewState.frame + 1) % 4;
            }

            // Render
            renderMap();

            // Continue loop
            npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
        }

        // ===== ANIMATED PROPS FUNCTIONS =====
        let animPropEditorImage = null;
        let animPropEditorData = null;
        let animPropEditorFrameW = 16;
        let animPropEditorFrameH = 16;
        let animPropEditorEditingIndex = -1;
        let animPropEditorZoom = 3; // Zoom level for sprite sheet
        let animPropTool = 'none'; // 'none', 'collision', 'erase', 'split'
        let animPropCollisionMasks = {}; // Per-frame collision: { frameIndex: 2D array }
        let animPropCollisionFrame = 0; // Which frame we're editing collision for
        let animPropSplitLine = null; // Array of Y values per column (like tileSplitLines)
        let animPropPainting = false;

        function animPropZoomIn() {
            animPropEditorZoom = Math.min(6, animPropEditorZoom + 1);
            document.getElementById('animPropZoomLevel').textContent = animPropEditorZoom + 'x';
            animPropDrawCanvas();
        }

        function animPropZoomOut() {
            animPropEditorZoom = Math.max(1, animPropEditorZoom - 1);
            document.getElementById('animPropZoomLevel').textContent = animPropEditorZoom + 'x';
            animPropDrawCanvas();
        }

        function openAnimPropEditor(editIndex = -1) {
            // Check if someone else is already editing this prop
            if (editIndex >= 0 && isBeingEdited('animProp', editIndex)) {
                const editor = getEditor('animProp', editIndex);
                if (!confirm(`"${editor}" is currently editing this animated prop.\n\nEditing simultaneously may cause conflicts.\n\nOpen anyway?`)) {
                    return;
                }
            }

            // Stop any running preview from previous session
            animPropStopPreview();

            animPropEditorEditingIndex = editIndex;

            // Broadcast that we're editing this prop
            if (editIndex >= 0) {
                startEditing('animProp', editIndex);
            }

            animPropFrames = [];

            // Reset collision/split tool state
            animPropTool = 'none';
            setAnimPropTool('none');

            if (editIndex >= 0 && animatedProps[editIndex]) {
                // Editing existing
                const prop = animatedProps[editIndex];
                animPropEditorFrameW = prop.frameWidth || 16;
                animPropEditorFrameH = prop.frameHeight || 16;
                animPropFrames = JSON.parse(JSON.stringify(prop.frames || []));
                animPropEditorData = prop.spriteData;
                document.getElementById('animPropNameInput').value = prop.name;
                document.getElementById('animPropType').value = prop.type || 'loop';
                const fps = prop.fps || 8;
                document.getElementById('animPropSpeedSlider').value = fps;
                document.getElementById('animPropSpeedLabel').textContent = fps + ' fps';

                // Load existing collision/split data (support both old single-mask and new per-frame format)
                if (prop.collisionMasks) {
                    // New per-frame format
                    animPropCollisionMasks = JSON.parse(JSON.stringify(prop.collisionMasks));
                } else if (prop.collisionMask) {
                    // Convert old single mask to per-frame (apply to all frames)
                    animPropCollisionMasks = {};
                    const numFrames = (prop.frames || []).length || 1;
                    for (let i = 0; i < numFrames; i++) {
                        animPropCollisionMasks[i] = JSON.parse(JSON.stringify(prop.collisionMask));
                    }
                } else {
                    animPropCollisionMasks = {};
                }
                animPropCollisionFrame = 0;
                animPropSplitLine = prop.splitLine ? JSON.parse(JSON.stringify(prop.splitLine)) : null;

                // Load giveItem settings
                document.getElementById('animPropGiveItem').checked = prop.giveItem || false;
                if (prop.type === 'interactive') {
                    document.getElementById('animPropInteractOptions').style.display = 'block';
                    animPropUpdateItemDropdown();
                    if (prop.giveItem) {
                        document.getElementById('animPropItemSection').style.display = 'block';
                        if (prop.giveItemIndex >= 0 && prop.giveItemIndex < items.length) {
                            document.getElementById('animPropItemSelect').value = prop.giveItemIndex;
                        }
                    } else {
                        document.getElementById('animPropItemSection').style.display = 'none';
                    }
                } else {
                    document.getElementById('animPropInteractOptions').style.display = 'none';
                    document.getElementById('animPropItemSection').style.display = 'none';
                }

                if (prop.spriteData) {
                    animPropEditorImage = new Image();
                    animPropEditorImage.onload = () => {
                        document.getElementById('animPropFrameSection').style.display = 'block';
                        document.getElementById('animPropTypeSection').style.display = 'block';
                        document.getElementById('animPropCollisionSection').style.display = 'block';
                        document.getElementById('animPropNameSection').style.display = 'block';
                        animPropDrawCanvas();
                        animPropUpdateFramesList();
                    };
                    animPropEditorImage.src = prop.spriteData;
                    document.getElementById('animPropFileName').textContent = 'Sprite loaded';
                }
            } else {
                // New prop - default frame size to match grid size
                animPropEditorImage = null;
                animPropEditorData = null;
                animPropEditorFrameW = gridSize;
                animPropEditorFrameH = gridSize;
                animPropCollisionMasks = {};
                animPropCollisionFrame = 0;
                animPropSplitLine = null;
                animPropFrames = []; // Ensure frames list is cleared
                document.getElementById('animPropNameInput').value = '';
                document.getElementById('animPropType').value = 'loop';
                document.getElementById('animPropSpeedSlider').value = 8;
                document.getElementById('animPropSpeedLabel').textContent = '8 fps';
                document.getElementById('animPropFileName').textContent = '';
                document.getElementById('animPropFrameSection').style.display = 'none';
                document.getElementById('animPropTypeSection').style.display = 'none';
                document.getElementById('animPropCollisionSection').style.display = 'none';
                document.getElementById('animPropNameSection').style.display = 'none';
                // Reset give item settings
                document.getElementById('animPropGiveItem').checked = false;
                document.getElementById('animPropInteractOptions').style.display = 'none';
                document.getElementById('animPropItemSection').style.display = 'none';
                // Clear live preview
                const previewCtx = document.getElementById('animPropLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 48, 48);
                // Clear editor canvas
                const editorCanvas = document.getElementById('animPropEditorCanvas');
                const editorCtx = editorCanvas.getContext('2d');
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                // Clear frames list display
                const framesList = document.getElementById('animPropFramesList');
                if (framesList) framesList.innerHTML = '';
                // Reset file input
                const fileInput = document.getElementById('animPropFileInput');
                if (fileInput) fileInput.value = '';
            }

            document.getElementById('animPropFrameW').value = animPropEditorFrameW;
            document.getElementById('animPropFrameH').value = animPropEditorFrameH;
            animPropUpdateFramesList();

            document.getElementById('animPropModal').classList.add('visible');
        }

        function animPropLoadSheet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                animPropEditorData = e.target.result;
                animPropEditorImage = new Image();
                animPropEditorImage.onload = () => {
                    document.getElementById('animPropFileName').textContent = file.name + ' (' + animPropEditorImage.naturalWidth + 'x' + animPropEditorImage.naturalHeight + ')';
                    document.getElementById('animPropFrameSection').style.display = 'block';
                    document.getElementById('animPropTypeSection').style.display = 'block';
                    document.getElementById('animPropCollisionSection').style.display = 'block';
                    document.getElementById('animPropNameSection').style.display = 'block';

                    // Reset collision/split for new sheet
                    animPropCollisionMasks = {};
                    animPropCollisionFrame = 0;
                    animPropSplitLine = null;

                    // Auto-suggest frame size
                    const w = animPropEditorImage.naturalWidth;
                    const h = animPropEditorImage.naturalHeight;
                    const sizes = [16, 32, 24, 48, 64];
                    for (const size of sizes) {
                        if (w % size === 0 && h % size === 0) {
                            animPropEditorFrameW = size;
                            animPropEditorFrameH = size;
                            break;
                        }
                    }
                    document.getElementById('animPropFrameW').value = animPropEditorFrameW;
                    document.getElementById('animPropFrameH').value = animPropEditorFrameH;

                    animPropUpdateGrid();
                    animPropDrawCanvas();
                };
                animPropEditorImage.src = animPropEditorData;
            };
            reader.readAsDataURL(file);
        }

        function animPropUpdateGrid() {
            animPropEditorFrameW = parseInt(document.getElementById('animPropFrameW').value) || 16;
            animPropEditorFrameH = parseInt(document.getElementById('animPropFrameH').value) || 16;

            if (animPropEditorImage) {
                const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
                const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);
                document.getElementById('animPropGridInfo').textContent = cols + ' cols x ' + rows + ' rows';
            }

            animPropDrawCanvas();
        }

        function animPropDrawCanvas() {
            const canvas = document.getElementById('animPropEditorCanvas');
            const ctx = canvas.getContext('2d');

            if (!animPropEditorImage) {
                canvas.width = 400;
                canvas.height = 300;
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Load a sprite sheet to begin', 200, 150);
                return;
            }

            const scale = animPropEditorZoom;
            canvas.width = animPropEditorImage.naturalWidth * scale;
            canvas.height = animPropEditorImage.naturalHeight * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(animPropEditorImage, 0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
            const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);

            for (let x = 0; x <= cols; x++) {
                ctx.beginPath();
                ctx.moveTo(x * animPropEditorFrameW * scale, 0);
                ctx.lineTo(x * animPropEditorFrameW * scale, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * animPropEditorFrameH * scale);
                ctx.lineTo(canvas.width, y * animPropEditorFrameH * scale);
                ctx.stroke();
            }

            // Highlight selected frames
            ctx.strokeStyle = '#4af';
            ctx.lineWidth = 3;
            animPropFrames.forEach((frame, i) => {
                ctx.strokeRect(frame.x * scale + 2, frame.y * scale + 2, frame.w * scale - 4, frame.h * scale - 4);
                ctx.fillStyle = '#4af';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(i + 1, frame.x * scale + 6, frame.y * scale + 18);
            });

            // Draw current drag selection
            if (animPropIsDragging && animPropDragStart && animPropDragEnd) {
                const startGX = Math.min(animPropDragStart.gridX, animPropDragEnd.gridX);
                const startGY = Math.min(animPropDragStart.gridY, animPropDragEnd.gridY);
                const endGX = Math.max(animPropDragStart.gridX, animPropDragEnd.gridX);
                const endGY = Math.max(animPropDragStart.gridY, animPropDragEnd.gridY);

                const selX = startGX * animPropEditorFrameW * scale;
                const selY = startGY * animPropEditorFrameH * scale;
                const selW = (endGX - startGX + 1) * animPropEditorFrameW * scale;
                const selH = (endGY - startGY + 1) * animPropEditorFrameH * scale;

                ctx.fillStyle = 'rgba(74, 170, 255, 0.3)';
                ctx.fillRect(selX, selY, selW, selH);
                ctx.strokeStyle = '#4af';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(selX, selY, selW, selH);
                ctx.setLineDash([]);
            }

            // Draw collision mask overlay on ALL frames (each frame has its own collision)
            if (animPropFrames.length > 0) {
                animPropFrames.forEach((frame, frameIndex) => {
                    const frameMask = animPropCollisionMasks[frameIndex];
                    if (frameMask) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                        for (let py = 0; py < frameMask.length; py++) {
                            if (!frameMask[py]) continue;
                            for (let px = 0; px < frameMask[py].length; px++) {
                                if (frameMask[py][px]) {
                                    ctx.fillRect(
                                        (frame.x + px) * scale,
                                        (frame.y + py) * scale,
                                        scale, scale
                                    );
                                }
                            }
                        }
                    }
                });
            }

            // Draw brush preview for collision tool
            if (animPropBrushPreviewPos && (animPropTool === 'collision' || animPropTool === 'erase') && animPropFrames.length > 0) {
                ctx.strokeStyle = animPropTool === 'erase' ? '#ff0' : '#0ff';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);

                const halfBrush = Math.floor(animPropBrushSize / 2);
                const previewX = (animPropBrushPreviewPos.x - halfBrush) * scale;
                const previewY = (animPropBrushPreviewPos.y - halfBrush) * scale;
                const previewSize = animPropBrushSize * scale;

                if (animPropBrushShape === 'square') {
                    ctx.strokeRect(previewX, previewY, previewSize, previewSize);
                } else if (animPropBrushShape === 'circle') {
                    ctx.beginPath();
                    ctx.arc(
                        animPropBrushPreviewPos.x * scale,
                        animPropBrushPreviewPos.y * scale,
                        (animPropBrushSize / 2) * scale,
                        0, Math.PI * 2
                    );
                    ctx.stroke();
                } else if (animPropBrushShape === 'rect') {
                    const rectW = animPropBrushRectW * scale;
                    const rectH = animPropBrushRectH * scale;
                    ctx.strokeRect(
                        (animPropBrushPreviewPos.x - Math.floor(animPropBrushRectW / 2)) * scale,
                        (animPropBrushPreviewPos.y - Math.floor(animPropBrushRectH / 2)) * scale,
                        rectW, rectH
                    );
                }
                ctx.setLineDash([]);
            }

            // Draw split line overlay on EACH frame separately
            if (animPropFrames.length > 0 && animPropSplitLine && typeof animPropSplitLine === 'object') {
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                ctx.font = 'bold ' + Math.max(8, scale * 3) + 'px sans-serif';

                // Draw split lines for each frame
                for (let frameIndex = 0; frameIndex < animPropFrames.length; frameIndex++) {
                    const frame = animPropFrames[frameIndex];
                    const tilesW = Math.ceil(frame.w / gridSize);
                    const tilesH = Math.ceil(frame.h / gridSize);

                    for (let ty = 0; ty < tilesH; ty++) {
                        for (let tx = 0; tx < tilesW; tx++) {
                            // Try new per-frame format first: "frameIndex:tileX,tileY"
                            let key = frameIndex + ':' + tx + ',' + ty;
                            let splitYArray = animPropSplitLine[key];

                            // Fall back to old format: "tileX,tileY" (shared across frames)
                            if (splitYArray === undefined || splitYArray === null) {
                                key = tx + ',' + ty;
                                splitYArray = animPropSplitLine[key];
                            }

                            if (splitYArray === undefined || splitYArray === null) continue;

                            const tileStartX = frame.x + tx * gridSize;
                            const tileStartY = frame.y + ty * gridSize;

                            // Fill canopy region (above split line) with semi-transparent cyan
                            ctx.fillStyle = 'rgba(0, 255, 255, 0.25)';
                            ctx.beginPath();
                            ctx.moveTo(tileStartX * scale, tileStartY * scale);
                            for (let col = 0; col < gridSize; col++) {
                                const splitY = Array.isArray(splitYArray) ? splitYArray[col] : splitYArray;
                                const lineX = (tileStartX + col + 0.5) * scale;
                                const lineY = (tileStartY + splitY) * scale;
                                ctx.lineTo(lineX, lineY);
                            }
                            ctx.lineTo((tileStartX + gridSize) * scale, tileStartY * scale);
                            ctx.closePath();
                            ctx.fill();

                            // Draw freeform split line in cyan
                            ctx.strokeStyle = '#0ff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            for (let col = 0; col < gridSize; col++) {
                                const splitY = Array.isArray(splitYArray) ? splitYArray[col] : splitYArray;
                                const lineX = (tileStartX + col + 0.5) * scale;
                                const lineY = (tileStartY + splitY) * scale;
                                if (col === 0) {
                                    ctx.moveTo(lineX, lineY);
                                } else {
                                    ctx.lineTo(lineX, lineY);
                                }
                            }
                            ctx.stroke();

                            // Calculate average Y for label placement
                            const avgSplitY = Array.isArray(splitYArray)
                                ? splitYArray.reduce((a, b) => a + b, 0) / splitYArray.length
                                : splitYArray;

                            // Draw C (canopy - above line) and T (trunk - below line) labels
                            ctx.fillStyle = '#0ff';
                            ctx.textAlign = 'center';
                            if (avgSplitY > 4) {
                                ctx.fillText('C', (tileStartX + gridSize / 2) * scale, (tileStartY + avgSplitY / 2) * scale + 4);
                            }
                            if (avgSplitY < gridSize - 4) {
                                ctx.fillText('T', (tileStartX + gridSize / 2) * scale, (tileStartY + avgSplitY + (gridSize - avgSplitY) / 2) * scale + 4);
                            }
                        }
                    }
                }
            }
        }

        // Animated prop editor brush size and shape
        let animPropBrushSize = 4;
        let animPropBrushShape = 'square'; // 'square', 'circle', 'rect'
        let animPropBrushRectW = 8;
        let animPropBrushRectH = 4;
        let animPropBrushPreviewPos = null; // { x, y } for brush preview
        let animPropFlatLineY = null; // Y position locked when flat line mode + dragging

        // Tool switching for animated prop editor
        function setAnimPropTool(tool) {
            animPropTool = tool;
            ['None', 'Collision', 'Erase', 'Split'].forEach(t => {
                const btn = document.getElementById('animPropTool' + t);
                if (btn) btn.classList.toggle('active', t.toLowerCase() === tool);
            });

            // Show/hide brush section for collision/erase tools
            const brushSection = document.getElementById('animPropBrushSection');
            if (brushSection) {
                brushSection.style.display = (tool === 'collision' || tool === 'erase') ? 'block' : 'none';
            }

            // Show/hide split controls
            const splitControls = document.getElementById('animPropSplitControls');
            if (splitControls) {
                splitControls.style.display = (tool === 'split') ? 'block' : 'none';
            }
        }

        function setAnimPropBrush(size) {
            animPropBrushSize = size;
            [1, 2, 4, 8].forEach(s => {
                const btn = document.getElementById('animPropBrush' + s);
                if (btn) btn.classList.toggle('active', s === size);
            });
        }

        function setAnimPropBrushShape(shape) {
            animPropBrushShape = shape;
            ['square', 'circle', 'rect'].forEach(s => {
                const btn = document.getElementById('animPropShape' + s.charAt(0).toUpperCase() + s.slice(1));
                if (btn) btn.classList.toggle('active', s === shape);
            });
            // Show/hide size row vs rect size row
            const sizeRow = document.getElementById('animPropBrushSizeRow');
            const rectRow = document.getElementById('animPropRectSizeRow');
            if (sizeRow) sizeRow.style.display = (shape === 'rect') ? 'none' : 'block';
            if (rectRow) rectRow.style.display = (shape === 'rect') ? 'block' : 'none';
        }

        function updateAnimPropRectSize() {
            animPropBrushRectW = parseInt(document.getElementById('animPropRectW').value) || 8;
            animPropBrushRectH = parseInt(document.getElementById('animPropRectH').value) || 4;
        }

        function setAnimPropCollisionFrame(frameIdx) {
            animPropCollisionFrame = parseInt(frameIdx) || 0;
            animPropDrawCanvas();
        }

        function updateAnimPropCollisionFrameDropdown() {
            const select = document.getElementById('animPropCollisionFrameSelect');
            if (!select) return;
            select.innerHTML = '';
            animPropFrames.forEach((frame, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = 'Frame ' + (i + 1);
                if (i === animPropCollisionFrame) opt.selected = true;
                select.appendChild(opt);
            });
            // Ensure current frame is valid
            if (animPropCollisionFrame >= animPropFrames.length) {
                animPropCollisionFrame = Math.max(0, animPropFrames.length - 1);
            }
        }

        function copyCollisionToAllFrames() {
            if (animPropFrames.length === 0) return;
            const sourceMask = animPropCollisionMasks[animPropCollisionFrame];
            if (!sourceMask) {
                alert('No collision on current frame to copy');
                return;
            }
            // Copy to all other frames
            for (let i = 0; i < animPropFrames.length; i++) {
                if (i !== animPropCollisionFrame) {
                    animPropCollisionMasks[i] = JSON.parse(JSON.stringify(sourceMask));
                }
            }
            animPropDrawCanvas();
            console.log('[ANIM PROP] Copied collision from frame', animPropCollisionFrame + 1, 'to all frames');
        }

        function setAnimPropSplitY() {
            const yVal = parseInt(document.getElementById('animPropSplitY').value) || 8;
            if (animPropFrames.length === 0) return;

            // Initialize split lines object if needed
            if (!animPropSplitLine || typeof animPropSplitLine !== 'object' || Array.isArray(animPropSplitLine)) {
                animPropSplitLine = {};
            }

            const clampedY = Math.max(0, Math.min(gridSize, yVal));

            // Set same Y for all tiles in ALL frames (flat line = array filled with same value)
            for (let frameIndex = 0; frameIndex < animPropFrames.length; frameIndex++) {
                const frame = animPropFrames[frameIndex];
                const tilesW = Math.ceil(frame.w / gridSize);
                const tilesH = Math.ceil(frame.h / gridSize);

                for (let ty = 0; ty < tilesH; ty++) {
                    for (let tx = 0; tx < tilesW; tx++) {
                        const key = frameIndex + ':' + tx + ',' + ty;
                        animPropSplitLine[key] = new Array(gridSize).fill(clampedY);
                    }
                }
            }
            animPropDrawCanvas();
        }

        function clearAnimPropSplit() {
            animPropSplitLine = null;
            animPropDrawCanvas();
        }

        // Collision/split painting helpers
        function animPropPaintCollision(px, py, erase) {
            if (animPropFrames.length === 0) return;

            // Find which frame was clicked - paint directly on that frame
            let clickedFrameIndex = -1;
            let clickedFrame = null;
            for (let i = 0; i < animPropFrames.length; i++) {
                const frame = animPropFrames[i];
                if (px >= frame.x && px < frame.x + frame.w &&
                    py >= frame.y && py < frame.y + frame.h) {
                    clickedFrameIndex = i;
                    clickedFrame = frame;
                    break;
                }
            }
            if (!clickedFrame || clickedFrameIndex < 0) return;

            // Use first frame dimensions for mask size (all frames share same size)
            const frame0 = animPropFrames[0];

            // Initialize mask for clicked frame if needed
            if (!animPropCollisionMasks[clickedFrameIndex]) {
                animPropCollisionMasks[clickedFrameIndex] = [];
                for (let y = 0; y < frame0.h; y++) {
                    animPropCollisionMasks[clickedFrameIndex][y] = new Array(frame0.w).fill(false);
                }
            }
            const mask = animPropCollisionMasks[clickedFrameIndex];

            // Calculate position relative to clicked frame
            const localX = px - clickedFrame.x;
            const localY = py - clickedFrame.y;

            if (localX < 0 || localX >= frame0.w || localY < 0 || localY >= frame0.h) return;

            // Paint based on brush shape
            if (animPropBrushShape === 'square') {
                const halfBrush = Math.floor(animPropBrushSize / 2);
                for (let dy = -halfBrush; dy < animPropBrushSize - halfBrush; dy++) {
                    for (let dx = -halfBrush; dx < animPropBrushSize - halfBrush; dx++) {
                        const bx = localX + dx;
                        const by = localY + dy;
                        if (bx >= 0 && bx < frame0.w && by >= 0 && by < frame0.h) {
                            if (!mask[by]) mask[by] = [];
                            mask[by][bx] = !erase;
                        }
                    }
                }
            } else if (animPropBrushShape === 'circle') {
                const radius = animPropBrushSize / 2;
                const radiusSq = radius * radius;
                for (let dy = -Math.ceil(radius); dy <= Math.ceil(radius); dy++) {
                    for (let dx = -Math.ceil(radius); dx <= Math.ceil(radius); dx++) {
                        if (dx * dx + dy * dy <= radiusSq) {
                            const bx = localX + dx;
                            const by = localY + dy;
                            if (bx >= 0 && bx < frame0.w && by >= 0 && by < frame0.h) {
                                if (!mask[by]) mask[by] = [];
                                mask[by][bx] = !erase;
                            }
                        }
                    }
                }
            } else if (animPropBrushShape === 'rect') {
                const halfW = Math.floor(animPropBrushRectW / 2);
                const halfH = Math.floor(animPropBrushRectH / 2);
                for (let dy = -halfH; dy < animPropBrushRectH - halfH; dy++) {
                    for (let dx = -halfW; dx < animPropBrushRectW - halfW; dx++) {
                        const bx = localX + dx;
                        const by = localY + dy;
                        if (bx >= 0 && bx < frame0.w && by >= 0 && by < frame0.h) {
                            if (!mask[by]) mask[by] = [];
                            mask[by][bx] = !erase;
                        }
                    }
                }
            }
        }

        function animPropPaintSplit(px, py, isStart = false) {
            if (animPropFrames.length === 0) return;

            // Find which frame was clicked
            let clickedFrameIndex = -1;
            let clickedFrame = null;
            for (let i = 0; i < animPropFrames.length; i++) {
                const frame = animPropFrames[i];
                if (px >= frame.x && px < frame.x + frame.w &&
                    py >= frame.y && py < frame.y + frame.h) {
                    clickedFrameIndex = i;
                    clickedFrame = frame;
                    break;
                }
            }
            if (!clickedFrame) return;

            // Calculate which tile within the frame was clicked
            const localX = px - clickedFrame.x;
            const localY = py - clickedFrame.y;

            const tileX = Math.floor(localX / gridSize);
            const tileY = Math.floor(localY / gridSize);

            // Position within the tile
            const tileLocalX = localX - (tileX * gridSize);
            const tileLocalY = localY - (tileY * gridSize);

            // Clamp Y value
            let clampedY = Math.round(tileLocalY);
            if (tileLocalY >= gridSize - 2) clampedY = gridSize;
            clampedY = Math.max(0, Math.min(gridSize, clampedY));

            // Clamp X for column index
            const clampedX = Math.max(0, Math.min(gridSize - 1, Math.floor(tileLocalX)));

            // Check flat line mode
            const flatLineCheckbox = document.getElementById('animPropFlatLine');
            const flatLineMode = flatLineCheckbox && flatLineCheckbox.checked;

            // Initialize split lines object if needed
            if (!animPropSplitLine || typeof animPropSplitLine !== 'object' || Array.isArray(animPropSplitLine)) {
                animPropSplitLine = {};
            }

            // Key format: "frameIndex:tileX,tileY" for per-frame splits
            const key = clickedFrameIndex + ':' + tileX + ',' + tileY;

            if (flatLineMode) {
                // Flat line mode: set entire tile to same Y value
                if (isStart) {
                    animPropFlatLineY = clampedY;
                }
                const yVal = (animPropFlatLineY !== null) ? animPropFlatLineY : clampedY;
                animPropSplitLine[key] = new Array(gridSize).fill(yVal);
            } else {
                // Freeform mode: initialize array if needed, then set this column
                if (!animPropSplitLine[key] || !Array.isArray(animPropSplitLine[key])) {
                    const defaultY = Math.floor(gridSize / 2);
                    animPropSplitLine[key] = new Array(gridSize).fill(defaultY);
                }
                animPropSplitLine[key][clampedX] = clampedY;
            }
        }

        // Canvas drag handlers for animated prop editor (multi-tile selection)
        document.getElementById('animPropEditorCanvas').addEventListener('mousedown', function(e) {
            if (!animPropEditorImage) return;

            const rect = this.getBoundingClientRect();
            const scale = animPropEditorZoom;
            const clickX = (e.clientX - rect.left) / scale;
            const clickY = (e.clientY - rect.top) / scale;

            if (animPropTool === 'collision' || animPropTool === 'erase') {
                animPropPainting = true;
                animPropPaintCollision(Math.floor(clickX), Math.floor(clickY), animPropTool === 'erase');
                animPropDrawCanvas();
            } else if (animPropTool === 'split') {
                animPropPainting = true;
                animPropPaintSplit(Math.floor(clickX), Math.floor(clickY), true); // isStart = true
                animPropDrawCanvas();
            } else {
                // Frame selection mode
                const gridX = Math.floor(clickX / animPropEditorFrameW);
                const gridY = Math.floor(clickY / animPropEditorFrameH);

                animPropDragStart = { gridX, gridY };
                animPropDragEnd = { gridX, gridY };
                animPropIsDragging = true;
                animPropDrawCanvas();
            }
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mousemove', function(e) {
            if (!animPropEditorImage) return;

            const rect = this.getBoundingClientRect();
            const scale = animPropEditorZoom;
            const clickX = (e.clientX - rect.left) / scale;
            const clickY = (e.clientY - rect.top) / scale;

            // Update brush preview position for collision/erase tools
            if (animPropTool === 'collision' || animPropTool === 'erase') {
                // Find which frame we're over
                let overFrame = null;
                for (const frame of animPropFrames) {
                    if (clickX >= frame.x && clickX < frame.x + frame.w &&
                        clickY >= frame.y && clickY < frame.y + frame.h) {
                        overFrame = frame;
                        break;
                    }
                }
                if (overFrame) {
                    animPropBrushPreviewPos = { x: Math.floor(clickX), y: Math.floor(clickY) };
                } else {
                    animPropBrushPreviewPos = null;
                }
            } else {
                animPropBrushPreviewPos = null;
            }

            if (animPropPainting) {
                if (animPropTool === 'collision' || animPropTool === 'erase') {
                    animPropPaintCollision(Math.floor(clickX), Math.floor(clickY), animPropTool === 'erase');
                    animPropDrawCanvas();
                } else if (animPropTool === 'split') {
                    animPropPaintSplit(Math.floor(clickX), Math.floor(clickY));
                    animPropDrawCanvas();
                }
            } else if (animPropIsDragging) {
                const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
                const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);

                const gridX = Math.max(0, Math.min(cols - 1, Math.floor(clickX / animPropEditorFrameW)));
                const gridY = Math.max(0, Math.min(rows - 1, Math.floor(clickY / animPropEditorFrameH)));

                animPropDragEnd = { gridX, gridY };
                animPropDrawCanvas();
            } else {
                // Redraw to show brush preview
                animPropDrawCanvas();
            }
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mouseup', function(e) {
            if (!animPropEditorImage) return;

            if (animPropPainting) {
                animPropPainting = false;
                animPropFlatLineY = null; // Reset flat line Y lock
                return;
            }

            if (!animPropIsDragging) return;
            animPropIsDragging = false;

            // Calculate selection rectangle
            const startGX = Math.min(animPropDragStart.gridX, animPropDragEnd.gridX);
            const startGY = Math.min(animPropDragStart.gridY, animPropDragEnd.gridY);
            const endGX = Math.max(animPropDragStart.gridX, animPropDragEnd.gridX);
            const endGY = Math.max(animPropDragStart.gridY, animPropDragEnd.gridY);

            const frameX = startGX * animPropEditorFrameW;
            const frameY = startGY * animPropEditorFrameH;
            const frameW = (endGX - startGX + 1) * animPropEditorFrameW;
            const frameH = (endGY - startGY + 1) * animPropEditorFrameH;

            if (frameX >= animPropEditorImage.naturalWidth || frameY >= animPropEditorImage.naturalHeight) return;

            animPropFrames.push({
                x: frameX,
                y: frameY,
                w: frameW,
                h: frameH
            });

            animPropDragStart = null;
            animPropDragEnd = null;
            animPropDrawCanvas();
            animPropUpdateFramesList();
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mouseleave', function(e) {
            animPropPainting = false;
            animPropFlatLineY = null; // Reset flat line Y lock
            animPropBrushPreviewPos = null; // Clear brush preview
            if (animPropIsDragging) {
                animPropIsDragging = false;
                animPropDragStart = null;
                animPropDragEnd = null;
            }
            animPropDrawCanvas();
        });

        function animPropUpdateFramesList() {
            const container = document.getElementById('animPropFramesList');
            container.innerHTML = '';
            document.getElementById('animPropFrameCount').textContent = animPropFrames.length;

            // Update collision frame dropdown when frames change
            updateAnimPropCollisionFrameDropdown();

            if (animPropFrames.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px;">Click or drag on sprite sheet to select frames</div>';
                animPropStopPreview();
                // Clear live preview
                const previewCtx = document.getElementById('animPropLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 48, 48);
                return;
            }

            animPropFrames.forEach((frame, i) => {
                const thumb = document.createElement('div');
                thumb.className = 'anim-frame-thumb';

                const canvas = document.createElement('canvas');
                canvas.width = 48;
                canvas.height = 48;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;

                const scale = Math.min(48 / frame.w, 48 / frame.h);
                const drawW = frame.w * scale;
                const drawH = frame.h * scale;
                const drawX = (48 - drawW) / 2;
                const drawY = (48 - drawH) / 2;

                ctx.drawImage(animPropEditorImage, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);

                const num = document.createElement('span');
                num.className = 'frame-num';
                num.textContent = i + 1;

                thumb.appendChild(canvas);
                thumb.appendChild(num);
                thumb.onclick = () => {
                    animPropFrames.splice(i, 1);
                    animPropUpdateFramesList();
                    animPropDrawCanvas();
                };
                thumb.title = 'Click to remove';

                container.appendChild(thumb);
            });

            // Auto-start live preview when frames exist
            animPropStartLivePreview();
        }

        function animPropClearFrames() {
            if (!confirm('Clear all frames?')) return;
            animPropFrames = [];
            animPropUpdateFramesList();
            animPropDrawCanvas();
        }

        // Live animation preview - starts automatically when frames are added
        function animPropStartLivePreview() {
            if (animPropPreviewInterval) return; // Already running
            if (animPropFrames.length === 0) return;

            animPropPreviewFrame = 0;
            const fps = parseInt(document.getElementById('animPropSpeedSlider').value) || 8;

            animPropPreviewInterval = setInterval(() => {
                animPropPreviewFrame = (animPropPreviewFrame + 1) % animPropFrames.length;
                animPropDrawLivePreview();

                // Highlight current frame in list
                const thumbs = document.querySelectorAll('.anim-frame-thumb');
                thumbs.forEach((t, i) => {
                    t.style.borderColor = i === animPropPreviewFrame ? '#0f0' : '#4af';
                });
            }, 1000 / fps);
        }

        function animPropStopPreview() {
            if (animPropPreviewInterval) {
                clearInterval(animPropPreviewInterval);
                animPropPreviewInterval = null;
            }
            const thumbs = document.querySelectorAll('.anim-frame-thumb');
            thumbs.forEach(t => t.style.borderColor = '#4af');
        }

        function animPropDrawLivePreview() {
            const canvas = document.getElementById('animPropLivePreview');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 48, 48);

            if (!animPropEditorImage || animPropFrames.length === 0) return;

            const frame = animPropFrames[animPropPreviewFrame];
            if (!frame) return;

            ctx.imageSmoothingEnabled = false;
            // Scale to fit 48x48 preview
            const scale = Math.min(48 / frame.w, 48 / frame.h);
            const drawW = frame.w * scale;
            const drawH = frame.h * scale;
            const drawX = (48 - drawW) / 2;
            const drawY = (48 - drawH) / 2;
            ctx.drawImage(animPropEditorImage, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);
        }

        function animPropUpdateSpeed() {
            const fps = parseInt(document.getElementById('animPropSpeedSlider').value) || 8;
            document.getElementById('animPropSpeedLabel').textContent = fps + ' fps';
            document.getElementById('animPropSpeed').value = fps; // Sync with hidden input

            // Restart preview with new speed
            if (animPropPreviewInterval) {
                animPropStopPreview();
                animPropStartLivePreview();
            }
        }


        function animPropTypeChanged() {
            const type = document.getElementById('animPropType').value;
            const interactOptions = document.getElementById('animPropInteractOptions');
            if (type === 'interactive') {
                interactOptions.style.display = 'block';
                animPropUpdateItemDropdown();
            } else {
                interactOptions.style.display = 'none';
            }
        }

        function animPropGiveItemChanged() {
            const giveItem = document.getElementById('animPropGiveItem').checked;
            document.getElementById('animPropItemSection').style.display = giveItem ? 'block' : 'none';
            if (giveItem) {
                animPropUpdateItemDropdown();
            }
        }

        function animPropUpdateItemDropdown() {
            const select = document.getElementById('animPropItemSelect');
            const currentValue = select.value;
            select.innerHTML = '';

            if (items.length === 0) {
                const opt = document.createElement('option');
                opt.value = '-1';
                opt.textContent = '-- No items defined (create in Items tab) --';
                select.appendChild(opt);
            } else {
                items.forEach((item, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = item.name || ('Item ' + (i + 1));
                    select.appendChild(opt);
                });
            }

            // Restore previous selection if valid
            if (currentValue && parseInt(currentValue) >= 0 && parseInt(currentValue) < items.length) {
                select.value = currentValue;
            }
        }

        function animPropSave() {
            const name = document.getElementById('animPropNameInput').value.trim();
            if (!name) {
                alert('Please enter a name for the prop');
                return;
            }

            if (!animPropEditorImage) {
                alert('Please load a sprite sheet first');
                return;
            }

            if (animPropFrames.length === 0) {
                alert('Please add at least one frame');
                return;
            }

            const propType = document.getElementById('animPropType').value;
            const giveItem = document.getElementById('animPropGiveItem').checked;
            const giveItemIndex = giveItem ? parseInt(document.getElementById('animPropItemSelect').value) : -1;

            const propData = {
                name: name,
                spriteData: animPropEditorData,
                frameWidth: animPropEditorFrameW,
                frameHeight: animPropEditorFrameH,
                frames: [...animPropFrames],
                type: propType,
                fps: parseInt(document.getElementById('animPropSpeedSlider').value) || 8,
                collisionMasks: Object.keys(animPropCollisionMasks).length > 0 ? JSON.parse(JSON.stringify(animPropCollisionMasks)) : null,
                splitLine: animPropSplitLine ? JSON.parse(JSON.stringify(animPropSplitLine)) : null,
                giveItem: giveItem,
                giveItemIndex: giveItemIndex,
                _spriteImg: animPropEditorImage // Store the loaded image
            };

            if (animPropEditorEditingIndex >= 0) {
                animatedProps[animPropEditorEditingIndex] = propData;
                // Sync prop update (exclude non-serializable _spriteImg)
                const syncProp = { ...propData };
                delete syncProp._spriteImg;
                broadcastEdit({ editType: 'updateAnimProp', index: animPropEditorEditingIndex, prop: syncProp });
            } else {
                animatedProps.push(propData);
                currentAnimPropIndex = animatedProps.length - 1; // Select the new prop
                // Sync new prop (exclude non-serializable _spriteImg)
                const syncProp = { ...propData };
                delete syncProp._spriteImg;
                broadcastEdit({ editType: 'addAnimProp', prop: syncProp });
            }

            animPropStopPreview();
            document.getElementById('animPropModal').classList.remove('visible');
            stopEditing(); // Clear editing lock
            updateAnimPropListDisplay();
            renderMap();
        }

        function animPropCancel() {
            animPropStopPreview();
            document.getElementById('animPropModal').classList.remove('visible');
            stopEditing(); // Clear editing lock
        }

        // ========== ITEM EDITOR FUNCTIONS ==========
        let itemEditorImage = null;
        let itemEditorData = null;
        let itemEditorFrameW = 16;
        let itemEditorFrameH = 16;
        let itemEditorEditingIndex = -1;
        let itemEditorZoom = 3;

        function openItemEditor(editIndex = -1) {
            // Check if someone else is already editing this item
            if (editIndex >= 0 && isBeingEdited('item', editIndex)) {
                const editor = getEditor('item', editIndex);
                if (!confirm(`"${editor}" is currently editing this item.\n\nEditing simultaneously may cause conflicts.\n\nOpen anyway?`)) {
                    return;
                }
            }

            itemStopPreview();
            itemEditorEditingIndex = editIndex;

            // Broadcast that we're editing this item
            if (editIndex >= 0) {
                startEditing('item', editIndex);
            }

            itemFrames = [];

            if (editIndex >= 0 && items[editIndex]) {
                const item = items[editIndex];
                itemEditorFrameW = item.frameWidth || 16;
                itemEditorFrameH = item.frameHeight || 16;
                itemFrames = JSON.parse(JSON.stringify(item.frames || []));
                itemEditorData = item.spriteData;
                document.getElementById('itemNameInput').value = item.name;
                const fps = item.fps || 8;
                document.getElementById('itemSpeedSlider').value = fps;
                document.getElementById('itemSpeedLabel').textContent = fps + ' fps';

                if (item.spriteData) {
                    itemEditorImage = new Image();
                    itemEditorImage.onload = () => {
                        document.getElementById('itemFrameSection').style.display = 'block';
                        document.getElementById('itemIdleSection').style.display = 'block';
                        document.getElementById('itemNameSection').style.display = 'block';
                        itemDrawCanvas();
                        itemUpdateFramesList();
                        itemUpdateIdleDropdown();
                        document.getElementById('itemIdleFrame').value = item.idleFrame || 0;
                    };
                    itemEditorImage.src = item.spriteData;
                    document.getElementById('itemFileName').textContent = 'Sprite loaded';
                }
            } else {
                itemEditorImage = null;
                itemEditorData = null;
                itemEditorFrameW = gridSize;
                itemEditorFrameH = gridSize;
                itemFrames = [];
                document.getElementById('itemNameInput').value = '';
                document.getElementById('itemSpeedSlider').value = 8;
                document.getElementById('itemSpeedLabel').textContent = '8 fps';
                document.getElementById('itemFileName').textContent = '';
                document.getElementById('itemFrameSection').style.display = 'none';
                document.getElementById('itemIdleSection').style.display = 'none';
                document.getElementById('itemNameSection').style.display = 'none';
                const previewCtx = document.getElementById('itemLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 48, 48);
                const editorCanvas = document.getElementById('itemEditorCanvas');
                const editorCtx = editorCanvas.getContext('2d');
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                const framesList = document.getElementById('itemFramesList');
                if (framesList) framesList.innerHTML = '';
                const fileInput = document.getElementById('itemFileInput');
                if (fileInput) fileInput.value = '';
            }

            document.getElementById('itemFrameW').value = itemEditorFrameW;
            document.getElementById('itemFrameH').value = itemEditorFrameH;
            itemUpdateFramesList();

            document.getElementById('itemModal').classList.add('visible');
        }

        function itemLoadSheet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                itemEditorData = e.target.result;
                itemEditorImage = new Image();
                itemEditorImage.onload = () => {
                    document.getElementById('itemFileName').textContent = file.name + ' (' + itemEditorImage.naturalWidth + 'x' + itemEditorImage.naturalHeight + ')';
                    document.getElementById('itemFrameSection').style.display = 'block';
                    document.getElementById('itemIdleSection').style.display = 'block';
                    document.getElementById('itemNameSection').style.display = 'block';

                    // Auto-suggest frame size
                    const w = itemEditorImage.naturalWidth;
                    const h = itemEditorImage.naturalHeight;
                    const sizes = [16, 32, 24, 48, 64];
                    for (const size of sizes) {
                        if (w % size === 0 && h % size === 0) {
                            itemEditorFrameW = size;
                            itemEditorFrameH = size;
                            break;
                        }
                    }
                    document.getElementById('itemFrameW').value = itemEditorFrameW;
                    document.getElementById('itemFrameH').value = itemEditorFrameH;

                    itemUpdateGrid();
                    itemDrawCanvas();
                };
                itemEditorImage.src = itemEditorData;
            };
            reader.readAsDataURL(file);
        }

        function itemUpdateGrid() {
            itemEditorFrameW = parseInt(document.getElementById('itemFrameW').value) || 16;
            itemEditorFrameH = parseInt(document.getElementById('itemFrameH').value) || 16;

            if (itemEditorImage) {
                const cols = Math.floor(itemEditorImage.naturalWidth / itemEditorFrameW);
                const rows = Math.floor(itemEditorImage.naturalHeight / itemEditorFrameH);
                document.getElementById('itemGridInfo').textContent = cols + ' cols x ' + rows + ' rows';
            }

            itemDrawCanvas();
        }

        function itemDrawCanvas() {
            const canvas = document.getElementById('itemEditorCanvas');
            const ctx = canvas.getContext('2d');

            if (!itemEditorImage) {
                canvas.width = 400;
                canvas.height = 300;
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Load a sprite sheet to begin', 200, 150);
                return;
            }

            const scale = itemEditorZoom;
            canvas.width = itemEditorImage.naturalWidth * scale;
            canvas.height = itemEditorImage.naturalHeight * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(itemEditorImage, 0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            const cols = Math.floor(itemEditorImage.naturalWidth / itemEditorFrameW);
            const rows = Math.floor(itemEditorImage.naturalHeight / itemEditorFrameH);

            for (let x = 0; x <= cols; x++) {
                ctx.beginPath();
                ctx.moveTo(x * itemEditorFrameW * scale, 0);
                ctx.lineTo(x * itemEditorFrameW * scale, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * itemEditorFrameH * scale);
                ctx.lineTo(canvas.width, y * itemEditorFrameH * scale);
                ctx.stroke();
            }

            // Highlight selected frames
            ctx.strokeStyle = '#4f8';
            ctx.lineWidth = 3;
            itemFrames.forEach((frame, i) => {
                ctx.strokeRect(frame.x * scale + 2, frame.y * scale + 2, frame.w * scale - 4, frame.h * scale - 4);
                ctx.fillStyle = '#4f8';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(i + 1, frame.x * scale + 6, frame.y * scale + 18);
            });

            // Draw drag selection box
            if (itemIsDragging && itemDragStart && itemDragEnd) {
                const startGX = Math.min(itemDragStart.gridX, itemDragEnd.gridX);
                const startGY = Math.min(itemDragStart.gridY, itemDragEnd.gridY);
                const endGX = Math.max(itemDragStart.gridX, itemDragEnd.gridX);
                const endGY = Math.max(itemDragStart.gridY, itemDragEnd.gridY);

                const selX = startGX * itemEditorFrameW * scale;
                const selY = startGY * itemEditorFrameH * scale;
                const selW = (endGX - startGX + 1) * itemEditorFrameW * scale;
                const selH = (endGY - startGY + 1) * itemEditorFrameH * scale;

                ctx.fillStyle = 'rgba(255, 200, 0, 0.3)';
                ctx.fillRect(selX, selY, selW, selH);
                ctx.strokeStyle = '#fc0';
                ctx.lineWidth = 3;
                ctx.strokeRect(selX, selY, selW, selH);
            }
        }

        // Legacy single-click handler (kept for backwards compat, but drag is preferred)
        function itemCanvasClick(e) {
            if (!itemEditorImage) return;
            const canvas = document.getElementById('itemEditorCanvas');
            const rect = canvas.getBoundingClientRect();
            const scale = itemEditorZoom;
            const x = Math.floor((e.clientX - rect.left) / (itemEditorFrameW * scale));
            const y = Math.floor((e.clientY - rect.top) / (itemEditorFrameH * scale));

            const frameX = x * itemEditorFrameW;
            const frameY = y * itemEditorFrameH;

            // Check if already selected
            const existingIdx = itemFrames.findIndex(f => f.x === frameX && f.y === frameY);
            if (existingIdx >= 0) {
                itemFrames.splice(existingIdx, 1);
            } else {
                itemFrames.push({ x: frameX, y: frameY, w: itemEditorFrameW, h: itemEditorFrameH });
            }

            itemDrawCanvas();
            itemUpdateFramesList();
            itemUpdateIdleDropdown();
            itemStartPreview();
        }

        function itemUpdateFramesList() {
            const container = document.getElementById('itemFramesList');
            const countEl = document.getElementById('itemFrameCount');
            if (!container) return;
            container.innerHTML = '';
            countEl.textContent = itemFrames.length;

            if (!itemEditorImage || itemFrames.length === 0) {
                container.innerHTML = '<span style="color:#666; font-size:11px;">Click frames on the sprite sheet</span>';
                return;
            }

            itemFrames.forEach((frame, i) => {
                const frameEl = document.createElement('div');
                frameEl.className = 'anim-frame-item';
                frameEl.innerHTML = `
                    <canvas width="32" height="32" style="border:1px solid #555; image-rendering:pixelated;"></canvas>
                    <span style="font-size:10px; color:#888;">${i + 1}</span>
                `;
                const canvas = frameEl.querySelector('canvas');
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(itemEditorImage, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                container.appendChild(frameEl);
            });
        }

        function itemUpdateIdleDropdown() {
            const select = document.getElementById('itemIdleFrame');
            if (!select) return;
            select.innerHTML = '';
            itemFrames.forEach((_, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = 'Frame ' + (i + 1) + (i === 0 ? ' (first)' : '');
                select.appendChild(opt);
            });
        }

        function itemClearFrames() {
            itemFrames = [];
            itemDrawCanvas();
            itemUpdateFramesList();
            itemUpdateIdleDropdown();
            itemStopPreview();
        }

        function itemStartPreview() {
            itemStopPreview();
            if (itemFrames.length === 0 || !itemEditorImage) return;
            const fps = parseInt(document.getElementById('itemSpeedSlider').value) || 8;
            itemPreviewPlaying = true;
            itemPreviewFrame = 0;
            itemPreviewInterval = setInterval(() => {
                itemPreviewFrame = (itemPreviewFrame + 1) % itemFrames.length;
                itemDrawPreviewFrame();
            }, 1000 / fps);
            itemDrawPreviewFrame();
        }

        function itemStopPreview() {
            if (itemPreviewInterval) {
                clearInterval(itemPreviewInterval);
                itemPreviewInterval = null;
            }
            itemPreviewPlaying = false;
        }

        function itemDrawPreviewFrame() {
            const canvas = document.getElementById('itemLivePreview');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 48, 48);
            if (!itemEditorImage || itemFrames.length === 0) return;
            const frame = itemFrames[itemPreviewFrame];
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(itemEditorImage, frame.x, frame.y, frame.w, frame.h, 0, 0, 48, 48);
        }

        function itemUpdateSpeed() {
            const fps = document.getElementById('itemSpeedSlider').value;
            document.getElementById('itemSpeedLabel').textContent = fps + ' fps';
            if (itemPreviewPlaying) itemStartPreview();
        }

        function itemZoomIn() {
            itemEditorZoom = Math.min(8, itemEditorZoom + 1);
            document.getElementById('itemZoomLevel').textContent = itemEditorZoom + 'x';
            itemDrawCanvas();
        }

        function itemZoomOut() {
            itemEditorZoom = Math.max(1, itemEditorZoom - 1);
            document.getElementById('itemZoomLevel').textContent = itemEditorZoom + 'x';
            itemDrawCanvas();
        }

        function itemSave() {
            if (!itemEditorData || itemFrames.length === 0) {
                alert('Please load a sprite sheet and select animation frames.');
                return;
            }

            const name = document.getElementById('itemNameInput').value.trim() || 'Item ' + (items.length + 1);
            const fps = parseInt(document.getElementById('itemSpeedSlider').value) || 8;
            const idleFrame = parseInt(document.getElementById('itemIdleFrame').value) || 0;

            const itemData = {
                name: name,
                spriteData: itemEditorData,
                frameWidth: itemEditorFrameW,
                frameHeight: itemEditorFrameH,
                frames: JSON.parse(JSON.stringify(itemFrames)),
                fps: fps,
                idleFrame: idleFrame
            };

            if (itemEditorEditingIndex >= 0) {
                items[itemEditorEditingIndex] = itemData;
                broadcastEdit({ editType: 'updateItem', index: itemEditorEditingIndex, item: itemData });
            } else {
                items.push(itemData);
                broadcastEdit({ editType: 'addItem', item: itemData });
            }

            itemStopPreview();
            document.getElementById('itemModal').classList.remove('visible');
            stopEditing(); // Clear editing lock
            updateItemList();
            renderMap();
        }

        function itemCancel() {
            itemStopPreview();
            document.getElementById('itemModal').classList.remove('visible');
            stopEditing(); // Clear editing lock
        }

        function updateItemLayerDropdown() {
            const select = document.getElementById('itemPlacementLayer');
            if (!select) return;
            const currentVal = parseInt(select.value) || 0;
            select.innerHTML = '';
            layers.forEach((layer, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = layerNames[i] || ('Layer ' + (i + 1));
                if (i === currentVal) opt.selected = true;
                select.appendChild(opt);
            });
            // Default to player layer if available
            if (currentVal === 0 && playerLayerIndex >= 0 && playerLayerIndex < layers.length) {
                select.value = playerLayerIndex;
            }
        }

        function updateItemList() {
            const container = document.getElementById('itemList');
            if (!container) return;
            container.innerHTML = '';

            if (items.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; padding:10px;">No items yet</div>';
                return;
            }

            items.forEach((item, i) => {
                const itemEl = document.createElement('div');
                const isSelected = (currentItemIndex === i);
                itemEl.style.cssText = 'display:flex; align-items:center; gap:10px; padding:8px; background:' + (isSelected ? '#3a4a3a' : '#333') + '; border:2px solid ' + (isSelected ? '#4f8' : 'transparent') + '; border-radius:5px; margin-bottom:5px; cursor:pointer;';
                itemEl.onclick = () => { currentItemIndex = i; updateItemList(); };

                // Preview thumbnail
                if (item.frames && item.frames.length > 0) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 32;
                    canvas.height = 32;
                    canvas.style.cssText = 'border:1px solid #555; image-rendering:pixelated;';
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;

                    const idleIdx = item.idleFrame || 0;
                    const frame = item.frames[idleIdx] || item.frames[0];
                    if (item._spriteImg) {
                        ctx.drawImage(item._spriteImg, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                    } else if (item.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            item._spriteImg = img;
                            ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                        };
                        img.src = item.spriteData;
                    }
                    itemEl.appendChild(canvas);
                }

                // Name and info
                const info = document.createElement('div');
                info.innerHTML = `<div style="font-weight:bold; color:#4f8;">${item.name}</div>
                    <div style="font-size:10px; color:#888;">${item.frames?.length || 0} frames</div>`;
                itemEl.appendChild(info);

                // Edit/Delete buttons
                const btns = document.createElement('div');
                btns.style.cssText = 'margin-left:auto; display:flex; gap:5px;';
                btns.innerHTML = `
                    <button onclick="event.stopPropagation(); openItemEditor(${i})" style="padding:3px 6px; font-size:10px;">Edit</button>
                    <button onclick="event.stopPropagation(); deleteItem(${i})" style="padding:3px 6px; font-size:10px; background:#a55;">×</button>
                `;
                itemEl.appendChild(btns);

                container.appendChild(itemEl);
            });
        }

        function deleteItem(index) {
            if (!confirm('Delete this item?')) return;
            items.splice(index, 1);
            broadcastEdit({ editType: 'deleteItem', index: index });
            if (currentItemIndex >= items.length) currentItemIndex = items.length - 1;
            updateItemList();
            renderMap();
        }

        function updatePlacedItemsList() {
            const container = document.getElementById('placedItemsList');
            if (!container) return;

            const currentMapItems = placedItems.filter(p => !p.mapName || p.mapName === currentMapName);

            if (currentMapItems.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; text-align:center; padding:10px;">No items placed</div>';
                return;
            }

            container.innerHTML = '';
            currentMapItems.forEach((placed, i) => {
                const item = items[placed.itemIndex];
                if (!item) return;
                const realIdx = placedItems.indexOf(placed);
                const div = document.createElement('div');
                div.style.cssText = 'display:flex; justify-content:space-between; align-items:center; padding:4px 0; border-bottom:1px solid #333;';
                div.innerHTML = `
                    <span style="color:#4f8;">${item.name}</span>
                    <span style="font-size:10px; color:#888;">(${placed.x}, ${placed.y})</span>
                    <button onclick="removePlacedItem(${realIdx})" style="padding:2px 6px; font-size:9px; background:#a55;">×</button>
                `;
                container.appendChild(div);
            });
        }

        function removePlacedItem(index) {
            const item = placedItems[index];
            if (item) {
                broadcastEdit({ editType: 'removeItem', x: item.x, y: item.y, mapName: item.mapName || currentMapName });
            }
            placedItems.splice(index, 1);
            updatePlacedItemsList();
            renderMap();
        }

        // Find an interactive anim prop (with giveItem) at the given map coordinates
        function findInteractivePropAt(x, y) {
            for (let i = 0; i < placedAnimProps.length; i++) {
                const placed = placedAnimProps[i];
                if (placed.mapName && placed.mapName !== currentMapName) continue;

                const prop = animatedProps[placed.propIndex];
                if (!prop || !prop.giveItem) continue;

                // Calculate prop bounds
                const frames = prop.frames || [];
                if (frames.length === 0) continue;
                const frame = frames[0];
                const tilesW = Math.ceil(frame.w / gridSize);
                const tilesH = Math.ceil(frame.h / gridSize);

                // Check if click is within prop bounds
                if (x >= placed.x && x < placed.x + tilesW &&
                    y >= placed.y && y < placed.y + tilesH) {
                    return i;
                }
            }
            return -1;
        }

        // Open a popup to assign an item to a specific placed prop instance
        function openPropItemAssignment(placedPropIndex) {
            const placed = placedAnimProps[placedPropIndex];
            if (!placed) return;

            const prop = animatedProps[placed.propIndex];
            if (!prop) return;

            // Build item options
            let itemOptions = '<option value="-1">(Use default: ' + (items[prop.giveItemIndex]?.name || 'None') + ')</option>';
            items.forEach((item, idx) => {
                const selected = placed.instanceItemIndex === idx ? ' selected' : '';
                itemOptions += '<option value="' + idx + '"' + selected + '>' + item.name + '</option>';
            });

            // Create simple popup
            const popup = document.createElement('div');
            popup.id = 'propItemAssignPopup';
            popup.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#2a2a3a; padding:20px; border-radius:8px; border:2px solid #fa0; z-index:10000; min-width:300px;';
            popup.innerHTML = `
                <div style="color:#fa0; font-weight:bold; margin-bottom:15px; font-size:14px;">
                    📦 Assign Item to: ${prop.name}
                </div>
                <div style="margin-bottom:15px;">
                    <label style="color:#ccc; display:block; margin-bottom:5px;">Item to give:</label>
                    <select id="propInstanceItemSelect" style="width:100%; padding:8px; background:#1a1a2a; color:#fff; border:1px solid #555; border-radius:4px;">
                        ${itemOptions}
                    </select>
                </div>
                <div style="display:flex; gap:10px; justify-content:flex-end;">
                    <button onclick="closePropItemAssignment()" style="padding:8px 16px; background:#555; color:#fff; border:none; border-radius:4px; cursor:pointer;">Cancel</button>
                    <button onclick="savePropItemAssignment(${placedPropIndex})" style="padding:8px 16px; background:#fa0; color:#000; border:none; border-radius:4px; cursor:pointer; font-weight:bold;">Save</button>
                </div>
            `;
            document.body.appendChild(popup);

            // Add backdrop
            const backdrop = document.createElement('div');
            backdrop.id = 'propItemAssignBackdrop';
            backdrop.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999;';
            backdrop.onclick = closePropItemAssignment;
            document.body.appendChild(backdrop);
        }

        function closePropItemAssignment() {
            const popup = document.getElementById('propItemAssignPopup');
            const backdrop = document.getElementById('propItemAssignBackdrop');
            if (popup) popup.remove();
            if (backdrop) backdrop.remove();
        }

        function savePropItemAssignment(placedPropIndex) {
            const select = document.getElementById('propInstanceItemSelect');
            if (!select) return;

            const itemIdx = parseInt(select.value);
            const placed = placedAnimProps[placedPropIndex];
            if (!placed) return;

            if (itemIdx < 0) {
                // Clear instance override (use default)
                delete placed.instanceItemIndex;
            } else {
                placed.instanceItemIndex = itemIdx;
            }

            // Broadcast to co-op builders
            broadcastEdit({ editType: 'updatePlacedAnimProp', index: placedPropIndex, prop: placed });

            closePropItemAssignment();
            renderMap();
        }

        function placeItemAt(x, y) {
            if (x < 0 || y < 0 || x >= mapCols || y >= mapRows) return;
            if (currentItemIndex < 0 || !items[currentItemIndex]) return;

            // Get selected layer from dropdown
            const layerSelect = document.getElementById('itemPlacementLayer');
            const itemLayer = layerSelect ? parseInt(layerSelect.value) : 0;

            // Check if item already exists at this position on same layer
            const existingIdx = placedItems.findIndex(p =>
                p.x === x && p.y === y &&
                (!p.mapName || p.mapName === currentMapName) &&
                p.layer === itemLayer
            );
            if (existingIdx >= 0) return; // Don't stack items

            const newItem = {
                itemIndex: currentItemIndex,
                x: x,
                y: y,
                layer: itemLayer,
                mapName: currentMapName,
                used: false
            };
            placedItems.push(newItem);

            // Broadcast to co-op builders
            broadcastEdit({ editType: 'placeItem', item: newItem, index: placedItems.length - 1 });

            updatePlacedItemsList();
            renderMap();
        }

        function removeItemAt(x, y) {
            const idx = placedItems.findIndex(p =>
                p.x === x && p.y === y &&
                (!p.mapName || p.mapName === currentMapName)
            );
            if (idx >= 0) {
                placedItems.splice(idx, 1);
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeItem', x: x, y: y, mapName: currentMapName });
                updatePlacedItemsList();
                renderMap();
            }
        }

        // Initialize item editor canvas with drag selection handlers
        document.addEventListener('DOMContentLoaded', () => {
            const itemCanvas = document.getElementById('itemEditorCanvas');
            if (itemCanvas) {
                itemCanvas.addEventListener('mousedown', function(e) {
                    if (!itemEditorImage) return;
                    const rect = this.getBoundingClientRect();
                    const scale = itemEditorZoom;
                    const gridX = Math.floor((e.clientX - rect.left) / (itemEditorFrameW * scale));
                    const gridY = Math.floor((e.clientY - rect.top) / (itemEditorFrameH * scale));
                    itemDragStart = { gridX, gridY };
                    itemDragEnd = { gridX, gridY };
                    itemIsDragging = true;
                    itemDrawCanvas();
                });

                itemCanvas.addEventListener('mousemove', function(e) {
                    if (!itemIsDragging || !itemEditorImage) return;
                    const rect = this.getBoundingClientRect();
                    const scale = itemEditorZoom;
                    const gridX = Math.floor((e.clientX - rect.left) / (itemEditorFrameW * scale));
                    const gridY = Math.floor((e.clientY - rect.top) / (itemEditorFrameH * scale));
                    itemDragEnd = { gridX, gridY };
                    itemDrawCanvas();
                });

                itemCanvas.addEventListener('mouseup', function(e) {
                    if (!itemIsDragging || !itemEditorImage) return;
                    itemIsDragging = false;

                    if (itemDragStart && itemDragEnd) {
                        const startGX = Math.min(itemDragStart.gridX, itemDragEnd.gridX);
                        const startGY = Math.min(itemDragStart.gridY, itemDragEnd.gridY);
                        const endGX = Math.max(itemDragStart.gridX, itemDragEnd.gridX);
                        const endGY = Math.max(itemDragStart.gridY, itemDragEnd.gridY);

                        // Add all frames in the selection as a single multi-tile frame
                        const frameX = startGX * itemEditorFrameW;
                        const frameY = startGY * itemEditorFrameH;
                        const frameW = (endGX - startGX + 1) * itemEditorFrameW;
                        const frameH = (endGY - startGY + 1) * itemEditorFrameH;

                        // Check if already exists
                        const existingIdx = itemFrames.findIndex(f => f.x === frameX && f.y === frameY && f.w === frameW && f.h === frameH);
                        if (existingIdx >= 0) {
                            itemFrames.splice(existingIdx, 1);
                        } else {
                            itemFrames.push({ x: frameX, y: frameY, w: frameW, h: frameH });
                        }

                        itemUpdateFramesList();
                        itemUpdateIdleDropdown();
                        itemStartPreview();
                    }

                    itemDragStart = null;
                    itemDragEnd = null;
                    itemDrawCanvas();
                });

                itemCanvas.addEventListener('mouseleave', function() {
                    if (itemIsDragging) {
                        itemIsDragging = false;
                        itemDragStart = null;
                        itemDragEnd = null;
                        itemDrawCanvas();
                    }
                });
            }
        });

        function updateAnimPropScale() {
            const scale = parseFloat(document.getElementById('animPropScale').value) || 1;
            currentAnimPropScale = scale;
            document.getElementById('animPropScaleValue').textContent = scale.toFixed(2) + 'x';
            renderMap(); // Update preview
        }

        function toggleEditAnimPropMode() {
            editAnimPropOnMapMode = !editAnimPropOnMapMode;
            const btn = document.getElementById('editAnimPropOnMapBtn');
            if (editAnimPropOnMapMode) {
                btn.classList.add('active');
                btn.textContent = '✓ Click Prop to Edit';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Edit Object on Map';
            }
            renderMap();
        }

        // Find placed animated prop at map position
        function findAnimPropAt(x, y) {
            // Search all layers for animTile at this position
            for (let li = 0; li < layers.length; li++) {
                const layer = layers[li];
                if (!layer || !layer[y] || !layer[y][x]) continue;
                const cell = layer[y][x];
                if (cell && cell.type === 'animTile') {
                    // Return origin position for multi-tile props
                    const originX = x - (cell.offsetX || 0);
                    const originY = y - (cell.offsetY || 0);
                    return { x: originX, y: originY, layer: li, cell: layer[originY][originX] };
                }
            }
            return null;
        }

        // Open popup to edit placed animated prop timing
        function openAnimPropEditPopup(propInfo) {
            const { x, y, layer, cell } = propInfo;
            const prop = animatedProps[cell.propIndex];
            if (!prop) return;

            // Get current instance settings or defaults
            const currentMode = cell.instancePlayMode || 'default';
            const currentPlayCount = cell.instancePlayCount || 1;
            const currentWaitTime = cell.instanceWaitTime || 2;
            const currentSpeed = cell.instanceSpeed !== undefined ? cell.instanceSpeed : 1;
            const currentScale = cell.scale !== undefined ? cell.scale : 1;

            const popup = document.createElement('div');
            popup.id = 'animPropEditPopup';
            popup.style.cssText = 'position:fixed; bottom:20px; left:50%; transform:translateX(-50%); background:#2a2a3a; padding:20px; border-radius:8px; border:2px solid #fa0; z-index:10000; width:500px; max-width:90vw;';

            let html = '<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">';
            html += '<div style="color:#fa0; font-weight:bold; font-size:14px;">Edit: ' + prop.name + '</div>';
            html += '<button onclick="closeAnimPropEditPopup()" style="background:none; border:none; color:#888; font-size:18px; cursor:pointer;">&times;</button>';
            html += '</div>';

            html += '<div style="display:flex; gap:20px;">';

            // Left column - Scale and Speed
            html += '<div style="flex:1;">';
            html += '<div style="margin-bottom:12px;">';
            html += '<label style="color:#ccc; display:block; margin-bottom:5px;">Scale:</label>';
            html += '<div style="display:flex; align-items:center; gap:10px;">';
            html += '<input type="range" id="editAnimScale" min="0.25" max="4" step="0.25" value="' + currentScale + '" style="flex:1;" oninput="document.getElementById(\'scaleValue\').textContent = this.value + \'x\'; previewAnimPropScale(' + x + ', ' + y + ', ' + layer + ', this.value)">';
            html += '<span id="scaleValue" style="color:#4af; min-width:40px;">' + currentScale + 'x</span>';
            html += '</div></div>';
            html += '<div style="margin-bottom:12px;">';
            html += '<label style="color:#ccc; display:block; margin-bottom:5px;">Animation Speed:</label>';
            html += '<div style="display:flex; align-items:center; gap:10px;">';
            html += '<input type="range" id="editAnimSpeed" min="0.25" max="3" step="0.25" value="' + currentSpeed + '" style="flex:1;" oninput="document.getElementById(\'speedValue\').textContent = this.value + \'x\'">';
            html += '<span id="speedValue" style="color:#4af; min-width:40px;">' + currentSpeed + 'x</span>';
            html += '</div></div>';
            html += '</div>';

            // Right column - Animation Mode
            html += '<div style="flex:1;">';
            html += '<div style="margin-bottom:12px;">';
            html += '<label style="color:#ccc; display:block; margin-bottom:5px;">Animation Mode:</label>';
            html += '<select id="editAnimMode" style="width:100%; padding:8px; background:#1a1a2a; color:#fff; border:1px solid #555; border-radius:4px;" onchange="updateAnimEditPopup()">';
            html += '<option value="default"' + (currentMode === 'default' ? ' selected' : '') + '>Default (from prop)</option>';
            html += '<option value="loop"' + (currentMode === 'loop' ? ' selected' : '') + '>Loop Forever</option>';
            html += '<option value="timed"' + (currentMode === 'timed' ? ' selected' : '') + '>Timed</option>';
            html += '</select></div>';
            html += '<div id="timedSettings" style="display:' + (currentMode === 'timed' ? 'block' : 'none') + '; background:#1a1a2a; padding:10px; border-radius:4px;">';
            html += '<div style="margin-bottom:8px;"><label style="color:#aaa; font-size:11px;">Play animation:</label>';
            html += '<div style="display:flex; align-items:center; gap:5px; margin-top:3px;">';
            html += '<input type="number" id="editPlayCount" value="' + currentPlayCount + '" min="1" max="10" style="width:50px; padding:5px; background:#222; color:#4af; border:1px solid #555; border-radius:3px;">';
            html += '<span style="color:#888;">time(s)</span></div></div>';
            html += '<div><label style="color:#aaa; font-size:11px;">Then wait:</label>';
            html += '<div style="display:flex; align-items:center; gap:5px; margin-top:3px;">';
            html += '<input type="number" id="editWaitTime" value="' + currentWaitTime + '" min="0.5" max="60" step="0.5" style="width:60px; padding:5px; background:#222; color:#4af; border:1px solid #555; border-radius:3px;">';
            html += '<span style="color:#888;">seconds</span></div></div></div>';
            html += '</div>';

            html += '</div>'; // End flex container

            html += '<div style="display:flex; gap:10px; justify-content:flex-end; margin-top:15px; padding-top:15px; border-top:1px solid #444;">';
            html += '<button onclick="closeAnimPropEditPopup()" style="padding:8px 20px; background:#555; color:#fff; border:none; border-radius:4px; cursor:pointer;">Cancel</button>';
            html += '<button onclick="saveAnimPropEdit(' + x + ', ' + y + ', ' + layer + ')" style="padding:8px 20px; background:#fa0; color:#000; border:none; border-radius:4px; cursor:pointer; font-weight:bold;">Save</button>';
            html += '</div>';

            popup.innerHTML = html;
            document.body.appendChild(popup);

            // Add backdrop (semi-transparent, doesn't block view much)
            const backdrop = document.createElement('div');
            backdrop.id = 'animPropEditBackdrop';
            backdrop.style.cssText = 'position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.3); z-index:9999;';
            backdrop.onclick = closeAnimPropEditPopup;
            document.body.appendChild(backdrop);
        }

        function updateAnimEditPopup() {
            const mode = document.getElementById('editAnimMode').value;
            document.getElementById('timedSettings').style.display = mode === 'timed' ? 'block' : 'none';
        }

        function closeAnimPropEditPopup() {
            const popup = document.getElementById('animPropEditPopup');
            const backdrop = document.getElementById('animPropEditBackdrop');
            if (popup) popup.remove();
            if (backdrop) backdrop.remove();
        }

        function previewAnimPropScale(originX, originY, layerIdx, scaleValue) {
            const scale = parseFloat(scaleValue) || 1;
            const layer = layers[layerIdx];
            if (!layer || !layer[originY] || !layer[originY][originX]) return;

            const cell = layer[originY][originX];
            if (!cell || cell.type !== 'animTile') return;

            // Temporarily update scale on origin cell
            if (scale === 1) {
                delete cell.scale;
            } else {
                cell.scale = scale;
            }

            // Propagate scale to all tiles of multi-tile prop
            const prop = animatedProps[cell.propIndex];
            if (prop && (prop.tilesW > 1 || prop.tilesH > 1)) {
                const tilesW = prop.tilesW || 1;
                const tilesH = prop.tilesH || 1;
                for (let ty = 0; ty < tilesH; ty++) {
                    for (let tx = 0; tx < tilesW; tx++) {
                        if (tx === 0 && ty === 0) continue;
                        const tileX = originX + tx;
                        const tileY = originY + ty;
                        if (layer[tileY] && layer[tileY][tileX] && layer[tileY][tileX].type === 'animTile') {
                            if (scale === 1) {
                                delete layer[tileY][tileX].scale;
                            } else {
                                layer[tileY][tileX].scale = scale;
                            }
                        }
                    }
                }
            }

            renderMap();
        }

        function saveAnimPropEdit(originX, originY, layerIdx) {
            const mode = document.getElementById('editAnimMode').value;
            const playCount = parseInt(document.getElementById('editPlayCount').value) || 1;
            const waitTime = parseFloat(document.getElementById('editWaitTime').value) || 2;
            const speed = parseFloat(document.getElementById('editAnimSpeed').value) || 1;
            const scale = parseFloat(document.getElementById('editAnimScale').value) || 1;

            const layer = layers[layerIdx];
            if (!layer || !layer[originY] || !layer[originY][originX]) return;

            const cell = layer[originY][originX];
            if (!cell || cell.type !== 'animTile') return;

            // Update instance scale
            if (scale === 1) {
                delete cell.scale;
            } else {
                cell.scale = scale;
            }

            // Update instance speed
            if (speed === 1) {
                delete cell.instanceSpeed;
            } else {
                cell.instanceSpeed = speed;
            }

            // Update instance settings
            if (mode === 'default') {
                delete cell.instancePlayMode;
                delete cell.instancePlayCount;
                delete cell.instanceWaitTime;
            } else {
                cell.instancePlayMode = mode;
                if (mode === 'timed') {
                    cell.instancePlayCount = playCount;
                    cell.instanceWaitTime = waitTime;
                } else {
                    delete cell.instancePlayCount;
                    delete cell.instanceWaitTime;
                }
            }

            // Propagate scale to all tiles of multi-tile prop
            const prop = animatedProps[cell.propIndex];
            if (prop && (prop.tilesW > 1 || prop.tilesH > 1)) {
                const tilesW = prop.tilesW || 1;
                const tilesH = prop.tilesH || 1;
                for (let ty = 0; ty < tilesH; ty++) {
                    for (let tx = 0; tx < tilesW; tx++) {
                        if (tx === 0 && ty === 0) continue; // Skip origin, already updated
                        const tileX = originX + tx;
                        const tileY = originY + ty;
                        if (layer[tileY] && layer[tileY][tileX] && layer[tileY][tileX].type === 'animTile') {
                            if (scale === 1) {
                                delete layer[tileY][tileX].scale;
                            } else {
                                layer[tileY][tileX].scale = scale;
                            }
                        }
                    }
                }
            }

            // Reset animation state for this prop
            const key = originX + ',' + originY + ',' + layerIdx;
            delete placedAnimPropFrames[key];

            // Broadcast to co-op
            broadcastEdit({ editType: 'tile', layer: layerIdx, x: originX, y: originY, cell: cell, mapName: currentMapName });

            closeAnimPropEditPopup();
            renderMap();
        }

        function updateAnimPropListDisplay() {
            const container = document.getElementById('animPropList');
            if (!container) return;
            container.innerHTML = '';

            if (animatedProps.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; padding:10px;">No animated props yet</div>';
                return;
            }

            animatedProps.forEach((prop, i) => {
                const item = document.createElement('div');
                const isSelected = (currentAnimPropIndex === i);
                item.style.cssText = 'display:flex; align-items:center; gap:10px; padding:8px; background:' + (isSelected ? '#4a4a6e' : '#333') + '; border:2px solid ' + (isSelected ? '#4af' : 'transparent') + '; border-radius:5px; margin-bottom:5px; cursor:pointer;';
                item.onclick = () => { currentAnimPropIndex = i; updateAnimPropListDisplay(); };

                // Preview thumbnail
                if (prop.frames && prop.frames.length > 0) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 32;
                    canvas.height = 32;
                    canvas.style.cssText = 'border:1px solid #555; image-rendering:pixelated;';
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;

                    const frame = prop.frames[0];
                    if (prop._spriteImg) {
                        ctx.drawImage(prop._spriteImg, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                    } else if (prop.spriteData) {
                        // Fallback: load image if _spriteImg not available
                        const img = new Image();
                        img.onload = () => {
                            prop._spriteImg = img;
                            ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                        };
                        img.src = prop.spriteData;
                    }
                    item.appendChild(canvas);
                }

                const info = document.createElement('div');
                info.style.flex = '1';
                info.innerHTML = '<div style="color:#4af; font-weight:bold;">' + prop.name + '</div>' +
                    '<div style="font-size:10px; color:#888;">' + prop.frames.length + ' frames | ' + prop.type + '</div>';
                item.appendChild(info);

                // Edit button
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.style.cssText = 'padding:4px 8px; font-size:10px;';
                editBtn.onclick = (e) => { e.stopPropagation(); openAnimPropEditor(i); };
                item.appendChild(editBtn);

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = '×';
                delBtn.style.cssText = 'padding:4px 8px; font-size:10px; background:#a55;';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Delete "' + prop.name + '"?')) {
                        const deleteIndex = i;
                        animatedProps.splice(deleteIndex, 1);
                        placedAnimProps = placedAnimProps.filter(p => p.propIndex !== deleteIndex);
                        placedAnimProps.forEach(p => { if (p.propIndex > deleteIndex) p.propIndex--; });
                        broadcastEdit({ editType: 'removeAnimProp', index: deleteIndex });
                        updateAnimPropListDisplay();
                        renderMap();
                    }
                };
                item.appendChild(delBtn);

                container.appendChild(item);
            });
        }

        // ========== STATIC OBJECTS LIST ==========
        function updateStaticObjectsList() {
            const container = document.getElementById('staticObjList');
            if (!container) return;
            container.innerHTML = '';

            if (staticObjects.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; padding:10px; text-align:center;">No static objects yet</div>';
                return;
            }

            staticObjects.forEach((obj, i) => {
                const item = document.createElement('div');
                const isSelected = (currentStaticObjIndex === i);
                item.style.cssText = `
                    display:flex; align-items:center; gap:8px; padding:6px 8px;
                    background:${isSelected ? '#2a4a3a' : '#333'};
                    border:2px solid ${isSelected ? '#4a7c59' : 'transparent'};
                    border-radius:5px; cursor:pointer; min-width:120px;
                `;
                item.onclick = () => selectStaticObject(i);

                // Preview thumbnail
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                canvas.style.cssText = 'border:1px solid #555; image-rendering:pixelated; flex-shrink:0;';
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;

                if (obj._spriteImg && obj._spriteImg.complete) {
                    const srcW = obj.width * gridSize;
                    const srcH = obj.height * gridSize;
                    const scale = Math.min(32 / srcW, 32 / srcH);
                    const drawW = srcW * scale;
                    const drawH = srcH * scale;
                    ctx.drawImage(obj._spriteImg, 0, 0, srcW, srcH,
                                 (32 - drawW) / 2, (32 - drawH) / 2, drawW, drawH);
                }
                item.appendChild(canvas);

                // Info text
                const info = document.createElement('div');
                info.style.cssText = 'flex:1; min-width:0;';
                info.innerHTML = `
                    <div style="color:#4a7c59; font-weight:bold; font-size:11px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${obj.name}</div>
                    <div style="font-size:9px; color:#888;">${obj.width}x${obj.height} tiles</div>
                `;
                item.appendChild(info);

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = '×';
                delBtn.style.cssText = 'padding:2px 6px; font-size:12px; background:#a55; border:none; color:white; cursor:pointer; border-radius:3px;';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteStaticObject(i);
                };
                item.appendChild(delBtn);

                container.appendChild(item);
            });
        }

        function selectStaticObject(index) {
            currentStaticObjIndex = index;
            currentAnimPropIndex = -1; // Deselect animated props

            updateStaticObjectsList();
            updateAnimPropListDisplay();

            // Show/hide placement controls
            const controls = document.getElementById('staticObjPlacementControls');
            if (controls) {
                controls.style.display = (index >= 0) ? 'block' : 'none';
            }
        }

        function deleteStaticObject(index) {
            const obj = staticObjects[index];
            if (!obj) return;

            if (!confirm('Delete "' + obj.name + '"?\n\nAll placed instances will also be removed.')) return;

            // Remove placed instances
            placedStaticObjects = placedStaticObjects.filter(p => p.objIndex !== index);

            // Update indices for remaining placements
            placedStaticObjects.forEach(p => {
                if (p.objIndex > index) p.objIndex--;
            });

            // Remove from array
            staticObjects.splice(index, 1);

            // Fix selection
            if (currentStaticObjIndex >= staticObjects.length) {
                currentStaticObjIndex = staticObjects.length - 1;
            }
            if (currentStaticObjIndex < 0) {
                const controls = document.getElementById('staticObjPlacementControls');
                if (controls) controls.style.display = 'none';
            }

            // Broadcast
            broadcastEdit({ editType: 'removeStaticObj', index: index });

            updateStaticObjectsList();
            renderMap();
        }

        // ===== INDEXEDDB STORAGE =====
        let projectDB = null;

        function initProjectDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('WorldBuilderDB', 1);
                request.onerror = () => {
                    console.error('IndexedDB error:', request.error);
                    reject(request.error);
                };
                request.onsuccess = () => {
                    projectDB = request.result;
                    console.log('IndexedDB opened successfully');
                    resolve(projectDB);
                };
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('projects')) {
                        db.createObjectStore('projects');
                        console.log('Created projects object store');
                    }
                };
            });
        }

        async function saveProjectToDB(data) {
            try {
                if (!projectDB) await initProjectDB();
                return new Promise((resolve, reject) => {
                    const tx = projectDB.transaction('projects', 'readwrite');
                    const store = tx.objectStore('projects');
                    const request = store.put(data, 'current');
                    request.onsuccess = () => {
                        console.log('Project saved to IndexedDB');
                        resolve();
                    };
                    request.onerror = () => {
                        console.error('IndexedDB save error:', request.error);
                        reject(request.error);
                    };
                });
            } catch (err) {
                console.error('saveProjectToDB error:', err);
                throw err;
            }
        }

        async function loadProjectFromDB() {
            try {
                if (!projectDB) await initProjectDB();
                return new Promise((resolve, reject) => {
                    const tx = projectDB.transaction('projects', 'readonly');
                    const store = tx.objectStore('projects');
                    const request = store.get('current');
                    request.onsuccess = () => {
                        resolve(request.result);
                    };
                    request.onerror = () => {
                        console.error('IndexedDB load error:', request.error);
                        reject(request.error);
                    };
                });
            } catch (err) {
                console.error('loadProjectFromDB error:', err);
                throw err;
            }
        }

        async function showStorageInfo() {
            const data = getProjectData();
            const json = JSON.stringify(data);
            const totalMB = (json.length / 1000000).toFixed(2);

            // Get storage quota (if available)
            let quotaInfo = 'Unknown';
            if (navigator.storage && navigator.storage.estimate) {
                const estimate = await navigator.storage.estimate();
                const usedMB = (estimate.usage / 1000000).toFixed(2);
                const quotaMB = (estimate.quota / 1000000).toFixed(0);
                quotaInfo = usedMB + 'MB / ' + quotaMB + 'MB';
            }

            // Breakdown by component
            const soundsSize = JSON.stringify(data.sounds || []).length;
            const tilesetsSize = JSON.stringify(data.tilesets || []).length;
            const propsSize = JSON.stringify(data.props || []).length;
            const animPropsSize = JSON.stringify(data.animatedProps || []).length;
            const npcsSize = JSON.stringify(data.npcs || []).length;
            const mapSize = JSON.stringify(data.layers || []).length;

            alert('Project Size: ' + totalMB + 'MB\n' +
                'Browser Storage: ' + quotaInfo + '\n\n' +
                'Breakdown:\n' +
                '- Sounds: ' + (soundsSize/1000000).toFixed(2) + 'MB\n' +
                '- Tilesets: ' + (tilesetsSize/1000000).toFixed(2) + 'MB\n' +
                '- Props: ' + (propsSize/1000000).toFixed(2) + 'MB\n' +
                '- Animated Props: ' + (animPropsSize/1000000).toFixed(2) + 'MB\n' +
                '- NPCs: ' + (npcsSize/1000000).toFixed(2) + 'MB\n' +
                '- Map Data: ' + (mapSize/1000000).toFixed(2) + 'MB');
        }

        // Initialize IndexedDB on page load
        initProjectDB().catch(err => console.warn('IndexedDB init failed, will use localStorage:', err));

        // ===== QUEST SYSTEM FUNCTIONS =====

        function generateQuestId() {
            return 'quest_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function addNewQuest() {
            const newQuest = {
                id: generateQuestId(),
                name: 'New Quest ' + (quests.length + 1),
                description: '',
                conditions: [],
                onComplete: {
                    giveItems: [],
                    removeItems: []
                },
                startNpcUid: '',
                turnInNpcUid: '',
                startDialogId: '',    // Dialog shown when offering quest
                activeDialogId: '',   // Dialog shown while quest is active (reminder)
                completeDialogId: '', // Dialog shown when turning in quest
                prerequisites: [],
                autoStart: false,
                isRepeatable: false
            };
            quests.push(newQuest);
            broadcastEdit({ editType: 'addQuest', quest: newQuest });
            renderQuestList();
            selectQuest(quests.length - 1);
        }

        function selectQuest(index) {
            selectedQuestIndex = index;
            renderQuestList();

            const panel = document.getElementById('questEditorPanel');
            if (index < 0 || index >= quests.length) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';
            loadQuestIntoEditor(index);
        }

        function loadQuestIntoEditor(index) {
            const quest = quests[index];
            if (!quest) return;

            document.getElementById('questName').value = quest.name || '';
            document.getElementById('questDescription').value = quest.description || '';
            document.getElementById('questAutoStart').checked = quest.autoStart || false;
            document.getElementById('questRepeatable').checked = quest.isRepeatable || false;

            // Update NPC display names
            updateQuestNpcDisplayNames();

            // Update dialog dropdowns
            updateQuestDialogDropdowns();

            // Update prerequisites
            updateQuestPrereqDropdown();
            renderQuestPrerequisites();

            renderQuestConditions();
            renderQuestRewards();
        }

        // Populate quest dialog dropdowns with available dialogs
        function updateQuestDialogDropdowns() {
            const startSelect = document.getElementById('questStartDialog');
            const activeSelect = document.getElementById('questActiveDialog');
            const completeSelect = document.getElementById('questCompleteDialog');
            if (!startSelect || !activeSelect || !completeSelect) return;

            // Build dialog options
            let options = '<option value="">(None - skip)</option>';
            dialogs.forEach((d, i) => {
                const name = d.name || 'Dialog ' + (i + 1);
                options += '<option value="' + i + '">' + name + '</option>';
            });

            startSelect.innerHTML = options;
            activeSelect.innerHTML = options;
            completeSelect.innerHTML = options;

            // Set selected values from current quest
            const quest = quests[selectedQuestIndex];
            if (quest) {
                if (quest.startDialogId !== undefined && quest.startDialogId !== '') {
                    startSelect.value = quest.startDialogId;
                }
                if (quest.activeDialogId !== undefined && quest.activeDialogId !== '') {
                    activeSelect.value = quest.activeDialogId;
                }
                if (quest.completeDialogId !== undefined && quest.completeDialogId !== '') {
                    completeSelect.value = quest.completeDialogId;
                }
            }
        }

        // Open dialog creator/picker for quest dialog
        let questDialogPickerType = null; // 'start', 'active', or 'complete'

        function openDialogPickerForQuest(type) {
            questDialogPickerType = type;
            // Open the dialog editor with a new dialog
            openDialogEditor(-1);
            // Show hint to user
            const typeLabels = { start: 'Offer Quest', active: 'While Active', complete: 'Turn In' };
            setTimeout(() => {
                const nameInput = document.getElementById('dialogName');
                if (nameInput) {
                    const quest = quests[selectedQuestIndex];
                    const questName = quest?.name || 'Quest';
                    nameInput.value = questName + ' - ' + typeLabels[type];
                }
            }, 100);
        }

        // Hook into dialog save to auto-attach to quest
        function attachNewDialogToQuest(dialogIndex) {
            if (questDialogPickerType && selectedQuestIndex >= 0) {
                const fieldMap = {
                    'start': 'startDialogId',
                    'active': 'activeDialogId',
                    'complete': 'completeDialogId'
                };
                const field = fieldMap[questDialogPickerType];
                if (field) {
                    updateQuestField(field, dialogIndex.toString());
                    updateQuestDialogDropdowns();
                }
                questDialogPickerType = null;
            }
        }

        function updateQuestField(field, value) {
            if (selectedQuestIndex < 0 || selectedQuestIndex >= quests.length) return;
            const quest = quests[selectedQuestIndex];
            quest[field] = value;
            broadcastEdit({ editType: 'updateQuest', questId: quest.id, quest: quest });
            if (field === 'name') renderQuestList();
        }

        function deleteCurrentQuest() {
            if (selectedQuestIndex < 0 || selectedQuestIndex >= quests.length) return;
            if (!confirm('Delete quest "' + quests[selectedQuestIndex].name + '"?')) return;

            const questId = quests[selectedQuestIndex].id;
            quests.splice(selectedQuestIndex, 1);
            broadcastEdit({ editType: 'deleteQuest', questId: questId });
            selectedQuestIndex = -1;
            renderQuestList();
            document.getElementById('questEditorPanel').style.display = 'none';
        }

        // Quest prerequisites - require specific quests to be completed
        function updateQuestPrereqDropdown() {
            const select = document.getElementById('questPrereqSelect');
            if (!select) return;

            const currentQuest = quests[selectedQuestIndex];
            if (!currentQuest) return;

            // Show all other quests except current one and already added prereqs
            const prereqs = currentQuest.prerequisites || [];
            let options = '<option value="">Select quest...</option>';
            quests.forEach((q, i) => {
                if (i === selectedQuestIndex) return; // Can't require itself
                if (prereqs.includes(q.id)) return; // Already a prereq
                options += '<option value="' + q.id + '">' + (q.name || 'Quest ' + (i + 1)) + '</option>';
            });
            select.innerHTML = options;
        }

        function renderQuestPrerequisites() {
            const container = document.getElementById('questPrereqList');
            if (!container) return;

            const quest = quests[selectedQuestIndex];
            if (!quest || !quest.prerequisites || quest.prerequisites.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:10px;">None (available from start)</div>';
                return;
            }

            container.innerHTML = quest.prerequisites.map((prereqId, i) => {
                const prereqQuest = quests.find(q => q.id === prereqId);
                const name = prereqQuest ? (prereqQuest.name || prereqId) : prereqId + ' (not found)';
                return '<div style="display:flex; justify-content:space-between; align-items:center; padding:3px; margin:2px 0; background:#333; border-radius:3px; font-size:10px;">' +
                    '<span style="color:#fa0;">' + name + '</span>' +
                    '<button onclick="removeQuestPrerequisite(' + i + ')" style="padding:1px 5px; font-size:9px; background:#a55; border:none; color:#fff; cursor:pointer;">×</button>' +
                '</div>';
            }).join('');
        }

        function addQuestPrerequisite() {
            if (selectedQuestIndex < 0) return;
            const select = document.getElementById('questPrereqSelect');
            const prereqId = select.value;
            if (!prereqId) return;

            const quest = quests[selectedQuestIndex];
            if (!quest.prerequisites) quest.prerequisites = [];
            if (quest.prerequisites.includes(prereqId)) return;

            quest.prerequisites.push(prereqId);
            broadcastEdit({ editType: 'updateQuest', questId: quest.id, quest: quest });

            updateQuestPrereqDropdown();
            renderQuestPrerequisites();
        }

        function removeQuestPrerequisite(index) {
            if (selectedQuestIndex < 0) return;
            const quest = quests[selectedQuestIndex];
            if (!quest.prerequisites) return;

            quest.prerequisites.splice(index, 1);
            broadcastEdit({ editType: 'updateQuest', questId: quest.id, quest: quest });

            updateQuestPrereqDropdown();
            renderQuestPrerequisites();
        }

        function renderQuestList() {
            const container = document.getElementById('questList');
            if (!container) return;

            if (quests.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; text-align:center; padding:10px;">No quests created</div>';
                return;
            }

            // Find NPCs with multiple quests
            const npcQuestCounts = {};
            quests.forEach(q => {
                if (q.startNpcUid) {
                    npcQuestCounts[q.startNpcUid] = (npcQuestCounts[q.startNpcUid] || 0) + 1;
                }
            });

            container.innerHTML = quests.map((q, i) => {
                const isSelected = i === selectedQuestIndex;
                const condCount = q.conditions?.length || 0;
                const prereqCount = q.prerequisites?.length || 0;
                const hasMultiQuestNpc = q.startNpcUid && npcQuestCounts[q.startNpcUid] > 1;
                const multiQuestBadge = hasMultiQuestNpc ?
                    '<span style="background:#fa0; color:#000; padding:1px 4px; border-radius:3px; font-size:9px; font-weight:bold; margin-left:5px;" title="This NPC has multiple quests - order matters!">#' + (i + 1) + '</span>' : '';
                const prereqBadge = prereqCount > 0 ?
                    '<span style="background:#a80; color:#fff; padding:1px 4px; border-radius:3px; font-size:9px; margin-left:5px;" title="Requires ' + prereqCount + ' quest(s) completed first">🔒' + prereqCount + '</span>' : '';
                const npcName = getNpcNameByUid(q.startNpcUid);
                const npcInfo = npcName ? '<span style="color:#8cf;"> → ' + npcName + '</span>' : '';

                return '<div draggable="true" ondragstart="questDragStart(event, ' + i + ')" ondragover="questDragOver(event)" ondrop="questDrop(event, ' + i + ')" onclick="selectQuest(' + i + ')" style="padding:8px; margin:3px 0; background:' + (isSelected ? '#4a4a7a' : '#333') + '; border-radius:4px; cursor:pointer; border:2px solid ' + (isSelected ? '#a8f' : 'transparent') + '; display:flex; align-items:center; gap:8px;">' +
                    '<span style="cursor:grab; color:#666; font-size:14px;" title="Drag to reorder">⋮⋮</span>' +
                    '<div style="flex:1;">' +
                        '<div style="font-size:12px; color:#fff;">' + (q.name || 'Unnamed Quest') + multiQuestBadge + prereqBadge + '</div>' +
                        '<div style="font-size:10px; color:#888;">' + condCount + ' condition' + (condCount !== 1 ? 's' : '') + npcInfo + '</div>' +
                    '</div>' +
                '</div>';
            }).join('');
        }

        // Helper to get NPC name by UID
        function getNpcNameByUid(uid) {
            if (!uid) return null;
            const placed = placedNpcs.find(p => p.uid === uid);
            if (!placed) return null;
            const npcDef = npcs[placed.npcIndex];
            return npcDef?.name || 'NPC';
        }

        // Quest drag and drop for reordering
        let questDragIndex = -1;

        function questDragStart(e, index) {
            questDragIndex = index;
            e.dataTransfer.effectAllowed = 'move';
            e.target.style.opacity = '0.5';
        }

        function questDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function questDrop(e, dropIndex) {
            e.preventDefault();
            e.target.style.opacity = '1';

            if (questDragIndex < 0 || questDragIndex === dropIndex) return;

            // Reorder quests array
            const draggedQuest = quests[questDragIndex];
            quests.splice(questDragIndex, 1);
            quests.splice(dropIndex, 0, draggedQuest);

            // Update selection if needed
            if (selectedQuestIndex === questDragIndex) {
                selectedQuestIndex = dropIndex;
            } else if (selectedQuestIndex > questDragIndex && selectedQuestIndex <= dropIndex) {
                selectedQuestIndex--;
            } else if (selectedQuestIndex < questDragIndex && selectedQuestIndex >= dropIndex) {
                selectedQuestIndex++;
            }

            // Broadcast the reorder
            broadcastEdit({ editType: 'reorderQuests', quests: quests.map(q => q.id) });

            questDragIndex = -1;
            renderQuestList();
        }

        function updateQuestNpcDropdowns() {
            const startSelect = document.getElementById('questStartNpc');
            const turnInSelect = document.getElementById('questTurnInNpc');
            if (!startSelect || !turnInSelect) return;

            // Build NPC options from placed NPCs
            let options = '<option value="">(None)</option>';
            placedNpcs.forEach((placed, i) => {
                const npcDef = npcs[placed.npcIndex];
                const name = npcDef?.name || 'NPC ' + i;
                const uid = placed.uid || 'npc_' + i;  // Generate UID if not present
                if (!placed.uid) placed.uid = uid;  // Store it
                options += '<option value="' + uid + '">' + name + ' at (' + placed.x + ',' + placed.y + ')</option>';
            });

            startSelect.innerHTML = options;
            turnInSelect.innerHTML = '<option value="">(Same as quest giver)</option>' + options.substring(options.indexOf('</option>') + 9);
        }

        function renderQuestConditions() {
            const container = document.getElementById('questConditions');
            if (!container) return;

            const quest = quests[selectedQuestIndex];
            if (!quest || !quest.conditions || quest.conditions.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:10px;">No conditions</div>';
                return;
            }

            container.innerHTML = quest.conditions.map((c, i) => {
                const typeLabels = { enemyDefeated: 'Kill', talkedToNpc: 'Talk', locationVisited: 'Visit', hasItem: 'Has Item' };
                const isBroken = c.broken;
                return '<div style="display:flex; justify-content:space-between; align-items:center; padding:4px; margin:2px 0; background:' + (isBroken ? '#4a2a2a' : '#333') + '; border-radius:3px; font-size:10px;">' +
                    '<span style="color:' + (isBroken ? '#f88' : '#fff') + ';">' + (typeLabels[c.type] || c.type) + ': ' + (c.displayName || 'Unknown') + '</span>' +
                    '<button onclick="removeQuestCondition(' + i + ')" style="padding:2px 6px; font-size:9px; background:#a55;">×</button>' +
                '</div>';
            }).join('');
        }

        function removeQuestCondition(index) {
            if (selectedQuestIndex < 0) return;
            const quest = quests[selectedQuestIndex];
            if (!quest.conditions) return;
            quest.conditions.splice(index, 1);
            broadcastEdit({ editType: 'updateQuest', questId: quest.id, quest: quest });
            renderQuestConditions();
        }

        function renderQuestRewards() {
            const container = document.getElementById('questRewards');
            if (!container) return;

            const quest = quests[selectedQuestIndex];
            const giveItems = quest?.onComplete?.giveItems || [];

            if (giveItems.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:10px;">No rewards</div>';
                return;
            }

            container.innerHTML = giveItems.map((itemId, i) => {
                const item = items.find(it => it.id === itemId) || { name: 'Unknown Item' };
                return '<div style="display:flex; justify-content:space-between; align-items:center; padding:4px; margin:2px 0; background:#2a3a2a; border-radius:3px; font-size:10px;">' +
                    '<span style="color:#4f8;">Give: ' + (item.name || itemId) + '</span>' +
                    '<button onclick="removeQuestReward(' + i + ')" style="padding:2px 6px; font-size:9px; background:#a55;">×</button>' +
                '</div>';
            }).join('');
        }

        function addQuestReward() {
            if (selectedQuestIndex < 0) return;
            if (items.length === 0) {
                alert('Create some items first in the Items tab!');
                return;
            }

            // Show item picker popup
            let html = '<div style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#222; padding:20px; border-radius:8px; border:2px solid #4f8; z-index:10000;">';
            html += '<h3 style="margin:0 0 10px 0; color:#4f8;">Select Item to Give</h3>';
            items.forEach((item, i) => {
                const itemId = item.id || 'item_' + i;
                if (!item.id) item.id = itemId;
                html += '<div onclick="selectRewardItem(\'' + itemId + '\')" style="padding:8px; margin:5px 0; background:#333; border-radius:4px; cursor:pointer;">' + (item.name || 'Item ' + i) + '</div>';
            });
            html += '<button onclick="closeItemPickerPopup()" style="margin-top:10px; width:100%;">Cancel</button>';
            html += '</div><div id="itemPickerOverlay" onclick="closeItemPickerPopup()" style="position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999;"></div>';

            const popup = document.createElement('div');
            popup.id = 'itemPickerPopup';
            popup.innerHTML = html;
            document.body.appendChild(popup);
        }

        function selectRewardItem(itemId) {
            if (selectedQuestIndex < 0) return;
            const quest = quests[selectedQuestIndex];
            if (!quest.onComplete) quest.onComplete = {};
            if (!quest.onComplete.giveItems) quest.onComplete.giveItems = [];
            quest.onComplete.giveItems.push(itemId);
            broadcastEdit({ editType: 'updateQuest', questId: quest.id, quest: quest });
            closeItemPickerPopup();
            renderQuestRewards();
        }

        function removeQuestReward(index) {
            if (selectedQuestIndex < 0) return;
            const quest = quests[selectedQuestIndex];
            if (!quest.onComplete?.giveItems) return;
            quest.onComplete.giveItems.splice(index, 1);
            broadcastEdit({ editType: 'updateQuest', questId: quest.id, quest: quest });
            renderQuestRewards();
        }

        function closeItemPickerPopup() {
            const popup = document.getElementById('itemPickerPopup');
            if (popup) popup.remove();
        }

        // Condition setting mode
        function toggleSetCondition() {
            const type = document.getElementById('conditionType').value;

            if (settingConditionMode) {
                cancelSettingCondition();
                return;
            }

            if (type === 'hasItem') {
                showItemConditionPicker();
                return;
            }

            settingConditionMode = true;
            settingConditionType = type;

            const btn = document.getElementById('setConditionBtn');
            btn.textContent = 'CANCEL';
            btn.style.background = '#f55';

            const statusTexts = {
                'kill': 'Click on an ENEMY NPC on the map...',
                'talk': 'Click on any NPC on the map...',
                'visit': 'Click on a tile on the map...'
            };
            document.getElementById('conditionStatus').textContent = statusTexts[type] || 'Click on map...';

            renderMap();
        }

        function cancelSettingCondition() {
            settingConditionMode = false;
            settingConditionType = null;

            const btn = document.getElementById('setConditionBtn');
            btn.textContent = 'SET CONDITION';
            btn.style.background = 'linear-gradient(135deg, #0ff, #a8f)';
            document.getElementById('conditionStatus').textContent = '';

            renderMap();
        }

        function showItemConditionPicker() {
            if (items.length === 0) {
                alert('Create some items first in the Items tab!');
                return;
            }

            let html = '<div style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#222; padding:20px; border-radius:8px; border:2px solid #0ff; z-index:10000;">';
            html += '<h3 style="margin:0 0 10px 0; color:#0ff;">Select Required Item</h3>';
            items.forEach((item, i) => {
                const itemId = item.id || 'item_' + i;
                if (!item.id) item.id = itemId;
                html += '<div onclick="addItemCondition(\'' + itemId + '\', \'' + (item.name || 'Item ' + i).replace(/'/g, "\\'") + '\')" style="padding:8px; margin:5px 0; background:#333; border-radius:4px; cursor:pointer;">' + (item.name || 'Item ' + i) + '</div>';
            });
            html += '<button onclick="closeItemPickerPopup()" style="margin-top:10px; width:100%;">Cancel</button>';
            html += '</div><div id="itemPickerOverlay" onclick="closeItemPickerPopup()" style="position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.5); z-index:9999;"></div>';

            const popup = document.createElement('div');
            popup.id = 'itemPickerPopup';
            popup.innerHTML = html;
            document.body.appendChild(popup);
        }

        function addItemCondition(itemId, itemName) {
            if (selectedQuestIndex < 0) return;
            const quest = quests[selectedQuestIndex];
            if (!quest.conditions) quest.conditions = [];

            quest.conditions.push({
                type: 'hasItem',
                targetUid: itemId,
                count: 1,
                displayName: itemName
            });

            broadcastEdit({ editType: 'updateQuest', questId: quest.id, quest: quest });
            closeItemPickerPopup();
            renderQuestConditions();
        }

        function handleMapClickForCondition(tileX, tileY) {
            if (!settingConditionMode || selectedQuestIndex < 0) return false;

            const quest = quests[selectedQuestIndex];
            if (!quest.conditions) quest.conditions = [];

            const typeMap = { 'kill': 'enemyDefeated', 'talk': 'talkedToNpc', 'visit': 'locationVisited' };
            const internalType = typeMap[settingConditionType];

            if (settingConditionType === 'visit') {
                // Location visit condition
                quest.conditions.push({
                    type: 'locationVisited',
                    mapName: currentMapName,
                    x: tileX,
                    y: tileY,
                    displayName: 'Visit (' + tileX + ',' + tileY + ') on ' + currentMapName
                });
            } else {
                // NPC-based condition - find NPC at click position
                const npcIndex = findPlacedNpcAt(tileX, tileY);
                if (npcIndex < 0) {
                    document.getElementById('conditionStatus').textContent = 'No NPC there! Click on an NPC...';
                    return true;
                }

                const placed = placedNpcs[npcIndex];
                const npcDef = npcs[placed.npcIndex];
                const isEnemy = placed.isEnemy || npcDef?.isEnemy;

                if (settingConditionType === 'kill' && !isEnemy) {
                    document.getElementById('conditionStatus').textContent = 'That NPC is not an enemy! Click on an enemy...';
                    return true;
                }

                // Ensure NPC has a UID
                if (!placed.uid) placed.uid = 'npc_' + npcIndex + '_' + Date.now();

                const npcName = npcDef?.name || 'NPC';
                quest.conditions.push({
                    type: internalType,
                    targetUid: placed.uid,
                    displayName: (settingConditionType === 'kill' ? 'Kill ' : 'Talk to ') + npcName + ' at (' + placed.x + ',' + placed.y + ')'
                });
            }

            broadcastEdit({ editType: 'updateQuest', questId: quest.id, quest: quest });
            cancelSettingCondition();
            renderQuestConditions();
            return true;
        }

        function findPlacedNpcAt(tileX, tileY) {
            for (let i = 0; i < placedNpcs.length; i++) {
                const placed = placedNpcs[i];
                if (placed.mapName && placed.mapName !== currentMapName) continue;
                if (placed.x === tileX && placed.y === tileY) return i;
            }
            return -1;
        }

        // ===== QUEST GIVER / TURN-IN NPC CLICK SELECTION =====
        let settingQuestGiverMode = false;
        let settingQuestTurnInMode = false;

        function toggleSetQuestGiver() {
            if (settingQuestGiverMode) {
                cancelSetQuestGiver();
                return;
            }
            // Cancel other modes
            if (settingConditionMode) cancelSettingCondition();
            if (settingQuestTurnInMode) cancelSetQuestTurnIn();

            settingQuestGiverMode = true;
            document.getElementById('setQuestGiverBtn').textContent = 'CANCEL';
            document.getElementById('setQuestGiverBtn').style.background = '#f44';
            document.getElementById('questGiverStatus').textContent = 'Click on an NPC on the map...';
            renderMap();
        }

        function cancelSetQuestGiver() {
            settingQuestGiverMode = false;
            document.getElementById('setQuestGiverBtn').textContent = 'CLICK NPC TO SET QUEST GIVER';
            document.getElementById('setQuestGiverBtn').style.background = 'linear-gradient(135deg, #fa0, #f80)';
            document.getElementById('questGiverStatus').textContent = '';
            renderMap();
        }

        function toggleSetQuestTurnIn() {
            if (settingQuestTurnInMode) {
                cancelSetQuestTurnIn();
                return;
            }
            // Cancel other modes
            if (settingConditionMode) cancelSettingCondition();
            if (settingQuestGiverMode) cancelSetQuestGiver();

            settingQuestTurnInMode = true;
            document.getElementById('setQuestTurnInBtn').textContent = 'CANCEL';
            document.getElementById('setQuestTurnInBtn').style.background = '#f44';
            document.getElementById('questTurnInStatus').textContent = 'Click on an NPC on the map...';
            renderMap();
        }

        function cancelSetQuestTurnIn() {
            settingQuestTurnInMode = false;
            document.getElementById('setQuestTurnInBtn').textContent = 'CLICK NPC TO SET TURN-IN';
            document.getElementById('setQuestTurnInBtn').style.background = 'linear-gradient(135deg, #4a4, #282)';
            document.getElementById('questTurnInStatus').textContent = '';
            renderMap();
        }

        function handleMapClickForQuestNpc(tileX, tileY) {
            if (!settingQuestGiverMode && !settingQuestTurnInMode) return false;
            if (selectedQuestIndex < 0) return false;

            const npcIndex = findPlacedNpcAt(tileX, tileY);
            if (npcIndex < 0) {
                const statusEl = settingQuestGiverMode ? 'questGiverStatus' : 'questTurnInStatus';
                document.getElementById(statusEl).textContent = 'No NPC there! Click on an NPC...';
                return true;
            }

            const placed = placedNpcs[npcIndex];
            const npcDef = npcs[placed.npcIndex];
            const npcName = npcDef?.name || 'NPC';

            // Ensure NPC has a UID
            if (!placed.uid) placed.uid = 'npc_' + npcIndex + '_' + Date.now();

            const quest = quests[selectedQuestIndex];

            if (settingQuestGiverMode) {
                quest.startNpcUid = placed.uid;
                quest._startNpcName = npcName + ' at (' + placed.x + ',' + placed.y + ')';
                document.getElementById('questGiverName').textContent = quest._startNpcName;
                broadcastEdit({ editType: 'updateQuest', questId: quest.id, quest: quest });
                cancelSetQuestGiver();
            } else if (settingQuestTurnInMode) {
                quest.turnInNpcUid = placed.uid;
                quest._turnInNpcName = npcName + ' at (' + placed.x + ',' + placed.y + ')';
                document.getElementById('questTurnInName').textContent = quest._turnInNpcName;
                broadcastEdit({ editType: 'updateQuest', questId: quest.id, quest: quest });
                cancelSetQuestTurnIn();
            }

            return true;
        }

        function updateQuestNpcDisplayNames() {
            const quest = quests[selectedQuestIndex];
            if (!quest) return;

            // Find and display quest giver name
            if (quest.startNpcUid) {
                const npcIndex = placedNpcs.findIndex(p => p.uid === quest.startNpcUid);
                if (npcIndex >= 0) {
                    const placed = placedNpcs[npcIndex];
                    const npcDef = npcs[placed.npcIndex];
                    document.getElementById('questGiverName').textContent = (npcDef?.name || 'NPC') + ' at (' + placed.x + ',' + placed.y + ')';
                } else {
                    document.getElementById('questGiverName').textContent = '(NPC not found)';
                }
            } else {
                document.getElementById('questGiverName').textContent = '(None)';
            }

            // Find and display turn-in name
            if (quest.turnInNpcUid) {
                const npcIndex = placedNpcs.findIndex(p => p.uid === quest.turnInNpcUid);
                if (npcIndex >= 0) {
                    const placed = placedNpcs[npcIndex];
                    const npcDef = npcs[placed.npcIndex];
                    document.getElementById('questTurnInName').textContent = (npcDef?.name || 'NPC') + ' at (' + placed.x + ',' + placed.y + ')';
                } else {
                    document.getElementById('questTurnInName').textContent = '(NPC not found)';
                }
            } else {
                document.getElementById('questTurnInName').textContent = '(Same as giver)';
            }
        }

        // ===== SAVE/LOAD =====
        async function saveProject() {
            // Count tiles in first layer for debugging
            let tileCount = 0;
            if (layers[0]) {
                for (let y = 0; y < layers[0].length; y++) {
                    if (layers[0][y]) {
                        for (let x = 0; x < layers[0][y].length; x++) {
                            if (layers[0][y][x]) tileCount++;
                        }
                    }
                }
            }
            console.log('Saving project with', layers.length, 'layers,', tileCount, 'tiles in first layer,', tilesets.length, 'tilesets,', props.length, 'props');

            // Save current prop's collision masks before saving
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Save all tilesets
            const tilesetsData = tilesets.map(ts => ({ name: ts.name, data: ts.data }));

            // Save all props
            const propsData = props.map(p => ({
                name: p.name,
                data: p.data,
                collisionMasks: p.collisionMasks || {}
            }));

            // Save all animated props
            const animPropsData = animatedProps.map(prop => ({
                name: prop.name,
                spriteData: prop.spriteData,
                frameWidth: prop.frameWidth,
                frameHeight: prop.frameHeight,
                frames: prop.frames,
                type: prop.type,
                fps: prop.fps,
                collisionMasks: prop.collisionMasks || null,
                splitLine: prop.splitLine || null,
                giveItem: prop.giveItem || false,
                giveItemIndex: prop.giveItemIndex ?? -1
            }));

            // Save sounds
            const soundsData = sounds.map(s => ({
                name: s.name,
                data: s.data,
                duration: s.duration,
                type: s.type
            }));
            console.log('=== SAVING SOUNDS ===');
            console.log('Sounds to save:', sounds.length);
            console.log('Tile sounds to save:', Object.keys(tileSounds).length, tileSounds);
            console.log('Player sounds to save:', playerSounds);

            const data = {
                gridSize, mapCols, mapRows,
                layers, layerVisibility, layerNames, currentLayer,
                tileCollisions, collisionMasks,
                tileSplitLines, // Depth split lines for Y-sorting
                tileSplitLineFlipped, // Flipped split lines (bottom covers player)
                tilesets: tilesetsData,
                currentTilesetIndex,
                // Keep for backwards compatibility
                tilesetData: tilesets[0]?.data,
                // Save multiple props
                props: propsData,
                currentPropIndex,
                // Keep old format for backwards compatibility
                propImageData: props[0]?.data || null,
                propCollisionMasks: props[0]?.collisionMasks || {},
                // Save animated props
                animatedProps: animPropsData,
                currentAnimPropIndex,
                placedAnimProps,
                // Save NPCs
                npcs: npcs.map(npc => ({
                    name: npc.name,
                    spriteData: npc.spriteData,
                    frameWidth: npc.frameWidth,
                    frameHeight: npc.frameHeight,
                    animations: npc.animations,
                    animMirrors: npc.animMirrors || {},
                    fps: npc.fps,
                    pingPong: npc.pingPong || false,
                    collisionInsets: npc.collisionInsets || null,
                    shadowOffsetX: npc.shadowOffsetX ?? 0,
                    shadowOffsetY: npc.shadowOffsetY ?? 4,
                    shadowWidth: npc.shadowWidth ?? 0.35,
                    shadowHeight: npc.shadowHeight ?? 0.12
                })),
                currentNpcIndex,
                placedNpcs,
                // Save static objects
                staticObjects: staticObjects.map(obj => ({
                    name: obj.name,
                    spriteData: obj.spriteData,
                    width: obj.width,
                    height: obj.height,
                    tilesetIndex: obj.tilesetIndex,
                    sourceTiles: obj.sourceTiles,
                    sourceOrigin: obj.sourceOrigin
                })),
                placedStaticObjects,
                // Save player layer settings
                playerLayerIndex,
                playerPreviewPos,
                spawnMapName,
                playerPreviewVisible,
                // Save sound data
                sounds: soundsData,
                tileSounds,
                playerSounds,
                // Save lighting data
                lightingSettings,
                pointLights,
                // Save player characters with all data
                playerCharacters: playerCharacters.map(c => ({
                    name: c.name,
                    spriteData: c.spriteData,
                    spriteSheets: c.spriteSheets || (c.spriteData ? [c.spriteData] : []),
                    frameWidth: c.frameWidth,
                    frameHeight: c.frameHeight,
                    animations: c.animations,
                    animMirrors: c.animMirrors || {},
                    hitboxMasks: c.hitboxMasks || {},
                    animFps: c.animFps || {},
                    fps: c.fps || 8,
                    pingPong: c.pingPong || false,
                    attackMovement: c.attackMovement || 'stop',
                    gameOverSoundIndex: c.gameOverSoundIndex !== undefined ? c.gameOverSoundIndex : -1
                })),
                activePlayerIndex,
                // Multi-map support
                maps,
                currentMapName,
                placedTriggers,
                // Dialogs
                dialogs
            };
            console.log('Saving playerPreviewPos:', playerPreviewPos, 'on map:', spawnMapName);
            try {
                // Try IndexedDB first (much larger storage)
                await saveProjectToDB(data);
                alert('Saved! Player spawn: (' + playerPreviewPos.x + ', ' + playerPreviewPos.y + ')');
            } catch (e) {
                console.warn('IndexedDB save failed, trying localStorage:', e);
                // Fallback to localStorage for older browsers
                try {
                    localStorage.setItem('worldBuilderProject', JSON.stringify(data));
                    console.log('Project saved to localStorage (fallback)');
                    alert('Saved! Player spawn: (' + playerPreviewPos.x + ', ' + playerPreviewPos.y + ')');
                } catch (e2) {
                    if (e2.name === 'QuotaExceededError') {
                        alert('Project too large to save! Use "Download" to save to a file.');
                    } else {
                        throw e2;
                    }
                }
            }
            return data; // Return for file download
        }

        function downloadProject() {
            // Get save data
            const data = getProjectData();
            const json = JSON.stringify(data, null, 2);

            // Create download
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'world-project-' + new Date().toISOString().slice(0,10) + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function getProjectData() {
            // Save current map state to maps object before saving
            saveCurrentMapState();

            // Save current prop's collision masks before saving
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Save all tilesets
            const tilesetsData = tilesets.map(ts => ({ name: ts.name, data: ts.data }));

            // Save all props
            const propsData = props.map(p => ({
                name: p.name,
                data: p.data,
                collisionMasks: p.collisionMasks || {}
            }));

            // Save all animated props
            const animPropsData = animatedProps.map(prop => ({
                name: prop.name,
                spriteData: prop.spriteData,
                frameWidth: prop.frameWidth,
                frameHeight: prop.frameHeight,
                frames: prop.frames,
                type: prop.type,
                fps: prop.fps,
                collisionMasks: prop.collisionMasks || null,
                splitLine: prop.splitLine || null,
                giveItem: prop.giveItem || false,
                giveItemIndex: prop.giveItemIndex ?? -1
            }));

            // Save sounds
            const soundsData = sounds.map(s => ({
                name: s.name,
                data: s.data,
                duration: s.duration,
                type: s.type
            }));
            console.log('getProjectData - sounds:', sounds.length, 'tileSounds:', Object.keys(tileSounds).length);

            // Debug: log all triggers being passed
            console.log('=== getProjectData TRIGGERS ===');
            placedTriggers.forEach((t, i) => {
                console.log('Trigger ' + i + ': Door ' + t.doorNumber + ' at (' + t.x + ',' + t.y + ') on "' + t.mapName + '" -> "' + t.targetMap + '" spawn (' + t.targetX + ',' + t.targetY + ')');
            });

            return {
                gridSize, mapCols, mapRows,
                layers, layerVisibility, layerNames, currentLayer,
                tileCollisions, collisionMasks,
                tileSplitLines, // Depth split lines for Y-sorting
                tileSplitLineFlipped, // Flipped split lines (bottom covers player)
                tilesets: tilesetsData,
                currentTilesetIndex,
                // Keep for backwards compatibility
                tilesetData: tilesets[0]?.data,
                // Save multiple props
                props: propsData,
                currentPropIndex,
                // Keep old format for backwards compatibility
                propImageData: props[0]?.data || null,
                propCollisionMasks: props[0]?.collisionMasks || {},
                // Save animated props
                animatedProps: animPropsData,
                currentAnimPropIndex,
                placedAnimProps,
                // Save NPCs
                npcs: npcs.map(npc => ({
                    name: npc.name,
                    spriteData: npc.spriteData,
                    frameWidth: npc.frameWidth,
                    frameHeight: npc.frameHeight,
                    animations: npc.animations,
                    animMirrors: npc.animMirrors || {},
                    fps: npc.fps,
                    pingPong: npc.pingPong || false,
                    collisionInsets: npc.collisionInsets || null,
                    shadowOffsetX: npc.shadowOffsetX ?? 0,
                    shadowOffsetY: npc.shadowOffsetY ?? 4,
                    shadowWidth: npc.shadowWidth ?? 0.35,
                    shadowHeight: npc.shadowHeight ?? 0.12
                })),
                currentNpcIndex,
                placedNpcs,
                // Save player layer settings
                playerLayerIndex,
                playerPreviewPos,
                spawnMapName,
                playerPreviewVisible,
                // Save sound data
                sounds: soundsData,
                tileSounds,
                playerSounds,
                // Save lighting data
                lightingSettings,
                pointLights,
                polyLights,
                // Save player sprite (legacy)
                playerSpriteData,
                // Player characters system
                playerCharacters: playerCharacters.map(c => ({
                    name: c.name,
                    spriteData: c.spriteData, // Legacy single sheet
                    spriteSheets: c.spriteSheets || (c.spriteData ? [c.spriteData] : []), // All sheets
                    frameWidth: c.frameWidth,
                    frameHeight: c.frameHeight,
                    animations: c.animations,
                    animMirrors: c.animMirrors || {},
                    hitboxMasks: c.hitboxMasks || {},
                    animFps: c.animFps || {},
                    fps: c.fps || 8,
                    pingPong: c.pingPong || false,
                    attackMovement: c.attackMovement || 'stop',
                    gameOverSoundIndex: c.gameOverSoundIndex !== undefined ? c.gameOverSoundIndex : -1
                })),
                activePlayerIndex,
                // Multi-map support
                maps,
                currentMapName,
                placedTriggers,
                // Dialogs
                dialogs,
                placedDialogTiles,
                // Items (interactive objects like chests)
                items: items.map(item => ({
                    id: item.id,
                    name: item.name,
                    spriteData: item.spriteData,
                    frameWidth: item.frameWidth,
                    frameHeight: item.frameHeight,
                    frames: item.frames,
                    fps: item.fps,
                    idleFrame: item.idleFrame
                })),
                placedItems,
                // Static objects (multi-tile props from tilesets)
                staticObjects: staticObjects.map(obj => ({
                    name: obj.name,
                    spriteData: obj.spriteData,
                    width: obj.width,
                    height: obj.height,
                    tilesetIndex: obj.tilesetIndex,
                    sourceTiles: obj.sourceTiles,
                    sourceOrigin: obj.sourceOrigin
                })),
                placedStaticObjects,
                // Quests
                quests
            };
        }

        function uploadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    // Save to IndexedDB so Test Map works
                    try {
                        await saveProjectToDB(data);
                        console.log('Uploaded project saved to IndexedDB');
                    } catch (dbErr) {
                        console.warn('IndexedDB save failed, trying localStorage:', dbErr);
                        try {
                            localStorage.setItem('worldBuilderProject', JSON.stringify(data));
                        } catch (storageErr) {
                            console.warn('localStorage also full, project loaded but not persisted');
                        }
                    }
                    // Load into editor
                    await loadProject(data);
                } catch (err) {
                    alert('Error loading file: ' + err.message);
                }
            };
            reader.readAsText(file);

            // Clear input so same file can be loaded again
            event.target.value = '';
        }

        // Load save and show mode selection
        let pendingSaveData = null;

        // Show save choice menu (demo vs own save)
        function showSaveChoice() {
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('saveChoice').style.display = 'block';
        }

        // Load save menu HTML
        const saveChoiceOriginalHTML = `
            <h1>LOAD<br>SAVE</h1>
            <p>- SELECT SOURCE -</p>
            <div style="margin-top:20px;">
                <button class="retro-btn" onclick="playButtonSound(); document.getElementById('projectFileInputWelcome').click(); document.getElementById('saveChoice').style.display='none'; document.getElementById('mainMenu').style.display='block';">
                    > YOUR SAVE
                </button>
            </div>
            <div style="margin-top:10px;">
                <button class="retro-btn" onclick="playButtonSound(); document.getElementById('saveChoice').style.display='none'; document.getElementById('mainMenu').style.display='block';" style="font-size:10px;">
                    > BACK
                </button>
            </div>
        `;
        async function loadDemo() {
            document.getElementById('saveChoice').innerHTML = '<h1>LOADING...</h1>';
            try {
                const response = await fetch('thenewdemo.json');
                const data = await response.json();
                pendingSaveData = data;
                await saveProjectToDB(pendingSaveData);
                document.getElementById('saveChoice').innerHTML = saveChoiceOriginalHTML;
                document.getElementById('saveChoice').style.display = 'none';
                document.getElementById('modeSelect').style.display = 'block';
            } catch (err) {
                alert('Error loading demo: ' + err.message);
                document.getElementById('saveChoice').innerHTML = saveChoiceOriginalHTML;
                document.getElementById('saveChoice').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'block';
            }
        }
        function loadSaveWithModeSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    pendingSaveData = JSON.parse(e.target.result);
                    await saveProjectToDB(pendingSaveData);
                    document.getElementById('mainMenu').style.display = 'none';
                    document.getElementById('modeSelect').style.display = 'block';
                } catch (err) {
                    alert('Error: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Multiplayer prompt functions
        function showMultiplayerPrompt() {
            document.getElementById('modeSelect').style.display = 'none';
            document.getElementById('multiplayerPrompt').style.display = 'block';
            document.getElementById('mpPlayerName').focus();
        }

        function hideMultiplayerPrompt() {
            document.getElementById('multiplayerPrompt').style.display = 'none';
            document.getElementById('modeSelect').style.display = 'block';
        }

        // Craft multiplayer prompt functions
        function showCraftMultiplayerPrompt() {
            document.getElementById('modeSelect').style.display = 'none';
            document.getElementById('craftMultiplayerPrompt').style.display = 'block';
            // Focus is handled in showHostPrompt/showJoinPrompt
        }

        function hideCraftMultiplayerPrompt() {
            document.getElementById('craftMultiplayerPrompt').style.display = 'none';
            document.getElementById('modeSelect').style.display = 'block';
        }

        // Simple builder start - shows co-op prompt
        function startBuilder() {
            if (!pendingSaveData) {
                console.log('[START] No save data, returning');
                return;
            }

            // Hide mode select, show co-op prompt
            document.getElementById('modeSelect').style.display = 'none';
            document.getElementById('craftMultiplayerPrompt').style.display = 'block';
            // Focus is handled in showHostPrompt/showJoinPrompt
        }

        // === BUILDER MULTIPLAYER SYSTEM ===
        let builderSocket = null;
        let builderConnected = false;
        let builderPlayerName = 'Builder';
        let builderRoomCode = null;
        let testGameWindow = null; // Reference to test game window for solo live sync

        // Track who's editing what modal (to prevent conflicts)
        // Format: { 'npc:0': { username: 'Player1', socketId: 'abc123' }, 'item:2': {...} }
        let currentlyEditing = {};
        let myEditingKey = null; // What am I currently editing?

        // Check if something is being edited by someone else
        function isBeingEdited(type, index) {
            const key = type + ':' + index;
            return currentlyEditing[key] && currentlyEditing[key].username !== builderPlayerName;
        }

        // Get who is editing something
        function getEditor(type, index) {
            const key = type + ':' + index;
            return currentlyEditing[key] ? currentlyEditing[key].username : null;
        }

        // Start editing something
        function startEditing(type, index) {
            const key = type + ':' + index;
            myEditingKey = key;
            currentlyEditing[key] = { username: builderPlayerName };
            broadcastEdit({ editType: 'startEditing', editorType: type, editorIndex: index, username: builderPlayerName });
        }

        // Stop editing something
        function stopEditing() {
            if (myEditingKey) {
                const [type, index] = myEditingKey.split(':');
                delete currentlyEditing[myEditingKey];
                broadcastEdit({ editType: 'stopEditing', editorType: type, editorIndex: parseInt(index) });
                myEditingKey = null;
            }
        }

        // Clear all edits by a disconnected player
        function clearPlayerEdits(username) {
            for (const key in currentlyEditing) {
                if (currentlyEditing[key].username === username) {
                    delete currentlyEditing[key];
                }
            }
        }

        // Track game players visible in builder
        let gamePlayersInBuilder = new Map(); // id -> {x, y, name, direction, currentMap, animation, frame, lastFrameTime}
        let gamePlayerAnimInterval = null; // Animation loop for game players in builder
        let builderGameSocket = null; // socket to game server to see testers

        // Track builder co-op players in the room
        let builderPlayersInRoom = new Map(); // id -> {name, joinedAt}

        function connectBuilderMultiplayer(name, roomCode) {
            console.log('[BUILDER MP DEBUG] connectBuilderMultiplayer called with name:', name, 'roomCode:', roomCode);

            if (!roomCode) {
                console.log('[BUILDER MP DEBUG] No room code, solo mode');
                return; // Solo mode
            }

            builderPlayerName = name;
            builderRoomCode = roomCode;
            const wsUrl = 'wss://multiplayer.lakotafox.partykit.dev/parties/builder/' + roomCode;
            console.log('[BUILDER MP DEBUG] Connecting to:', wsUrl);

            try {
                builderSocket = new WebSocket(wsUrl);
                console.log('[BUILDER MP DEBUG] WebSocket created, waiting for open...');

                builderSocket.onopen = () => {
                    console.log('[BUILDER MP DEBUG] WebSocket OPEN!');
                    builderConnected = true;
                    const joinMsg = {
                        type: 'join',
                        name: builderPlayerName,
                        gameType: 'builder'
                    };
                    console.log('[BUILDER MP DEBUG] Sending join message:', joinMsg);
                    builderSocket.send(JSON.stringify(joinMsg));
                    showBuilderStatus('Connected: ' + roomCode);
                    console.log('[BUILDER MP DEBUG] builderConnected is now:', builderConnected);
                };

                builderSocket.onmessage = (event) => {
                    console.log('[BUILDER MP DEBUG] Raw message received:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        handleBuilderMessage(data);
                    } catch (e) {
                        console.error('[BUILDER MP DEBUG] Parse error:', e);
                    }
                };

                builderSocket.onclose = (event) => {
                    console.log('[BUILDER MP DEBUG] WebSocket CLOSED, code:', event.code, 'reason:', event.reason);
                    builderConnected = false;
                    showBuilderStatus('Disconnected');
                    // Also close game socket and clear players
                    if (builderGameSocket) {
                        builderGameSocket.close();
                        builderGameSocket = null;
                    }
                    gamePlayersInBuilder.clear();
                    renderMap();
                };

                builderSocket.onerror = (err) => {
                    console.error('[BUILDER MP DEBUG] WebSocket ERROR:', err);
                };
            } catch (e) {
                console.error('[BUILDER MP DEBUG] Connect failed:', e);
            }

            // Also connect to game server to see players testing the game
            connectToGameServerForBuilder(roomCode);
        }

        function connectToGameServerForBuilder(roomCode) {
            const gameWsUrl = 'wss://multiplayer.lakotafox.partykit.dev/party/' + roomCode;
            console.log('[BUILDER GAME] Connecting to game server:', gameWsUrl);
            builderGameSocket = new WebSocket(gameWsUrl);

            builderGameSocket.onopen = () => {
                console.log('[BUILDER GAME] Connected to game server!');
            };

            builderGameSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'welcome' && data.players) {
                        data.players.forEach(p => {
                            if (p.gameType === 'game2d') {
                                p.frame = 0;
                                p.lastFrameTime = Date.now();
                                gamePlayersInBuilder.set(p.id, p);
                            }
                        });
                        startGamePlayerAnimLoop();
                        renderMap();
                    } else if (data.type === 'join' && data.player && data.player.gameType === 'game2d') {
                        console.log('[BUILDER] Game player joined:', data.player.name);
                        data.player.frame = 0;
                        data.player.lastFrameTime = Date.now();
                        gamePlayersInBuilder.set(data.player.id, data.player);
                        startGamePlayerAnimLoop();
                        renderMap();
                    } else if (data.type === 'update' && data.player && data.player.gameType === 'game2d') {
                        const existing = gamePlayersInBuilder.get(data.player.id);
                        data.player.frame = existing ? existing.frame : 0;
                        data.player.lastFrameTime = existing ? existing.lastFrameTime : Date.now();
                        gamePlayersInBuilder.set(data.player.id, data.player);
                    } else if (data.type === 'leave' && data.playerId) {
                        console.log('[BUILDER] Game player left');
                        gamePlayersInBuilder.delete(data.playerId);
                        if (gamePlayersInBuilder.size === 0) stopGamePlayerAnimLoop();
                        renderMap();
                    }
                } catch (e) {}
            };

            builderGameSocket.onclose = () => {
                console.log('[BUILDER GAME] Disconnected from game server');
                gamePlayersInBuilder.clear();
                stopGamePlayerAnimLoop();
            };
        }

        // Animation loop for game players shown in builder
        function startGamePlayerAnimLoop() {
            if (gamePlayerAnimInterval) return; // Already running
            gamePlayerAnimInterval = setInterval(() => {
                if (gamePlayersInBuilder.size === 0) {
                    stopGamePlayerAnimLoop();
                    return;
                }
                const now = Date.now();
                let needsRender = false;
                gamePlayersInBuilder.forEach(p => {
                    // Advance frame every 150ms for walking players
                    if (p.animation === 'walk' && now - p.lastFrameTime > 150) {
                        p.frame = (p.frame + 1) % 4;
                        p.lastFrameTime = now;
                        needsRender = true;
                    } else if (p.animation !== 'walk') {
                        // Reset to idle frame
                        if (p.frame !== 0) needsRender = true;
                        p.frame = 0;
                    }
                });
                if (needsRender) renderMap();
            }, 100);
        }

        function stopGamePlayerAnimLoop() {
            if (gamePlayerAnimInterval) {
                clearInterval(gamePlayerAnimInterval);
                gamePlayerAnimInterval = null;
            }
        }

        function handleBuilderMessage(data) {
            console.log('[BUILDER MP DEBUG] handleBuilderMessage received:', data);
            console.log('[BUILDER MP DEBUG] data.type:', data.type);

            // Track players joining/leaving for room info
            if (data.type === 'welcome') {
                // Initial player list when we join
                if (data.players) {
                    builderPlayersInRoom.clear();
                    data.players.forEach(p => {
                        builderPlayersInRoom.set(p.id, { name: p.name, joinedAt: Date.now() });
                    });
                    console.log('[BUILDER MP] Players in room:', builderPlayersInRoom.size);
                }
                return;
            }

            if (data.type === 'join') {
                if (data.player) {
                    builderPlayersInRoom.set(data.player.id, { name: data.player.name, joinedAt: Date.now() });
                    console.log('[BUILDER MP] Player joined:', data.player.name, '- Total:', builderPlayersInRoom.size);
                }
                return;
            }

            if (data.type === 'leave') {
                if (data.playerId) {
                    // Clear any editing locks held by this player
                    const leavingPlayer = builderPlayersInRoom.get(data.playerId);
                    if (leavingPlayer && leavingPlayer.name) {
                        clearPlayerEdits(leavingPlayer.name);
                    }
                    builderPlayersInRoom.delete(data.playerId);
                    console.log('[BUILDER MP] Player left - Remaining:', builderPlayersInRoom.size);
                }
                return;
            }

            // Handle edit messages from other builders
            if (data.type === 'builderEdit' && data.editType) {
                console.log('[BUILDER MP DEBUG] >>> APPLYING REMOTE EDIT <<<', data.editType);
                applyRemoteEdit(data);
            }
        }

        function sendFullProject() {
            if (!builderSocket || !builderConnected) return;

            // Save current map state first
            saveCurrentMapState();

            // Create serializable project data (exclude non-serializable stuff like images)
            const projectData = {
                maps: {},
                placedTriggers: placedTriggers,
                placedNpcs: placedNpcs,
                staticObjects: staticObjects.map(obj => ({
                    name: obj.name,
                    spriteData: obj.spriteData,
                    width: obj.width,
                    height: obj.height,
                    tilesetIndex: obj.tilesetIndex,
                    sourceTiles: obj.sourceTiles,
                    sourceOrigin: obj.sourceOrigin
                })),
                placedStaticObjects: placedStaticObjects,
                tileSounds: tileSounds,
                pointLights: pointLights,
                polyLights: polyLights,
                tileCollisions: tileCollisions,
                collisionMasks: collisionMasks,
                tileSplitLines: tileSplitLines,
                tileSplitLineFlipped: tileSplitLineFlipped,
                animatedProps: animatedProps.map(p => {
                    const copy = { ...p };
                    delete copy._spriteImg; // Not serializable
                    return copy;
                }),
                // Tilesets (with base64 data for image reload)
                tilesets: tilesets.map(t => {
                    let data = t.data;
                    // If no data but we have an image, extract base64 from it
                    if (!data && t.img) {
                        try {
                            const canvas = document.createElement('canvas');
                            canvas.width = t.img.width;
                            canvas.height = t.img.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(t.img, 0, 0);
                            data = canvas.toDataURL('image/png');
                            t.data = data; // Cache it for future
                        } catch (e) {
                            console.error('[BUILDER MP] Failed to extract tileset data:', e);
                        }
                    }
                    return { name: t.name, data: data };
                }),
                // NPC definitions (with spriteData for image reload)
                npcs: npcs.map(n => {
                    const copy = { ...n };
                    delete copy._spriteImg; // Not serializable
                    return copy;
                }),
                currentTilesetIndex: currentTilesetIndex,
                currentMapName: currentMapName,
                playerPreviewPos: playerPreviewPos,
                spawnMapName: spawnMapName,
                // Dialogs
                dialogs: dialogs,
                // Player characters
                playerCharacters: playerCharacters.map(c => {
                    const copy = { ...c };
                    delete copy._spriteImg;
                    return copy;
                }),
                activePlayerIndex: activePlayerIndex
            };

            // Copy all maps (without image references)
            for (const mapName in maps) {
                // Note: collision data is global (per-tileset), saved at top level, not per-map
                projectData.maps[mapName] = {
                    layers: maps[mapName].layers,
                    layerVisibility: maps[mapName].layerVisibility,
                    layerNames: maps[mapName].layerNames,
                    currentLayer: maps[mapName].currentLayer,
                    mapCols: maps[mapName].mapCols,
                    mapRows: maps[mapName].mapRows,
                    cameraBounds: maps[mapName].cameraBounds
                };
            }

            console.log('[BUILDER MP] Sending full project:');
            console.log('[BUILDER MP] - Maps:', Object.keys(projectData.maps).length);
            console.log('[BUILDER MP] - Tilesets:', projectData.tilesets.length);
            console.log('[BUILDER MP] - NPCs:', projectData.npcs.length);
            console.log('[BUILDER MP] - Triggers:', projectData.placedTriggers.length);

            // Send tilesets separately in chunks (base64 images are huge)
            const tilesetsToSend = projectData.tilesets;
            projectData.tilesets = []; // Send empty, will send separately

            // Send main project first (without tileset data)
            // Wrap as builderEdit so server broadcasts it
            const mainMsg = JSON.stringify({
                type: 'builderEdit',
                editType: 'fullProject',
                project: projectData
            });
            console.log('[BUILDER MP] Main project size:', (mainMsg.length / 1024).toFixed(1), 'KB');
            builderSocket.send(mainMsg);

            // Send each tileset as a separate message
            tilesetsToSend.forEach((ts, i) => {
                setTimeout(() => {
                    if (!builderSocket || !builderConnected) return;
                    const tsMsg = JSON.stringify({
                        type: 'builderEdit',
                        editType: 'tilesetSync',
                        index: i,
                        name: ts.name,
                        data: ts.data
                    });
                    console.log('[BUILDER MP] Sending tileset', i, ts.name, (tsMsg.length / 1024).toFixed(1), 'KB');
                    try {
                        builderSocket.send(tsMsg);
                    } catch (e) {
                        console.error('[BUILDER MP] Failed to send tileset:', e);
                    }
                }, 100 * (i + 1)); // Stagger sends to avoid overwhelming
            });

            console.log('[BUILDER MP] Full project queued!');
        }

        function loadFullProject(project) {
            console.log('[BUILDER MP] Loading full project with maps:', Object.keys(project.maps));

            // Load maps
            for (const mapName in project.maps) {
                maps[mapName] = project.maps[mapName];
            }

            // Load triggers, NPCs, sounds, lights
            placedTriggers = project.placedTriggers || [];
            placedNpcs = project.placedNpcs || [];
            // Ensure all placed NPCs have UIDs (for backwards compatibility)
            placedNpcs.forEach((npc, i) => {
                if (!npc.uid) {
                    npc.uid = 'npc_' + npc.npcIndex + '_' + i + '_' + Date.now();
                }
            });

            // Load static objects from multiplayer sync
            staticObjects = [];
            placedStaticObjects = project.placedStaticObjects || [];
            if (project.staticObjects && project.staticObjects.length > 0) {
                project.staticObjects.forEach((objData, i) => {
                    staticObjects[i] = {
                        ...objData,
                        _spriteImg: new Image()
                    };
                    staticObjects[i]._spriteImg.src = objData.spriteData;
                });
            }
            updateStaticObjectsList();

            tileSounds = project.tileSounds || {};
            pointLights = project.pointLights || {};
            polyLights = project.polyLights || [];
            tileCollisions = project.tileCollisions || {};
            collisionMasks = project.collisionMasks || {};
            tileSplitLines = project.tileSplitLines || {};
            tileSplitLineFlipped = project.tileSplitLineFlipped || {};

            // Load animated props (need to reload images)
            animatedProps = project.animatedProps || [];
            animatedProps.forEach((prop, i) => {
                if (prop.spriteData) {
                    const img = new Image();
                    img.onload = () => {
                        animatedProps[i]._spriteImg = img;
                        updateAnimPropListDisplay();
                    };
                    img.src = prop.spriteData;
                }
            });

            // Load tilesets (need to reload images from base64)
            console.log('[BUILDER MP] Loading tilesets:', project.tilesets ? project.tilesets.length : 0);
            if (project.tilesets && project.tilesets.length > 0) {
                tilesets = [];
                project.tilesets.forEach((ts, i) => {
                    console.log('[BUILDER MP] Tileset', i, ts.name, 'data length:', ts.data ? ts.data.length : 'NO DATA');
                    if (!ts.data) {
                        console.error('[BUILDER MP] Tileset', ts.name, 'has no data!');
                        return;
                    }
                    const img = new Image();
                    img.onload = () => {
                        console.log('[BUILDER MP] Tileset loaded:', ts.name, img.width, 'x', img.height);
                        tilesets[i] = { name: ts.name, img: img, data: ts.data };
                        // Update tilesetImg if this is the current tileset
                        if (i === (project.currentTilesetIndex || 0)) {
                            tilesetImg = img;
                            currentTilesetIndex = i;
                        }
                        updateTilesetDropdown();
                        renderTilesetPanel();
                        renderMap();
                    };
                    img.onerror = (e) => {
                        console.error('[BUILDER MP] Failed to load tileset image:', ts.name, e);
                    };
                    img.src = ts.data;
                });
            } else {
                console.warn('[BUILDER MP] No tilesets in project!');
            }

            // Load NPC definitions (need to reload images from spriteData)
            if (project.npcs && project.npcs.length > 0) {
                npcs = [];
                project.npcs.forEach((npc, i) => {
                    npcs[i] = { ...npc };
                    if (npc.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            npcs[i]._spriteImg = img;
                            updateNpcList();
                        };
                        img.src = npc.spriteData;
                    }
                });
            }

            // Load dialogs
            if (project.dialogs) {
                dialogs = project.dialogs;
            }

            // Load player characters
            if (project.playerCharacters && project.playerCharacters.length > 0) {
                playerCharacters = [];
                project.playerCharacters.forEach((char, i) => {
                    playerCharacters[i] = { ...char };
                    if (char.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            playerCharacters[i]._spriteImg = img;
                            updatePlayerList();
                        };
                        img.src = char.spriteData;
                    }
                });
                activePlayerIndex = project.activePlayerIndex !== undefined ? project.activePlayerIndex : 0;
            }

            // Load spawn
            if (project.playerPreviewPos) {
                playerPreviewPos = project.playerPreviewPos;
            }
            spawnMapName = project.spawnMapName || spawnMapName;

            // Switch to the current map
            if (project.currentMapName && maps[project.currentMapName]) {
                currentMapName = project.currentMapName;
                loadMapState(maps[currentMapName]);
            }

            // Update all UI
            updateMapDropdowns();
            updateTriggerList();
            updatePlacedNpcList();
            updatePlacedSoundsList();
            updatePlacedLightsList();
            updatePolyLightsList();
            updateAnimPropListDisplay();
            updateDialogList();
            updatePlayerList();
            renderLayerList();
            renderMap();

            console.log('[BUILDER MP] Full project loaded successfully!');
            showBuilderStatus('Synced: ' + builderRoomCode);
        }

        function applyRemoteEdit(edit) {
            console.log('[BUILDER MP] Applying remote edit:', edit.editType);

            // Get the target map's layers
            let targetLayers;
            if (edit.mapName && edit.mapName !== currentMapName && maps[edit.mapName]) {
                // Edit is for a different map
                targetLayers = maps[edit.mapName].layers;
            } else {
                // Edit is for current map
                targetLayers = layers;
            }

            switch (edit.editType) {
                case 'batch':
                    // Apply batch of edits
                    let needsRender = false;
                    for (const e of edit.edits) {
                        // Apply each edit without rendering
                        applyRemoteEditNoRender(e);
                        if (!e.mapName || e.mapName === currentMapName) needsRender = true;
                    }
                    if (needsRender) renderMap();
                    break;

                case 'tile':
                    // Apply tile placement
                    if (!targetLayers[edit.layer]) targetLayers[edit.layer] = [];
                    if (!targetLayers[edit.layer][edit.y]) targetLayers[edit.layer][edit.y] = [];
                    targetLayers[edit.layer][edit.y][edit.x] = edit.cell;
                    if (!edit.mapName || edit.mapName === currentMapName) {
                        renderMap();
                    }
                    break;

                case 'eraseTile':
                    // Apply tile erasure
                    if (targetLayers[edit.layer] && targetLayers[edit.layer][edit.y]) {
                        targetLayers[edit.layer][edit.y][edit.x] = null;
                    }
                    if (!edit.mapName || edit.mapName === currentMapName) {
                        renderMap();
                    }
                    break;

                case 'tileSound':
                    // Apply tile sound placement
                    tileSounds[edit.key] = edit.sound;
                    updatePlacedSoundsList();
                    renderMap();
                    break;

                case 'removeTileSound':
                    // Remove tile sound
                    delete tileSounds[edit.key];
                    updatePlacedSoundsList();
                    renderMap();
                    break;

                case 'light':
                    // Apply light placement
                    pointLights[edit.key] = edit.light;
                    updatePlacedLightsList();
                    renderMap();
                    break;

                case 'removeLight':
                    // Remove light
                    delete pointLights[edit.key];
                    updatePlacedLightsList();
                    renderMap();
                    break;

                case 'addPolyLight':
                    // Add polygon light
                    polyLights.push(edit.light);
                    updatePolyLightsList();
                    renderMap();
                    break;

                case 'removePolyLight':
                    // Remove polygon light by ID
                    const polyIdx = polyLights.findIndex(pl => pl.id === edit.lightId);
                    if (polyIdx >= 0) {
                        polyLights.splice(polyIdx, 1);
                        updatePolyLightsList();
                        renderMap();
                    }
                    break;

                case 'placeNpc':
                    // Add NPC
                    placedNpcs.push(edit.npc);
                    updatePlacedNpcList();
                    renderMap();
                    break;

                case 'removeNpc':
                    // Remove NPC by index
                    if (edit.index >= 0 && edit.index < placedNpcs.length) {
                        placedNpcs.splice(edit.index, 1);
                        updatePlacedNpcList();
                        renderMap();
                    }
                    break;

                case 'placeTrigger':
                    // Add trigger
                    placedTriggers.push(edit.trigger);
                    updateTriggerList();
                    renderMap();
                    break;

                case 'removeTrigger':
                    // Remove trigger by index
                    if (edit.index >= 0 && edit.index < placedTriggers.length) {
                        placedTriggers.splice(edit.index, 1);
                        updateTriggerList();
                        renderMap();
                    }
                    break;

                case 'updateTrigger':
                    // Update existing trigger (spawn point, etc.)
                    if (edit.index >= 0 && edit.index < placedTriggers.length) {
                        placedTriggers[edit.index] = edit.trigger;
                        updateTriggerList();
                        renderMap();
                        console.log('[BUILDER MP] Remote trigger updated:', edit.index);
                    }
                    break;

                case 'placeItem':
                    // Add item
                    placedItems.push(edit.item);
                    updatePlacedItemsList();
                    renderMap();
                    console.log('[BUILDER MP] Remote item placed');
                    break;

                case 'removeItem':
                    // Remove item by position
                    const itemIdx = placedItems.findIndex(p =>
                        p.x === edit.x && p.y === edit.y &&
                        (!p.mapName || p.mapName === edit.mapName)
                    );
                    if (itemIdx >= 0) {
                        placedItems.splice(itemIdx, 1);
                        updatePlacedItemsList();
                        renderMap();
                        console.log('[BUILDER MP] Remote item removed');
                    }
                    break;

                case 'updatePlacedAnimProp':
                    // Update placed anim prop (e.g., instance item override)
                    if (edit.index >= 0 && edit.index < placedAnimProps.length) {
                        placedAnimProps[edit.index] = edit.prop;
                        renderMap();
                        console.log('[BUILDER MP] Remote placed anim prop updated:', edit.index);
                    }
                    break;

                case 'collision':
                    // Apply collision change
                    if (edit.value) {
                        tileCollisions[edit.key] = true;
                    } else {
                        delete tileCollisions[edit.key];
                    }
                    break;

                case 'collisionMask':
                    // Apply collision mask
                    collisionMasks[edit.key] = edit.mask;
                    break;

                case 'addLayer':
                    // Add new layer (from another builder)
                    if (edit.mapName === currentMapName) {
                        addLayer(true); // true = from network, don't rebroadcast
                    } else if (maps[edit.mapName]) {
                        maps[edit.mapName].layers.push(createEmptyLayer());
                    }
                    break;

                case 'addMap':
                    // Another builder created a new map
                    if (!maps[edit.mapName]) {
                        createMapData(edit.mapName);
                        updateMapDropdowns();
                        console.log('[BUILDER MP] Remote map created:', edit.mapName);
                    }
                    break;

                case 'deleteMap':
                    // Another builder deleted a map
                    if (maps[edit.mapName]) {
                        deleteMap(edit.mapName);
                        updateMapDropdowns();
                        updateTriggerList();
                        renderMap();
                        console.log('[BUILDER MP] Remote map deleted:', edit.mapName);
                    }
                    break;

                case 'clearMap':
                    // Another builder cleared a map
                    if (edit.mapName === currentMapName) {
                        initMap();
                        mapInitialized = true;
                        renderMap();
                    } else if (maps[edit.mapName]) {
                        // Clear the other map's data
                        maps[edit.mapName].layers = [createEmptyLayer()];
                        maps[edit.mapName].tileCollisions = {};
                        maps[edit.mapName].collisionMasks = {};
                    }
                    console.log('[BUILDER MP] Remote map cleared:', edit.mapName);
                    break;

                case 'addAnimProp':
                    // Another builder added an animated prop
                    animatedProps.push(edit.prop);
                    // Load the sprite image
                    if (edit.prop.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            animatedProps[animatedProps.length - 1]._spriteImg = img;
                            updateAnimPropListDisplay();
                            renderMap();
                        };
                        img.src = edit.prop.spriteData;
                    }
                    updateAnimPropListDisplay();
                    console.log('[BUILDER MP] Remote anim prop added:', edit.prop.name);
                    break;

                case 'removeAnimProp':
                    // Another builder removed an animated prop
                    if (edit.index >= 0 && edit.index < animatedProps.length) {
                        animatedProps.splice(edit.index, 1);
                        placedAnimProps = placedAnimProps.filter(p => p.propIndex !== edit.index);
                        placedAnimProps.forEach(p => { if (p.propIndex > edit.index) p.propIndex--; });
                        updateAnimPropListDisplay();
                        renderMap();
                        console.log('[BUILDER MP] Remote anim prop removed:', edit.index);
                    }
                    break;

                case 'addStaticObj':
                    // Another builder created a static object
                    const newStaticObj = {
                        name: edit.obj.name,
                        spriteData: edit.obj.spriteData,
                        width: edit.obj.width,
                        height: edit.obj.height,
                        tilesetIndex: edit.obj.tilesetIndex,
                        sourceTiles: edit.obj.sourceTiles,
                        sourceOrigin: edit.obj.sourceOrigin,
                        _spriteImg: new Image()
                    };
                    newStaticObj._spriteImg.onload = () => {
                        updateStaticObjectsList();
                        renderMap();
                    };
                    newStaticObj._spriteImg.src = edit.obj.spriteData;
                    staticObjects.push(newStaticObj);
                    updateStaticObjectsList();
                    console.log('[BUILDER MP] Remote static object added:', edit.obj.name);
                    break;

                case 'removeStaticObj':
                    // Another builder removed a static object definition
                    if (edit.index >= 0 && edit.index < staticObjects.length) {
                        placedStaticObjects = placedStaticObjects.filter(p => p.objIndex !== edit.index);
                        placedStaticObjects.forEach(p => {
                            if (p.objIndex > edit.index) p.objIndex--;
                        });
                        staticObjects.splice(edit.index, 1);
                        if (currentStaticObjIndex >= staticObjects.length) {
                            currentStaticObjIndex = staticObjects.length - 1;
                        }
                        updateStaticObjectsList();
                        renderMap();
                        console.log('[BUILDER MP] Remote static object removed:', edit.index);
                    }
                    break;

                case 'placeStaticObj':
                    // Another builder placed a static object
                    if (edit.placed) {
                        placedStaticObjects.push(edit.placed);
                        renderMap();
                        console.log('[BUILDER MP] Remote static object placed at', edit.placed.x, edit.placed.y);
                    }
                    break;

                case 'removeStaticObjPlacement':
                    // Another builder removed a placed static object
                    placedStaticObjects = placedStaticObjects.filter(p =>
                        !(p.x === edit.x && p.y === edit.y && p.mapName === edit.mapName)
                    );
                    renderMap();
                    console.log('[BUILDER MP] Remote static object placement removed');
                    break;

                case 'updateAnimProp':
                    // Another builder updated an animated prop
                    if (edit.index >= 0 && edit.index < animatedProps.length) {
                        animatedProps[edit.index] = edit.prop;
                        // Load the sprite image
                        if (edit.prop.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                animatedProps[edit.index]._spriteImg = img;
                                updateAnimPropListDisplay();
                                renderMap();
                            };
                            img.src = edit.prop.spriteData;
                        }
                        updateAnimPropListDisplay();
                        console.log('[BUILDER MP] Remote anim prop updated:', edit.index);
                    }
                    break;

                case 'addTileset':
                    // Another builder added a tileset
                    if (edit.name && edit.data) {
                        const img = new Image();
                        img.onload = () => {
                            tilesets.push({ name: edit.name, img: img, data: edit.data });
                            updateTilesetDropdown();
                            renderMap();
                            console.log('[BUILDER MP] Remote tileset added:', edit.name);
                        };
                        img.src = edit.data;
                    }
                    break;

                case 'addNpc':
                    // Another builder added an NPC definition
                    if (edit.npc) {
                        npcs.push({ ...edit.npc });
                        const idx = npcs.length - 1;
                        if (edit.npc.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                npcs[idx]._spriteImg = img;
                                updateNpcList();
                            };
                            img.src = edit.npc.spriteData;
                        }
                        updateNpcList();
                        console.log('[BUILDER MP] Remote NPC added:', edit.npc.name);
                    }
                    break;

                case 'updateNpc':
                    // Another builder updated an NPC definition
                    if (edit.index >= 0 && edit.index < npcs.length && edit.npc) {
                        npcs[edit.index] = { ...edit.npc };
                        if (edit.npc.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                npcs[edit.index]._spriteImg = img;
                                updateNpcList();
                            };
                            img.src = edit.npc.spriteData;
                        }
                        updateNpcList();
                        console.log('[BUILDER MP] Remote NPC updated:', edit.npc.name);
                    }
                    break;

                case 'updatePlacedNpc':
                    // Another builder updated a placed NPC (enemy settings, path, speed, etc.)
                    if (edit.index >= 0 && edit.index < placedNpcs.length && edit.npc) {
                        placedNpcs[edit.index] = edit.npc;
                        // Refresh UI if this NPC is currently selected
                        if (selectedPlacedNpcIndex === edit.index) {
                            selectPlacedNpc(edit.index);
                        }
                        updatePlacedNpcList();
                        renderMap();
                        console.log('[BUILDER MP] Remote placed NPC updated at index:', edit.index);
                    }
                    break;

                case 'addDialog':
                    // Another builder added a dialog
                    if (edit.dialog) {
                        dialogs.push(edit.dialog);
                        updateDialogList();
                        console.log('[BUILDER MP] Remote dialog added:', edit.dialog.name);
                    }
                    break;

                case 'updateDialog':
                    // Another builder updated a dialog
                    if (edit.index >= 0 && edit.index < dialogs.length && edit.dialog) {
                        dialogs[edit.index] = edit.dialog;
                        updateDialogList();
                        console.log('[BUILDER MP] Remote dialog updated:', edit.dialog.name);
                    }
                    break;

                case 'deleteDialog':
                    // Another builder deleted a dialog
                    if (edit.index >= 0 && edit.index < dialogs.length) {
                        dialogs.splice(edit.index, 1);
                        placedNpcs.forEach(n => {
                            if (n.dialogIndex === edit.index) n.dialogIndex = -1;
                            else if (n.dialogIndex > edit.index) n.dialogIndex--;
                        });
                        updateDialogList();
                        console.log('[BUILDER MP] Remote dialog deleted:', edit.index);
                    }
                    break;

                case 'attachNpcDialog':
                    // Another builder attached a dialog to an NPC
                    if (edit.npcIndex >= 0 && edit.npcIndex < placedNpcs.length) {
                        placedNpcs[edit.npcIndex].dialogIndex = edit.dialogIndex;
                        if (edit.dialogTrigger) {
                            placedNpcs[edit.npcIndex].dialogTrigger = edit.dialogTrigger;
                        } else if (edit.dialogIndex < 0) {
                            delete placedNpcs[edit.npcIndex].dialogTrigger;
                        }
                        updateDialogNpcDropdown();
                        console.log('[BUILDER MP] Remote NPC dialog attached:', edit.npcIndex, '->', edit.dialogIndex);
                    }
                    break;

                case 'deleteLayer':
                    // Another builder deleted a layer
                    if (edit.mapName === currentMapName) {
                        deleteLayer(edit.index, true);
                    } else if (maps[edit.mapName]) {
                        maps[edit.mapName].layers.splice(edit.index, 1);
                        maps[edit.mapName].layerVisibility.splice(edit.index, 1);
                        maps[edit.mapName].layerNames.splice(edit.index, 1);
                    }
                    console.log('[BUILDER MP] Remote layer deleted:', edit.index);
                    break;

                case 'moveLayerUp':
                    // Another builder moved a layer up
                    if (edit.mapName === currentMapName) {
                        moveLayerUp(edit.index, true);
                    } else if (maps[edit.mapName] && edit.index > 0) {
                        const m = maps[edit.mapName];
                        [m.layers[edit.index], m.layers[edit.index-1]] = [m.layers[edit.index-1], m.layers[edit.index]];
                        [m.layerVisibility[edit.index], m.layerVisibility[edit.index-1]] = [m.layerVisibility[edit.index-1], m.layerVisibility[edit.index]];
                        [m.layerNames[edit.index], m.layerNames[edit.index-1]] = [m.layerNames[edit.index-1], m.layerNames[edit.index]];
                    }
                    break;

                case 'moveLayerDown':
                    // Another builder moved a layer down
                    if (edit.mapName === currentMapName) {
                        moveLayerDown(edit.index, true);
                    } else if (maps[edit.mapName] && edit.index < maps[edit.mapName].layers.length - 1) {
                        const m = maps[edit.mapName];
                        [m.layers[edit.index], m.layers[edit.index+1]] = [m.layers[edit.index+1], m.layers[edit.index]];
                        [m.layerVisibility[edit.index], m.layerVisibility[edit.index+1]] = [m.layerVisibility[edit.index+1], m.layerVisibility[edit.index]];
                        [m.layerNames[edit.index], m.layerNames[edit.index+1]] = [m.layerNames[edit.index+1], m.layerNames[edit.index]];
                    }
                    break;

                case 'renameLayer':
                    // Another builder renamed a layer
                    if (edit.mapName === currentMapName) {
                        renameLayer(edit.index, edit.name, true);
                    } else if (maps[edit.mapName]) {
                        maps[edit.mapName].layerNames[edit.index] = edit.name;
                    }
                    break;

                case 'renameMap':
                    // Another builder renamed a map
                    if (maps[edit.oldName]) {
                        maps[edit.newName] = maps[edit.oldName];
                        delete maps[edit.oldName];
                        placedTriggers.forEach(t => {
                            if (t.mapName === edit.oldName) t.mapName = edit.newName;
                            if (t.targetMap === edit.oldName) t.targetMap = edit.newName;
                        });
                        placedNpcs.forEach(npc => {
                            if (npc.mapName === edit.oldName) npc.mapName = edit.newName;
                        });
                        if (currentMapName === edit.oldName) currentMapName = edit.newName;
                        if (spawnMapName === edit.oldName) spawnMapName = edit.newName;
                        updateMapDropdowns();
                        updateTriggerList();
                        console.log('[BUILDER MP] Remote map renamed:', edit.oldName, '->', edit.newName);
                    }
                    break;

                case 'cameraBounds':
                    // Another builder set/cleared camera bounds
                    if (edit.mapName === currentMapName) {
                        cameraBounds = edit.bounds;
                        updateCameraBoundsInfo();
                        renderMap();
                    } else if (maps[edit.mapName]) {
                        maps[edit.mapName].cameraBounds = edit.bounds;
                    }
                    break;

                case 'selectAllCollision':
                    // Another builder filled all collision for a tileset
                    selectAllCollision(true, edit.tilesetIndex);
                    break;

                case 'clearAllCollision':
                    // Another builder cleared all collision for a tileset
                    clearAllCollision(true, edit.tilesetIndex);
                    break;

                case 'splitLine':
                    // Another builder set a split line
                    console.log('[SYNC] Received splitLine:', edit.key, 'mask:', edit.mask);
                    if (edit.mask && Array.isArray(edit.mask)) {
                        tileSplitLines[edit.key] = edit.mask;
                    } else {
                        // Fallback: flat line at middle
                        tileSplitLines[edit.key] = new Array(16).fill(8);
                    }
                    drawCollisionTileset();
                    break;

                case 'clearSplitLine':
                    // Another builder cleared a split line
                    delete tileSplitLines[edit.key];
                    delete tileSplitLineFlipped[edit.key];
                    drawCollisionTileset();
                    break;

                case 'splitLineFlip':
                    // Another builder changed split line flip state
                    if (edit.flipped) {
                        tileSplitLineFlipped[edit.key] = true;
                    } else {
                        delete tileSplitLineFlipped[edit.key];
                    }
                    drawCollisionTileset();
                    break;

                case 'addPlayerCharacter':
                    // Another builder added a player character
                    if (edit.character) {
                        playerCharacters.push({ ...edit.character });
                        const idx = playerCharacters.length - 1;
                        if (edit.character.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                playerCharacters[idx]._spriteImg = img;
                                updatePlayerList();
                            };
                            img.src = edit.character.spriteData;
                        }
                        updatePlayerList();
                        console.log('[BUILDER MP] Remote player character added:', edit.character.name);
                    }
                    break;

                case 'updatePlayerCharacter':
                    // Another builder updated a player character
                    if (edit.index >= 0 && edit.index < playerCharacters.length && edit.character) {
                        playerCharacters[edit.index] = { ...edit.character };
                        if (edit.character.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                playerCharacters[edit.index]._spriteImg = img;
                                updatePlayerList();
                            };
                            img.src = edit.character.spriteData;
                        }
                        updatePlayerList();
                        console.log('[BUILDER MP] Remote player character updated:', edit.character.name);
                    }
                    break;

                case 'deletePlayerCharacter':
                    // Another builder deleted a player character
                    if (edit.index >= 0 && edit.index < playerCharacters.length) {
                        playerCharacters.splice(edit.index, 1);
                        if (activePlayerIndex >= playerCharacters.length) {
                            activePlayerIndex = playerCharacters.length - 1;
                        }
                        updatePlayerList();
                        console.log('[BUILDER MP] Remote player character deleted:', edit.index);
                    }
                    break;

                case 'setActivePlayer':
                    // Another builder changed active player
                    if (edit.index >= -1 && edit.index < playerCharacters.length) {
                        activePlayerIndex = edit.index;
                        updatePlayerList();
                        console.log('[BUILDER MP] Remote active player changed:', edit.index);
                    }
                    break;

                case 'addItem':
                    // Another builder added an item definition
                    if (edit.item) {
                        items.push(edit.item);
                        if (edit.item.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                itemImages[items.length - 1] = img;
                                updateItemList();
                            };
                            img.src = edit.item.spriteData;
                        }
                        updateItemList();
                        console.log('[BUILDER MP] Remote item definition added:', edit.item.name);
                    }
                    break;

                case 'updateItem':
                    // Another builder updated an item definition
                    if (edit.index >= 0 && edit.index < items.length && edit.item) {
                        items[edit.index] = edit.item;
                        if (edit.item.spriteData) {
                            const img = new Image();
                            img.onload = () => {
                                itemImages[edit.index] = img;
                                updateItemList();
                            };
                            img.src = edit.item.spriteData;
                        }
                        updateItemList();
                        console.log('[BUILDER MP] Remote item definition updated:', edit.item.name);
                    }
                    break;

                case 'deleteItem':
                    // Another builder deleted an item definition
                    if (edit.index >= 0 && edit.index < items.length) {
                        items.splice(edit.index, 1);
                        itemImages.splice(edit.index, 1);
                        // Update placedItems indices
                        placedItems = placedItems.filter(pi => pi.itemIndex !== edit.index);
                        placedItems.forEach(pi => { if (pi.itemIndex > edit.index) pi.itemIndex--; });
                        updateItemList();
                        updatePlacedItemsList();
                        renderMap();
                        console.log('[BUILDER MP] Remote item definition deleted:', edit.index);
                    }
                    break;

                // ===== QUEST SYNC HANDLERS =====
                case 'addQuest':
                    // Another builder added a quest
                    if (edit.quest) {
                        quests.push(edit.quest);
                        renderQuestList();
                        console.log('[BUILDER MP] Remote quest added:', edit.quest.name);
                    }
                    break;

                case 'updateQuest':
                    // Another builder updated a quest field
                    if (edit.questId) {
                        const questIndex = quests.findIndex(q => q.id === edit.questId);
                        if (questIndex >= 0 && edit.quest) {
                            quests[questIndex] = edit.quest;
                            if (selectedQuestIndex === questIndex) {
                                loadQuestIntoEditor(questIndex);
                            }
                            renderQuestList();
                            console.log('[BUILDER MP] Remote quest updated:', edit.quest.name);
                        }
                    }
                    break;

                case 'deleteQuest':
                    // Another builder deleted a quest
                    if (edit.questId) {
                        const questIndex = quests.findIndex(q => q.id === edit.questId);
                        if (questIndex >= 0) {
                            quests.splice(questIndex, 1);
                            if (selectedQuestIndex === questIndex) {
                                selectedQuestIndex = -1;
                                document.getElementById('questEditorPanel').style.display = 'none';
                            } else if (selectedQuestIndex > questIndex) {
                                selectedQuestIndex--;
                            }
                            renderQuestList();
                            console.log('[BUILDER MP] Remote quest deleted:', edit.questId);
                        }
                    }
                    break;

                case 'reorderQuests':
                    // Another builder reordered quests
                    if (edit.quests && Array.isArray(edit.quests)) {
                        const newOrder = [];
                        edit.quests.forEach(questId => {
                            const quest = quests.find(q => q.id === questId);
                            if (quest) newOrder.push(quest);
                        });
                        // Add any quests that weren't in the reorder list (shouldn't happen but safety)
                        quests.forEach(q => {
                            if (!newOrder.find(nq => nq.id === q.id)) {
                                newOrder.push(q);
                            }
                        });
                        quests.length = 0;
                        quests.push(...newOrder);
                        renderQuestList();
                        console.log('[BUILDER MP] Quests reordered');
                    }
                    break;

                case 'expandMap':
                    // Another builder expanded a map
                    if (edit.direction && edit.mapName) {
                        if (edit.mapName === currentMapName) {
                            expandMap(edit.direction, true); // true = fromNetwork
                        } else if (maps[edit.mapName]) {
                            // Expand another map's data
                            const targetMap = maps[edit.mapName];
                            const dir = edit.direction;
                            const mapWidth = targetMap.layers[0][0].length;
                            const mapHeight = targetMap.layers[0].length;

                            targetMap.layers.forEach(layer => {
                                if (dir === 'right' || dir === 'left') {
                                    layer.forEach(row => {
                                        if (dir === 'right') row.push(null);
                                        else row.unshift(null);
                                    });
                                } else {
                                    const newRow = new Array(mapWidth + (dir === 'left' || dir === 'right' ? 1 : 0)).fill(null);
                                    if (dir === 'down') layer.push([...newRow]);
                                    else layer.unshift([...newRow]);
                                }
                            });
                        }
                        console.log('[BUILDER MP] Remote map expanded:', edit.mapName, edit.direction);
                    }
                    break;

                case 'deleteTileset':
                    // Another builder deleted a tileset
                    if (edit.index >= 0 && edit.index < tilesets.length) {
                        deleteTileset(true, edit.index); // true = fromNetwork
                        console.log('[BUILDER MP] Remote tileset deleted:', edit.index);
                    }
                    break;

                case 'startEditing':
                    // Another builder started editing something
                    if (edit.editorType && edit.editorIndex !== undefined && edit.username) {
                        const key = edit.editorType + ':' + edit.editorIndex;
                        currentlyEditing[key] = { username: edit.username };
                        console.log('[BUILDER MP] Remote user started editing:', key, 'by', edit.username);
                    }
                    break;

                case 'stopEditing':
                    // Another builder stopped editing something
                    if (edit.editorType && edit.editorIndex !== undefined) {
                        const key = edit.editorType + ':' + edit.editorIndex;
                        delete currentlyEditing[key];
                        console.log('[BUILDER MP] Remote user stopped editing:', key);
                    }
                    break;
            }
        }

        // Version without renderMap calls (for batching)
        function applyRemoteEditNoRender(edit) {
            let targetLayers = (edit.mapName && edit.mapName !== currentMapName && maps[edit.mapName])
                ? maps[edit.mapName].layers : layers;

            switch (edit.editType) {
                case 'tile':
                    if (!targetLayers[edit.layer]) targetLayers[edit.layer] = [];
                    if (!targetLayers[edit.layer][edit.y]) targetLayers[edit.layer][edit.y] = [];
                    targetLayers[edit.layer][edit.y][edit.x] = edit.cell;
                    break;
                case 'eraseTile':
                    if (targetLayers[edit.layer] && targetLayers[edit.layer][edit.y]) {
                        targetLayers[edit.layer][edit.y][edit.x] = null;
                    }
                    break;
                case 'tileSound':
                    tileSounds[edit.key] = edit.sound;
                    break;
                case 'removeTileSound':
                    delete tileSounds[edit.key];
                    break;
                case 'light':
                    pointLights[edit.key] = edit.light;
                    break;
                case 'removeLight':
                    delete pointLights[edit.key];
                    break;
                case 'placeNpc':
                    placedNpcs.push(edit.npc);
                    break;
                case 'removeNpc':
                    if (edit.index >= 0 && edit.index < placedNpcs.length) {
                        placedNpcs.splice(edit.index, 1);
                    }
                    break;
                case 'placeTrigger':
                    placedTriggers.push(edit.trigger);
                    break;
                case 'removeTrigger':
                    if (edit.index >= 0 && edit.index < placedTriggers.length) {
                        placedTriggers.splice(edit.index, 1);
                    }
                    break;
                case 'collision':
                    if (edit.value) tileCollisions[edit.key] = true;
                    else delete tileCollisions[edit.key];
                    break;
                case 'collisionMask':
                    collisionMasks[edit.key] = edit.mask;
                    break;
            }
        }

        // Batching system for builder edits
        let editBatch = [];
        let batchTimeout = null;
        const BATCH_DELAY = 250; // ms to wait before sending batch (higher = less network traffic)

        function broadcastEdit(editData) {
            // Send to test game window directly (works in solo mode)
            if (testGameWindow && !testGameWindow.closed) {
                try {
                    testGameWindow.postMessage({ type: 'builderEdit', edit: editData }, '*');
                } catch (e) {
                    // Window might be closed or cross-origin
                }
            }

            // Also broadcast via WebSocket if in CO-OP mode
            if (!builderConnected || !builderSocket) return;

            // Add to batch
            editBatch.push(editData);

            // If no pending send, schedule one
            if (!batchTimeout) {
                batchTimeout = setTimeout(flushEditBatch, BATCH_DELAY);
            }
        }

        function flushEditBatch() {
            batchTimeout = null;
            if (editBatch.length === 0 || !builderConnected || !builderSocket) return;

            if (editBatch.length === 1) {
                // Single edit - send normally
                builderSocket.send(JSON.stringify({
                    type: 'update',
                    ...editBatch[0],
                    gameType: 'builder'
                }));
            } else {
                // Multiple edits - send as batch
                builderSocket.send(JSON.stringify({
                    type: 'update',
                    editType: 'batch',
                    edits: editBatch,
                    gameType: 'builder'
                }));
            }
            editBatch = [];
        }

        // Warn before closing tab if in co-op mode
        window.addEventListener('beforeunload', (e) => {
            if (builderConnected) {
                e.preventDefault();
                e.returnValue = 'You are in a co-op session. Make sure to save your work!';
                return e.returnValue;
            }
        });

        function showBuilderStatus(msg) {
            // Show connection status in Tools dropdown menu
            const statusEl = document.getElementById('coopStatusInMenu');
            if (statusEl) {
                statusEl.style.display = 'block';
                statusEl.textContent = 'CO-OP: ' + msg;
                if (msg.includes('Disconnected')) {
                    statusEl.className = 'coop-status-menu disconnected';
                } else {
                    statusEl.className = 'coop-status-menu connected';
                }
            }
            // Also update tools button to show connection indicator
            const toolsBtn = document.querySelector('.tools-toggle');
            if (toolsBtn) {
                if (msg.includes('Disconnected')) {
                    toolsBtn.innerHTML = '⚙ Tools ▼';
                } else {
                    toolsBtn.innerHTML = '⚙ Tools <span style="color:#0f0;">●</span> ▼';
                }
            }
        }

        function showRoomInfo() {
            // Create or update room info modal
            let modal = document.getElementById('roomInfoModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'roomInfoModal';
                modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);display:flex;align-items:center;justify-content:center;z-index:10000;';
                modal.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };
                document.body.appendChild(modal);
            }

            // Build content - retro styled
            let html = '<div style="background:#1a1a1a;border:3px solid #fff;padding:25px;min-width:320px;max-width:500px;font-family:\'Press Start 2P\',monospace;">';
            html += '<h2 style="color:#fff;margin:0 0 20px 0;text-align:center;font-size:14px;letter-spacing:2px;">ROOM INFO</h2>';

            // Connection status
            if (builderConnected && builderRoomCode) {
                html += '<div style="background:#0a1a0a;color:#0f0;padding:10px;margin-bottom:15px;border:2px solid #0f0;text-align:center;font-size:8px;">';
                html += '> CONNECTED: <strong>' + builderRoomCode + '</strong></div>';
            } else {
                html += '<div style="background:#1a0a0a;color:#f00;padding:10px;margin-bottom:15px;border:2px solid #f00;text-align:center;font-size:8px;">';
                html += '> NOT CONNECTED</div>';
            }

            // Your name
            html += '<div style="color:#888;margin-bottom:12px;font-size:8px;"><span style="color:#f90;">PLAYER:</span> ' + builderPlayerName + '</div>';

            // Builder players in room
            html += '<div style="color:#4af;margin-bottom:8px;font-size:8px;">BUILDERS (' + builderPlayersInRoom.size + ')</div>';
            if (builderPlayersInRoom.size > 0) {
                html += '<div style="color:#666;margin:0 0 15px 10px;font-size:7px;">';
                builderPlayersInRoom.forEach((p, id) => {
                    html += '> ' + p.name + '<br>';
                });
                html += '</div>';
            } else {
                html += '<div style="color:#444;margin-bottom:15px;padding-left:10px;font-size:7px;">No other builders</div>';
            }

            // Game testers in room
            html += '<div style="color:#0ff;margin-bottom:8px;font-size:8px;">TESTERS (' + gamePlayersInBuilder.size + ')</div>';
            if (gamePlayersInBuilder.size > 0) {
                html += '<div style="color:#666;margin:0 0 15px 10px;font-size:7px;">';
                gamePlayersInBuilder.forEach((p, id) => {
                    html += '> ' + p.name + ' <span style="color:#444;">[' + (p.currentMap || '?') + ']</span><br>';
                });
                html += '</div>';
            } else {
                html += '<div style="color:#444;margin-bottom:15px;padding-left:10px;font-size:7px;">No game testers</div>';
            }

            // Project info
            html += '<div style="border-top:1px solid #333;padding-top:15px;margin-top:10px;">';
            html += '<div style="color:#a6f;margin-bottom:10px;font-size:8px;">PROJECT STATS</div>';
            html += '<div style="color:#666;margin-left:10px;font-size:7px;">';
            html += '<div style="margin:4px 0;">Maps........ ' + Object.keys(maps).length + '</div>';
            html += '<div style="margin:4px 0;">Tilesets.... ' + tilesets.length + '</div>';
            html += '<div style="margin:4px 0;">NPCs........ ' + npcs.length + '</div>';
            html += '<div style="margin:4px 0;">Triggers.... ' + placedTriggers.length + '</div>';
            html += '</div></div>';

            // Share save button (for host to share with late joiners)
            html += '<div style="border-top:1px solid #333;padding-top:15px;margin-top:15px;">';
            html += '<div style="color:#fd0;margin-bottom:8px;font-size:8px;">LATE JOINERS</div>';
            html += '<p style="color:#444;font-size:6px;margin:0 0 10px 0;">Download save to share with friends</p>';
            html += '<button onclick="downloadProject(); document.getElementById(\'roomInfoModal\').style.display=\'none\'" ';
            html += 'style="width:100%;padding:12px;background:#1a1a1a;color:#0f0;border:2px solid #0f0;cursor:pointer;font-family:\'Press Start 2P\',monospace;font-size:8px;">DOWNLOAD SAVE</button>';
            html += '</div>';

            // Close button
            html += '<button onclick="document.getElementById(\'roomInfoModal\').style.display=\'none\'" ';
            html += 'style="width:100%;margin-top:12px;padding:12px;background:#1a1a1a;color:#f55;border:2px solid #f55;cursor:pointer;font-family:\'Press Start 2P\',monospace;font-size:8px;">CLOSE</button>';

            html += '</div>';
            modal.innerHTML = html;
            modal.style.display = 'flex';
        }

        // Adventure mode - load project, open test, hide UI
        let launchAsAdventure = false;
        let multiplayerSettings = null; // Will be set from prompt

        async function startAdventure() {
            if (!pendingSaveData) return;

            // Get multiplayer settings from prompt
            const playerName = document.getElementById('mpPlayerName').value.trim() || 'Player';
            const roomCode = document.getElementById('mpRoomCode').value.trim();

            if (roomCode) {
                multiplayerSettings = { playerName, roomCode };
            } else {
                multiplayerSettings = null; // Solo mode
            }

            document.getElementById('multiplayerPrompt').style.display = 'none';
            document.getElementById('modeSelect').style.display = 'block';
            document.getElementById('modeSelect').innerHTML = '<h1>LOADING...</h1>';
            // Keep loadPhase visible during entire loading process
            keepLoadPhaseVisible = true;
            document.getElementById('loadPhase').style.zIndex = '9999';

            await loadProject(pendingSaveData);
            pendingSaveData = null;

            // Wait for tilesets to load
            setTimeout(() => {
                launchAsAdventure = true;
                testMap();
                launchAsAdventure = false;
                // Return to start menu after game opens
                setTimeout(() => {
                    keepLoadPhaseVisible = false;
                    document.getElementById('loadPhase').style.zIndex = '';
                    // Reset to start screen (not builder)
                    document.getElementById('modeSelect').style.display = 'none';
                    document.getElementById('mainMenu').style.display = 'block';
                    document.getElementById('loadPhase').classList.add('active');
                    setPhase('load');
                }, 2000);
            }, 1000);
        }

        // Show/hide prompt functions
        function showDirectJoinPrompt() {
            // Show join prompt directly from main menu (no save file needed)
            document.getElementById('mainMenu').style.display = 'none';
            document.getElementById('joinRoomPrompt').style.display = 'block';
        }

        function showHostPrompt() {
            document.getElementById('craftMultiplayerPrompt').style.display = 'none';
            document.getElementById('hostRoomPrompt').style.display = 'block';
            setTimeout(() => document.getElementById('hostPlayerName').focus(), 50);
        }

        function hideHostPrompt() {
            document.getElementById('hostRoomPrompt').style.display = 'none';
            document.getElementById('craftMultiplayerPrompt').style.display = 'block';
        }

        function showJoinPrompt() {
            document.getElementById('craftMultiplayerPrompt').style.display = 'none';
            document.getElementById('joinRoomPrompt').style.display = 'block';
            setTimeout(() => document.getElementById('joinPlayerName').focus(), 50);
        }

        function hideJoinPrompt() {
            document.getElementById('joinRoomPrompt').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';
            joinSaveData = null;
            document.getElementById('joinSaveStatus').textContent = 'No file loaded';
        }

        // Handle save file loaded in Join Room prompt
        let joinSaveData = null;
        function handleJoinSaveFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    joinSaveData = JSON.parse(e.target.result);
                    document.getElementById('joinSaveStatus').textContent = 'Loaded: ' + file.name;
                    document.getElementById('joinSaveStatus').style.color = '#0f0';
                    console.log('[JOIN] Save file loaded:', file.name);
                } catch (err) {
                    alert('Invalid save file!');
                    joinSaveData = null;
                    document.getElementById('joinSaveStatus').textContent = 'Error loading file';
                    document.getElementById('joinSaveStatus').style.color = '#f00';
                }
            };
            reader.readAsText(file);
        }

        // SOLO MODE - Load local save, no multiplayer
        async function startCraftSolo() {
            console.log('[CRAFT] Starting SOLO mode');
            if (!pendingSaveData) {
                console.log('[CRAFT] No pendingSaveData, returning');
                return;
            }

            document.getElementById('craftMultiplayerPrompt').style.display = 'none';

            await loadProject(pendingSaveData);
            pendingSaveData = null;
            document.getElementById('modeSelect').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';

            console.log('[CRAFT] Solo mode ready');
        }

        // HOST MODE - Load local save, then connect to room (others get your project)
        async function startCraftHost() {
            console.log('[CRAFT] Starting HOST mode');
            if (!pendingSaveData) {
                console.log('[CRAFT] No pendingSaveData, returning');
                return;
            }

            const playerName = document.getElementById('hostPlayerName').value.trim() || 'Host';
            const roomCode = document.getElementById('hostRoomCode').value.trim();

            if (!roomCode) {
                alert('Please enter a room code for others to join');
                return;
            }

            document.getElementById('hostRoomPrompt').style.display = 'none';

            // Load YOUR local project first (you're the host, your project is the map)
            await loadProject(pendingSaveData);
            pendingSaveData = null;
            document.getElementById('modeSelect').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'block';

            // Connect to multiplayer - you're the host
            console.log('[CRAFT] Host connecting to room:', roomCode);
            connectBuilderMultiplayer(playerName, roomCode);

            console.log('[CRAFT] Host mode ready - share room code:', roomCode);
        }

        // JOIN MODE - Load same save as host, then connect for real-time sync
        async function startCraftJoin() {
            console.log('[CRAFT] Starting JOIN mode');

            const playerName = document.getElementById('joinPlayerName').value.trim() || 'Builder';
            const roomCode = document.getElementById('joinRoomCode').value.trim();

            if (!roomCode) {
                alert('Please enter a room code to join');
                return;
            }

            if (!joinSaveData) {
                alert('Please load the save file first!');
                return;
            }

            document.getElementById('joinRoomPrompt').style.display = 'none';

            // Load the save file
            console.log('[CRAFT] Loading save for co-op join');
            await loadProject(joinSaveData);
            joinSaveData = null;

            // Show the builder interface
            document.getElementById('loadPhase').classList.remove('active');
            document.getElementById('buildPhase').classList.add('active');
            setPhase('build');

            // Connect to multiplayer for real-time sync
            console.log('[CRAFT] Joining room:', roomCode);
            connectBuilderMultiplayer(playerName, roomCode);

            console.log('[CRAFT] Join mode ready - edits will sync with room');
        }

        // Initialize an empty project for joiners
        function initEmptyProject() {
            gridSize = 16;
            mapCols = 40;
            mapRows = 30;
            layers = [[]];
            layerVisibility = [true];
            layerNames = ['Layer 1'];
            currentLayer = 0;
            tileCollisions = {};
            collisionMasks = {};
            tileSplitLines = {};
            maps = { 'main': { layers: [[]], layerVisibility: [true], layerNames: ['Layer 1'], currentLayer: 0 }};
            currentMapName = 'main';
            placedTriggers = [];
            placedNpcs = [];
            npcs = [];
            tilesets = [];
            animatedProps = [];
            placedAnimProps = [];
            sounds = [];
            tileSounds = {};
            pointLights = {};
            dialogs = [];

            // Initialize empty layer grid
            for (let y = 0; y < mapRows; y++) {
                layers[0][y] = [];
                for (let x = 0; x < mapCols; x++) {
                    layers[0][y][x] = null;
                }
            }

            console.log('[CRAFT] Empty project initialized');
        }

        // Legacy function for backwards compatibility
        async function startCraft() {
            startCraftSolo();
        }

        async function loadProject(projectData) {
            // If no data passed, load from IndexedDB (or migrate from localStorage)
            let p;
            if (projectData) {
                p = projectData;
            } else {
                // Try IndexedDB first
                try {
                    const dbData = await loadProjectFromDB();
                    if (dbData) {
                        p = dbData;
                        console.log('Loaded project from IndexedDB');
                    }
                } catch (err) {
                    console.warn('IndexedDB load failed:', err);
                }

                // If no IndexedDB data, check localStorage for migration
                if (!p) {
                    const legacyData = localStorage.getItem('worldBuilderProject');
                    if (legacyData) {
                        try {
                            p = JSON.parse(legacyData);
                            console.log('Loaded project from localStorage, migrating to IndexedDB...');
                            // Migrate to IndexedDB
                            try {
                                await saveProjectToDB(p);
                                localStorage.removeItem('worldBuilderProject');
                                console.log('Migration complete, localStorage cleared');
                            } catch (migErr) {
                                console.warn('Migration to IndexedDB failed:', migErr);
                            }
                        } catch (parseErr) {
                            alert('Error parsing saved data: ' + parseErr.message);
                            return;
                        }
                    }
                }

                if (!p) {
                    alert('No saved project found in browser storage. Use "Load File" to load from a downloaded file.');
                    return;
                }
            }

            console.log('Loading project:', p);
            gridSize = p.gridSize || 16;
            mapCols = p.mapCols || 40;
            mapRows = p.mapRows || 30;
            tileCollisions = p.tileCollisions || {};
            collisionMasks = p.collisionMasks || {};
            tileSplitLines = p.tileSplitLines || {}; // Depth split lines for Y-sorting
            tileSplitLineFlipped = p.tileSplitLineFlipped || {}; // Flipped split lines

            // Load multiple props (new format)
            props = [];
            propImage = null;
            propImageData = null;
            propCollisionMasks = {};
            currentPropIndex = -1;

            if (p.props && p.props.length > 0) {
                console.log('Loading', p.props.length, 'props');
                let propsLoaded = 0;
                p.props.forEach((propData, i) => {
                    const img = new Image();
                    img.onload = () => {
                        props[i] = {
                            name: propData.name,
                            img: img,
                            data: propData.data,
                            collisionMasks: propData.collisionMasks || {}
                        };
                        propsLoaded++;
                        if (propsLoaded === p.props.length) {
                            // All props loaded
                            currentPropIndex = p.currentPropIndex >= 0 ? p.currentPropIndex : 0;
                            if (props[currentPropIndex]) {
                                propImage = props[currentPropIndex].img;
                                propImageData = props[currentPropIndex].data;
                                propCollisionMasks = props[currentPropIndex].collisionMasks;
                            }
                            updatePropDropdown();
                            updatePropUI();
                            drawPropTileset();
                            renderMap();
                        }
                    };
                    img.onerror = () => {
                        console.error('Failed to load prop', i);
                        propsLoaded++;
                    };
                    img.src = propData.data;
                });
            } else if (p.propImageData) {
                // Old format - single prop image (backwards compatibility)
                console.log('Loading single prop (old format)');
                const img = new Image();
                img.onload = () => {
                    props = [{
                        name: 'prop',
                        img: img,
                        data: p.propImageData,
                        collisionMasks: p.propCollisionMasks || {}
                    }];
                    currentPropIndex = 0;
                    propImage = img;
                    propImageData = p.propImageData;
                    propCollisionMasks = p.propCollisionMasks || {};
                    updatePropDropdown();
                    updatePropUI();
                    drawPropTileset();
                    renderMap();
                };
                img.onerror = () => console.error('Failed to load prop image');
                img.src = p.propImageData;
            } else {
                console.log('No props in saved project');
                updatePropDropdown();
                updatePropUI();
            }

            // Load animated props
            animatedProps = [];
            animPropSpriteSheet = null;
            animPropSpriteData = null;
            currentAnimPropIndex = -1;
            placedAnimProps = p.placedAnimProps || [];

            if (p.animatedProps && p.animatedProps.length > 0) {
                console.log('Loading', p.animatedProps.length, 'animated props');
                let propsLoaded = 0;
                p.animatedProps.forEach((propData, i) => {
                    animatedProps[i] = {
                        name: propData.name,
                        spriteData: propData.spriteData,
                        frameWidth: propData.frameWidth || 16,
                        frameHeight: propData.frameHeight || 16,
                        frames: propData.frames || [],
                        type: propData.type || 'loop',
                        fps: propData.fps || 8,
                        collisionMask: propData.collisionMask || null,
                        splitLine: propData.splitLine || null
                    };

                    // Load sprite sheet image if present
                    if (propData.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            animatedProps[i]._spriteImg = img;
                            propsLoaded++;
                            if (propsLoaded === p.animatedProps.length) {
                                currentAnimPropIndex = p.currentAnimPropIndex >= 0 ? p.currentAnimPropIndex : 0;
                                if (animatedProps[currentAnimPropIndex] && animatedProps[currentAnimPropIndex]._spriteImg) {
                                    animPropSpriteSheet = animatedProps[currentAnimPropIndex]._spriteImg;
                                    animPropSpriteData = animatedProps[currentAnimPropIndex].spriteData;
                                }
                                updateAnimPropListDisplay();
                                renderMap();
                            }
                        };
                        img.onerror = () => {
                            console.error('Failed to load animated prop sprite', i);
                            propsLoaded++;
                        };
                        img.src = propData.spriteData;
                    } else {
                        propsLoaded++;
                        if (propsLoaded === p.animatedProps.length) {
                            currentAnimPropIndex = p.currentAnimPropIndex >= 0 ? p.currentAnimPropIndex : 0;
                            updateAnimPropListDisplay();
                            renderMap();
                        }
                    }
                });
            } else {
                console.log('No animated props in saved project');
                updateAnimPropListDisplay();
            }

            // Load NPCs
            npcs = [];
            currentNpcIndex = -1;
            placedNpcs = p.placedNpcs || [];
            selectedPlacedNpcIndex = -1;
            npcPathDrawing = false;

            if (p.npcs && p.npcs.length > 0) {
                console.log('Loading', p.npcs.length, 'NPCs');
                p.npcs.forEach((npcData, i) => {
                    // Spread all saved fields to preserve collisionInsets, shadow settings, etc.
                    npcs[i] = {
                        ...npcData,
                        // Ensure required fields have defaults
                        frameWidth: npcData.frameWidth || 32,
                        frameHeight: npcData.frameHeight || 32,
                        animations: npcData.animations || { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [], attackDown: [], attackUp: [], attackLeft: [], attackRight: [] },
                        animMirrors: npcData.animMirrors || {},
                        fps: npcData.fps || 8
                    };
                    // Preload sprite image
                    if (npcData.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            npcs[i]._editorImg = img;
                            renderMap();
                        };
                        img.src = npcData.spriteData;
                    }
                });
                currentNpcIndex = p.currentNpcIndex >= 0 ? p.currentNpcIndex : 0;
                updateNpcList();
                updatePlacedNpcList();
            } else {
                console.log('No NPCs in saved project');
                updateNpcList();
                updatePlacedNpcList();
            }

            // Load static objects
            staticObjects = [];
            currentStaticObjIndex = -1;
            placedStaticObjects = p.placedStaticObjects || [];

            if (p.staticObjects && p.staticObjects.length > 0) {
                console.log('Loading', p.staticObjects.length, 'static objects');
                p.staticObjects.forEach((objData, i) => {
                    staticObjects[i] = {
                        name: objData.name,
                        spriteData: objData.spriteData,
                        width: objData.width,
                        height: objData.height,
                        tilesetIndex: objData.tilesetIndex,
                        sourceTiles: objData.sourceTiles,
                        sourceOrigin: objData.sourceOrigin,
                        _spriteImg: new Image()
                    };
                    staticObjects[i]._spriteImg.src = objData.spriteData;
                });
            }
            updateStaticObjectsList();

            // Load layers (backwards compatible with old saves)
            if (p.layers) {
                layers = p.layers;
                layerVisibility = p.layerVisibility || layers.map(() => true);
                layerNames = p.layerNames || layers.map(() => '');
                currentLayer = p.currentLayer || 0;
            } else if (p.map) {
                // Old format - single map
                layers = [p.map];
                layerVisibility = [true];
                layerNames = [''];
                currentLayer = 0;
            } else {
                layers = [createEmptyLayer()];
                layerVisibility = [true];
                layerNames = [''];
                currentLayer = 0;
            }
            map = layers[currentLayer];

            // Load player layer settings
            playerLayerIndex = p.playerLayerIndex !== undefined ? p.playerLayerIndex : 1;
            playerPreviewPos = p.playerPreviewPos || { x: 5, y: 5 };
            spawnMapName = p.spawnMapName || 'main';
            playerPreviewVisible = p.playerPreviewVisible !== undefined ? p.playerPreviewVisible : true;

            // Load sounds
            sounds = [];
            tileSounds = p.tileSounds || {};
            playerSounds = p.playerSounds || {
                walk: { soundIndex: -1, interval: 200, volume: 0.5, pitchVariation: 0.1 },
                attack: { soundIndex: -1, volume: 0.7, pitchVariation: 0.15, lengthVariation: 0 }
            };

            if (p.sounds && p.sounds.length > 0) {
                console.log('Loading', p.sounds.length, 'sounds');
                p.sounds.forEach((soundData, i) => {
                    sounds[i] = {
                        name: soundData.name,
                        data: soundData.data,
                        duration: soundData.duration || 0,
                        type: soundData.type || 'ambient'
                    };
                });
                updateSoundDropdown();
                updatePlacedSoundsList();
                updatePlayerSoundAssignments();
            } else {
                console.log('No sounds in saved project');
                updateSoundDropdown();
                updatePlacedSoundsList();
                updatePlayerSoundAssignments();
            }

            // Load lighting settings
            if (p.lightingSettings) {
                lightingSettings = {
                    playerLight: p.lightingSettings.playerLight || false,
                    playerLightRadius: p.lightingSettings.playerLightRadius || 4
                };
                // Update UI to match loaded settings
                const playerLightEl = document.getElementById('playerLight');
                const radiusEl = document.getElementById('playerLightRadius');
                if (playerLightEl) playerLightEl.checked = lightingSettings.playerLight;
                if (radiusEl) {
                    radiusEl.value = lightingSettings.playerLightRadius;
                    document.getElementById('playerLightRadiusVal').textContent = lightingSettings.playerLightRadius;
                }
            }
            pointLights = p.pointLights || {};
            polyLights = p.polyLights || [];
            updatePlacedLightsList();
            updatePolyLightsList();

            // Load multi-map data
            if (p.maps && Object.keys(p.maps).length > 0) {
                maps = p.maps;
                currentMapName = p.currentMapName || 'main';
                console.log('Loaded', Object.keys(maps).length, 'maps');
            } else {
                // No multi-map data - will create 'main' map from current data after load
                maps = {};
                currentMapName = 'main';
            }

            // Load triggers
            placedTriggers = p.placedTriggers || [];
            console.log('Loaded', placedTriggers.length, 'triggers');
            updateDoorNumberDropdown();

            // Load dialogs
            dialogs = p.dialogs || [];
            placedDialogTiles = p.placedDialogTiles || [];
            console.log('Loaded', dialogs.length, 'dialogs,', placedDialogTiles.length, 'dialog tiles');
            updateDialogList();

            // Load items
            items = [];
            placedItems = p.placedItems || [];
            currentItemIndex = -1;
            if (p.items && p.items.length > 0) {
                p.items.forEach((itemData, i) => {
                    items[i] = {
                        name: itemData.name,
                        spriteData: itemData.spriteData,
                        frameWidth: itemData.frameWidth || 16,
                        frameHeight: itemData.frameHeight || 16,
                        frames: itemData.frames || [],
                        fps: itemData.fps || 8,
                        idleFrame: itemData.idleFrame || 0
                    };
                    // Preload sprite image
                    if (itemData.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            items[i]._spriteImg = img;
                            renderMap();
                        };
                        img.src = itemData.spriteData;
                    }
                });
                console.log('Loaded', items.length, 'items,', placedItems.length, 'placed items');
            }
            updateItemList();
            updatePlacedItemsList();

            // Load quests
            quests = p.quests || [];
            selectedQuestIndex = -1;
            console.log('Loaded', quests.length, 'quests');
            renderQuestList();

            // Load player characters
            playerCharacters = [];
            activePlayerIndex = -1;
            if (p.playerCharacters && p.playerCharacters.length > 0) {
                p.playerCharacters.forEach((char, i) => {
                    playerCharacters[i] = { ...char };
                    if (char.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            playerCharacters[i]._spriteImg = img;
                            updatePlayerList();
                        };
                        img.src = char.spriteData;
                    }
                });
                activePlayerIndex = p.activePlayerIndex !== undefined ? p.activePlayerIndex : 0;
                console.log('Loaded', playerCharacters.length, 'player characters, active:', activePlayerIndex);
            }
            updatePlayerList();

            // Load tilesets (new format with multiple tilesets)
            if (p.tilesets && p.tilesets.length > 0) {
                let loadedCount = 0;
                tilesets = [];
                p.tilesets.forEach((tsData, i) => {
                    const img = new Image();
                    img.onload = () => {
                        tilesets[i] = { name: tsData.name, img: img, data: tsData.data };
                        loadedCount++;
                        if (loadedCount === p.tilesets.length) {
                            // All tilesets loaded
                            currentTilesetIndex = p.currentTilesetIndex || 0;
                            tilesetImg = tilesets[currentTilesetIndex].img;
                            mapInitialized = true; // Mark map as loaded

                            // Initialize maps object if empty (old format project)
                            if (Object.keys(maps).length === 0) {
                                saveCurrentMapState();
                                console.log('Initialized maps object with current data');
                            }

                            updateTilesetDropdown();
                            setPhase('build');
                            drawPaintTileset();
                            renderLayerList();
                            renderMap();
                            updateAnimPropListDisplay();
                            updateMapDropdowns();
                            updateTriggerList();
                        }
                    };
                    img.src = tsData.data;
                });
            } else if (p.tilesetData) {
                // Old format - single tileset
                const img = new Image();
                img.onload = () => {
                    tilesets = [{ name: 'tileset', img: img, data: p.tilesetData }];
                    currentTilesetIndex = 0;
                    tilesetImg = img;
                    mapInitialized = true; // Mark map as loaded

                    // Initialize maps object if empty (old format project)
                    if (Object.keys(maps).length === 0) {
                        saveCurrentMapState();
                        console.log('Initialized maps object with current data');
                    }

                    updateTilesetDropdown();
                    setPhase('build');
                    drawPaintTileset();
                    renderLayerList();
                    renderMap();
                    updateAnimPropListDisplay();
                    updateMapDropdowns();
                    updateTriggerList();
                };
                img.src = p.tilesetData;
            } else {
                alert('No tileset data found in save');
            }
        }

        function exportConfig() {
            const config = { gridSize, mapSize: { cols: mapCols, rows: mapRows }, tileCollisions, layers };
            navigator.clipboard.writeText(JSON.stringify(config, null, 2)).then(() => alert('Copied!'));
        }

        // ===== MULTI-MAP FUNCTIONS =====

        // Save the current map state to the maps object
        // Camera bounds for current map (null = no bounds)
        let cameraBounds = null;

        function saveCurrentMapState() {
            // Note: tileCollisions, collisionMasks, tileSplitLines are GLOBAL (per-tileset, not per-map)
            // They apply to all maps using the same tileset tiles
            maps[currentMapName] = {
                layers: JSON.parse(JSON.stringify(layers)),
                layerVisibility: [...layerVisibility],
                layerNames: [...layerNames],
                currentLayer: currentLayer,
                mapCols: mapCols,
                mapRows: mapRows,
                cameraBounds: cameraBounds ? { ...cameraBounds } : null
            };
            console.log('Saved map state for:', currentMapName);
        }

        // Load a map state from the maps object
        function loadMapState(mapData) {
            layers = JSON.parse(JSON.stringify(mapData.layers));
            layerVisibility = [...mapData.layerVisibility];
            layerNames = [...mapData.layerNames];
            currentLayer = mapData.currentLayer || 0;
            // Note: collision data is global, not loaded per-map
            // Migrate old per-map collision data to global if present (backwards compatibility)
            if (mapData.tileCollisions && Object.keys(mapData.tileCollisions).length > 0) {
                Object.assign(tileCollisions, mapData.tileCollisions);
            }
            if (mapData.collisionMasks && Object.keys(mapData.collisionMasks).length > 0) {
                Object.assign(collisionMasks, mapData.collisionMasks);
            }
            if (mapData.tileSplitLines && Object.keys(mapData.tileSplitLines).length > 0) {
                Object.assign(tileSplitLines, mapData.tileSplitLines);
            }
            mapCols = mapData.mapCols || mapCols;
            mapRows = mapData.mapRows || mapRows;
            cameraBounds = mapData.cameraBounds ? { ...mapData.cameraBounds } : null;
            map = layers[currentLayer];
        }

        // Create a new empty map
        function createMapData(name) {
            // Note: collision/split data is global (per-tileset), not per-map
            maps[name] = {
                layers: [createEmptyLayer()],
                layerVisibility: [true],
                layerNames: ['Layer 1'],
                currentLayer: 0,
                mapCols: mapCols,
                mapRows: mapRows,
                cameraBounds: null // {x, y, width, height} in tiles, null = no bounds
            };
            console.log('Created new map:', name);
        }

        // Switch to a different map
        function switchToMap(mapName) {
            if (!maps[mapName]) {
                console.warn('Map not found:', mapName);
                return false;
            }

            // Save current map state first
            saveCurrentMapState();

            // Load the new map
            currentMapName = mapName;
            loadMapState(maps[mapName]);

            // Update UI
            renderLayerList();
            renderMap();
            updateTriggerList();
            updatePlacedNpcList();
            updatePlacedSoundsList();
            updatePlacedLightsList();
            updateMapDropdowns(); // Update dropdown to show current map
            updateCameraBoundsInfo(); // Update camera bounds display

            console.log('Switched to map:', mapName);
            return true;
        }

        // Get list of all map names
        function getMapNames() {
            return Object.keys(maps);
        }

        // Delete a map (cannot delete last map)
        function deleteMap(mapName) {
            const mapNames = getMapNames();
            if (mapNames.length <= 1) {
                alert('Cannot delete the last map');
                return false;
            }
            if (mapName === currentMapName) {
                // Switch to another map first
                const otherMap = mapNames.find(n => n !== mapName);
                switchToMap(otherMap);
            }
            delete maps[mapName];

            // Remove triggers that are on or target this map
            placedTriggers = placedTriggers.filter(t => t.mapName !== mapName && t.targetMap !== mapName);
            updateDoorNumberDropdown();

            console.log('Deleted map:', mapName);
            return true;
        }

        // Update map dropdown selectors
        function updateMapDropdowns() {
            const mapNames = getMapNames();

            // Update current map selector (triggers tab)
            const currentSelect = document.getElementById('currentMapSelect');
            if (currentSelect) {
                currentSelect.innerHTML = mapNames.map(name =>
                    `<option value="${name}" ${name === currentMapName ? 'selected' : ''}>${name}</option>`
                ).join('');
            }

            // Update toolbar map selector
            const toolbarSelect = document.getElementById('toolbarMapSelect');
            if (toolbarSelect) {
                toolbarSelect.innerHTML = mapNames.map(name =>
                    `<option value="${name}" ${name === currentMapName ? 'selected' : ''}>${name}</option>`
                ).join('');
            }

            // Update camera map selector
            const cameraSelect = document.getElementById('cameraMapSelect');
            if (cameraSelect) {
                cameraSelect.innerHTML = mapNames.map(name =>
                    `<option value="${name}" ${name === currentMapName ? 'selected' : ''}>${name}</option>`
                ).join('');
            }

            // Update target map selector
            const targetSelect = document.getElementById('triggerTargetMap');
            if (targetSelect) {
                targetSelect.innerHTML = '<option value="">-- Select Map --</option>' +
                    mapNames.map(name => `<option value="${name}">${name}</option>`).join('');
            }
        }

        // Update trigger list UI
        function updateTriggerList() {
            const container = document.getElementById('triggerList');
            if (!container) return;

            const currentTriggers = placedTriggers.filter(t => t.mapName === currentMapName);

            if (currentTriggers.length === 0) {
                container.innerHTML = '<div style="color:#666; text-align:center; padding:10px;">No triggers placed</div>';
                return;
            }

            container.innerHTML = currentTriggers.map((t, i) => {
                const globalIdx = placedTriggers.indexOf(t);
                const doorNum = t.doorNumber || 1;
                const doorType = t.doorType || 'walkover';
                const isExternal = doorType === 'external';
                const spawnSet = isExternal ? (t.returnX != null && t.returnY != null) : (t.targetX != null && t.targetY != null);
                const spawnText = isExternal
                    ? (spawnSet ? `return:(${t.returnX}, ${t.returnY})` : '<span style="color:#f80;">SET RETURN!</span>')
                    : (spawnSet ? `(${t.targetX}, ${t.targetY})` : '<span style="color:#f80;">SET SPAWN!</span>');
                const typeIcon = isExternal ? '🌐' : (doorType === 'interact' ? '🔘' : '🚶');
                const destination = isExternal ? t.externalUrl : t.targetMap;
                const borderColor = spawnSet ? (isExternal ? '#0cc' : '#f4f') : '#f80';
                return `<div style="background:#333; padding:8px; margin-bottom:4px; border-radius:3px; border-left:3px solid ${borderColor};">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <span>${typeIcon} <b>Door ${doorNum}</b> → ${destination}</span>
                        <button onclick="deleteTrigger(${globalIdx})" style="background:#a33; padding:2px 6px; font-size:10px;">x</button>
                    </div>
                    <div style="font-size:10px; color:#888; margin-top:4px;">
                        ${t.width}x${t.height} | ${spawnText}${t.animTiles && t.animTiles.length ? ' | anim:' + t.animTiles.length : ''}
                    </div>
                </div>`;
            }).join('');
        }

        // Prompt for new map name
        function promptNewMap() {
            const name = prompt('Enter new map name:');
            if (!name || !name.trim()) return;

            const cleanName = name.trim().toLowerCase().replace(/[^a-z0-9_-]/g, '_');
            if (maps[cleanName]) {
                alert('Map "' + cleanName + '" already exists');
                return;
            }

            // Save current map first
            saveCurrentMapState();

            // Create new map and switch to it
            createMapData(cleanName);
            broadcastEdit({ editType: 'addMap', mapName: cleanName });
            currentMapName = cleanName;
            loadMapState(maps[cleanName]);

            updateMapDropdowns();
            updateTriggerList();
            renderLayerList();
            renderMap();

            alert('Created and switched to map: ' + cleanName);
        }

        // Prompt to delete current map
        function promptDeleteMap() {
            if (getMapNames().length <= 1) {
                alert('Cannot delete the last map');
                return;
            }

            if (!confirm('Delete map "' + currentMapName + '"? This cannot be undone.')) {
                return;
            }

            const deletedName = currentMapName;
            deleteMap(deletedName);
            broadcastEdit({ editType: 'deleteMap', mapName: deletedName });
            updateMapDropdowns();
            updateTriggerList();
            renderMap();

            alert('Deleted map: ' + deletedName);
        }

        // Rename current map
        function promptRenameMap() {
            const oldName = currentMapName;
            const newName = prompt('Enter new name for map "' + oldName + '":', oldName);

            if (!newName || !newName.trim()) return;

            const cleanName = newName.trim().toLowerCase().replace(/[^a-z0-9_-]/g, '_');

            if (cleanName === oldName) return; // No change

            if (maps[cleanName]) {
                alert('Map "' + cleanName + '" already exists');
                return;
            }

            // Rename in maps object
            maps[cleanName] = maps[oldName];
            delete maps[oldName];

            // Update placedTriggers
            placedTriggers.forEach(t => {
                if (t.mapName === oldName) t.mapName = cleanName;
                if (t.targetMap === oldName) t.targetMap = cleanName;
            });

            // Update placedNpcs
            placedNpcs.forEach(npc => {
                if (npc.mapName === oldName) npc.mapName = cleanName;
            });

            // Update tileSounds keys
            const oldSoundKeys = Object.keys(tileSounds).filter(k => k.startsWith(oldName + ':'));
            oldSoundKeys.forEach(oldKey => {
                const newKey = cleanName + ':' + oldKey.substring(oldName.length + 1);
                tileSounds[newKey] = tileSounds[oldKey];
                delete tileSounds[oldKey];
            });

            // Update pointLights keys
            const oldLightKeys = Object.keys(pointLights).filter(k => k.startsWith(oldName + ':'));
            oldLightKeys.forEach(oldKey => {
                const newKey = cleanName + ':' + oldKey.substring(oldName.length + 1);
                pointLights[newKey] = pointLights[oldKey];
                delete pointLights[oldKey];
            });

            // Update currentMapName
            currentMapName = cleanName;

            // Update spawnMapName if it matches
            if (spawnMapName === oldName) {
                spawnMapName = cleanName;
            }

            // Sync to other builders
            broadcastEdit({ editType: 'renameMap', oldName: oldName, newName: cleanName });

            // Update UI
            updateMapDropdowns();
            updateTriggerList();
            renderMap();

            console.log('[RENAME] Map renamed: "' + oldName + '" → "' + cleanName + '"');
        }

        // Update door number dropdown to only show available numbers
        function updateDoorNumberDropdown() {
            const select = document.getElementById('triggerDoorNumber');
            if (!select) return;

            const usedNumbers = placedTriggers.map(t => t.doorNumber);

            select.innerHTML = '';
            for (let i = 1; i <= 10; i++) {
                if (!usedNumbers.includes(i)) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = 'Door ' + i;
                    select.appendChild(option);
                }
            }

            // If all doors used, show message
            if (select.options.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'All doors used!';
                select.appendChild(option);
            }
        }

        // Door modal state
        let pendingDoorX = 0;
        let pendingDoorY = 0;
        let pendingDoorNumber = 1;
        let selectedWalkDirection = 'down'; // Default walk direction
        let useWalkOutPoint = false; // Whether to set walk-out destination by clicking
        let settingWalkOutPoint = false; // Currently in walk-out setting mode
        let pendingWalkOutTrigger = null; // Trigger waiting for walk-out point

        // Door animation state
        let selectingAnimTiles = false; // Selecting which tiles to swap
        let paintingAnimTiles = false; // Painting replacement tiles
        let pendingAnimTrigger = null; // Trigger being set up for animation
        let selectedAnimTiles = []; // Array of {x, y, layer, tileData} for selected tiles
        let doorAnimMapName = null; // Which map the door animation is being set up on

        // Update door animation panel visibility and hide extra UI
        function updateDoorAnimPanel() {
            const panel = document.getElementById('doorAnimPanel');
            const selectMode = document.getElementById('doorAnimSelectMode');
            const paintMode = document.getElementById('doorAnimPaintMode');

            // Elements to hide during door animation mode
            const hideElements = [
                'tileNormalUI',      // Selected tile + transform
                'tileExtraButtons',  // Select Tiles button
                'tileCopyCollision', // Copy from Map + Edit Collisions
                'tileLayerAdd',      // + Add Layer button
                'tilePlayerSprite'   // Player sprite section
            ];

            const inDoorAnimMode = selectingAnimTiles || paintingAnimTiles;

            // Show/hide extra UI elements
            hideElements.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = inDoorAnimMode ? 'none' : 'block';
            });

            // Hide mode tabs and main toolbar during door animation
            const modeTabs = document.getElementById('modeTabs');
            if (modeTabs) modeTabs.style.display = inDoorAnimMode ? 'none' : 'flex';

            const mainToolbar = document.getElementById('mainToolbar');
            if (mainToolbar) mainToolbar.style.display = inDoorAnimMode ? 'none' : 'flex';

            if (selectingAnimTiles) {
                panel.style.display = 'block';
                selectMode.style.display = 'block';
                paintMode.style.display = 'none';
            } else if (paintingAnimTiles) {
                panel.style.display = 'block';
                selectMode.style.display = 'none';
                paintMode.style.display = 'block';
            } else {
                panel.style.display = 'none';
                selectMode.style.display = 'none';
                paintMode.style.display = 'none';
            }
        }

        // Update modal options visibility based on door type
        function updateDoorModalOptions() {
            const doorType = document.getElementById('doorModalType').value;
            const walkoverOptions = document.getElementById('walkoverOptions');
            const interactOptions = document.getElementById('interactOptions');
            const externalOptions = document.getElementById('externalOptions');
            const mapSelectDiv = document.getElementById('doorMapSelectDiv');
            const confirmBtn = document.getElementById('doorModalConfirmBtn');

            walkoverOptions.style.display = doorType === 'walkover' ? 'block' : 'none';
            interactOptions.style.display = doorType === 'interact' ? 'block' : 'none';
            externalOptions.style.display = doorType === 'external' ? 'block' : 'none';

            // Hide map selector for external doors (they don't need a target map)
            if (mapSelectDiv) mapSelectDiv.style.display = doorType === 'external' ? 'none' : 'block';

            // Change confirm button text and color
            if (confirmBtn) {
                if (doorType === 'external') {
                    confirmBtn.textContent = 'Create Door';
                    confirmBtn.style.background = '#0cc';
                } else {
                    confirmBtn.textContent = 'Set Spawn →';
                    confirmBtn.style.background = '#4af';
                }
            }
        }

        // Toggle between walk-out point mode and direction mode
        function toggleWalkOutMode() {
            useWalkOutPoint = document.getElementById('useWalkOutPoint').checked;
            const dirOptions = document.getElementById('walkDirectionOptions');
            dirOptions.style.display = useWalkOutPoint ? 'none' : 'block';
        }

        // Set walk direction for walkover doors
        function setWalkDirection(dir) {
            selectedWalkDirection = dir;
            // Uncheck walk-out point if direction is selected
            document.getElementById('useWalkOutPoint').checked = false;
            useWalkOutPoint = false;
            document.getElementById('walkDirectionOptions').style.display = 'block';

            // Update button styles
            ['up', 'down', 'left', 'right'].forEach(d => {
                const btn = document.getElementById('walkDir' + d.charAt(0).toUpperCase() + d.slice(1));
                if (btn) {
                    btn.style.background = d === dir ? '#4af' : '#444';
                    btn.style.color = d === dir ? '#000' : '#fff';
                }
            });
        }

        // Show door map selection modal
        function showDoorMapModal(x, y, doorNumber) {
            pendingDoorX = x;
            pendingDoorY = y;
            pendingDoorNumber = doorNumber;

            // Update modal title
            document.getElementById('doorModalNumber').textContent = doorNumber;

            // Populate dropdown with other maps
            const select = document.getElementById('doorMapSelect');
            const otherMaps = Object.keys(maps).filter(m => m !== currentMapName);

            select.innerHTML = '';
            if (otherMaps.length === 0) {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = '(No other maps - create one below)';
                select.appendChild(opt);
            } else {
                otherMaps.forEach(mapName => {
                    const opt = document.createElement('option');
                    opt.value = mapName;
                    opt.textContent = mapName;
                    select.appendChild(opt);
                });
            }

            // Clear new map input
            document.getElementById('doorNewMapName').value = '';

            // Reset door options to defaults
            document.getElementById('doorModalType').value = 'walkover';
            document.getElementById('doorWalkDuration').value = '0.5';
            document.getElementById('doorFadeDuration').value = '0.5';
            document.getElementById('useWalkOutPoint').checked = false;
            useWalkOutPoint = false;
            document.getElementById('walkDirectionOptions').style.display = 'block';
            selectedWalkDirection = 'down';
            setWalkDirection('down');
            updateDoorModalOptions();

            // Show modal
            document.getElementById('doorMapModal').style.display = 'flex';
        }

        function closeDoorMapModal() {
            document.getElementById('doorMapModal').style.display = 'none';
            // Reset pending trigger state
            pendingTriggerWidth = 1;
            pendingTriggerHeight = 1;
            useWalkOutPoint = false;
            settingWalkOutPoint = false;
            pendingWalkOutTrigger = null;
        }

        function confirmDoorMapModal() {
            // Get selected or new map
            let targetMap = document.getElementById('doorNewMapName').value.trim();
            const doorType = document.getElementById('doorModalType').value;
            const isExternal = doorType === 'external';

            // Handle external doors (link to another HTML file)
            if (isExternal) {
                const externalUrl = document.getElementById('externalDestination').value;
                const trigger = {
                    x: pendingDoorX,
                    y: pendingDoorY,
                    width: pendingTriggerWidth,
                    height: pendingTriggerHeight,
                    mapName: currentMapName,
                    doorNumber: pendingDoorNumber,
                    type: 'door',
                    doorType: 'external',
                    externalUrl: externalUrl,
                    fadeDuration: parseFloat(document.getElementById('doorFadeDuration').value),
                    returnX: null,  // Return spawn point (set by clicking on map)
                    returnY: null
                };
                pendingTriggerWidth = 1;
                pendingTriggerHeight = 1;

                console.log('=== EXTERNAL DOOR PLACED ===');
                console.log('[DOOR] Door ' + pendingDoorNumber + ' at (' + pendingDoorX + ', ' + pendingDoorY + ') -> "' + externalUrl + '"');

                placedTriggers.push(trigger);
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'placeTrigger', trigger: trigger });
                updateTriggerList();
                updateDoorNumberDropdown();
                closeDoorMapModal();

                // Now set return spawn point (stay on same map)
                pendingTriggerForSpawn = trigger;
                pendingTriggerForSpawn.isExternalReturn = true; // Flag for special handling
                spawnSourceMap = currentMapName;
                settingSpawnPoint = true;
                setMode('trigger');
                renderMap();
                return;
            }

            if (!targetMap) {
                targetMap = document.getElementById('doorMapSelect').value;
            }

            if (!targetMap) {
                alert('Please select a map or enter a new map name');
                return;
            }

            const cleanMapName = targetMap.toLowerCase().replace(/[^a-z0-9_-]/g, '_');

            // Create target map if it doesn't exist
            if (!maps[cleanMapName]) {
                createMapData(cleanMapName);
                broadcastEdit({ editType: 'addMap', mapName: cleanMapName });
                updateMapDropdowns();
            }

            const isWalkOver = doorType === 'walkover';
            const isInteract = doorType === 'interact';
            const useDoorAnim = isInteract && document.getElementById('useDoorAnimation').checked;
            const trigger = {
                x: pendingDoorX,
                y: pendingDoorY,
                width: pendingTriggerWidth,
                height: pendingTriggerHeight,
                mapName: currentMapName,
                targetMap: cleanMapName,
                targetX: null,
                targetY: null,
                doorNumber: pendingDoorNumber,
                type: 'door',
                doorType: doorType, // 'walkover' or 'interact'
                // Walkover properties
                walkOutX: null, // Will be set if useWalkOutPoint is true
                walkOutY: null,
                walkDirection: isWalkOver && !useWalkOutPoint ? selectedWalkDirection : null,
                walkDuration: isWalkOver && !useWalkOutPoint ? parseFloat(document.getElementById('doorWalkDuration').value) : 0,
                fadeDuration: parseFloat(document.getElementById('doorFadeDuration').value),
                // Door animation properties (for interact doors)
                animTiles: useDoorAnim ? [] : null // Array of {x, y, layer} tiles to hide on open
            };
            // Reset for next trigger
            pendingTriggerWidth = 1;
            pendingTriggerHeight = 1;

            console.log('=== DOOR PLACED ===');
            console.log('[DOOR] Door ' + pendingDoorNumber + ' at (' + pendingDoorX + ', ' + pendingDoorY + ') -> "' + cleanMapName + '"');

            placedTriggers.push(trigger);
            // Broadcast to co-op builders
            broadcastEdit({ editType: 'placeTrigger', trigger: trigger });
            updateTriggerList();
            updateDoorNumberDropdown();

            // Close modal
            closeDoorMapModal();

            // If walk-out point mode, stay on this map to set walk-out first
            if (isWalkOver && useWalkOutPoint) {
                settingWalkOutPoint = true;
                pendingWalkOutTrigger = trigger;
                pendingTriggerForSpawn = trigger;
                spawnSourceMap = currentMapName;
                renderMap();
                return;
            }

            // If door animation mode, mark trigger for anim setup after spawn is set
            if (useDoorAnim) {
                trigger.needsAnimSetup = true;
                console.log('[DOOR ANIM] Marked trigger for anim setup, needsAnimSetup =', trigger.needsAnimSetup);
            }

            // Go to target map to set spawn
            pendingTriggerForSpawn = trigger;
            spawnSourceMap = currentMapName;
            settingSpawnPoint = true;
            setMode('trigger'); // Ensure trigger mode for spawn click
            switchToMap(cleanMapName);
            renderMap();
        }

        // Place a trigger at the given tile position
        function placeTriggerAt(x, y) {
            // Auto-select next available door number
            const usedNumbers = placedTriggers.map(t => t.doorNumber);
            let doorNumber = null;
            for (let i = 1; i <= 10; i++) {
                if (!usedNumbers.includes(i)) {
                    doorNumber = i;
                    break;
                }
            }

            if (doorNumber === null) {
                alert('All door numbers (1-10) are in use! Delete an existing door first.');
                return;
            }

            // Show modal to select target map
            showDoorMapModal(x, y, doorNumber);
        }

        // Delete a trigger by index
        function deleteTrigger(index) {
            if (index >= 0 && index < placedTriggers.length) {
                placedTriggers.splice(index, 1);
                // Broadcast to co-op builders
                broadcastEdit({ editType: 'removeTrigger', index: index });
                updateTriggerList();
                updateDoorNumberDropdown();
                renderMap();
            }
        }

        // Remove trigger at position (for right-click)
        function removeTriggerAt(x, y) {
            const idx = placedTriggers.findIndex(t =>
                t.mapName === currentMapName &&
                x >= t.x && x < t.x + t.width &&
                y >= t.y && y < t.y + t.height
            );
            if (idx >= 0) {
                deleteTrigger(idx);
            }
        }

        // Set spawn point at clicked location
        function setSpawnPointAt(x, y) {
            // Update the pending trigger directly
            if (pendingTriggerForSpawn) {
                // Check if this is an external door return spawn
                if (pendingTriggerForSpawn.isExternalReturn) {
                    pendingTriggerForSpawn.returnX = x;
                    pendingTriggerForSpawn.returnY = y;
                    delete pendingTriggerForSpawn.isExternalReturn; // Clean up temp flag
                    console.log('=== EXTERNAL RETURN SPAWN PLACED ===');
                    console.log('[SPAWN] Door', pendingTriggerForSpawn.doorNumber, 'RETURN spawn set at (' + x + ', ' + y + ') on "' + currentMapName + '"');
                } else {
                    pendingTriggerForSpawn.targetX = x;
                    pendingTriggerForSpawn.targetY = y;
                    console.log('=== SPAWN PLACED ===');
                    console.log('[SPAWN] Door', pendingTriggerForSpawn.doorNumber, 'spawn set at (' + x + ', ' + y + ') on "' + currentMapName + '"');
                }
                // Sync the trigger update
                const triggerIndex = placedTriggers.indexOf(pendingTriggerForSpawn);
                if (triggerIndex >= 0) {
                    broadcastEdit({ editType: 'updateTrigger', index: triggerIndex, trigger: pendingTriggerForSpawn });
                }
            }

            // Check if this trigger needs animation setup
            const needsAnim = pendingTriggerForSpawn && pendingTriggerForSpawn.needsAnimSetup;
            const triggerForAnim = pendingTriggerForSpawn;
            const isExternalDoor = pendingTriggerForSpawn && pendingTriggerForSpawn.doorType === 'external';
            console.log('[DOOR ANIM] In setSpawnPointAt, needsAnim =', needsAnim, 'trigger.needsAnimSetup =', pendingTriggerForSpawn?.needsAnimSetup);

            // Exit spawn setting mode
            settingSpawnPoint = false;
            const returnMap = spawnSourceMap;
            spawnSourceMap = null;
            pendingTriggerForSpawn = null;

            // Auto-return to source map (but not for external doors - we're already on the right map)
            if (returnMap && !isExternalDoor) {
                switchToMap(returnMap);
            }

            // If needs animation setup, start tile selection mode
            if (needsAnim && triggerForAnim) {
                triggerForAnim.needsAnimSetup = false;
                triggerForAnim.animTiles = [];
                pendingAnimTrigger = triggerForAnim;
                selectingAnimTiles = true;
                selectedAnimTiles = [];
                doorAnimMapName = currentMapName; // Track which map we're editing
                console.log('[DOOR ANIM] Starting tile selection for door', triggerForAnim.doorNumber);
                setMode('tile'); // Switch to tile mode for layer controls + palette
                updateDoorAnimPanel();
            } else {
                console.log('[DOOR ANIM] NOT starting tile selection. needsAnim =', needsAnim, 'triggerForAnim =', triggerForAnim);
            }

            renderMap();
        }

        // Set walk-out point at clicked location (where player walks TO before fade)
        function setWalkOutPointAt(x, y) {
            if (pendingWalkOutTrigger) {
                pendingWalkOutTrigger.walkOutX = x;
                pendingWalkOutTrigger.walkOutY = y;
                console.log('=== WALK-OUT POINT SET ===');
                console.log('[WALK-OUT] Door', pendingWalkOutTrigger.doorNumber, 'walk-out at (' + x + ', ' + y + ')');
            }

            // Exit walk-out setting mode
            settingWalkOutPoint = false;
            pendingWalkOutTrigger = null;

            // Now switch to target map to set spawn
            if (pendingTriggerForSpawn) {
                settingSpawnPoint = true;
                switchToMap(pendingTriggerForSpawn.targetMap);
            }
            renderMap();
        }

        // Toggle a tile in the animation selection
        function toggleAnimTileSelection(x, y) {
            // Check if already selected on current layer
            const idx = selectedAnimTiles.findIndex(t => t.x === x && t.y === y && t.layer === currentLayer);
            if (idx >= 0) {
                // Remove it
                selectedAnimTiles.splice(idx, 1);
                console.log('[DOOR ANIM] Deselected tile at', x, y, 'layer', currentLayer);
            } else {
                // Add it - capture current tile data from current layer
                const tileData = (layers[currentLayer] && layers[currentLayer][y] && layers[currentLayer][y][x])
                    ? JSON.parse(JSON.stringify(layers[currentLayer][y][x])) : null;
                selectedAnimTiles.push({
                    x, y,
                    layer: currentLayer,
                    before: tileData
                });
                console.log('[DOOR ANIM] Selected tile at', x, y, 'layer', currentLayer);
            }
            renderMap();
        }

        // Finish tile selection, move to painting mode
        function finishTileSelection() {
            if (selectedAnimTiles.length === 0) {
                alert('Select at least one tile to animate');
                return;
            }

            // Erase the selected tiles so user can paint replacements
            selectedAnimTiles.forEach(tile => {
                if (layers[tile.layer] && layers[tile.layer][tile.y]) {
                    layers[tile.layer][tile.y][tile.x] = null;
                }
            });

            selectingAnimTiles = false;
            paintingAnimTiles = true;
            setMode('tile'); // Switch to tile mode for painting
            console.log('[DOOR ANIM] Moved to paint mode with', selectedAnimTiles.length, 'tiles');
            updateDoorAnimPanel();
            renderMap();
        }

        // Finish painting, save the animation
        function finishAnimPainting() {
            // Capture the "after" state for each selected tile position
            const animChanges = [];
            selectedAnimTiles.forEach(tile => {
                const afterData = (layers[tile.layer] && layers[tile.layer][tile.y] && layers[tile.layer][tile.y][tile.x])
                    ? JSON.parse(JSON.stringify(layers[tile.layer][tile.y][tile.x])) : null;
                animChanges.push({
                    x: tile.x,
                    y: tile.y,
                    layer: tile.layer,
                    before: tile.before,
                    after: afterData
                });
            });

            // Restore the "before" tiles (door starts closed)
            selectedAnimTiles.forEach(tile => {
                if (!layers[tile.layer]) layers[tile.layer] = [];
                if (!layers[tile.layer][tile.y]) layers[tile.layer][tile.y] = [];
                layers[tile.layer][tile.y][tile.x] = tile.before;
            });

            // Save to trigger
            if (pendingAnimTrigger) {
                pendingAnimTrigger.animTiles = animChanges;
                console.log('=== DOOR ANIM SAVED ===');
                console.log('[DOOR ANIM] Door', pendingAnimTrigger.doorNumber, 'has', animChanges.length, 'tile swaps');
            }

            // Reset state
            paintingAnimTiles = false;
            pendingAnimTrigger = null;
            selectedAnimTiles = [];
            doorAnimMapName = null;
            updateDoorAnimPanel();
            renderMap();
        }

        // ===== CAMERA BOUNDS =====
        let settingCameraBounds = false;
        let cameraBoundsDragStart = null;
        let cameraBoundsDragEnd = null;

        function toggleCameraBoundsMode() {
            settingCameraBounds = !settingCameraBounds;
            const btn = document.getElementById('setCameraBoundsBtn');
            if (settingCameraBounds) {
                btn.textContent = '✓ Done';
                btn.style.background = '#8a4';
            } else {
                btn.textContent = 'Set Bounds';
                btn.style.background = '#484';
                cameraBoundsDragStart = null;
                cameraBoundsDragEnd = null;
            }
            updateCameraBoundsInfo();
            renderMap();
        }

        function clearCameraBounds(fromNetwork = false) {
            cameraBounds = null;
            cameraBoundsDragStart = null;
            cameraBoundsDragEnd = null;
            settingCameraBounds = false;
            document.getElementById('setCameraBoundsBtn').textContent = 'Set Bounds';
            document.getElementById('setCameraBoundsBtn').style.background = '#484';
            if (!fromNetwork) {
                broadcastEdit({ editType: 'cameraBounds', bounds: null, mapName: currentMapName });
            }
            updateCameraBoundsInfo();
            renderMap();
        }

        function setCameraBoundsFromDrag() {
            if (!cameraBoundsDragStart || !cameraBoundsDragEnd) return;

            const x1 = Math.min(cameraBoundsDragStart.x, cameraBoundsDragEnd.x);
            const y1 = Math.min(cameraBoundsDragStart.y, cameraBoundsDragEnd.y);
            const x2 = Math.max(cameraBoundsDragStart.x, cameraBoundsDragEnd.x);
            const y2 = Math.max(cameraBoundsDragStart.y, cameraBoundsDragEnd.y);

            if (cameraBounds) {
                // Expand existing bounds to include new selection
                const oldX2 = cameraBounds.x + cameraBounds.width - 1;
                const oldY2 = cameraBounds.y + cameraBounds.height - 1;
                const newX1 = Math.min(cameraBounds.x, x1);
                const newY1 = Math.min(cameraBounds.y, y1);
                const newX2 = Math.max(oldX2, x2);
                const newY2 = Math.max(oldY2, y2);

                cameraBounds = {
                    x: newX1,
                    y: newY1,
                    width: newX2 - newX1 + 1,
                    height: newY2 - newY1 + 1
                };
            } else {
                // First selection
                cameraBounds = {
                    x: x1,
                    y: y1,
                    width: x2 - x1 + 1,
                    height: y2 - y1 + 1
                };
            }

            console.log('Camera bounds expanded:', cameraBounds);
            broadcastEdit({ editType: 'cameraBounds', bounds: cameraBounds, mapName: currentMapName });

            // Stay in bounds mode for more selections
            cameraBoundsDragStart = null;
            cameraBoundsDragEnd = null;
            updateCameraBoundsInfo();
            renderMap();
        }

        function updateCameraBoundsInfo() {
            const info = document.getElementById('cameraBoundsInfo');
            if (!info) return;

            if (settingCameraBounds) {
                if (cameraBounds) {
                    info.innerHTML = `${cameraBounds.width}x${cameraBounds.height} tiles - drag to expand`;
                } else {
                    info.innerHTML = 'Drag on map to select area';
                }
                info.style.color = '#fa0';
            } else if (cameraBounds) {
                info.innerHTML = `Bounds: ${cameraBounds.width}x${cameraBounds.height} tiles`;
                info.style.color = '#8f8';
            } else {
                info.innerHTML = 'No bounds (camera follows player)';
                info.style.color = '#aaa';
            }
        }

        // ===== DIALOG SYSTEM =====
        const dialogStylePresets = {
            1: { name: 'Classic NES', bg: '#000000', border: '#ffffff', text: '#ffffff', accent: '#ffffff', radius: 0, borderW: 4 },
            2: { name: 'Final Fantasy', bg: '#000088', border: '#ffffff', text: '#ffffff', accent: '#ffff00', radius: 0, borderW: 2 },
            3: { name: 'Pokemon', bg: '#f8f8f8', border: '#303030', text: '#303030', accent: '#e03030', radius: 8, borderW: 3 },
            4: { name: 'Earthbound', bg: '#000000', border: '#a080ff', text: '#ffffff', accent: '#ffff00', radius: 0, borderW: 2 },
            5: { name: 'Chrono Trigger', bg: '#1a1a4e', border: '#8888ff', text: '#ffffff', accent: '#ffcc00', radius: 4, borderW: 2 },
            6: { name: 'Modern Pixel', bg: '#2d2d2d', border: '#4a9eff', text: '#ffffff', accent: '#4a9eff', radius: 6, borderW: 2 }
        };

        let dialogEditorPages = [{ speaker: '', text: '' }];
        let dialogEditorPageIndex = 0;
        let dialogEditingIndex = -1; // -1 = new dialog
        let dialogAutoAttachNpcIndex = -1; // NPC to auto-attach dialog to after saving

        // Add dialog to currently selected NPC - switches to dialog tab and opens editor
        function addDialogToSelectedNpc() {
            if (selectedPlacedNpcIndex < 0) {
                alert('No NPC selected! Select an NPC first.');
                return;
            }

            const npc = placedNpcs[selectedPlacedNpcIndex];
            const npcDef = npcs[npc.npcIndex];
            const npcName = npcDef?.name || 'NPC ' + selectedPlacedNpcIndex;

            // Store which NPC to attach to
            dialogAutoAttachNpcIndex = selectedPlacedNpcIndex;

            // Switch to dialog mode
            setMode('dialog');

            // Open dialog editor for new dialog with NPC name pre-filled
            openDialogEditor(-1);
            document.getElementById('dialogNameInput').value = npcName + ' Dialog';

            console.log('[DIALOG] Adding dialog for NPC:', npcName);
        }

        function openDialogEditor(index) {
            dialogEditingIndex = index;

            if (index >= 0 && dialogs[index]) {
                // Editing existing dialog
                const d = dialogs[index];
                document.getElementById('dialogNameInput').value = d.name || '';
                document.getElementById('dialogStyleSelect').value = d.style || 1;
                document.getElementById('dialogBgColor').value = d.colors?.background || '#000000';
                document.getElementById('dialogBorderColor').value = d.colors?.border || '#ffffff';
                document.getElementById('dialogTextColor').value = d.colors?.text || '#ffffff';
                document.getElementById('dialogAccentColor').value = d.colors?.accent || '#ffffff';
                document.getElementById('dialogWidth').value = d.width || 280;
                document.getElementById('dialogHeight').value = d.height || 80;
                dialogEditorPages = d.pages ? JSON.parse(JSON.stringify(d.pages)) : [{ speaker: '', text: '' }];
            } else {
                // New dialog
                document.getElementById('dialogNameInput').value = '';
                document.getElementById('dialogStyleSelect').value = '1';
                applyDialogStylePreset(1);
                document.getElementById('dialogWidth').value = 280;
                document.getElementById('dialogHeight').value = 80;
                dialogEditorPages = [{ speaker: '', text: '' }];
            }

            dialogEditorPageIndex = 0;
            loadDialogPage(0);
            updateDialogPagesListEditor();
            updateDialogPreview();

            document.getElementById('dialogModal').classList.add('visible');
        }

        function closeDialogEditor() {
            document.getElementById('dialogModal').classList.remove('visible');
            dialogAutoAttachNpcIndex = -1; // Reset auto-attach
        }

        function applyDialogStylePreset(style) {
            const preset = dialogStylePresets[style];
            if (preset) {
                document.getElementById('dialogBgColor').value = preset.bg;
                document.getElementById('dialogBorderColor').value = preset.border;
                document.getElementById('dialogTextColor').value = preset.text;
                document.getElementById('dialogAccentColor').value = preset.accent;
            }
        }

        function loadDialogPage(index) {
            // Save current page first
            if (dialogEditorPages[dialogEditorPageIndex]) {
                dialogEditorPages[dialogEditorPageIndex] = {
                    speaker: document.getElementById('dialogSpeaker').value,
                    text: document.getElementById('dialogTextInput').value
                };
            }

            dialogEditorPageIndex = index;
            const page = dialogEditorPages[index] || { speaker: '', text: '' };
            document.getElementById('dialogSpeaker').value = page.speaker || '';
            document.getElementById('dialogTextInput').value = page.text || '';
            updateDialogPagesListEditor();
            updateDialogPreview();
        }

        function selectDialogPageEditor(index) {
            loadDialogPage(index);
        }

        function addDialogPage() {
            // Save current page
            dialogEditorPages[dialogEditorPageIndex] = {
                speaker: document.getElementById('dialogSpeaker').value,
                text: document.getElementById('dialogTextInput').value
            };

            dialogEditorPages.push({ speaker: '', text: '' });
            loadDialogPage(dialogEditorPages.length - 1);
        }

        function removeCurrentDialogPage() {
            if (dialogEditorPages.length <= 1) {
                alert('Cannot delete the only page');
                return;
            }

            dialogEditorPages.splice(dialogEditorPageIndex, 1);
            if (dialogEditorPageIndex >= dialogEditorPages.length) {
                dialogEditorPageIndex = dialogEditorPages.length - 1;
            }
            loadDialogPage(dialogEditorPageIndex);
        }

        function updateDialogPagesListEditor() {
            const container = document.getElementById('dialogPagesList');
            container.innerHTML = dialogEditorPages.map((page, i) => {
                const active = i === dialogEditorPageIndex ? 'active' : '';
                const preview = (page.text || 'Empty').substring(0, 15);
                return `<div class="dialog-page ${active}" onclick="selectDialogPageEditor(${i})">${i + 1}</div>`;
            }).join('');
        }

        function updateDialogPreview() {
            const canvas = document.getElementById('dialogPreviewCanvas');
            if (!canvas) return;

            const width = parseInt(document.getElementById('dialogWidth').value) || 280;
            const height = parseInt(document.getElementById('dialogHeight').value) || 80;
            canvas.width = width;
            canvas.height = height;

            const ctx = canvas.getContext('2d');
            const bgColor = document.getElementById('dialogBgColor').value;
            const borderColor = document.getElementById('dialogBorderColor').value;
            const textColor = document.getElementById('dialogTextColor').value;
            const accentColor = document.getElementById('dialogAccentColor').value;
            const style = parseInt(document.getElementById('dialogStyleSelect').value);
            const preset = dialogStylePresets[style];

            // Draw background
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, width, height);

            // Draw border
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = preset?.borderW || 2;
            const radius = preset?.radius || 0;

            if (radius > 0) {
                ctx.beginPath();
                ctx.roundRect(2, 2, width - 4, height - 4, radius);
                ctx.stroke();
            } else {
                ctx.strokeRect(2, 2, width - 4, height - 4);
            }

            // Draw speaker name
            const speaker = document.getElementById('dialogSpeaker').value;
            const text = document.getElementById('dialogTextInput').value;

            ctx.font = '12px monospace';
            let y = 18;

            if (speaker) {
                ctx.fillStyle = accentColor;
                ctx.fillText(speaker, 12, y);
                y += 16;
            }

            // Draw text (simple word wrap)
            ctx.fillStyle = textColor;
            const words = text.split(' ');
            let line = '';
            const maxWidth = width - 24;

            for (const word of words) {
                const testLine = line + word + ' ';
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && line) {
                    ctx.fillText(line, 12, y);
                    line = word + ' ';
                    y += 14;
                    if (y > height - 10) break;
                } else {
                    line = testLine;
                }
            }
            if (y <= height - 10) {
                ctx.fillText(line, 12, y);
            }
        }

        function saveDialog() {
            // Save current page
            dialogEditorPages[dialogEditorPageIndex] = {
                speaker: document.getElementById('dialogSpeaker').value,
                text: document.getElementById('dialogTextInput').value
            };

            const name = document.getElementById('dialogNameInput').value.trim() || 'Dialog ' + (dialogs.length + 1);
            const style = parseInt(document.getElementById('dialogStyleSelect').value);

            const dialogData = {
                name: name,
                style: style,
                width: parseInt(document.getElementById('dialogWidth').value) || 280,
                height: parseInt(document.getElementById('dialogHeight').value) || 80,
                colors: {
                    background: document.getElementById('dialogBgColor').value,
                    border: document.getElementById('dialogBorderColor').value,
                    text: document.getElementById('dialogTextColor').value,
                    accent: document.getElementById('dialogAccentColor').value
                },
                pages: JSON.parse(JSON.stringify(dialogEditorPages))
            };

            if (dialogEditingIndex >= 0) {
                dialogs[dialogEditingIndex] = dialogData;
                broadcastEdit({ editType: 'updateDialog', index: dialogEditingIndex, dialog: dialogData });
            } else {
                dialogs.push(dialogData);
                broadcastEdit({ editType: 'addDialog', dialog: dialogData });

                // Auto-attach to NPC if we came from NPC panel
                if (dialogAutoAttachNpcIndex >= 0 && dialogAutoAttachNpcIndex < placedNpcs.length) {
                    const newDialogIndex = dialogs.length - 1;
                    placedNpcs[dialogAutoAttachNpcIndex].dialogIndex = newDialogIndex;
                    placedNpcs[dialogAutoAttachNpcIndex].dialogTrigger = 'interact'; // Default to interact trigger
                    broadcastEdit({ editType: 'attachNpcDialog', npcIndex: dialogAutoAttachNpcIndex, dialogIndex: newDialogIndex, dialogTrigger: 'interact' });
                    console.log('[DIALOG] Auto-attached dialog to NPC', dialogAutoAttachNpcIndex);
                    dialogAutoAttachNpcIndex = -1; // Reset
                }

                // Auto-attach to quest if we came from quest dialog picker
                if (typeof questDialogPickerType !== 'undefined' && questDialogPickerType) {
                    attachNewDialogToQuest(dialogs.length - 1);
                }
            }

            closeDialogEditor();
            updateDialogList();
            console.log('[DIALOG] Saved dialog:', name);
        }

        function deleteDialog(index) {
            if (!confirm('Delete dialog "' + dialogs[index].name + '"?')) return;

            // Check if any NPC uses this dialog
            const usedBy = placedNpcs.filter(n => n.dialogIndex === index);
            if (usedBy.length > 0) {
                alert('Cannot delete: This dialog is attached to ' + usedBy.length + ' NPC(s)');
                return;
            }

            dialogs.splice(index, 1);

            // Update NPC dialog references
            placedNpcs.forEach(n => {
                if (n.dialogIndex > index) n.dialogIndex--;
            });

            broadcastEdit({ editType: 'deleteDialog', index: index });
            updateDialogList();
        }

        function updateDialogList() {
            const container = document.getElementById('dialogList');
            if (!container) return;

            if (dialogs.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:12px; text-align:center; padding:20px;">No dialogs created yet</div>';
                return;
            }

            // Gather info about each dialog
            const dialogInfo = dialogs.map((d, i) => {
                const pageCount = d.pages?.length || 1;
                const attachedTo = [];
                const questUsage = [];

                // Check which NPCs use this dialog
                placedNpcs.forEach((n, npcIdx) => {
                    if (n.dialogIndex === i) {
                        const npcDef = npcs[n.npcIndex];
                        const npcName = npcDef?.name || 'NPC ' + npcIdx;
                        const trigger = n.dialogTrigger === 'auto' ? ' (auto)' : '';
                        attachedTo.push('NPC: ' + npcName + trigger);
                    }
                });

                // Check which signs use this dialog
                placedDialogTiles.forEach((tile, tileIdx) => {
                    if (tile.dialogIndex === i) {
                        attachedTo.push('Sign at (' + tile.x + ',' + tile.y + ')');
                    }
                });

                // Check which quests use this dialog
                quests.forEach(quest => {
                    if (parseInt(quest.startDialogId) === i) {
                        questUsage.push({ quest: quest.name || quest.id, type: 'Start' });
                    }
                    if (parseInt(quest.activeDialogId) === i) {
                        questUsage.push({ quest: quest.name || quest.id, type: 'Active' });
                    }
                    if (parseInt(quest.completeDialogId) === i) {
                        questUsage.push({ quest: quest.name || quest.id, type: 'Complete' });
                    }
                });

                return {
                    dialog: d,
                    index: i,
                    pageCount,
                    attachedTo,
                    questUsage,
                    isQuestDialog: questUsage.length > 0
                };
            });

            // Separate into quest dialogs and regular dialogs
            const questDialogs = dialogInfo.filter(d => d.isQuestDialog);
            const regularDialogs = dialogInfo.filter(d => !d.isQuestDialog);

            let html = '';

            // Quest Dialogs section
            if (questDialogs.length > 0) {
                html += '<div style="font-size:11px; color:#fa0; font-weight:bold; margin:8px 0 4px 0; border-bottom:1px solid #fa0; padding-bottom:2px;">QUEST DIALOGS</div>';
                html += questDialogs.map(info => renderDialogItem(info)).join('');
            }

            // Regular Dialogs section
            if (regularDialogs.length > 0) {
                html += '<div style="font-size:11px; color:#8cf; font-weight:bold; margin:8px 0 4px 0; border-bottom:1px solid #8cf; padding-bottom:2px;">REGULAR DIALOGS</div>';
                html += regularDialogs.map(info => renderDialogItem(info)).join('');
            }

            container.innerHTML = html;

            // Also update the dialog dropdown for attaching
            updateDialogDropdown();
            updateDialogTileDropdown();
            updatePlacedDialogTilesList();
        }

        function renderDialogItem(info) {
            const { dialog, index, pageCount, attachedTo, questUsage, isQuestDialog } = info;
            const isSelected = currentDialogTileIndex === index;
            const bgColor = isSelected ? '#4a7c59' : '#333';
            const borderStyle = isSelected ? '2px solid #8f8' : '2px solid transparent';

            // Build usage text
            let usageText = '';
            if (questUsage.length > 0) {
                usageText = questUsage.map(q => q.quest + ' (' + q.type + ')').join(', ');
            } else if (attachedTo.length > 0) {
                usageText = attachedTo.join(', ');
            } else {
                usageText = '<span style="color:#f88;">Not attached</span>';
            }

            return `<div onclick="selectDialogForPlacement(${index})" style="display:flex; align-items:center; gap:8px; padding:8px; margin-bottom:5px; background:${bgColor}; border-radius:4px; cursor:pointer; border:${borderStyle};">
                <div style="flex:1; min-width:0;">
                    <div style="font-size:12px; color:#fff; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${dialog.name}</div>
                    <div style="font-size:10px; color:#888;">${pageCount} page${pageCount > 1 ? 's' : ''}${isSelected ? ' - SELECTED' : ''}</div>
                    <div style="font-size:9px; color:#aaa; margin-top:2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${usageText}</div>
                </div>
                <button onclick="event.stopPropagation(); openDialogEditor(${index})" style="padding:4px 8px; font-size:11px; background:#448;">Edit</button>
                <button onclick="event.stopPropagation(); deleteDialog(${index})" style="padding:4px 8px; font-size:11px; background:#644;">X</button>
            </div>`;
        }

        function updateDialogDropdown() {
            const select = document.getElementById('dialogToAttach');
            if (!select) return;

            select.innerHTML = '<option value="">Select a dialog...</option>' +
                dialogs.map((d, i) => `<option value="${i}">${d.name}</option>`).join('');
        }

        function updateDialogNpcDropdown() {
            const select = document.getElementById('dialogNpcSelect');
            if (!select) return;

            select.innerHTML = '<option value="">Select an NPC...</option>' +
                placedNpcs.map((n, i) => {
                    const npcDef = npcs[n.npcIndex];
                    const name = npcDef?.name || 'NPC ' + i;
                    const hasDialog = n.dialogIndex >= 0 ? ' (has dialog)' : '';
                    return `<option value="${i}">${name}${hasDialog}</option>`;
                }).join('');
        }

        function attachDialogToNpc() {
            const npcIdx = parseInt(document.getElementById('dialogNpcSelect').value);
            const dialogIdx = parseInt(document.getElementById('dialogToAttach').value);
            const triggerType = document.getElementById('dialogNpcTrigger').value;

            if (isNaN(npcIdx) || npcIdx < 0) {
                alert('Please select an NPC');
                return;
            }
            if (isNaN(dialogIdx) || dialogIdx < 0) {
                alert('Please select a dialog');
                return;
            }

            placedNpcs[npcIdx].dialogIndex = dialogIdx;
            placedNpcs[npcIdx].dialogTrigger = triggerType; // 'interact' or 'auto'
            broadcastEdit({ editType: 'attachNpcDialog', npcIndex: npcIdx, dialogIndex: dialogIdx, dialogTrigger: triggerType });

            alert('Dialog attached to NPC!');
            updateDialogNpcDropdown();
        }

        // ===== DIALOG TILE PLACEMENT (Signs) =====
        function selectDialogForPlacement(index) {
            // Toggle selection
            if (currentDialogTileIndex === index) {
                currentDialogTileIndex = -1; // Deselect
            } else {
                currentDialogTileIndex = index;
            }
            updateDialogList();
            // Also update dropdown if it exists
            const select = document.getElementById('dialogTileSelect');
            if (select) select.value = currentDialogTileIndex;
        }

        function selectDialogForTile(value) {
            currentDialogTileIndex = parseInt(value);
            updateDialogList();
        }

        function updateDialogTileDropdown() {
            const select = document.getElementById('dialogTileSelect');
            if (!select) return;
            select.innerHTML = '<option value="-1">Select a dialog...</option>' +
                dialogs.map((d, i) => `<option value="${i}">${d.name}</option>`).join('');
            select.value = currentDialogTileIndex;
        }

        function updatePlacedDialogTilesList() {
            const list = document.getElementById('placedDialogTilesList');
            if (!list) return;

            const tilesOnMap = placedDialogTiles.filter(t => t.mapName === currentMapName);
            if (tilesOnMap.length === 0) {
                list.innerHTML = '<div style="color:#666; font-size:11px; text-align:center; padding:10px;">No dialog tiles placed</div>';
                return;
            }

            list.innerHTML = tilesOnMap.map((t, i) => {
                const globalIdx = placedDialogTiles.indexOf(t);
                const dialogName = dialogs[t.dialogIndex]?.name || 'Unknown';
                return `<div style="display:flex; justify-content:space-between; align-items:center; padding:4px; margin:2px 0; background:#333; border-radius:3px; font-size:11px;">
                    <span>(${t.x}, ${t.y}) - ${dialogName}</span>
                    <button onclick="removeDialogTileByIndex(${globalIdx})" style="padding:2px 6px; font-size:10px; background:#a33;">x</button>
                </div>`;
            }).join('');
        }

        function placeDialogTileAt(x, y) {
            if (currentDialogTileIndex < 0) {
                alert('Select a dialog first');
                return;
            }

            // Check if already has dialog tile at this position
            const existing = findDialogTileAt(x, y);
            if (existing >= 0) {
                // Update existing
                placedDialogTiles[existing].dialogIndex = currentDialogTileIndex;
                broadcastEdit({ editType: 'updateDialogTile', index: existing, tile: placedDialogTiles[existing] });
            } else {
                // Add new
                const tile = { x, y, mapName: currentMapName, dialogIndex: currentDialogTileIndex };
                placedDialogTiles.push(tile);
                broadcastEdit({ editType: 'placeDialogTile', tile });
            }

            updatePlacedDialogTilesList();
            renderMap();
        }

        function removeDialogTileAt(x, y) {
            const idx = findDialogTileAt(x, y);
            if (idx >= 0) {
                placedDialogTiles.splice(idx, 1);
                broadcastEdit({ editType: 'removeDialogTile', index: idx });
                updatePlacedDialogTilesList();
                renderMap();
            }
        }

        function removeDialogTileByIndex(idx) {
            if (idx >= 0 && idx < placedDialogTiles.length) {
                placedDialogTiles.splice(idx, 1);
                broadcastEdit({ editType: 'removeDialogTile', index: idx });
                updatePlacedDialogTilesList();
                renderMap();
            }
        }

        function findDialogTileAt(x, y) {
            return placedDialogTiles.findIndex(t => t.x === x && t.y === y && t.mapName === currentMapName);
        }

        // ===== TEST MAP =====
        let testLogs = []; // Logs saved to localStorage for crash recovery

        function logTestEvent(msg, type = 'info') {
            const entry = { time: Date.now(), msg, type };
            testLogs.push(entry);
            localStorage.setItem('testGameCrashLog', JSON.stringify(testLogs));
            console.log('[TestMap]', msg);

            // Add to visible console
            const logsDiv = document.getElementById('testConsoleLogs');
            if (logsDiv) {
                const time = new Date().toLocaleTimeString();
                const div = document.createElement('div');
                div.className = type;
                div.innerHTML = '<span class="time">' + time + '</span>' + msg;
                logsDiv.appendChild(div);
                logsDiv.scrollTop = logsDiv.scrollHeight; // Auto-scroll
            }
        }

        function openTestConsole() {
            const console = document.getElementById('testConsole');
            const logsDiv = document.getElementById('testConsoleLogs');
            if (console) console.classList.add('visible');
            if (logsDiv) logsDiv.innerHTML = ''; // Clear previous logs
        }

        function testMap() {
            // Open visible console and clear previous logs
            openTestConsole();
            testLogs = [];
            logTestEvent('Starting test game...');

            // Get current project data
            const projectDataForTest = getProjectData();
            // Add base URL so external doors can resolve relative paths
            projectDataForTest.baseUrl = window.location.href.replace(/\/[^\/]*$/, '/');
            if (launchAsAdventure) {
                projectDataForTest.autoHideUI = true;
            }
            // Add multiplayer settings if set
            if (multiplayerSettings) {
                projectDataForTest.multiplayer = {
                    playerName: multiplayerSettings.playerName,
                    roomCode: multiplayerSettings.roomCode
                };
                logTestEvent('Multiplayer: ' + multiplayerSettings.playerName + ' in room ' + multiplayerSettings.roomCode);
            }
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

            logTestEvent('Mobile: ' + isMobile + ', Sounds: ' + (projectDataForTest.sounds?.length || 0));

            // On mobile, strip sound data - will stream via postMessage
            let soundsToStream = [];
            if (isMobile && projectDataForTest.sounds && projectDataForTest.sounds.length > 0) {
                soundsToStream = projectDataForTest.sounds.map(s => ({ ...s }));
                projectDataForTest.sounds = projectDataForTest.sounds.map(s => ({
                    name: s.name, duration: s.duration, type: s.type
                }));
                projectDataForTest.soundsWillStream = true;
                logTestEvent('Stripped ' + soundsToStream.length + ' sounds for streaming');
            }

            const projectDataJSON = JSON.stringify(projectDataForTest);
            const dataSize = projectDataJSON.length;
            const sizeMB = (dataSize / 1000000).toFixed(1);
            logTestEvent('Project size: ' + sizeMB + 'MB');

            // Setup message listener for test game communication
            window.testGameData = { projectDataJSON, soundsToStream };
            window.onmessage = (e) => {
                if (e.data.type === 'log') {
                    logTestEvent('[Game] ' + e.data.msg, e.data.level || 'info');
                } else if (e.data.type === 'ready') {
                    logTestEvent('Test game ready, sending data...');
                    // Include builder room code so test game can auto-join multiplayer
                    const payload = { type: 'project-data', data: projectDataJSON };
                    if (builderConnected && builderRoomCode) {
                        payload.autoMultiplayer = {
                            roomCode: builderRoomCode,
                            playerName: builderPlayerName + '-tester'
                        };
                        // Also pass builder room for live sync of edits
                        payload.builderSync = {
                            roomCode: builderRoomCode
                        };
                    }
                    e.source.postMessage(payload, '*');
                    // Stream sounds with delay
                    if (soundsToStream.length > 0) {
                        streamSoundsToWindow(e.source, soundsToStream);
                    }
                }
            };

            logTestEvent('Opening test window...');

            // Create minimal loader HTML
            const loaderHTML = `
<!DOCTYPE html>
<html>
<head>
    <title>Map Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; }
        body { background: #000; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #debugPanel {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            min-width: 200px;
            display: none;
        }
        #debugPanel.visible { display: block; }
        #debugPanel h3 { margin: 0 0 10px 0; color: #4af; font-size: 14px; }
        #debugPanel label { display: block; margin: 8px 0 4px 0; color: #aaa; }
        #debugPanel input[type="range"] { width: 100%; }
        #debugPanel .value { color: #4f8; float: right; }
        #debugPanel button {
            margin-top: 10px;
            padding: 5px 10px;
            background: #4a7c59;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        #debugPanel button:hover { background: #5a9c69; }

        /* Performance overlay */
        #perfPanel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.85);
            padding: 10px 15px;
            border-radius: 8px;
            color: white;
            font-family: monospace;
            font-size: 11px;
            min-width: 180px;
            z-index: 1000;
            display: none;
            border: 1px solid #4af;
        }
        #perfPanel.visible { display: block; }
        #perfPanel h3 { margin: 0 0 8px 0; color: #4af; font-size: 12px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        #perfPanel .perf-row { display: flex; justify-content: space-between; margin: 3px 0; }
        #perfPanel .perf-label { color: #aaa; }
        #perfPanel .perf-value { color: #4f8; font-weight: bold; }
        #perfPanel .perf-value.warning { color: #fa4; }
        #perfPanel .perf-value.critical { color: #f44; }
        #perfPanel .fps-graph { height: 30px; background: #222; margin-top: 8px; border-radius: 3px; overflow: hidden; display: flex; align-items: flex-end; }
        #perfPanel .fps-bar { width: 2px; margin-right: 1px; background: #4f8; transition: height 0.1s; }

        /* Debug log for iPad (no console) */
        #debugLog {
            position: fixed;
            bottom: 10px;
            left: 10px;
            right: 10px;
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0,0,0,0.9);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            padding: 8px;
            border-radius: 5px;
            display: none;
            z-index: 2000;
        }
        #debugLog.visible { display: block; }
        #debugLog .error { color: #f44; }
        #debugLog .warn { color: #fa0; }
        #toggleLogBtn {
            position: fixed;
            bottom: 170px;
            left: 10px;
            background: rgba(0,100,0,0.8);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 2001;
        }

        /* Touch controls - Virtual Joystick */
        #touchControls {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 1000;
            display: none;
        }
        @media (pointer: coarse), (max-width: 800px) {
            #touchControls { display: block; }
        }
        /* Left half touch zone for dynamic joystick */
        #leftTouchZone {
            position: fixed;
            left: 0;
            top: 0;
            width: 50%;
            height: 100%;
            z-index: 999;
            touch-action: none;
            display: none;
        }
        @media (pointer: coarse), (max-width: 800px) {
            #leftTouchZone { display: block; }
        }
        .joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            position: fixed;
            touch-action: none;
            display: none;
            pointer-events: none;
        }
        .joystick-base.active {
            display: block;
        }
        .joystick-thumb {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.5);
            border: 2px solid rgba(255,255,255,0.7);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .touch-actions {
            position: fixed;
            bottom: 50px;
            right: 30px;
        }
        .action-btn {
            width: 80px;
            height: 80px;
            background: rgba(255,100,100,0.3);
            border: 3px solid rgba(255,100,100,0.5);
            border-radius: 50%;
            font-size: 32px;
            color: white;
            cursor: pointer;
            touch-action: manipulation;
        }
        .action-btn:active { background: rgba(255,100,100,0.6); }

        /* Debug buttons */
        #debugButtons {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
            display: flex;
            gap: 5px;
        }
        #debugButtons button {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #666;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }
        #debugButtons button:hover { background: rgba(100,100,100,0.7); }
        #debugButtons button.active { background: rgba(74,175,89,0.7); border-color: #4af; }

        /* Loading overlay - retro pixel style */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            font-family: 'Press Start 2P', monospace;
            color: white;
        }
        #loadingOverlay.hidden { display: none; }
        #loadingText {
            font-size: 12px;
            color: #fff;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }
        #loadingProgress {
            width: 200px;
            height: 16px;
            background: #000;
            border: 2px solid #fff;
            padding: 2px;
        }
        #loadingBar {
            width: 0%;
            height: 100%;
            background: #fff;
            transition: width 0.1s steps(20);
        }
        #loadingPercent {
            margin-top: 15px;
            font-size: 10px;
            color: #888;
        }
        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }
        .blink { animation: blink 1s step-end infinite; }
        /* 3D Interior styles */
        #interior3D canvas {
            display: block;
        }
        #exitButton3D {
            position: fixed;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            border: 2px solid #4af;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            z-index: 600;
        }
        #exitButton3D:hover { background: rgba(50,100,150,0.8); }
        .hotspot-label {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <!-- Loading overlay shows immediately -->
    <div id="loadingOverlay">
        <div id="loadingText">LOADING</div>
        <div id="loadingProgress"><div id="loadingBar"></div></div>
        <div id="loadingPercent">0%</div>
        <div class="blink" style="margin-top:20px; font-size:8px;">PLEASE WAIT</div>
    </div>
    <canvas id="game"></canvas>
    <!-- 3D Interior container (hidden by default) -->
    <div id="interior3D" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; z-index:500;"></div>
    <div id="leftTouchZone"></div>
    <div class="joystick-base" id="joystickBase">
        <div class="joystick-thumb" id="joystickThumb"></div>
    </div>
    <div id="touchControls">
        <div class="touch-actions">
            <button class="action-btn" id="interactBtn">A</button>
            <button class="action-btn" id="attackBtn">⚔</button>
        </div>
    </div>
    <div id="debugButtons">
        <button onclick="toggleFullscreen()">⛶</button>
        <button onclick="toggleCollision()">C</button>
        <button onclick="toggleSoundDebug()">S</button>
        <button onclick="toggleDebugPanel()">P</button>
        <button onclick="toggleHitboxPanel()">ATK</button>
        <button onclick="togglePerfPanel()">FPS</button>
        <button onclick="hideAllUI()">H</button>
        <button onclick="closeGame()">✕</button>
    </div>
    <div id="info">Move: Arrows | Attack: SPACE | Interact: A</div>
    <!-- Game Over Overlay -->
    <div id="gameOverOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:9999; justify-content:center; align-items:center; flex-direction:column;">
        <div style="text-align:center; font-family:'Press Start 2P', 'Courier New', monospace;">
            <h1 style="font-size:48px; color:#fff; text-shadow:4px 4px 0 #000; margin-bottom:40px; letter-spacing:8px;">GAME OVER</h1>
            <div style="display:flex; flex-direction:column; gap:20px;">
                <button onclick="tryAgain()" style="padding:15px 40px; font-size:18px; font-family:inherit; background:#444; color:#fff; border:3px solid #fff; cursor:pointer; letter-spacing:2px;">TRY AGAIN</button>
                <button onclick="quitGame()" style="padding:15px 40px; font-size:18px; font-family:inherit; background:#222; color:#888; border:3px solid #666; cursor:pointer; letter-spacing:2px;">QUIT</button>
            </div>
        </div>
    </div>
    <!-- Dialog Box -->
    <div id="dialogBox" style="display:none; position:fixed; bottom:60px; left:50%; transform:translateX(-50%); width:80%; max-width:500px; padding:20px; font-family:'Press Start 2P', monospace; font-size:12px; z-index:1000; image-rendering:pixelated;"></div>
    <!-- Quest Tracker HUD -->
    <div id="questTracker" style="display:none; position:fixed; top:10px; right:10px; background:rgba(0,0,0,0.85); border:2px solid #a8f; border-radius:8px; padding:10px; min-width:180px; max-width:250px; font-family:monospace; color:#fff; z-index:100; cursor:pointer;" onclick="toggleQuestLog()">
        <div id="questTrackerTitle" style="font-weight:bold; color:#FFD700; margin-bottom:6px; border-bottom:1px solid #444; padding-bottom:4px; font-size:11px;"></div>
        <div id="questTrackerObjectives" style="font-size:10px;"></div>
    </div>
    <!-- Quest Log Popup -->
    <div id="questLogPopup" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(20,20,40,0.95); border:3px solid #a8f; border-radius:12px; padding:20px; min-width:300px; max-width:400px; max-height:70vh; overflow-y:auto; z-index:200; font-family:monospace;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; border-bottom:2px solid #a8f; padding-bottom:10px;">
            <span style="color:#a8f; font-weight:bold; font-size:14px;">QUEST LOG</span>
            <button onclick="toggleQuestLog()" style="background:none; border:none; color:#fff; font-size:18px; cursor:pointer;">&times;</button>
        </div>
        <div id="questLogContent"></div>
    </div>
    <!-- Performance Panel -->
    <div id="perfPanel">
        <h3>⚡ Performance</h3>
        <div class="perf-row"><span class="perf-label">FPS:</span><span class="perf-value" id="perfFPS">60</span></div>
        <div class="perf-row"><span class="perf-label">Frame Time:</span><span class="perf-value" id="perfFrameTime">16.7ms</span></div>
        <div class="perf-row"><span class="perf-label">NPCs:</span><span class="perf-value" id="perfNPCs">0</span></div>
        <div class="perf-row"><span class="perf-label">Triggers:</span><span class="perf-value" id="perfTriggers">0</span></div>
        <div class="perf-row"><span class="perf-label">Lights:</span><span class="perf-value" id="perfLights">0</span></div>
        <div class="perf-row"><span class="perf-label">Layers:</span><span class="perf-value" id="perfLayers">0</span></div>
        <div class="fps-graph" id="fpsGraph"></div>
        <div style="margin-top:10px; display:flex; gap:5px;">
            <button id="recordNetBtn" onclick="toggleNetworkRecording()" style="flex:1; padding:5px; font-size:10px; background:#533; color:#fff; border:1px solid #755; border-radius:3px; cursor:pointer;">🔴 Record</button>
            <button id="copyNetBtn" onclick="copyNetworkLog()" style="flex:1; padding:5px; font-size:10px; background:#335; color:#fff; border:1px solid #557; border-radius:3px; cursor:pointer;" disabled>📋 Copy Log</button>
        </div>
        <div id="recordStatus" style="margin-top:5px; font-size:9px; color:#888;"></div>
    </div>
    <div id="debugPanel">
        <h3>Player Settings</h3>
        <label>Scale: <span class="value" id="scaleVal">1.7</span></label>
        <input type="range" id="scaleSlider" min="0.1" max="10" step="0.1" value="1.7">
        <label>Move Speed: <span class="value" id="speedVal">5.5</span></label>
        <input type="range" id="speedSlider" min="1" max="15" step="0.5" value="5.5">
        <label>Anim Speed: <span class="value" id="animVal">7</span></label>
        <input type="range" id="animSlider" min="1" max="20" step="1" value="7">
        <label>Hitbox Width: <span class="value" id="widthVal">28</span></label>
        <input type="range" id="widthSlider" min="10" max="60" step="2" value="28">
        <label>Hitbox Height: <span class="value" id="heightVal">76</span></label>
        <input type="range" id="heightSlider" min="20" max="100" step="2" value="76">
        <h3 style="margin-top:15px;">Camera</h3>
        <label>Zoom: <span class="value" id="zoomVal">0.9</span></label>
        <input type="range" id="zoomSlider" min="0.5" max="3" step="0.1" value="0.9">
        <h3 style="margin-top:15px;">Lighting</h3>
        <label>Darkness: <span class="value" id="darknessVal">0</span>%</label>
        <input type="range" id="darknessSlider" min="0" max="100" step="5" value="0">
        <label style="margin-top:10px;"><input type="checkbox" id="torchEnabled"> Player Torch</label>
        <label>Torch Radius: <span class="value" id="torchRadiusVal">4</span></label>
        <input type="range" id="torchRadiusSlider" min="1" max="15" step="1" value="4">
        <label style="margin-top:10px;"><input type="checkbox" id="cycleEnabled"> Enable Day/Night Cycle</label>
        <label>Cycle Time: <span class="value" id="dayLengthVal">1</span> min</label>
        <input type="range" id="dayLengthSlider" min="1" max="10" step="0.5" value="1">
        <div id="timeDisplay" style="color:#4f8;margin-top:5px;"></div>
        <h3 style="margin-top:15px;">Item Receive Display</h3>
        <label>Item Scale: <span class="value" id="itemScaleVal">2</span>x</label>
        <input type="range" id="itemScaleSlider" min="0.5" max="4" step="0.25" value="2">
        <label>Float Height: <span class="value" id="itemHeightVal">45</span>px</label>
        <input type="range" id="itemHeightSlider" min="-30" max="150" step="5" value="45">
        <label>Display Duration: <span class="value" id="itemDurationVal">2</span>s</label>
        <input type="range" id="itemDurationSlider" min="0.5" max="5" step="0.25" value="2">
        <label>Final Frame Pause: <span class="value" id="itemPauseVal">1</span>s</label>
        <input type="range" id="itemPauseSlider" min="0" max="3" step="0.25" value="1">
        <button onclick="copySettings()">Copy Settings</button>
    </div>
    <div id="hitboxPanel" style="display:none; position:fixed; top:60px; left:10px; background:rgba(20,20,40,0.95); padding:12px; border-radius:8px; font-size:10px; color:#fff; z-index:200; width:280px; border:2px solid #66f;">
        <h3 style="margin:0 0 10px 0; color:#88f;">Attack Hitbox (Per Direction)</h3>
        <div style="display:flex; gap:5px; margin-bottom:10px;">
            <button id="hitboxDirUp" onclick="setHitboxDir('up')" style="flex:1; padding:5px; font-size:10px;">↑ Up</button>
            <button id="hitboxDirDown" onclick="setHitboxDir('down')" class="active" style="flex:1; padding:5px; font-size:10px; background:#66f;">↓ Down</button>
            <button id="hitboxDirLeft" onclick="setHitboxDir('left')" style="flex:1; padding:5px; font-size:10px;">← Left</button>
            <button id="hitboxDirRight" onclick="setHitboxDir('right')" style="flex:1; padding:5px; font-size:10px;">→ Right</button>
        </div>
        <div style="background:rgba(0,0,0,0.3); padding:8px; border-radius:4px;">
            <label>Range: <span class="value" id="hbRangeVal">40</span>px</label>
            <input type="range" id="hbRangeSlider" min="10" max="120" step="5" value="40" style="width:100%;">
            <label>Width: <span class="value" id="hbWidthVal">60</span>°</label>
            <input type="range" id="hbWidthSlider" min="20" max="180" step="5" value="60" style="width:100%;">
            <label>Offset X: <span class="value" id="hbOffsetXVal">0</span>px</label>
            <input type="range" id="hbOffsetXSlider" min="-50" max="50" step="5" value="0" style="width:100%;">
            <label>Offset Y: <span class="value" id="hbOffsetYVal">0</span>px</label>
            <input type="range" id="hbOffsetYSlider" min="-50" max="50" step="5" value="0" style="width:100%;">
        </div>
        <div style="margin-top:8px; display:flex; gap:5px;">
            <button onclick="copyAllHitboxFromDir()" style="flex:1; padding:5px; font-size:9px; background:#484;">Copy to All</button>
            <button onclick="copyHitboxSettings()" style="flex:1; padding:5px; font-size:9px; background:#448;">Copy JSON</button>
        </div>
        <h3 style="margin:12px 0 8px 0; color:#fa0;">Attack Slide</h3>
        <div style="background:rgba(0,0,0,0.3); padding:8px; border-radius:4px;">
            <label>Slide Amount: <span class="value" id="slideAmountVal">50</span>%</label>
            <input type="range" id="slideAmountSlider" min="0" max="100" step="5" value="50" style="width:100%;">
            <label>Slide Duration: <span class="value" id="slideDurationVal">30</span> frames</label>
            <input type="range" id="slideDurationSlider" min="5" max="60" step="5" value="30" style="width:100%;">
        </div>
        <p style="font-size:8px; color:#888; margin:8px 0 0 0;">Blue=preview, Magenta=active hit. Press C to show.</p>
    </div>
    <button id="toggleLogBtn" onclick="toggleDebugLog()">Show Log</button>
    <div id="debugLog"></div>
    <script>
        // Debug log for iPad (captures console output)
        const debugLogEl = document.getElementById('debugLog');
        let debugLogVisible = false;

        function toggleDebugLog() {
            debugLogVisible = !debugLogVisible;
            debugLogEl.classList.toggle('visible', debugLogVisible);
            document.getElementById('toggleLogBtn').textContent = debugLogVisible ? 'Hide Log' : 'Show Log';
        }

        function logToScreen(msg, type = 'log') {
            const line = document.createElement('div');
            line.className = type;
            line.textContent = new Date().toLocaleTimeString() + ' ' + msg;
            debugLogEl.appendChild(line);
            debugLogEl.scrollTop = debugLogEl.scrollHeight;
            // Keep only last 50 lines
            while (debugLogEl.children.length > 50) {
                debugLogEl.removeChild(debugLogEl.firstChild);
            }
        }

        // Capture console methods
        const origLog = console.log;
        const origWarn = console.warn;
        const origError = console.error;
        console.log = (...args) => { origLog(...args); logToScreen(args.join(' '), 'log'); };
        console.warn = (...args) => { origWarn(...args); logToScreen(args.join(' '), 'warn'); };
        console.error = (...args) => { origError(...args); logToScreen(args.join(' '), 'error'); };

        // Capture uncaught errors
        window.onerror = (msg, url, line, col, error) => {
            logToScreen('ERROR: ' + msg + ' at line ' + line, 'error');
        };
        window.onunhandledrejection = (e) => {
            logToScreen('PROMISE ERROR: ' + e.reason, 'error');
        };

        logToScreen('Debug log initialized');
    <\/script>
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Fullscreen canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Show loading message with percentage - updates HTML overlay
        function showLoading(current, total) {
            const percent = total > 0 ? Math.round((current / total) * 100) : 0;

            // Update HTML loading overlay (visible immediately)
            const loadingBar = document.getElementById('loadingBar');
            const loadingPercent = document.getElementById('loadingPercent');
            const loadingText = document.getElementById('loadingText');
            if (loadingBar) loadingBar.style.width = percent + '%';
            if (loadingPercent) loadingPercent.textContent = current + '/' + total + ' (' + percent + '%)';
            if (loadingText && current > 0) loadingText.textContent = 'Loading Assets...';
        }

        // Hide loading overlay when game starts
        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) overlay.classList.add('hidden');
        }

        showLoading(0, 1);

        // Load project data via postMessage from opener window
        let projectData = null;
        let builderSyncSocket = null;
        let liveSyncNeedsRedraw = false;

        // Declare game state variables at outer scope so applyLiveEdit can access them
        let layers = [];
        let mapRows = 30;
        let mapCols = 40;
        let tileCollisions = {};
        let collisionMasks = {};
        let tileSplitLines = {};
        let tileSplitLineFlipped = {};
        let placedNpcs = [];
        let placedTriggers = [];
        let pointLights = {};
        let polyLights = [];
        let tileSounds = {};
        let cameraBounds = null;
        let currentGameMap = 'main';

        // ===== QUEST SYSTEM RUNTIME =====
        let questsData = [];  // Loaded from projectData
        let playerInventory = {};  // { [itemId]: quantity }
        let gameProgress = {
            npcsSpokenTo: {},       // { [npcUid]: true }
            enemiesDefeated: {},    // { [npcUid]: count }
            locationsVisited: {},   // { [mapName]: true }
            questStates: {}         // { [questId]: { status } }
        };
        const QUEST_STATUS = {
            LOCKED: 'locked',
            AVAILABLE: 'available',
            ACTIVE: 'active',
            COMPLETED: 'completed'
        };

        // NPC data for live sync
        let npcsData = [];
        let npcImages = [];
        let npcRuntimeState = [];
        let gridSize = 16; // Will be set from projectData

        // Live sync: Connect to builder WebSocket to receive real-time edits
        function connectToBuilderSync(roomCode) {
            const wsUrl = 'wss://multiplayer.lakotafox.partykit.dev/parties/builder/' + roomCode;
            console.log('[LIVE SYNC] Connecting to builder room:', roomCode);

            builderSyncSocket = new WebSocket(wsUrl);

            builderSyncSocket.onopen = () => {
                console.log('[LIVE SYNC] Connected to builder!');
                // Join as observer (don't send edits, just receive)
                builderSyncSocket.send(JSON.stringify({
                    type: 'join',
                    name: 'TestGame-Observer',
                    gameType: 'test-observer'
                }));
            };

            builderSyncSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    logNetworkEvent(data.editType || data.type || 'builderEdit', 'recv-builder', data, event.data.length);
                    if (data.type === 'builderEdit' || data.editType) {
                        applyLiveEdit(data);
                    }
                } catch (e) {
                    console.error('[LIVE SYNC] Parse error:', e);
                }
            };

            builderSyncSocket.onclose = () => {
                console.log('[LIVE SYNC] Disconnected from builder');
                // Reconnect after delay
                setTimeout(() => connectToBuilderSync(roomCode), 3000);
            };

            builderSyncSocket.onerror = (err) => {
                console.error('[LIVE SYNC] WebSocket error:', err);
            };
        }

        // Apply incoming edits from builder to live game state
        // fromMultiplayer = true means this edit came from another player, don't relay it again
        function applyLiveEdit(edit, fromMultiplayer = false) {
            // Handle batch edits
            if (edit.editType === 'batch' && edit.edits) {
                edit.edits.forEach(e => applyLiveEdit(e, fromMultiplayer));
                return;
            }

            const editType = edit.editType;

            // Skip non-edit messages
            if (!editType) return;

            console.log('[LIVE SYNC] Applying:', editType, fromMultiplayer ? '(from MP)' : '(from builder)');

            // Relay builder edits to other multiplayer players
            if (!fromMultiplayer && mpSocket && mpConnected) {
                mpSocket.send(JSON.stringify({
                    type: 'builderEdit',
                    edit: edit
                }));
            }

            // Get current map name (test game uses currentGameMap)
            const gameMapName = (typeof currentGameMap !== 'undefined') ? currentGameMap : 'main';

            switch (editType) {
                case 'tile':
                    // Update tile in the current map
                    if (edit.mapName === gameMapName || !edit.mapName) {
                        if (!layers[edit.layer]) layers[edit.layer] = [];
                        if (!layers[edit.layer][edit.y]) layers[edit.layer][edit.y] = [];
                        layers[edit.layer][edit.y][edit.x] = edit.cell;
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'eraseTile':
                    if (edit.mapName === gameMapName || !edit.mapName) {
                        if (layers[edit.layer] && layers[edit.layer][edit.y]) {
                            layers[edit.layer][edit.y][edit.x] = null;
                            liveSyncNeedsRedraw = true;
                        }
                    }
                    break;

                case 'collision':
                    if (edit.value) {
                        tileCollisions[edit.key] = true;
                    } else {
                        delete tileCollisions[edit.key];
                    }
                    break;

                case 'collisionMask':
                    collisionMasks[edit.key] = edit.mask;
                    break;

                case 'placeNpc':
                    if (typeof placedNpcs !== 'undefined' && edit.npc) {
                        placedNpcs.push(edit.npc);
                        // Create runtime state for new NPC
                        if (typeof createNpcRuntimeState === 'function') {
                            npcRuntimeState.push(createNpcRuntimeState(edit.npc));
                        }
                        console.log('[LIVE SYNC] Added NPC at', edit.npc.x, edit.npc.y);
                    }
                    break;

                case 'removeNpc':
                    if (typeof placedNpcs !== 'undefined' && edit.index >= 0 && edit.index < placedNpcs.length) {
                        placedNpcs.splice(edit.index, 1);
                        // Remove runtime state
                        if (npcRuntimeState && edit.index < npcRuntimeState.length) {
                            npcRuntimeState.splice(edit.index, 1);
                        }
                        console.log('[LIVE SYNC] Removed NPC at index', edit.index);
                    }
                    break;

                case 'updateNpc':
                    if (typeof placedNpcs !== 'undefined' && edit.index >= 0 && edit.index < placedNpcs.length && edit.npc) {
                        placedNpcs[edit.index] = edit.npc;
                        // Update runtime state position if NPC moved
                        if (npcRuntimeState && npcRuntimeState[edit.index]) {
                            npcRuntimeState[edit.index].x = edit.npc.x * gridSize;
                            npcRuntimeState[edit.index].y = edit.npc.y * gridSize;
                            npcRuntimeState[edit.index].targetX = edit.npc.x * gridSize;
                            npcRuntimeState[edit.index].targetY = edit.npc.y * gridSize;
                        }
                        console.log('[LIVE SYNC] Updated NPC at index', edit.index);
                    }
                    break;

                case 'addNpc':
                    // NPC definition added (not placed NPC)
                    if (typeof npcsData !== 'undefined' && edit.npc) {
                        npcsData.push(edit.npc);
                        // Load sprite image
                        if (edit.npc.spriteData) {
                            const img = new Image();
                            img.src = edit.npc.spriteData;
                            npcImages.push(img);
                        }
                        console.log('[LIVE SYNC] Added NPC definition:', edit.npc.name);
                    }
                    break;

                case 'updatePlacedNpc':
                    // Update placed NPC settings (including enemy AI)
                    if (typeof placedNpcs !== 'undefined' && edit.index >= 0 && edit.index < placedNpcs.length && edit.npc) {
                        // Preserve position but update all other settings
                        const oldPlaced = placedNpcs[edit.index];
                        placedNpcs[edit.index] = edit.npc;
                        // Update runtime state with new enemy settings
                        if (npcRuntimeState && npcRuntimeState[edit.index]) {
                            const state = npcRuntimeState[edit.index];
                            // Initialize enemy AI state if becoming an enemy
                            if (edit.npc.isEnemy && !state.aiState) {
                                state.aiState = 'idle';
                                state.aggroTimer = 0;
                                state.attackCooldown = 0;
                                state.returnX = state.x;
                                state.returnY = state.y;
                            }
                        }
                        console.log('[LIVE SYNC] Updated placed NPC at index', edit.index, 'isEnemy:', edit.npc.isEnemy);
                    }
                    break;

                case 'placeTrigger':
                    if (typeof placedTriggers !== 'undefined' && edit.trigger) {
                        placedTriggers.push(edit.trigger);
                        console.log('[LIVE SYNC] Added trigger:', edit.trigger.type, 'at', edit.trigger.x, edit.trigger.y);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'removeTrigger':
                    if (typeof placedTriggers !== 'undefined' && edit.index >= 0 && edit.index < placedTriggers.length) {
                        placedTriggers.splice(edit.index, 1);
                        console.log('[LIVE SYNC] Removed trigger at index', edit.index);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'updateTrigger':
                    if (typeof placedTriggers !== 'undefined' && edit.index >= 0 && edit.index < placedTriggers.length && edit.trigger) {
                        placedTriggers[edit.index] = edit.trigger;
                        console.log('[LIVE SYNC] Updated trigger at index', edit.index);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'light':
                    if (typeof pointLights !== 'undefined' && edit.light) {
                        pointLights[edit.key] = edit.light;
                        console.log('[LIVE SYNC] Added/updated light:', edit.key);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'removeLight':
                    if (typeof pointLights !== 'undefined') {
                        delete pointLights[edit.key];
                        console.log('[LIVE SYNC] Removed light:', edit.key);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'addPolyLight':
                    if (typeof polyLights !== 'undefined' && edit.light) {
                        polyLights.push(edit.light);
                        console.log('[LIVE SYNC] Added polygon light:', edit.light.id);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'removePolyLight':
                    if (typeof polyLights !== 'undefined') {
                        const idx = polyLights.findIndex(pl => pl.id === edit.lightId);
                        if (idx >= 0) {
                            polyLights.splice(idx, 1);
                            console.log('[LIVE SYNC] Removed polygon light:', edit.lightId);
                            liveSyncNeedsRedraw = true;
                        }
                    }
                    break;

                case 'tileSound':
                    if (typeof tileSounds !== 'undefined' && edit.sound) {
                        tileSounds[edit.key] = edit.sound;
                        console.log('[LIVE SYNC] Added tile sound:', edit.key);
                    }
                    break;

                case 'removeTileSound':
                    if (typeof tileSounds !== 'undefined') {
                        delete tileSounds[edit.key];
                        console.log('[LIVE SYNC] Removed tile sound:', edit.key);
                    }
                    break;

                case 'updatePlacedAnimProp':
                    // Update placed anim prop (e.g., instance item override)
                    if (typeof placedAnimPropsData !== 'undefined' && edit.index >= 0 && edit.index < placedAnimPropsData.length) {
                        placedAnimPropsData[edit.index] = edit.prop;
                        console.log('[LIVE SYNC] Updated placed anim prop at index', edit.index);
                    }
                    break;

                case 'cameraBounds':
                    if (typeof cameraBounds !== 'undefined' && (edit.mapName === gameMapName || !edit.mapName)) {
                        cameraBounds = edit.bounds;
                        console.log('[LIVE SYNC] Updated camera bounds');
                    }
                    break;

                case 'splitLine':
                    if (typeof tileSplitLines !== 'undefined') {
                        tileSplitLines[edit.key] = edit.mask;
                        console.log('[LIVE SYNC] Added split line:', edit.key);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'clearSplitLine':
                    if (typeof tileSplitLines !== 'undefined') {
                        delete tileSplitLines[edit.key];
                        delete tileSplitLineFlipped[edit.key];
                        console.log('[LIVE SYNC] Cleared split line:', edit.key);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'splitLineFlip':
                    if (typeof tileSplitLineFlipped !== 'undefined') {
                        if (edit.flipped) {
                            tileSplitLineFlipped[edit.key] = true;
                        } else {
                            delete tileSplitLineFlipped[edit.key];
                        }
                        console.log('[LIVE SYNC] Split line flip:', edit.key, edit.flipped);
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                case 'addLayer':
                    if (edit.mapName === gameMapName || !edit.mapName) {
                        layers.push([]);
                        for (let y = 0; y < mapRows; y++) {
                            layers[layers.length - 1][y] = [];
                            for (let x = 0; x < mapCols; x++) {
                                layers[layers.length - 1][y][x] = null;
                            }
                        }
                    }
                    break;

                case 'deleteLayer':
                    if (edit.mapName === gameMapName || !edit.mapName) {
                        if (edit.index >= 0 && edit.index < layers.length) {
                            layers.splice(edit.index, 1);
                            liveSyncNeedsRedraw = true;
                        }
                    }
                    break;

                case 'clearMap':
                    if (edit.mapName === gameMapName || !edit.mapName) {
                        layers.forEach((layer, i) => {
                            layers[i] = [];
                            for (let y = 0; y < mapRows; y++) {
                                layers[i][y] = [];
                                for (let x = 0; x < mapCols; x++) {
                                    layers[i][y][x] = null;
                                }
                            }
                        });
                        liveSyncNeedsRedraw = true;
                    }
                    break;

                default:
                    // Silently ignore unhandled edit types
                    break;
            }
        }

        // Wait for data from builder via postMessage
        console.log('Waiting for project data from builder...');
        window.onmessage = function(e) {
            if (e.data.type === 'project-data') {
                console.log('Received project data');
                projectData = JSON.parse(e.data.data);
                // Check for auto-multiplayer from builder co-op
                if (e.data.autoMultiplayer) {
                    console.log('Auto-multiplayer enabled:', e.data.autoMultiplayer);
                    // Set multiplayer config so initGame connects automatically
                    projectData.multiplayer = {
                        playerName: e.data.autoMultiplayer.playerName,
                        roomCode: e.data.autoMultiplayer.roomCode
                    };
                }
                if (window.opener) {
                    window.opener.postMessage({ type: 'log', msg: 'Project data received, size: ' + e.data.data.length }, '*');
                }
                initGame();

                // Connect to builder for live sync of edits
                if (e.data.builderSync && e.data.builderSync.roomCode) {
                    setTimeout(() => connectToBuilderSync(e.data.builderSync.roomCode), 1000);
                }
            } else if (e.data.type === 'sound-data') {
                const { index, data, name } = e.data;
                if (projectData && projectData.sounds && projectData.sounds[index]) {
                    projectData.sounds[index].data = data;
                    console.log('Received sound', index, name);
                    if (window.opener) {
                        window.opener.postMessage({ type: 'log', msg: 'Sound received: ' + name }, '*');
                    }
                }
            } else if (e.data.type === 'builderEdit') {
                // Live edit from builder (solo mode - direct postMessage)
                if (e.data.edit && typeof applyLiveEdit === 'function') {
                    console.log('[LIVE SYNC] Received edit via postMessage');
                    applyLiveEdit(e.data.edit, false);
                }
            }
        };
        // Signal ready to builder
        if (window.opener) {
            window.opener.postMessage({ type: 'ready' }, '*');
        } else {
            console.error('No opener window found!');
        }

        // Debug/UI functions (must be global for onclick handlers)
        let showCollision = false;
        let showSounds = false;

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen error:', err);
                });
            } else {
                document.exitFullscreen();
            }
        }
        function toggleCollision() {
            showCollision = !showCollision;
            document.querySelectorAll('#debugButtons button')[1].classList.toggle('active', showCollision);
        }
        function toggleSoundDebug() {
            showSounds = !showSounds;
            document.querySelectorAll('#debugButtons button')[2].classList.toggle('active', showSounds);
        }
        function toggleDebugPanel() {
            const panel = document.getElementById('debugPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
            document.querySelectorAll('#debugButtons button')[3].classList.toggle('active', panel.style.display === 'block');
        }

        // Performance panel
        let perfPanelVisible = false;
        let fpsHistory = [];
        const FPS_HISTORY_SIZE = 60;
        function togglePerfPanel() {
            perfPanelVisible = !perfPanelVisible;
            const panel = document.getElementById('perfPanel');
            panel.style.display = perfPanelVisible ? 'block' : 'none';
            document.querySelectorAll('#debugButtons button')[5].classList.toggle('active', perfPanelVisible);
            if (perfPanelVisible) {
                // Initialize FPS graph bars
                const graph = document.getElementById('fpsGraph');
                graph.innerHTML = '';
                for (let i = 0; i < FPS_HISTORY_SIZE; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'fps-bar';
                    bar.style.height = '0px';
                    graph.appendChild(bar);
                }
            }
        }

        // Network recording for debugging freezes
        let networkRecording = false;
        let networkLog = [];
        let frameTimeLog = [];
        let recordStartTime = 0;
        const MAX_LOG_ENTRIES = 500;

        function toggleNetworkRecording() {
            networkRecording = !networkRecording;
            const btn = document.getElementById('recordNetBtn');
            const copyBtn = document.getElementById('copyNetBtn');
            const status = document.getElementById('recordStatus');

            if (networkRecording) {
                // Start recording
                networkLog = [];
                frameTimeLog = [];
                recordStartTime = performance.now();
                btn.textContent = '⏹ Stop';
                btn.style.background = '#a33';
                copyBtn.disabled = true;
                status.textContent = 'Recording... (0 events)';
                status.style.color = '#f88';
            } else {
                // Stop recording
                btn.textContent = '🔴 Record';
                btn.style.background = '#533';
                copyBtn.disabled = false;
                status.textContent = 'Recorded ' + networkLog.length + ' net events, ' + frameTimeLog.length + ' frames';
                status.style.color = '#8f8';
            }
        }

        function logNetworkEvent(type, direction, data, size) {
            if (!networkRecording) return;
            if (networkLog.length >= MAX_LOG_ENTRIES) return;

            const now = performance.now();
            const elapsed = now - recordStartTime;

            networkLog.push({
                t: elapsed.toFixed(1),
                type: type,
                dir: direction,
                size: size || 0,
                data: typeof data === 'string' ? data.substring(0, 100) : JSON.stringify(data).substring(0, 100)
            });

            const status = document.getElementById('recordStatus');
            if (status) status.textContent = 'Recording... (' + networkLog.length + ' events)';
        }

        function logFrameTime(frameTime, fps) {
            if (!networkRecording) return;
            if (frameTimeLog.length >= MAX_LOG_ENTRIES * 2) return;

            const now = performance.now();
            const elapsed = now - recordStartTime;

            // Only log if frame time is high (potential freeze)
            if (frameTime > 20) { // More than 20ms = potential issue
                frameTimeLog.push({
                    t: elapsed.toFixed(1),
                    ft: frameTime.toFixed(1),
                    fps: fps
                });
            }
        }

        function copyNetworkLog() {
            const report = {
                recorded: new Date().toISOString(),
                duration: ((performance.now() - recordStartTime) / 1000).toFixed(1) + 's',
                networkEvents: networkLog,
                slowFrames: frameTimeLog,
                summary: {
                    totalNetEvents: networkLog.length,
                    totalSlowFrames: frameTimeLog.length,
                    avgSlowFrameTime: frameTimeLog.length > 0
                        ? (frameTimeLog.reduce((a, b) => a + parseFloat(b.ft), 0) / frameTimeLog.length).toFixed(1) + 'ms'
                        : 'N/A'
                }
            };

            const text = JSON.stringify(report, null, 2);
            navigator.clipboard.writeText(text).then(() => {
                const status = document.getElementById('recordStatus');
                status.textContent = 'Copied to clipboard!';
                status.style.color = '#4f8';
                setTimeout(() => {
                    status.textContent = 'Recorded ' + networkLog.length + ' net events, ' + frameTimeLog.length + ' frames';
                    status.style.color = '#8f8';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy. Check console for data.');
                console.log('Network Log:', text);
            });
        }

        function closeGame() {
            window.close();
        }
        let uiHidden = true; // Start with UI hidden
        function hideAllUI() {
            uiHidden = true;
            document.getElementById('debugButtons').style.display = 'none';
            document.getElementById('info').style.display = 'none';
            document.getElementById('debugPanel').style.display = 'none';
            document.getElementById('perfPanel').style.display = 'none';
            perfPanelVisible = false;
            const toggleBtn = document.getElementById('toggleLogBtn');
            if (toggleBtn) toggleBtn.style.display = 'none';
            const debugLog = document.getElementById('debugLog');
            if (debugLog) debugLog.style.display = 'none';
        }
        function showAllUI() {
            uiHidden = false;
            document.getElementById('debugButtons').style.display = '';
            document.getElementById('info').style.display = '';
        }
        function toggleAllUI() {
            if (uiHidden) showAllUI();
            else hideAllUI();
        }

        // Shape-based attack hitbox per direction (triangle/cone) - global for hitbox panel
        let playerHitboxRange = { up: 35, down: 35, left: 35, right: 30 };
        let playerHitboxWidth = { up: 90, down: 90, left: 90, right: 90 };
        let playerHitboxOffsetY = { up: 15, down: -15, left: 0, right: 0 };
        let playerHitboxOffsetX = { up: 0, down: 0, left: 15, right: -15 };

        // Hitbox panel functions
        let hitboxEditDir = 'down';
        function toggleHitboxPanel() {
            const panel = document.getElementById('hitboxPanel');
            panel.style.display = panel.style.display === 'block' ? 'none' : 'block';
            document.querySelectorAll('#debugButtons button')[4].classList.toggle('active', panel.style.display === 'block');
            if (panel.style.display === 'block') {
                updateHitboxSliders();
            }
        }

        function setHitboxDir(dir) {
            hitboxEditDir = dir;
            document.querySelectorAll('[id^="hitboxDir"]').forEach(b => {
                b.classList.remove('active');
                b.style.background = '';
            });
            const btn = document.getElementById('hitboxDir' + dir.charAt(0).toUpperCase() + dir.slice(1));
            btn.classList.add('active');
            btn.style.background = '#66f';
            updateHitboxSliders();
        }

        function updateHitboxSliders() {
            const dir = hitboxEditDir;
            document.getElementById('hbRangeSlider').value = playerHitboxRange[dir];
            document.getElementById('hbRangeVal').textContent = playerHitboxRange[dir];
            document.getElementById('hbWidthSlider').value = playerHitboxWidth[dir];
            document.getElementById('hbWidthVal').textContent = playerHitboxWidth[dir];
            document.getElementById('hbOffsetXSlider').value = playerHitboxOffsetX[dir];
            document.getElementById('hbOffsetXVal').textContent = playerHitboxOffsetX[dir];
            document.getElementById('hbOffsetYSlider').value = playerHitboxOffsetY[dir];
            document.getElementById('hbOffsetYVal').textContent = playerHitboxOffsetY[dir];
        }

        function copyAllHitboxFromDir() {
            const dir = hitboxEditDir;
            ['up', 'down', 'left', 'right'].forEach(d => {
                playerHitboxRange[d] = playerHitboxRange[dir];
                playerHitboxWidth[d] = playerHitboxWidth[dir];
                playerHitboxOffsetX[d] = playerHitboxOffsetX[dir];
                playerHitboxOffsetY[d] = playerHitboxOffsetY[dir];
            });
            console.log('Copied ' + dir + ' hitbox to all directions');
        }

        function copyHitboxSettings() {
            const settings = {
                hitboxRange: playerHitboxRange,
                hitboxWidth: playerHitboxWidth,
                hitboxOffsetX: playerHitboxOffsetX,
                hitboxOffsetY: playerHitboxOffsetY
            };
            const json = JSON.stringify(settings, null, 2);
            navigator.clipboard.writeText(json).then(() => {
                console.log('Hitbox settings copied to clipboard');
            });
        }

        // ===== QUEST SYSTEM FUNCTIONS =====

        // Inventory functions
        function addToInventory(itemId, quantity = 1) {
            if (!itemId) return;
            playerInventory[itemId] = (playerInventory[itemId] || 0) + quantity;
            console.log('[QUEST] Added to inventory:', itemId, 'x', quantity, '- total:', playerInventory[itemId]);
            checkQuestConditions();
        }

        function removeFromInventory(itemId, quantity = 1) {
            if (!itemId || !playerInventory[itemId]) return false;
            if (playerInventory[itemId] < quantity) return false;
            playerInventory[itemId] -= quantity;
            if (playerInventory[itemId] <= 0) delete playerInventory[itemId];
            console.log('[QUEST] Removed from inventory:', itemId, 'x', quantity);
            return true;
        }

        function hasInventoryItem(itemId, quantity = 1) {
            return (playerInventory[itemId] || 0) >= quantity;
        }

        // Tracking hooks - call these when events happen
        function onNpcInteraction(npcUid) {
            if (!npcUid) return;
            if (!gameProgress.npcsSpokenTo[npcUid]) {
                gameProgress.npcsSpokenTo[npcUid] = true;
                console.log('[QUEST] Talked to NPC:', npcUid);
                checkQuestConditions();
            }
        }

        function onEnemyDefeated(npcUid) {
            if (!npcUid) return;
            gameProgress.enemiesDefeated[npcUid] = (gameProgress.enemiesDefeated[npcUid] || 0) + 1;
            console.log('[QUEST] Enemy defeated:', npcUid, '- total:', gameProgress.enemiesDefeated[npcUid]);
            checkQuestConditions();
        }

        function onMapEnter(mapName) {
            if (!mapName) return;
            if (!gameProgress.locationsVisited[mapName]) {
                gameProgress.locationsVisited[mapName] = true;
                console.log('[QUEST] Visited location:', mapName);
                checkQuestConditions();
            }
        }

        function onLocationVisit(mapName, x, y) {
            const key = mapName + '_' + x + '_' + y;
            if (!gameProgress.locationsVisited[key]) {
                gameProgress.locationsVisited[key] = true;
                console.log('[QUEST] Visited tile:', key);
                checkQuestConditions();
            }
        }

        // Track player tile position for location-based quest conditions
        let lastKnownPlayerTile = { x: -1, y: -1 };
        function checkPlayerTileForQuests() {
            if (typeof player === 'undefined' || !player || player.x === undefined) return;
            const tileX = Math.floor((player.x + player.width / 2) / tileSize);
            const tileY = Math.floor((player.y + player.height / 2) / tileSize);
            if (tileX !== lastKnownPlayerTile.x || tileY !== lastKnownPlayerTile.y) {
                lastKnownPlayerTile = { x: tileX, y: tileY };
                onLocationVisit(currentGameMap, tileX, tileY);
            }
        }

        // Quest state management
        function initializeQuestStates() {
            if (!questsData || questsData.length === 0) return;

            questsData.forEach(quest => {
                if (!gameProgress.questStates[quest.id]) {
                    gameProgress.questStates[quest.id] = { status: QUEST_STATUS.LOCKED };
                }
            });

            updateQuestAvailability();
            console.log('[QUEST] Initialized', questsData.length, 'quests');
        }

        function updateQuestAvailability() {
            if (!questsData) return;

            questsData.forEach(quest => {
                const state = gameProgress.questStates[quest.id];
                if (!state) return;

                // Already completed and not repeatable? Stay completed
                if (state.status === QUEST_STATUS.COMPLETED && !quest.isRepeatable) return;

                // Already active? Stay active
                if (state.status === QUEST_STATUS.ACTIVE) return;

                // Check prerequisites
                const prereqsMet = !quest.prerequisites || quest.prerequisites.length === 0 ||
                    quest.prerequisites.every(prereqId =>
                        gameProgress.questStates[prereqId]?.status === QUEST_STATUS.COMPLETED
                    );

                if (prereqsMet) {
                    if (state.status !== QUEST_STATUS.AVAILABLE) {
                        state.status = QUEST_STATUS.AVAILABLE;

                        // Auto-start if configured
                        if (quest.autoStart) {
                            state.status = QUEST_STATUS.ACTIVE;
                            showQuestNotification('started', quest.name);
                        }
                    }
                } else {
                    state.status = QUEST_STATUS.LOCKED;
                }
            });
        }

        function checkQuestConditions() {
            if (!questsData) return;

            questsData.forEach(quest => {
                const state = gameProgress.questStates[quest.id];
                if (!state || state.status !== QUEST_STATUS.ACTIVE) return;

                // Check if all conditions are met
                const allMet = checkAllConditionsMet(quest);
                if (allMet) {
                    // Quest can be completed - but wait for turn-in NPC if specified
                    if (!quest.turnInNpcUid) {
                        completeQuest(quest);
                    }
                    // Otherwise player needs to talk to turn-in NPC
                }
            });

            // Update quest tracker UI
            updateQuestTracker();
        }

        function checkAllConditionsMet(quest) {
            if (!quest.conditions || quest.conditions.length === 0) return true;

            return quest.conditions.every(condition => {
                if (condition.broken) return true; // Skip broken conditions

                switch (condition.type) {
                    case 'enemyDefeated':
                        return (gameProgress.enemiesDefeated[condition.targetUid] || 0) >= (condition.count || 1);

                    case 'talkedToNpc':
                        return gameProgress.npcsSpokenTo[condition.targetUid] === true;

                    case 'locationVisited':
                        if (condition.x !== undefined && condition.y !== undefined) {
                            const key = condition.mapName + '_' + condition.x + '_' + condition.y;
                            return gameProgress.locationsVisited[key] === true;
                        }
                        return gameProgress.locationsVisited[condition.mapName] === true;

                    case 'hasItem':
                        return hasInventoryItem(condition.targetUid, condition.count || 1);

                    default:
                        console.warn('[QUEST] Unknown condition type:', condition.type);
                        return false;
                }
            });
        }

        function completeQuest(quest) {
            const state = gameProgress.questStates[quest.id];
            if (!state || state.status === QUEST_STATUS.COMPLETED) return;

            console.log('[QUEST] Completing quest:', quest.name);
            state.status = QUEST_STATUS.COMPLETED;

            // Apply rewards
            if (quest.onComplete) {
                if (quest.onComplete.giveItems) {
                    quest.onComplete.giveItems.forEach(itemId => addToInventory(itemId, 1));
                }
                if (quest.onComplete.removeItems) {
                    quest.onComplete.removeItems.forEach(itemId => removeFromInventory(itemId, 1));
                }
            }

            showQuestNotification('completed', quest.name);
            updateQuestAvailability();
        }

        function acceptQuest(questId) {
            const quest = questsData.find(q => q.id === questId);
            if (!quest) return;

            const state = gameProgress.questStates[questId];
            if (!state || state.status !== QUEST_STATUS.AVAILABLE) return;

            state.status = QUEST_STATUS.ACTIVE;
            console.log('[QUEST] Accepted quest:', quest.name);
            showQuestNotification('started', quest.name);
        }

        function getActiveQuest() {
            if (!questsData) return null;
            return questsData.find(q =>
                gameProgress.questStates[q.id]?.status === QUEST_STATUS.ACTIVE
            );
        }

        function getQuestById(questId) {
            return questsData?.find(q => q.id === questId);
        }

        function showQuestNotification(type, questName) {
            const messages = {
                'started': 'Quest Started: ' + questName,
                'updated': 'Quest Updated: ' + questName,
                'completed': 'Quest Completed: ' + questName
            };

            console.log('[QUEST]', messages[type] || type);

            // Create notification element if game container exists
            const container = document.getElementById('gameContainer') || document.body;
            const div = document.createElement('div');
            div.className = 'quest-notification ' + type;
            div.textContent = messages[type] || questName;
            div.style.cssText = 'position:fixed; top:100px; right:-300px; background:linear-gradient(135deg, #1a1a2e, #2a1a3e); border:2px solid #FFD700; border-radius:8px; padding:15px 25px; font-family:monospace; color:#FFD700; font-size:14px; transition:right 0.5s ease; z-index:150;';
            if (type === 'completed') div.style.borderColor = div.style.color = '#4f4';
            if (type === 'started') div.style.borderColor = div.style.color = '#0ff';

            container.appendChild(div);

            // Animate
            setTimeout(() => div.style.right = '20px', 10);
            setTimeout(() => div.style.right = '-300px', 3000);
            setTimeout(() => div.remove(), 3500);
        }

        // Quest Tracker HUD
        let questLogVisible = false;

        function updateQuestTracker() {
            const tracker = document.getElementById('questTracker');
            const titleEl = document.getElementById('questTrackerTitle');
            const objectivesEl = document.getElementById('questTrackerObjectives');
            if (!tracker || !titleEl) return;

            const activeQuest = getActiveQuest();
            if (!activeQuest) {
                tracker.style.display = 'none';
                return;
            }

            tracker.style.display = 'block';
            titleEl.textContent = activeQuest.name || 'Active Quest';

            // Hide objectives - just show quest name
            if (objectivesEl) objectivesEl.innerHTML = '';
        }

        function isConditionMet(condition) {
            if (condition.broken) return true;
            switch (condition.type) {
                case 'enemyDefeated':
                    return (gameProgress.enemiesDefeated[condition.targetUid] || 0) >= (condition.count || 1);
                case 'talkedToNpc':
                    return gameProgress.npcsSpokenTo[condition.targetUid] === true;
                case 'locationVisited':
                    if (condition.x !== undefined && condition.y !== undefined) {
                        const key = condition.mapName + '_' + condition.x + '_' + condition.y;
                        return gameProgress.locationsVisited[key] === true;
                    }
                    return gameProgress.locationsVisited[condition.mapName] === true;
                case 'hasItem':
                    return hasInventoryItem(condition.targetUid, condition.count || 1);
                default:
                    return false;
            }
        }

        function toggleQuestLog() {
            questLogVisible = !questLogVisible;
            const popup = document.getElementById('questLogPopup');
            if (popup) {
                popup.style.display = questLogVisible ? 'block' : 'none';
                if (questLogVisible) renderQuestLog();
            }
        }

        function renderQuestLog() {
            const content = document.getElementById('questLogContent');
            if (!content || !questsData) return;

            let html = '';

            // Active quests - just show name, no objectives
            const active = questsData.filter(q => gameProgress.questStates[q.id]?.status === QUEST_STATUS.ACTIVE);
            if (active.length > 0) {
                html += '<div style="color:#0ff; font-weight:bold; margin-bottom:8px;">ACTIVE QUESTS</div>';
                active.forEach(q => {
                    html += '<div style="background:#1a1a2e; border:1px solid #0ff; border-radius:6px; padding:10px; margin-bottom:8px;">';
                    html += '<div style="color:#FFD700; font-weight:bold;">' + q.name + '</div>';
                    if (q.description) {
                        html += '<div style="color:#888; font-size:11px; margin-top:4px;">' + q.description + '</div>';
                    }
                    html += '</div>';
                });
            }

            // Completed quests
            const completed = questsData.filter(q => gameProgress.questStates[q.id]?.status === QUEST_STATUS.COMPLETED);
            if (completed.length > 0) {
                html += '<div style="color:#4f4; font-weight:bold; margin:12px 0 8px;">COMPLETED</div>';
                completed.forEach(q => {
                    html += '<div style="background:#1a2a1a; border:1px solid #4f4; border-radius:6px; padding:8px; margin-bottom:8px; opacity:0.7;">';
                    html += '<div style="color:#4f4;">✓ ' + q.name + '</div>';
                    html += '</div>';
                });
            }

            if (!html) {
                html = '<div style="color:#666; text-align:center; padding:20px;">No active quests</div>';
            }

            content.innerHTML = html;
        }

        function initGame() {
        console.log('Initializing game with project data:', projectData);

        // Auto-hide UI if adventure mode
        if (projectData.autoHideUI) {
            setTimeout(() => hideAllUI(), 100);
        }

        const gridSize = projectData.gridSize || 16;
        mapRows = projectData.mapRows || 30;
        mapCols = projectData.mapCols || 40;

        // Load layers - use spawn map's data if available
        layers = [];
        const spawnMap = projectData.spawnMapName || 'main';
        const spawnMapData = projectData.maps && projectData.maps[spawnMap];

        if (spawnMapData && spawnMapData.layers && spawnMapData.layers.length > 0) {
            // Load from spawn map
            layers = spawnMapData.layers;
            console.log('Loaded layers from spawn map:', spawnMap);
        } else if (projectData.layers && projectData.layers.length > 0) {
            layers = projectData.layers;
            console.log('Loaded layers from projectData.layers');
        } else if (projectData.map && projectData.map.length > 0) {
            layers = [projectData.map];
            console.log('Loaded map from projectData.map (old format)');
        } else {
            console.error('No map data found!');
        }

        let layerVisibility = projectData.layerVisibility || layers.map(() => true);
        const playerLayerIndex = projectData.playerLayerIndex !== undefined ? projectData.playerLayerIndex : 1;

        console.log('Layers:', layers.length, 'MapRows:', mapRows, 'MapCols:', mapCols, 'PlayerLayer:', playerLayerIndex);

        // Debug: Check layer content
        if (layers.length > 0) {
            const firstLayer = layers[0];
            console.log('First layer type:', typeof firstLayer, 'isArray:', Array.isArray(firstLayer));
            if (Array.isArray(firstLayer) && firstLayer.length > 0) {
                console.log('First layer rows:', firstLayer.length);
                // Count non-null cells
                let tileCount = 0;
                for (let y = 0; y < firstLayer.length; y++) {
                    if (firstLayer[y]) {
                        for (let x = 0; x < firstLayer[y].length; x++) {
                            if (firstLayer[y][x]) tileCount++;
                        }
                    }
                }
                console.log('Tiles in first layer:', tileCount);
            }
        }

        // Load collision data - use spawn map's data if available
        tileCollisions = (spawnMapData && spawnMapData.tileCollisions) || projectData.tileCollisions || {};
        collisionMasks = (spawnMapData && spawnMapData.collisionMasks) || projectData.collisionMasks || {};
        tileSplitLines = (spawnMapData && spawnMapData.tileSplitLines) || projectData.tileSplitLines || {}; // Depth split for Y-sorting
        tileSplitLineFlipped = (spawnMapData && spawnMapData.tileSplitLineFlipped) || projectData.tileSplitLineFlipped || {}; // Flipped split lines

        console.log('Tiles with collision:', Object.keys(tileCollisions).length, 'from map:', spawnMap);
        console.log('Tiles with depth split:', Object.keys(tileSplitLines).length);

        // Multiple props system
        const propImages = [];
        const propsData = projectData.props || [];
        const propCollisionMasksAll = {}; // propIndex -> collision masks

        // Load tilesets (support multiple)
        const tilesetImages = [];
        const tilesetsData = projectData.tilesets || [{ data: projectData.tilesetData }];

        // Animated props data (needed for counting)
        const animatedPropsData = projectData.animatedProps || [];
        // Placed animated props (for instance-specific item overrides)
        const placedAnimPropsData = projectData.placedAnimProps || [];

        // Static objects data (multi-tile props from tilesets)
        const staticObjectsData = projectData.staticObjects || [];
        const placedStaticObjectsData = projectData.placedStaticObjects || [];
        const staticObjectImages = [];

        // Quest system data
        questsData = projectData.quests || [];
        initializeQuestStates();
        // Update quest tracker after a short delay to ensure UI elements exist
        setTimeout(updateQuestTracker, 100);

        // Track all images that need to load before starting the game
        let imagesToLoad = 0;
        let imagesLoaded = 0;
        let gameStarted = false;

        // Start game after preloading sounds
        function startGameAfterLoading() {
            console.log('Images loaded, preloading sounds...');
            preloadAllSounds(() => {
                console.log('Sounds preloaded, starting game...');
                gameStartTime = Date.now();
                hideLoading();
                findStartPos();
                hideAllUI(); // Start with debug UI hidden
                gameLoop();
            });
        }

        function checkAllImagesLoaded() {
            showLoading(imagesLoaded, imagesToLoad);
            if (imagesLoaded >= imagesToLoad && !gameStarted) {
                console.log('All images loaded');
                gameStarted = true;
                startGameAfterLoading();
            }
        }

        // Count all images to load
        imagesToLoad += tilesetsData.filter(ts => ts && ts.data).length; // Tilesets with valid data
        imagesToLoad += animatedPropsData.filter(p => p && p.spriteData).length; // Animated props
        imagesToLoad += staticObjectsData.filter(o => o && o.spriteData).length; // Static objects
        imagesToLoad += propsData.filter(p => p && p.data).length; // Regular props with valid data
        if (projectData.propImageData && propsData.length === 0) imagesToLoad += 1; // Legacy single prop
        imagesToLoad += (projectData.npcs || []).filter(n => n && n.spriteData).length; // NPC sprites
        imagesToLoad += 1; // Player sprite

        // Detect mobile for staggered loading
        const isMobileDevice = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        console.log('Total images to load:', imagesToLoad, isMobileDevice ? '(mobile - staggered loading)' : '');

        // Safety check - if somehow no images to load, start anyway
        if (imagesToLoad === 0) {
            console.warn('No images to load, starting game immediately');
            imagesToLoad = 1;
            imagesLoaded = 1;
            gameStarted = true;
            startGameAfterLoading();
        }

        // Fallback timeout - start game after 2 minutes even if some images failed (large projects need more time on iPad)
        setTimeout(() => {
            if (!gameStarted) {
                console.warn('Timeout reached, starting game with', imagesLoaded, '/', imagesToLoad, 'images loaded');
                gameStarted = true;
                startGameAfterLoading();
            }
        }, 120000);

        // Load all prop images
        if (propsData.length > 0) {
            propsData.forEach((propData, i) => {
                if (!propData || !propData.data) {
                    console.warn('Prop', i, 'has no data, skipping');
                    return;
                }
                const img = new Image();
                img.onload = () => {
                    console.log('Prop', i, 'loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error('Failed to load prop', i);
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.src = propData.data;
                propImages[i] = img;
                propCollisionMasksAll[i] = propData.collisionMasks || {};
            });
        } else if (projectData.propImageData) {
            // Backwards compatibility - single prop
            const img = new Image();
            img.onload = () => {
                console.log('Prop image loaded (legacy) (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.onerror = () => {
                console.error('Failed to load legacy prop');
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.src = projectData.propImageData;
            propImages[0] = img;
            propCollisionMasksAll[0] = projectData.propCollisionMasks || {};
        }

        tilesetsData.forEach((ts, i) => {
            if (!ts || !ts.data) {
                console.warn('Tileset', i, 'has no data, skipping');
                return;
            }
            const img = new Image();
            img.onload = () => {
                tilesetImages[i] = img;
                imagesLoaded++;
                console.log('Tileset', i, 'loaded (' + imagesLoaded + '/' + imagesToLoad + ')');
                checkAllImagesLoaded();
            };
            img.onerror = () => {
                console.error('Failed to load tileset', i);
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.src = ts.data;
        });

        // For backwards compat
        const tilesetImg = { complete: false };

        // Load animated props (stored as animTile cells in layers)
        const animPropImages = [];
        const animPropFrameTimers = {}; // key: "x,y,layer" -> { frame: 0, timer: 0 }
        const interactivePropStates = {}; // key: "x,y,layer" -> { used: false, animating: false, frame: 0 }

        animatedPropsData.forEach((propData, i) => {
            if (propData && propData.spriteData) {
                const img = new Image();
                img.onload = () => {
                    console.log('AnimProp', i, propData.name, 'loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error('Failed to load AnimProp', i);
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.src = propData.spriteData;
                animPropImages[i] = img;
            }
        });

        console.log('Animated props:', animatedPropsData.length);
        // Debug: log props with giveItem
        animatedPropsData.forEach((prop, i) => {
            if (prop.giveItem) {
                console.log('[PROP ' + i + '] "' + prop.name + '" gives item index:', prop.giveItemIndex);
            }
        });

        // Load static objects (multi-tile props from tilesets)
        staticObjectsData.forEach((objData, i) => {
            if (objData && objData.spriteData) {
                const img = new Image();
                img.onload = () => {
                    console.log('StaticObj', i, objData.name, 'loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error('Failed to load StaticObj', i);
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.src = objData.spriteData;
                staticObjectImages[i] = img;
            }
        });
        console.log('Static objects:', staticObjectsData.length, 'Placed:', placedStaticObjectsData.length);

        // Load player sprite - check for player characters first, then embedded sprite, then file
        let playerImg = new Image();
        const basePath = window.opener ? window.opener.location.href.replace(/[^/]*$/, '') : '';

        // Player character animation data (if using player characters system)
        let activePlayerChar = null;
        let playerFrameWidth = 64;
        let playerFrameHeight = 64;
        let playerAnimations = null;
        let playerAnimFpsList = {}; // Per-animation FPS
        let playerAnimMirrors = {}; // Per-animation mirror flags
        let playerAttackMovement = 'stop'; // 'stop', 'slide', 'move'
        let attackSlideAmount = 50; // 0-100%, how much speed to retain during slide
        let attackSlideDuration = 30; // How many frames the slide lasts

        let playerGameOverSoundIndex = -1; // Index of game over sound (-1 = none, 0-99 = builtin, 100+ = project)
        let playerSpriteSheets = []; // Array of loaded sprite sheet images

        // Built-in game over sounds (lazy loaded)
        const builtinGameOverSounds = [
            { name: 'Game Over 1', file: 'game-over-417465.mp3' },
            { name: 'Game Over 2 (Arcade)', file: 'game-over-arcade-6435.mp3' }
        ];
        let builtinGameOverAudios = [null, null];

        // Check for player characters system first
        if (projectData.playerCharacters && projectData.playerCharacters.length > 0 && projectData.activePlayerIndex >= 0) {
            activePlayerChar = projectData.playerCharacters[projectData.activePlayerIndex];
            console.log('=== PLAYER CHARACTER DATA ===');
            console.log('spriteSheets:', activePlayerChar.spriteSheets ? activePlayerChar.spriteSheets.length + ' sheets' : 'none');
            console.log('animMirrors:', JSON.stringify(activePlayerChar.animMirrors));
            console.log('animations keys:', Object.keys(activePlayerChar.animations || {}));
            console.log('attackDown frames:', activePlayerChar.animations?.attackDown?.length || 0);
            if (activePlayerChar) {
                playerFrameWidth = activePlayerChar.frameWidth || 64;
                playerFrameHeight = activePlayerChar.frameHeight || 64;
                playerAnimations = activePlayerChar.animations;
                // Load per-animation FPS
                if (activePlayerChar.animFps && typeof activePlayerChar.animFps === 'object') {
                    playerAnimFpsList = activePlayerChar.animFps;
                } else {
                    // Old format: use single fps for all
                    const defaultFps = activePlayerChar.fps || 8;
                    if (playerAnimations) {
                        Object.keys(playerAnimations).forEach(k => playerAnimFpsList[k] = defaultFps);
                    }
                }
                // Load per-animation mirror flags
                if (activePlayerChar.animMirrors && typeof activePlayerChar.animMirrors === 'object') {
                    playerAnimMirrors = activePlayerChar.animMirrors;
                    console.log('Loaded animMirrors:', JSON.stringify(playerAnimMirrors));
                }
                // Load attack hitbox shape (per-direction)
                if (activePlayerChar.hitboxRange !== undefined) {
                    // Handle both old single-value format and new per-direction format
                    if (typeof activePlayerChar.hitboxRange === 'object') {
                        playerHitboxRange = activePlayerChar.hitboxRange;
                    } else {
                        // Convert old format to new
                        const val = activePlayerChar.hitboxRange;
                        playerHitboxRange = { up: val, down: val, left: val, right: val };
                    }
                }
                if (activePlayerChar.hitboxWidth !== undefined) {
                    if (typeof activePlayerChar.hitboxWidth === 'object') {
                        playerHitboxWidth = activePlayerChar.hitboxWidth;
                    } else {
                        const val = activePlayerChar.hitboxWidth;
                        playerHitboxWidth = { up: val, down: val, left: val, right: val };
                    }
                }
                if (activePlayerChar.hitboxOffsetY !== undefined) {
                    if (typeof activePlayerChar.hitboxOffsetY === 'object') {
                        playerHitboxOffsetY = activePlayerChar.hitboxOffsetY;
                    } else {
                        const val = activePlayerChar.hitboxOffsetY;
                        playerHitboxOffsetY = { up: val, down: val, left: val, right: val };
                    }
                }
                if (activePlayerChar.hitboxOffsetX !== undefined) {
                    if (typeof activePlayerChar.hitboxOffsetX === 'object') {
                        playerHitboxOffsetX = activePlayerChar.hitboxOffsetX;
                    } else {
                        const val = activePlayerChar.hitboxOffsetX;
                        playerHitboxOffsetX = { up: val, down: val, left: val, right: val };
                    }
                }
                console.log('Loaded per-direction hitbox:', JSON.stringify(playerHitboxRange));
                // Load attack movement setting
                if (activePlayerChar.attackMovement) {
                    playerAttackMovement = activePlayerChar.attackMovement;
                }
                // Load game over sound index
                if (activePlayerChar.gameOverSoundIndex !== undefined) {
                    playerGameOverSoundIndex = activePlayerChar.gameOverSoundIndex;
                }
                console.log('Using player character:', activePlayerChar.name, playerFrameWidth + 'x' + playerFrameHeight, 'attackMovement:', playerAttackMovement);
            }
        }

        // Load player sprite sheets (supports multiple sheets)
        const sheetsToLoad = activePlayerChar?.spriteSheets || (activePlayerChar?.spriteData ? [activePlayerChar.spriteData] : null) || (projectData.playerSpriteData ? [projectData.playerSpriteData] : null);

        if (sheetsToLoad && sheetsToLoad.length > 0) {
            // Load all sprite sheets
            let sheetsLoaded = 0;
            sheetsToLoad.forEach((sheetData, index) => {
                const sheetImg = new Image();
                sheetImg.onload = () => {
                    playerSpriteSheets[index] = sheetImg;
                    sheetsLoaded++;
                    console.log('Player sheet ' + (index + 1) + ' loaded (' + sheetsLoaded + '/' + sheetsToLoad.length + ')');
                    if (sheetsLoaded === sheetsToLoad.length) {
                        // All sheets loaded - set playerImg to first sheet for backwards compat
                        playerImg = playerSpriteSheets[0];
                        imagesLoaded++;
                        checkAllImagesLoaded();
                    }
                };
                sheetImg.onerror = () => {
                    console.error('Failed to load player sheet ' + (index + 1));
                    sheetsLoaded++;
                    if (sheetsLoaded === sheetsToLoad.length) {
                        imagesLoaded++;
                        checkAllImagesLoaded();
                    }
                };
                sheetImg.src = sheetData;
            });
        } else {
            // No player sprite data in save - skip loading
            console.warn('No player sprite data in project - player will not be visible');
            imagesLoaded++;
            checkAllImagesLoaded();
        }

        // Player state (matching game.js)
        const player = {
            x: 100,
            y: 100,
            width: 28,
            height: 76,
            speed: 5.5,
            direction: 'down',
            frame: 0,
            frameTimer: 0,
            moving: false,
            attacking: false,
            attackTimer: 0,
            // Health system
            health: 100,
            maxHealth: 100,
            invincible: false,
            invincibleTimer: 0
        };

        // Store initial spawn for respawn on death
        let initialSpawnX = 100;
        let initialSpawnY = 100;
        let initialSpawnMap = '';

        // Damage player function
        function damagePlayer(amount) {
            if (player.invincible || player.health <= 0) return;

            player.health -= amount;
            player.invincible = true;
            player.invincibleTimer = 90; // 1.5 seconds of invincibility

            console.log('[COMBAT] Player took', amount, 'damage! Health:', player.health);

            if (player.health <= 0) {
                player.health = 0;
                startPlayerDeath();
            }
        }

        // Death animation state
        let playerDying = false;
        let deathAnimFrame = 0;
        let deathAnimTimer = 0;
        let gameOverShown = false;

        // Start player death sequence
        function startPlayerDeath() {
            console.log('[COMBAT] Player died! Playing death animation...');
            playerDying = true;
            deathAnimFrame = 0;
            deathAnimTimer = 0;
            player.attacking = false;
            player.attackAnim = false;
        }

        // Update death animation
        function updateDeathAnimation() {
            if (!playerDying) return;

            deathAnimTimer++;

            // Get death animation frames
            const deathFrames = playerAnimations?.death || [];
            const deathFps = playerAnimFpsList?.death || 4; // Slow death anim
            const frameDelay = Math.round(60 / deathFps);

            if (deathFrames.length > 0) {
                if (deathAnimTimer >= frameDelay) {
                    deathAnimTimer = 0;
                    deathAnimFrame++;

                    // Death animation finished
                    if (deathAnimFrame >= deathFrames.length) {
                        playerDying = false;
                        showGameOver();
                    }
                }
            } else {
                // No death animation - just wait a moment then show game over
                if (deathAnimTimer >= 60) {
                    playerDying = false;
                    showGameOver();
                }
            }
        }

        // Show Game Over screen
        function showGameOver() {
            gameOverShown = true;
            document.getElementById('gameOverOverlay').style.display = 'flex';
            // Play game over sound if set
            // Index scheme: -1 = none, 0-99 = builtin sounds, 100+ = project sounds
            if (playerGameOverSoundIndex >= 0) {
                if (playerGameOverSoundIndex < 100) {
                    // Builtin sound
                    const builtinIndex = playerGameOverSoundIndex;
                    if (builtinIndex >= 0 && builtinIndex < builtinGameOverSounds.length) {
                        if (!builtinGameOverAudios[builtinIndex]) {
                            builtinGameOverAudios[builtinIndex] = new Audio(builtinGameOverSounds[builtinIndex].file);
                        }
                        builtinGameOverAudios[builtinIndex].currentTime = 0;
                        builtinGameOverAudios[builtinIndex].volume = 1.0;
                        builtinGameOverAudios[builtinIndex].play().catch(e => console.warn('Game over sound blocked:', e));
                    }
                } else {
                    // Project sound (index - 100)
                    const projectIndex = playerGameOverSoundIndex - 100;
                    if (projectIndex >= 0 && projectIndex < soundsData.length) {
                        playSound(projectIndex, 1.0, 0);
                    }
                }
            }
        }

        // Try Again - respawn player
        function tryAgain() {
            gameOverShown = false;
            document.getElementById('gameOverOverlay').style.display = 'none';
            respawnPlayer();
        }
        window.tryAgain = tryAgain; // Expose to onclick

        // Quit game
        function quitGame() {
            window.close();
        }
        window.quitGame = quitGame; // Expose to onclick

        // Respawn player at initial spawn
        function respawnPlayer() {
            console.log('[COMBAT] Respawning player...');
            player.health = player.maxHealth;
            player.x = initialSpawnX;
            player.y = initialSpawnY;
            player.invincible = true;
            player.invincibleTimer = 120; // 2 seconds after respawn
            playerDying = false;
            deathAnimFrame = 0;
            if (initialSpawnMap && initialSpawnMap !== currentGameMap) {
                // Switch to spawn map
                switchMap(initialSpawnMap, initialSpawnX / (gridSize * TILE_SCALE), initialSpawnY / (gridSize * TILE_SCALE));
            }
        }

        // Damage NPC (enemy) by amount
        function damageNPC(npcIndex, amount) {
            const placed = placedNpcs[npcIndex];
            const state = npcRuntimeState[npcIndex];
            if (!placed || !state || !placed.isEnemy) return;

            // Initialize HP if not set (default to 30 HP)
            if (state.hp === undefined) {
                state.hp = placed.maxHp || 30;
                state.maxHp = state.hp;
            }

            // Apply damage
            state.hp -= amount;
            state.damageCooldown = 30; // Brief invincibility
            state.hitFlash = 10; // Flash white for 10 frames

            console.log('[COMBAT] NPC', npcIndex, 'took', amount, 'damage! HP:', state.hp);

            // Check for death
            if (state.hp <= 0) {
                state.hp = 0;
                state.dead = true;
                console.log('[COMBAT] NPC', npcIndex, 'defeated!');
                // Track for quest system
                if (placed.uid) {
                    onEnemyDefeated(placed.uid);
                }
            }
        }

        // Check player attack hitbox against NPCs using cone/triangle shape
        function checkAttackHitbox() {
            if (!player.attacking || !player.attackAnim) return;

            const attackDamage = 10; // TODO: Make configurable
            const tileSize = gridSize * TILE_SCALE;

            // Track which NPCs we've hit this attack to prevent multiple hits
            if (player.attackHitNpcs === undefined) player.attackHitNpcs = {};

            // Get cone parameters for current direction
            const dir = player.direction;
            const range = (playerHitboxRange[dir] || 40) * TILE_SCALE;
            const halfAngle = ((playerHitboxWidth[dir] || 60) / 2) * (Math.PI / 180); // Convert to radians
            const offsetX = (playerHitboxOffsetX[dir] || 0) * TILE_SCALE;
            const offsetY = (playerHitboxOffsetY[dir] || 0) * TILE_SCALE;

            // Direction to angle (radians) - 0 is right, PI/2 is down
            const dirAngles = { right: 0, down: Math.PI / 2, left: Math.PI, up: -Math.PI / 2 };
            const baseAngle = dirAngles[dir] || 0;

            // Player center position with offset
            const playerCenterX = player.x + player.width / 2 + offsetX;
            const playerCenterY = player.y + player.height / 2 + offsetY;

            // Helper to check if a point is within the attack cone
            function isPointInCone(px, py) {
                const dx = px - playerCenterX;
                const dy = py - playerCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > range) return false;

                const angleToPoint = Math.atan2(dy, dx);
                let angleDiff = angleToPoint - baseAngle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                return Math.abs(angleDiff) <= halfAngle;
            }

            for (let i = 0; i < placedNpcs.length; i++) {
                const placed = placedNpcs[i];
                const state = npcRuntimeState[i];

                // Skip non-enemies, dead enemies, and already-hit enemies this attack
                if (!placed || !placed.isEnemy || !state) continue;
                if (state.dead) continue;
                if (player.attackHitNpcs[i]) continue;

                // Get NPC definition for collision mask
                const npc = npcsData[placed.npcIndex];
                if (!npc) continue;

                // Calculate NPC collision bounds from collision mask
                const frameW = npc.frameWidth || gridSize;
                const frameH = npc.frameHeight || gridSize;
                const npcScale = placed.scale || 1;
                const scaledW = tileSize * npcScale;
                const scaledH = tileSize * npcScale;
                const scaleX = scaledW / frameW;
                const scaleY = scaledH / frameH;

                // NPC base position (anchored at bottom-center like collision system)
                const npcBaseX = state.x * TILE_SCALE + (tileSize - scaledW) / 2;
                const npcBaseY = state.y * TILE_SCALE + tileSize - scaledH;

                // Calculate collision box position using insets
                let boxX, boxY, boxW, boxH;
                const insets = npc.collisionInsets;
                if (insets && (insets.top > 0 || insets.bottom > 0 || insets.left > 0 || insets.right > 0)) {
                    boxX = npcBaseX + insets.left * scaleX;
                    boxY = npcBaseY + insets.top * scaleY;
                    boxW = scaledW - (insets.left + insets.right) * scaleX;
                    boxH = scaledH - (insets.top + insets.bottom) * scaleY;
                } else {
                    // No insets - use full sprite bounds
                    boxX = npcBaseX;
                    boxY = npcBaseY;
                    boxW = scaledW;
                    boxH = scaledH;
                }

                // Check multiple points on the collision box against the attack cone
                const points = [
                    // 4 corners
                    [boxX, boxY],
                    [boxX + boxW, boxY],
                    [boxX, boxY + boxH],
                    [boxX + boxW, boxY + boxH],
                    // Center
                    [boxX + boxW / 2, boxY + boxH / 2],
                    // Edge midpoints
                    [boxX + boxW / 2, boxY],           // Top middle
                    [boxX + boxW / 2, boxY + boxH],    // Bottom middle
                    [boxX, boxY + boxH / 2],           // Left middle
                    [boxX + boxW, boxY + boxH / 2]     // Right middle
                ];

                // If any point is in the cone, register a hit
                let hit = false;
                for (const [px, py] of points) {
                    if (isPointInCone(px, py)) {
                        hit = true;
                        break;
                    }
                }

                if (hit) {
                    damageNPC(i, attackDamage);
                    player.attackHitNpcs[i] = true;
                }
            }
        }

        // === MULTIPLAYER SYSTEM ===
        let mpSocket = null;
        let mpConnected = false;
        let mpPlayerName = 'Player';
        let mpLastSendTime = 0;
        const otherPlayers = new Map(); // id -> {x, y, targetX, targetY, direction, animation, name, frame, frameTimer}

        // Initialize multiplayer if settings provided
        if (projectData.multiplayer) {
            mpPlayerName = projectData.multiplayer.playerName || 'Player';
            const roomCode = projectData.multiplayer.roomCode;
            console.log('[MP] Connecting as', mpPlayerName, 'to room', roomCode);

            try {
                mpSocket = new WebSocket('wss://multiplayer.lakotafox.partykit.dev/party/' + roomCode);

                mpSocket.onopen = () => {
                    console.log('[MP] Connected to server');
                    mpConnected = true;
                    // Send join message
                    mpSocket.send(JSON.stringify({
                        type: 'join',
                        name: mpPlayerName,
                        x: player.x,
                        y: player.y,
                        direction: player.direction,
                        animation: 'idle',
                        currentMap: currentGameMap,
                        gameType: 'game2d'
                    }));
                };

                mpSocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        logNetworkEvent(data.type || 'unknown', 'recv', data, event.data.length);
                        handleMpMessage(data);
                    } catch (e) {
                        console.error('[MP] Error parsing message:', e);
                    }
                };

                mpSocket.onclose = () => {
                    console.log('[MP] Disconnected');
                    mpConnected = false;
                };

                mpSocket.onerror = (err) => {
                    console.error('[MP] WebSocket error:', err);
                };
            } catch (e) {
                console.error('[MP] Failed to connect:', e);
            }
        }

        function handleMpMessage(data) {
            switch (data.type) {
                case 'welcome':
                    console.log('[MP] Welcome:', data.message);
                    // Spawn existing players (only game2d ones)
                    if (data.players) {
                        data.players.filter(p => p.gameType === 'game2d').forEach(p => {
                            otherPlayers.set(p.id, {
                                x: p.x, y: p.y,
                                targetX: p.x, targetY: p.y,
                                direction: p.direction || 'down',
                                animation: p.animation || 'idle',
                                name: p.name || 'Player',
                                currentMap: p.currentMap || 'main',
                                inTavern: p.inTavern || false,
                                frame: 0, frameTimer: 0
                            });
                            console.log('[MP] Added existing player:', p.name, 'on map:', p.currentMap);
                        });
                    }
                    break;

                case 'join':
                    if (data.player && data.player.gameType === 'game2d') {
                        otherPlayers.set(data.player.id, {
                            x: data.player.x, y: data.player.y,
                            targetX: data.player.x, targetY: data.player.y,
                            direction: data.player.direction || 'down',
                            animation: data.player.animation || 'idle',
                            name: data.player.name || 'Player',
                            currentMap: data.player.currentMap || 'main',
                            inTavern: data.player.inTavern || false,
                            frame: 0, frameTimer: 0
                        });
                        console.log('[MP] Player joined:', data.player.name, 'on map:', data.player.currentMap);
                    }
                    break;

                case 'update':
                    if (data.player && data.player.gameType === 'game2d') {
                        const other = otherPlayers.get(data.player.id);
                        if (other) {
                            // Set target position (will lerp toward it)
                            other.targetX = data.player.x;
                            other.targetY = data.player.y;
                            other.direction = data.player.direction || other.direction;
                            other.animation = data.player.animation || other.animation;
                            other.currentMap = data.player.currentMap || other.currentMap;
                            other.inTavern = data.player.inTavern || false;
                        }
                    }
                    break;

                case 'leave':
                    if (data.playerId) {
                        const leaving = otherPlayers.get(data.playerId);
                        if (leaving) {
                            console.log('[MP] Player left:', leaving.name);
                            otherPlayers.delete(data.playerId);
                        }
                    }
                    break;

                case 'builderEdit':
                    // Received a builder edit relayed from another player
                    if (data.edit) {
                        console.log('[MP] Received builder edit from other player');
                        applyLiveEdit(data.edit, true); // true = from multiplayer, don't relay again
                    }
                    break;

                case 'itemInteract':
                    // Another player interacted with an item
                    if (data.itemIndex !== undefined && itemStates[data.itemIndex]) {
                        const state = itemStates[data.itemIndex];
                        if (!state.used && !state.animating) {
                            state.animating = true;
                            state.frame = 0;
                            state.frameTimer = 0;
                            console.log('[MP] Remote player opened item at', data.x, data.y);
                        }
                    }
                    break;

                case 'propInteract':
                    // Another player interacted with an animated prop
                    if (data.key) {
                        if (!interactivePropStates[data.key]) {
                            interactivePropStates[data.key] = { used: false, animating: false, frame: 0, gaveItem: false };
                        }
                        const state = interactivePropStates[data.key];
                        if (!state.used && !state.animating) {
                            state.animating = true;
                            state.frame = 0;
                            console.log('[MP] Remote player opened prop at', data.originX, data.originY);
                        }
                    }
                    break;
            }
        }

        function sendMpUpdate() {
            if (!mpConnected || !mpSocket) return;
            const now = Date.now();
            if (now - mpLastSendTime < 100) return; // Throttle to 10/sec
            mpLastSendTime = now;

            mpSocket.send(JSON.stringify({
                type: 'update',
                x: player.x,
                y: player.y,
                direction: player.direction,
                animation: player.moving ? 'walk' : 'idle',
                currentMap: currentGameMap,
                inTavern: inTavernMode
            }));
        }

        // === SOUND SYSTEM ===
        let soundsData = projectData.sounds || []; // 'let' so we can receive streamed sounds
        // Use outer scope tileSounds for live sync
        tileSounds = projectData.tileSounds || {};
        const playerSoundsData = projectData.playerSounds || {
            walk: { soundIndex: -1, interval: 200, volume: 0.5, pitchVariation: 0.1 },
            attack: { soundIndex: -1, volume: 0.7, pitchVariation: 0.15, lengthVariation: 0 }
        };
        const soundsWillStream = projectData.soundsWillStream || false;
        let soundsStreamedCount = 0;

        console.log('=== SOUND DATA LOADED ===');
        console.log('Sounds array:', soundsData.length, soundsData);
        console.log('Sounds will stream:', soundsWillStream);
        console.log('Tile sounds:', Object.keys(tileSounds).length, tileSounds);
        console.log('Player sounds:', playerSoundsData);

        // On mobile (streaming mode), create audioContext early so we can decode sounds as they arrive
        if (soundsWillStream) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('Audio context created for streaming sounds');
            } catch (e) {
                console.warn('Could not create audio context for streaming:', e);
            }
        }

        // === TRIGGER/MAP SYSTEM ===
        // Use outer scope placedTriggers for live sync
        placedTriggers = projectData.placedTriggers || [];
        const mapsData = projectData.maps || {};
        const spawnMapNameData = projectData.spawnMapName || 'main';
        currentGameMap = spawnMapNameData; // Start on the map where spawn is set
        onMapEnter(currentGameMap);  // Track initial map for quest conditions
        console.log('Triggers:', placedTriggers.length, 'Maps:', Object.keys(mapsData).length, 'SpawnMap:', spawnMapNameData);

        // === DIALOG SYSTEM ===
        const dialogs = projectData.dialogs || [];
        const placedDialogTiles = projectData.placedDialogTiles || [];
        console.log('Dialogs:', dialogs.length, 'Dialog tiles:', placedDialogTiles.length);

        // === ITEMS SYSTEM (interactive objects like chests) ===
        const itemsData = projectData.items || [];
        const placedItemsData = projectData.placedItems || [];
        const itemImages = {}; // Preloaded item sprite images
        const itemStates = {}; // Runtime state for each placed item: { used: false, animating: false, frame: 0 }

        // Preload item sprites
        itemsData.forEach((item, i) => {
            if (item.spriteData) {
                const img = new Image();
                img.src = item.spriteData;
                itemImages[i] = img;
            }
        });

        // Initialize item states
        placedItemsData.forEach((placed, i) => {
            itemStates[i] = {
                used: placed.used || false,
                animating: false,
                frame: itemsData[placed.itemIndex]?.idleFrame || 0,
                frameTimer: 0
            };
        });
        console.log('Items:', itemsData.length, 'Placed items:', placedItemsData.length);

        // Debug: log all received triggers
        console.log('=== TEST GAME RECEIVED TRIGGERS ===');
        placedTriggers.forEach((t, i) => {
            console.log('Trigger ' + i + ': Door ' + t.doorNumber + ' at (' + t.x + ',' + t.y + ') on "' + t.mapName + '" -> "' + t.targetMap + '" spawn (' + t.targetX + ',' + t.targetY + ')');
        });

        // Listen for streamed sound data from builder (mobile only)
        // Decode each sound as it arrives to avoid freeze on first play
        if (soundsWillStream) {
            console.log('Waiting for sound data to stream from builder...');
            window.addEventListener('message', function(e) {
                if (e.data && e.data.type === 'sound-data') {
                    const { index, data, name } = e.data;
                    if (soundsData[index]) {
                        soundsData[index].data = data;
                        soundsStreamedCount++;
                        console.log('Received sound', index, name, '(' + soundsStreamedCount + '/' + soundsData.length + ')');

                        // Pre-decode this sound in background so it's ready when needed
                        if (audioContext && data) {
                            try {
                                const base64 = data.split(',')[1];
                                const binary = atob(base64);
                                const bytes = Uint8Array.from(binary, c => c.charCodeAt(0));
                                const audioBuffer = bytes.buffer.slice(0);
                                audioContext.decodeAudioData(audioBuffer, (buffer) => {
                                    soundBuffers[index] = buffer;
                                    console.log('Pre-decoded streamed sound', index, name);
                                }, (err) => {
                                    console.warn('Failed to decode streamed sound', index, err);
                                });
                            } catch (err) {
                                console.warn('Error decoding streamed sound', index, ':', err.message);
                            }
                        }
                    }
                } else if (e.data && e.data.type === 'sounds-complete') {
                    console.log('All sounds received from builder');
                }
            });
        }

        // === LIGHTING SYSTEM ===
        const currentMapName = 'main'; // Default map name for lighting keys
        const lightingSettingsData = projectData.lightingSettings || {
            playerLight: false,
            playerLightRadius: 4
        };
        // Use outer scope pointLights/polyLights for live sync
        pointLights = projectData.pointLights || {};
        polyLights = projectData.polyLights || [];
        console.log('[INIT] Loaded polyLights:', polyLights.length, polyLights);
        const TIME_PRESETS = {
            dawn:  { r: 0, g: 0, b: 20, a: 0.45 },
            day:   { r: 0, g: 0, b: 0, a: 0 },
            dusk:  { r: 0, g: 0, b: 20, a: 0.55 },
            night: { r: 0, g: 0, b: 20, a: 0.95 }
        };

        // Day/Night cycle system
        let dayCycleEnabled = false;
        let dayLength = 60; // seconds for full cycle (1 min default)
        let cycleTime = 0;  // current position in cycle (0-1)
        let lastCycleUpdate = Date.now();
        let currentLighting = { r: 0, g: 0, b: 0, a: 0 }; // interpolated values
        let manualDarkness = 0; // 0-100, used when cycle is off

        // Shadow settings (fixed values)
        const shadowWidth = 21;
        const shadowHeight = 8;
        const shadowYOffset = 17;

        // === NPC SYSTEM ===
        // Use outer scope variables for live sync
        npcsData = projectData.npcs || [];
        placedNpcs = projectData.placedNpcs || [];
        npcImages = [];
        // gridSize is already set from projectData above

        // Migrate old collisionMask/collisionBox to collisionInsets (backwards compatibility)
        npcsData.forEach(npc => {
            if (npc && !npc.collisionInsets) {
                const frameW = npc.frameWidth || 32;
                const frameH = npc.frameHeight || 32;
                if (npc.collisionBox) {
                    // Migrate from old collisionBox format
                    npc.collisionInsets = {
                        top: npc.collisionBox.y || 0,
                        bottom: Math.max(0, frameH - (npc.collisionBox.y || 0) - (npc.collisionBox.height || frameH)),
                        left: npc.collisionBox.x || 0,
                        right: Math.max(0, frameW - (npc.collisionBox.x || 0) - (npc.collisionBox.width || frameW))
                    };
                } else if (npc.collisionMask) {
                    // Migrate from very old collisionMask format
                    let minX = Infinity, maxX = -1, minY = Infinity, maxY = -1;
                    for (let py = 0; py < npc.collisionMask.length; py++) {
                        if (!npc.collisionMask[py]) continue;
                        for (let px = 0; px < npc.collisionMask[py].length; px++) {
                            if (npc.collisionMask[py][px] === 1) {
                                minX = Math.min(minX, px);
                                maxX = Math.max(maxX, px);
                                minY = Math.min(minY, py);
                                maxY = Math.max(maxY, py);
                            }
                        }
                    }
                    if (minX !== Infinity) {
                        npc.collisionInsets = {
                            top: minY,
                            bottom: Math.max(0, frameH - maxY - 1),
                            left: minX,
                            right: Math.max(0, frameW - maxX - 1)
                        };
                    }
                }
            }
        });

        // Ensure all placed NPCs have UIDs (for backwards compatibility with older saves)
        placedNpcs.forEach((npc, i) => {
            if (!npc.uid) {
                npc.uid = 'npc_' + npc.npcIndex + '_' + i + '_' + Date.now();
            }
        });

        // Load NPC sprites (counted in imagesToLoad)
        npcsData.forEach((npc, i) => {
            if (npc && npc.spriteData) {
                const img = new Image();
                img.onload = () => {
                    console.log('NPC sprite loaded:', npc.name, '(' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error('Failed to load NPC sprite:', npc.name);
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.src = npc.spriteData;
                npcImages[i] = img;
            }
        });

        // NPC runtime state for each placed NPC
        npcRuntimeState = placedNpcs.map((placed, i) => createNpcRuntimeState(placed));

        // Helper function to create NPC runtime state (also used by live sync)
        function createNpcRuntimeState(placed) {
            return {
                // Position (in pixels)
                x: placed.x * gridSize,
                y: placed.y * gridSize,
                // Path following
                currentWaypoint: 0,
                pathDirection: 1, // 1 = forward, -1 = backward (for non-loop paths)
                // Animation
                direction: 'down',
                frame: 0,
                frameTimer: 0,
                // Movement
                moving: false,
                targetX: placed.x * gridSize,
                targetY: placed.y * gridSize,
                // Trigger state
                triggered: placed.trigger === 'loop', // Loop starts immediately
                waitTimer: 0,
                // Waypoint properties
                idleUntil: 0, // Timestamp when idle ends
                waypointAnimation: '', // Custom animation at waypoint
                // Enemy AI state
                aiState: 'idle', // 'idle', 'chase', 'attack', 'recover', 'return'
                aggroTimer: 0, // Time player has been in/out of vision
                attackCooldown: 0, // Time until can attack again
                returnX: placed.x * gridSize, // Position to return to when de-aggro
                returnY: placed.y * gridSize,
                lastAttackTime: 0 // Timestamp of last attack
            };
        }

        console.log('NPCs loaded:', npcsData.length, 'Placed:', placedNpcs.length);

        // Cycle phases: long night with peak darkness held for 50% of each night period
        // Night1: 0-30% (peak 0-15%), EarlyMorn: 30-38%, Dawn: 38-45%, Day: 45-55%,
        // Afternoon: 55-62%, Dusk: 62-70%, Night2: 70-100% (peak 85-100%)
        function updateDayCycle() {
            if (!dayCycleEnabled) return;

            const now = Date.now();
            const delta = (now - lastCycleUpdate) / 1000; // seconds
            lastCycleUpdate = now;

            // Advance cycle
            cycleTime += delta / dayLength;
            if (cycleTime >= 1) cycleTime -= 1;

            // Determine current phase and interpolation
            let fromPreset, toPreset, t, phaseName;

            if (cycleTime < 0.15) {
                // Peak Night 1 (0-15%) - full darkness
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = 0;
                phaseName = 'Night';
            } else if (cycleTime < 0.30) {
                // Late Night (15-30%) - very slowly lightening
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = (cycleTime - 0.15) / 0.15 * 0.1; // barely lighten
                phaseName = 'Late Night';
            } else if (cycleTime < 0.38) {
                // Early Morning (30-38%) - still very dark
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.dawn;
                t = (cycleTime - 0.30) / 0.08 * 0.4;
                phaseName = 'Early Morn';
            } else if (cycleTime < 0.45) {
                // Dawn (38-45%)
                fromPreset = TIME_PRESETS.dawn;
                toPreset = TIME_PRESETS.day;
                t = (cycleTime - 0.38) / 0.07;
                phaseName = 'Dawn';
            } else if (cycleTime < 0.55) {
                // Day (45-55%)
                fromPreset = TIME_PRESETS.day;
                toPreset = TIME_PRESETS.day;
                t = 0;
                phaseName = 'Day';
            } else if (cycleTime < 0.62) {
                // Afternoon (55-62%)
                fromPreset = TIME_PRESETS.day;
                toPreset = TIME_PRESETS.dusk;
                t = (cycleTime - 0.55) / 0.07;
                phaseName = 'Afternoon';
            } else if (cycleTime < 0.70) {
                // Dusk (62-70%)
                fromPreset = TIME_PRESETS.dusk;
                toPreset = TIME_PRESETS.night;
                t = (cycleTime - 0.62) / 0.08;
                phaseName = 'Dusk';
            } else if (cycleTime < 0.85) {
                // Early Night (70-85%) - getting darker
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = 0;
                phaseName = 'Early Night';
            } else {
                // Peak Night 2 (85-100%) - full darkness
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = 0;
                phaseName = 'Night';
            }

            // Smooth interpolation
            currentLighting.r = Math.round(fromPreset.r + (toPreset.r - fromPreset.r) * t);
            currentLighting.g = Math.round(fromPreset.g + (toPreset.g - fromPreset.g) * t);
            currentLighting.b = Math.round(fromPreset.b + (toPreset.b - fromPreset.b) * t);
            currentLighting.a = fromPreset.a + (toPreset.a - fromPreset.a) * t;

            // Update display
            const timeDisplay = document.getElementById('timeDisplay');
            if (timeDisplay) {
                timeDisplay.textContent = 'Time: ' + phaseName + ' (' + Math.round(cycleTime * 100) + '%)';
            }
        }

        console.log('=== LIGHTING DATA LOADED ===');
        console.log('Lighting settings:', lightingSettingsData);
        console.log('Point lights:', Object.keys(pointLights).length);

        // === NPC UPDATE FUNCTION ===
        function updateNPCs() {
            placedNpcs.forEach((placed, i) => {
                // Only update NPCs on current map
                if (placed.mapName && placed.mapName !== currentGameMap) return;

                const state = npcRuntimeState[i];
                if (!state) return;

                // Skip movement if NPC is paused for dialog
                if (state._dialogPaused) {
                    state.moving = false;
                    return;
                }

                const npc = npcsData[placed.npcIndex];
                if (!npc) return;

                const path = placed.path || [];
                const speed = (placed.speed || 3) * 0.5; // Convert to pixel speed

                // Check trigger conditions
                if (!state.triggered) {
                    if (placed.trigger === 'interact') {
                        // Triggered by player attack - check if player is attacking nearby
                        if (player.attacking) {
                            const dist = Math.hypot(player.x - state.x, player.y - state.y);
                            if (dist < gridSize * 2) {
                                state.triggered = true;
                            }
                        }
                    } else if (placed.trigger === 'timeDay') {
                        // Only active during day
                        state.triggered = dayCycleEnabled && cycleTime > 0.38 && cycleTime < 0.70;
                    } else if (placed.trigger === 'timeNight') {
                        // Only active during night
                        state.triggered = dayCycleEnabled && (cycleTime < 0.38 || cycleTime > 0.70);
                    }
                }

                // Reset trigger for time-based when condition no longer met
                if (placed.trigger === 'timeDay' && state.triggered) {
                    if (!dayCycleEnabled || cycleTime < 0.38 || cycleTime > 0.70) {
                        state.triggered = false;
                        state.currentWaypoint = 0;
                    }
                }
                if (placed.trigger === 'timeNight' && state.triggered) {
                    if (!dayCycleEnabled || (cycleTime > 0.38 && cycleTime < 0.70)) {
                        state.triggered = false;
                        state.currentWaypoint = 0;
                    }
                }

                // === ENEMY AI STATE MACHINE ===
                if (placed.isEnemy && !state.dead) {
                    const visionRadius = (placed.visionRadius || 5) * gridSize * TILE_SCALE;
                    const attackRange = (placed.attackRange || 2) * gridSize * TILE_SCALE;
                    const chaseSpeed = (placed.chaseSpeed || 4) * TILE_SCALE * 0.5;
                    const attackMode = placed.attackMode || 'touch';
                    const damage = placed.damage || 10;
                    const cooldownTime = (placed.attackCooldown || 1) * 60; // Convert seconds to frames
                    const lungeSpeed = (placed.lungeSpeed || 8) * TILE_SCALE * 0.5;

                    // NPC state uses unscaled coords, player uses scaled - convert NPC to scaled
                    const npcScaledX = state.x * TILE_SCALE;
                    const npcScaledY = state.y * TILE_SCALE;

                    // Calculate distance to player (both in scaled coordinates now)
                    const distToPlayer = Math.hypot(player.x - npcScaledX, player.y - npcScaledY);

                    // Initialize AI state if not set
                    if (!state.aiState) state.aiState = 'idle';
                    if (state.returnX === undefined) state.returnX = state.x;
                    if (state.returnY === undefined) state.returnY = state.y;
                    if (state.damageCooldown === undefined) state.damageCooldown = 0;

                    // Decrement damage cooldown
                    if (state.damageCooldown > 0) state.damageCooldown--;

                    // NPC scale affects hitbox size
                    const npcScale = placed.scale || 1;

                    // Contact hitbox size (scales with NPC)
                    const npcW = gridSize * TILE_SCALE * 0.7 * npcScale;
                    const npcH = gridSize * TILE_SCALE * 0.7 * npcScale;

                    // Get slowdown settings from placed NPC
                    const slowdownPercent = placed.slowdownPercent !== undefined ? placed.slowdownPercent : 50;
                    const slowdownDuration = placed.slowdownDuration !== undefined ? placed.slowdownDuration : 0.5;
                    const slowdownFrames = Math.floor(slowdownDuration * 60); // Convert to frames

                    // Check for contact damage (Touch mode or during Lunge)
                    const touchDistance = gridSize * TILE_SCALE * 0.6 * npcScale;
                    if (distToPlayer < touchDistance && state.damageCooldown <= 0) {
                        if (attackMode === 'touch' || state.aiState === 'lunge') {
                            damagePlayer(damage);
                            state.damageCooldown = cooldownTime;
                            // Trigger attack animation
                            state.attackAnimTimer = 30; // ~0.5 sec of attack anim
                            state.attackAnimFrame = 0;
                            // Trigger post-attack slowdown
                            state.slowdownTimer = slowdownFrames;
                            if (attackMode === 'lunge' && state.aiState === 'lunge') {
                                state.aiState = 'recover';
                                state.attackCooldown = 0;
                            }
                        }
                    }

                    // Decrement attack animation timer
                    if (state.attackAnimTimer > 0) {
                        state.attackAnimTimer--;
                        state.attackAnimFrame++;
                    }
                    // Decrement slowdown timer
                    if (state.slowdownTimer > 0) {
                        state.slowdownTimer--;
                    }

                    // State machine transitions
                    switch (state.aiState) {
                        case 'idle':
                            // Check if player is in vision range
                            if (distToPlayer <= visionRadius) {
                                state.aiState = 'chase';
                                state.aggroTimer = 0;
                            }
                            break;

                        case 'chase':
                            // Check if player left vision range for too long
                            if (distToPlayer > visionRadius * 1.5) {
                                state.aggroTimer++;
                                if (state.aggroTimer > 180) { // 3 seconds at 60fps
                                    state.aiState = 'return';
                                    state.aggroTimer = 0;
                                }
                            } else {
                                state.aggroTimer = 0;
                            }

                            // Lunge mode: start lunge when in attack range
                            if (attackMode === 'lunge' && distToPlayer <= attackRange && state.damageCooldown <= 0) {
                                state.aiState = 'lunge';
                                // Store target in unscaled coords (same as state.x/y)
                                state.lungeTargetX = player.x / TILE_SCALE;
                                state.lungeTargetY = player.y / TILE_SCALE;
                                state.lungeTimer = 0;
                            }
                            break;

                        case 'lunge':
                            // Dash toward the stored target position (both in unscaled coords)
                            const ldx = state.lungeTargetX - state.x;
                            const ldy = state.lungeTargetY - state.y;
                            const ldist = Math.hypot(ldx, ldy);
                            const unscaledLungeSpeed = lungeSpeed / TILE_SCALE;

                            state.lungeTimer++;

                            if (ldist > unscaledLungeSpeed && state.lungeTimer < 30) {
                                // Move toward lunge target at high speed
                                const lmoveX = (ldx / ldist) * unscaledLungeSpeed;
                                const lmoveY = (ldy / ldist) * unscaledLungeSpeed;

                                // Check collision (scale up position for collision check)
                                const scaledX = (state.x + lmoveX) * TILE_SCALE;
                                const scaledY = (state.y + lmoveY) * TILE_SCALE;
                                if (!checkCollision(scaledX, scaledY, npcW, npcH)) {
                                    state.x += lmoveX;
                                    state.y += lmoveY;
                                    state.moving = true;
                                } else {
                                    // Hit a wall, end lunge
                                    state.aiState = 'recover';
                                    state.attackCooldown = 0;
                                }

                                // Set direction
                                if (Math.abs(ldx) > Math.abs(ldy)) {
                                    state.direction = ldx > 0 ? 'right' : 'left';
                                } else {
                                    state.direction = ldy > 0 ? 'down' : 'up';
                                }
                            } else {
                                // Lunge complete or timeout
                                state.aiState = 'recover';
                                state.attackCooldown = 0;
                            }
                            break;

                        case 'recover':
                            // Recovery period after attack
                            state.attackCooldown++;
                            state.moving = false;
                            if (state.attackCooldown > 45) { // 0.75 second recovery
                                if (distToPlayer <= visionRadius) {
                                    state.aiState = 'chase';
                                } else {
                                    state.aiState = 'return';
                                }
                                state.attackCooldown = 0;
                            }
                            break;

                        case 'return':
                            // Check if back at start position
                            const distToHome = Math.hypot(state.returnX - state.x, state.returnY - state.y);
                            if (distToHome < chaseSpeed) {
                                state.x = state.returnX;
                                state.y = state.returnY;
                                state.aiState = 'idle';
                            }
                            // If player gets close again while returning, chase
                            if (distToPlayer <= visionRadius * 0.75) {
                                state.aiState = 'chase';
                            }
                            break;
                    }

                    // Handle movement based on AI state (chase and return)
                    if (state.aiState === 'chase' || state.aiState === 'return') {
                        let targetX, targetY;
                        if (state.aiState === 'chase') {
                            // Convert player position to unscaled coords
                            targetX = player.x / TILE_SCALE;
                            targetY = player.y / TILE_SCALE;
                        } else {
                            // Return position is already in unscaled coords
                            targetX = state.returnX;
                            targetY = state.returnY;
                        }

                        const dx = targetX - state.x;
                        const dy = targetY - state.y;
                        const dist = Math.hypot(dx, dy);

                        // Convert chase speed to unscaled coords
                        // Apply slowdown if timer is active
                        let effectiveSpeed = chaseSpeed;
                        if (state.slowdownTimer > 0) {
                            effectiveSpeed = chaseSpeed * (1 - slowdownPercent / 100);
                        }
                        const unscaledChaseSpeed = effectiveSpeed / TILE_SCALE;

                        if (dist > unscaledChaseSpeed) {
                            // Normalize movement (in unscaled coords)
                            let moveX = (dx / dist) * unscaledChaseSpeed;
                            let moveY = (dy / dist) * unscaledChaseSpeed;

                            // Scale up for collision checks
                            const newScaledX = (state.x + moveX) * TILE_SCALE;
                            const newScaledY = (state.y + moveY) * TILE_SCALE;

                            // Collision-aware movement - try full move, then axis by axis
                            if (!checkCollision(newScaledX, newScaledY, npcW, npcH) &&
                                !checkNPCPlayerCollision(newScaledX, newScaledY, i)) {
                                state.x += moveX;
                                state.y += moveY;
                                state.moving = true;
                            } else {
                                // Try X-only movement
                                const xOnlyScaledX = (state.x + moveX) * TILE_SCALE;
                                const xOnlyScaledY = state.y * TILE_SCALE;
                                if (Math.abs(moveX) > 0.1 &&
                                    !checkCollision(xOnlyScaledX, xOnlyScaledY, npcW, npcH) &&
                                    !checkNPCPlayerCollision(xOnlyScaledX, xOnlyScaledY, i)) {
                                    state.x += moveX;
                                    state.moving = true;
                                }
                                // Try Y-only movement
                                else {
                                    const yOnlyScaledX = state.x * TILE_SCALE;
                                    const yOnlyScaledY = (state.y + moveY) * TILE_SCALE;
                                    if (Math.abs(moveY) > 0.1 &&
                                        !checkCollision(yOnlyScaledX, yOnlyScaledY, npcW, npcH) &&
                                        !checkNPCPlayerCollision(yOnlyScaledX, yOnlyScaledY, i)) {
                                        state.y += moveY;
                                        state.moving = true;
                                    } else {
                                        state.moving = false;
                                    }
                                }
                            }

                            // Set direction based on target
                            if (Math.abs(dx) > Math.abs(dy)) {
                                state.direction = dx > 0 ? 'right' : 'left';
                            } else {
                                state.direction = dy > 0 ? 'down' : 'up';
                            }
                        } else {
                            state.moving = false;
                        }
                    } else if (state.aiState === 'idle' || state.aiState === 'recover') {
                        state.moving = false;
                    }

                    // Update animation for enemy (only when not idle - idle uses normal path anim)
                    if (state.aiState !== 'idle') {
                        state.frameTimer++;
                        const fps = placed.animSpeed || npc.fps || 8;
                        const animSpeed = Math.max(1, Math.round(60 / fps));
                        if (state.frameTimer >= animSpeed) {
                            state.frameTimer = 0;
                            state.frame = (state.frame + 1) % 4;
                        }
                        return; // Skip normal path movement when chasing/attacking/returning
                    }
                    // If idle, fall through to normal path movement (patrol behavior)
                }

                // Skip movement if not triggered or no path
                if (!state.triggered || path.length === 0) {
                    state.moving = false;
                    // Still animate idle NPCs even with no path
                    state.frameTimer++;
                    const fps = placed.animSpeed || npc.fps || 8;
                    const animSpeed = Math.max(1, Math.round(60 / fps));
                    if (state.frameTimer >= animSpeed) {
                        state.frameTimer = 0;
                        state.frame = (state.frame + 1) % 4;
                    }
                    return;
                }

                // Get current waypoint target
                const waypoint = path[state.currentWaypoint];
                if (!waypoint) {
                    // Reset to start
                    state.currentWaypoint = 0;
                    return;
                }

                state.targetX = waypoint.x * gridSize;
                state.targetY = waypoint.y * gridSize;

                // Calculate direction to target
                const dx = state.targetX - state.x;
                const dy = state.targetY - state.y;
                const dist = Math.hypot(dx, dy);

                // Check if currently idling at a waypoint
                if (state.idleUntil > 0) {
                    if (performance.now() < state.idleUntil) {
                        // Still idling - don't move, but keep animating
                        state.moving = false;
                        // Update animation while idling (use per-NPC animation speed)
                        state.frameTimer++;
                        const idleFps = placed.animSpeed || npc.fps || 8;
                        const idleAnimSpeed = Math.max(1, Math.round(60 / idleFps));
                        if (state.frameTimer >= idleAnimSpeed) {
                            state.frameTimer = 0;
                            state.frame = (state.frame + 1) % 4;
                        }
                        return;
                    } else {
                        // Idle complete - advance to next waypoint
                        state.idleUntil = 0;
                        state.waypointAnimation = '';
                        state.currentWaypoint++;

                        // Check if path complete after advancing
                        if (state.currentWaypoint >= path.length) {
                            if (placed.trigger === 'loop') {
                                state.currentWaypoint = 0;
                                state.x = placed.x * gridSize;
                                state.y = placed.y * gridSize;
                            } else {
                                state.triggered = false;
                                state.currentWaypoint = 0;
                                state.x = placed.x * gridSize;
                                state.y = placed.y * gridSize;
                            }
                        }
                        return; // Start moving to next waypoint on next frame
                    }
                }

                if (dist < speed) {
                    // Reached waypoint
                    state.x = state.targetX;
                    state.y = state.targetY;

                    // Check for waypoint properties (idle time, animation)
                    const currentWp = path[state.currentWaypoint];
                    let idleTime = currentWp?.idleTime || 0;
                    const wpAnim = currentWp?.animation || '';

                    // If animation is set but not "walk", ensure minimum idle time
                    if (wpAnim && wpAnim !== 'walk' && wpAnim !== '' && idleTime <= 0) {
                        idleTime = 2; // Default 2 seconds if animation set but no duration
                    }

                    if (idleTime > 0 && state.idleUntil === 0) {
                        // Start idling/performing action at this waypoint
                        state.idleUntil = performance.now() + (idleTime * 1000);
                        state.waypointAnimation = wpAnim;
                        state.moving = false;
                        // Don't advance waypoint - will advance after idle completes
                        return;
                    }

                    state.currentWaypoint++;

                    // Check if path complete
                    if (state.currentWaypoint >= path.length) {
                        if (placed.trigger === 'loop') {
                            // Return to start position, then repeat path
                            state.currentWaypoint = 0;
                            state.x = placed.x * gridSize;
                            state.y = placed.y * gridSize;
                        } else {
                            // One-shot trigger - stop and reset
                            state.triggered = false;
                            state.currentWaypoint = 0;
                            state.x = placed.x * gridSize;
                            state.y = placed.y * gridSize;
                        }
                    }
                    state.moving = false;
                } else {
                    // Move towards waypoint
                    const moveX = (dx / dist) * speed;
                    const moveY = (dy / dist) * speed;
                    const newX = state.x + moveX;
                    const newY = state.y + moveY;

                    // Check if NPC would collide with player
                    if (checkNPCPlayerCollision(newX, newY, i)) {
                        // Stop and wait for player to move
                        state.moving = false;
                        // Still face the direction of movement
                        if (Math.abs(dx) > Math.abs(dy)) {
                            state.direction = dx > 0 ? 'right' : 'left';
                        } else {
                            state.direction = dy > 0 ? 'down' : 'up';
                        }
                    } else {
                        // No collision, proceed with movement
                        state.moving = true;
                        state.x = newX;
                        state.y = newY;

                        // Set direction based on movement
                        if (Math.abs(dx) > Math.abs(dy)) {
                            state.direction = dx > 0 ? 'right' : 'left';
                        } else {
                            state.direction = dy > 0 ? 'down' : 'up';
                        }
                    }
                }

                // Update animation using per-NPC animation speed
                state.frameTimer++;
                const fps = placed.animSpeed || npc.fps || 8;
                const animSpeed = Math.max(1, Math.round(60 / fps)); // Convert fps to frame delay
                if (state.frameTimer >= animSpeed) {
                    state.frameTimer = 0;
                    state.frame = (state.frame + 1) % 4;
                }
            });
        }

        // Offscreen canvas for lighting effects
        let lightCanvas = null;
        let lightCtx = null;

        // Flicker optimization - cache random values and update less frequently
        let flickerValues = {}; // key -> { value, lastUpdate }
        let lastFlickerUpdate = 0;
        const FLICKER_UPDATE_INTERVAL = 80; // ms between flicker updates (12.5 fps for flicker)

        function getFlickerValue(key, intensity = 0.1) {
            const now = performance.now();
            if (!flickerValues[key] || now - flickerValues[key].lastUpdate > FLICKER_UPDATE_INTERVAL) {
                flickerValues[key] = {
                    value: 1 - intensity / 2 + Math.random() * intensity,
                    lastUpdate: now
                };
            }
            return flickerValues[key].value;
        }

        // Audio context for playback
        let audioContext = null;
        let soundBuffers = {}; // soundIndex -> AudioBuffer
        let soundsDecoding = {}; // Track sounds currently being decoded
        let decodeQueue = []; // Queue of sounds waiting to decode
        let isDecoding = false; // Currently decoding a sound
        const DECODE_DELAY = 500; // ms between each decode (give iPad breathing room)
        let gameStartTime = 0; // Track when game started for sound delay
        const SOUND_STARTUP_DELAY = 1500; // Wait 1.5 seconds before starting ambient sounds

        // Walk sound timing
        let lastWalkSoundTime = 0;

        // Ambient sounds currently playing
        let ambientSounds = {}; // "x,y" -> { source, gainNode, playing }

        // Debug flags
        let showLayers = false; // L key to toggle layer debug

        // Initialize audio context on first user interaction (LAZY - don't decode all sounds)
        function initAudio() {
            if (audioContext) {
                // iOS requires resume after user gesture
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                return;
            }
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            // iOS may start suspended - resume it
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            console.log('Audio context initialized (lazy mode - sounds decode on first play)');
            console.log('Sounds available:', soundsData.length);
            console.log('Tile sounds:', Object.keys(tileSounds).length);
            console.log('Player sounds:', playerSoundsData);
        }

        // Queue a sound for decoding (one at a time with delays for iPad)
        function decodeSound(idx, callback) {
            // Already decoded
            if (soundBuffers[idx]) {
                if (callback) callback(soundBuffers[idx]);
                return;
            }
            // Already in queue or decoding
            if (soundsDecoding[idx]) return;

            const sound = soundsData[idx];
            if (!sound || !sound.data) {
                console.warn('No sound data for index', idx);
                return;
            }

            // Mark as queued and add to queue
            soundsDecoding[idx] = true;
            decodeQueue.push({ idx, callback });
            processDecodeQueue();
        }

        // Process decode queue one at a time with delays
        function processDecodeQueue() {
            if (isDecoding || decodeQueue.length === 0) return;

            isDecoding = true;
            const { idx, callback } = decodeQueue.shift();
            const sound = soundsData[idx];

            try {
                const base64 = sound.data.split(',')[1];
                const binary = atob(base64);
                const bytes = Uint8Array.from(binary, c => c.charCodeAt(0));
                const audioBuffer = bytes.buffer.slice(0);

                audioContext.decodeAudioData(audioBuffer, (buffer) => {
                    soundBuffers[idx] = buffer;
                    soundsDecoding[idx] = false;
                    console.log('Sound', idx, sound.name, 'decoded (' + decodeQueue.length + ' in queue)');
                    if (callback) callback(buffer);

                    // Wait before processing next sound
                    setTimeout(() => {
                        isDecoding = false;
                        processDecodeQueue();
                    }, DECODE_DELAY);
                }, (err) => {
                    console.error('Failed to decode sound', idx, err);
                    soundsDecoding[idx] = false;
                    setTimeout(() => {
                        isDecoding = false;
                        processDecodeQueue();
                    }, DECODE_DELAY);
                });
            } catch (e) {
                console.error('Error decoding sound', idx, ':', e.message);
                soundsDecoding[idx] = false;
                setTimeout(() => {
                    isDecoding = false;
                    processDecodeQueue();
                }, DECODE_DELAY);
            }
        }

        // Preload all sounds before game starts (shows loading progress)
        let soundsPreloaded = false;
        function preloadAllSounds(onComplete) {
            // No sounds to load - complete immediately
            if (!soundsData || soundsData.length === 0) {
                console.log('No sounds to preload');
                soundsPreloaded = true;
                if (onComplete) onComplete();
                return;
            }

            // Check if sounds have data (mobile streaming may not have data yet)
            const soundsWithData = soundsData.filter(s => s && s.data);
            if (soundsWithData.length === 0) {
                console.log('No sound data available yet (may be streaming)');
                soundsPreloaded = true;
                if (onComplete) onComplete();
                return;
            }

            // Initialize audio context for decoding
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('Audio context created for preloading');
                } catch (e) {
                    console.warn('Could not create audio context:', e);
                    soundsPreloaded = true;
                    if (onComplete) onComplete();
                    return;
                }
            }

            const totalSounds = soundsWithData.length;
            let loadedCount = 0;
            let currentIndex = 0;

            // Update loading UI for sounds
            function updateSoundLoadingUI() {
                const percent = totalSounds > 0 ? Math.round((loadedCount / totalSounds) * 100) : 0;
                const loadingBar = document.getElementById('loadingBar');
                const loadingPercent = document.getElementById('loadingPercent');
                const loadingText = document.getElementById('loadingText');
                if (loadingBar) loadingBar.style.width = percent + '%';
                if (loadingPercent) loadingPercent.textContent = loadedCount + '/' + totalSounds + ' (' + percent + '%)';
                if (loadingText) loadingText.textContent = 'Loading Sounds...';
            }

            // Decode one sound at a time
            function decodeNext() {
                // Find next sound with data
                while (currentIndex < soundsData.length && (!soundsData[currentIndex] || !soundsData[currentIndex].data)) {
                    currentIndex++;
                }

                if (currentIndex >= soundsData.length) {
                    // All done
                    console.log('All sounds preloaded:', loadedCount);
                    soundsPreloaded = true;
                    if (onComplete) onComplete();
                    return;
                }

                const idx = currentIndex;
                const sound = soundsData[idx];
                currentIndex++;

                // Already decoded? Skip
                if (soundBuffers[idx]) {
                    loadedCount++;
                    updateSoundLoadingUI();
                    setTimeout(decodeNext, 50);
                    return;
                }

                try {
                    const base64 = sound.data.split(',')[1];
                    const binary = atob(base64);
                    const bytes = Uint8Array.from(binary, c => c.charCodeAt(0));
                    const audioBuffer = bytes.buffer.slice(0);

                    audioContext.decodeAudioData(audioBuffer, (buffer) => {
                        soundBuffers[idx] = buffer;
                        loadedCount++;
                        console.log('Preloaded sound', idx, sound.name, '(' + loadedCount + '/' + totalSounds + ')');
                        updateSoundLoadingUI();
                        // Delay between decodes to prevent overwhelming mobile
                        setTimeout(decodeNext, 100);
                    }, (err) => {
                        console.warn('Failed to decode sound', idx, err);
                        loadedCount++;
                        updateSoundLoadingUI();
                        setTimeout(decodeNext, 100);
                    });
                } catch (e) {
                    console.warn('Error decoding sound', idx, ':', e.message);
                    loadedCount++;
                    updateSoundLoadingUI();
                    setTimeout(decodeNext, 100);
                }
            }

            updateSoundLoadingUI();
            decodeNext();
        }

        // Play a sound with optional pitch and length variation (lazy decode on first play)
        function playSound(soundIndex, volume = 1, pitchVariation = 0, lengthVariation = 0) {
            if (!audioContext) {
                console.log('playSound: No audio context');
                return;
            }
            if (soundIndex < 0 || soundIndex >= soundsData.length) {
                return;
            }

            // Lazy decode: if buffer not ready, decode it first then play
            if (!soundBuffers[soundIndex]) {
                decodeSound(soundIndex, (buffer) => {
                    // Play after decode completes
                    playSoundBuffer(buffer, volume, pitchVariation, lengthVariation);
                });
                return;
            }

            return playSoundBuffer(soundBuffers[soundIndex], volume, pitchVariation, lengthVariation);
        }

        // Internal: play an already-decoded buffer
        function playSoundBuffer(buffer, volume, pitchVariation, lengthVariation = 0) {
            if (!buffer) return;

            const source = audioContext.createBufferSource();
            source.buffer = buffer;

            // Apply pitch variation (randomizes pitch each play)
            if (pitchVariation > 0) {
                source.playbackRate.value = 1 + (Math.random() - 0.5) * pitchVariation * 2;
            }

            const gainNode = audioContext.createGain();
            gainNode.gain.value = volume;

            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Apply length variation (randomly cuts off sound early)
            if (lengthVariation > 0) {
                const duration = buffer.duration;
                const minLength = Math.max(0.1, duration * (1 - lengthVariation));
                const actualLength = minLength + Math.random() * (duration - minLength);
                source.start(0, 0, actualLength);
            } else {
                source.start();
            }

            return { source, gainNode };
        }

        // Update ambient sounds based on player position with smooth fading
        function updateAmbientSounds() {
            if (!audioContext) return;

            // Delay ambient sounds on startup to prevent iPad crashes
            if (gameStartTime && Date.now() - gameStartTime < SOUND_STARTUP_DELAY) {
                return;
            }

            const tileSize = gridSize * TILE_SCALE;
            const playerTileX = Math.floor(player.x / tileSize);
            const playerTileY = Math.floor(player.y / tileSize);
            const fadeTime = 0.1; // Smooth transition time in seconds

            Object.keys(tileSounds).forEach(key => {
                // Filter by current map (keys are "mapName:x,y" or legacy "x,y")
                let sx, sy;
                if (key.includes(':')) {
                    // New format: "mapName:x,y"
                    const parts = key.split(':');
                    if (parts[0] !== currentGameMap) return; // Skip sounds on other maps
                    [sx, sy] = parts[1].split(',').map(Number);
                } else {
                    // Legacy format: "x,y" (treat as main map)
                    if (currentGameMap !== 'main') return;
                    [sx, sy] = key.split(',').map(Number);
                }
                const ts = tileSounds[key];
                let soundBuffer = soundBuffers[ts.soundIndex];

                // Lazy decode: if not loaded yet, trigger decode (will be available next frame)
                if (!soundBuffer && ts.soundIndex >= 0 && ts.soundIndex < soundsData.length) {
                    decodeSound(ts.soundIndex);
                    return;
                }
                if (!soundBuffer) return;

                // Calculate distance from player (in tiles)
                const dx = playerTileX - sx;
                const dy = playerTileY - sy;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Get fade percent (default 50% = half the radius is fade zone)
                const fadePercent = ts.fadePercent !== undefined ? ts.fadePercent : 0.5;

                // Calculate volume based on distance with fade zone
                let targetVolume = 0;
                if (dist <= ts.radius) {
                    // Inside radius - calculate fade
                    const fadeStartDist = ts.radius * (1 - fadePercent); // Where fade begins
                    if (dist <= fadeStartDist) {
                        // Inside inner zone - full volume
                        targetVolume = ts.volume;
                    } else {
                        // In fade zone - linear fade from full to zero
                        const fadeZoneSize = ts.radius - fadeStartDist;
                        const distInFadeZone = dist - fadeStartDist;
                        targetVolume = ts.volume * (1 - distInFadeZone / fadeZoneSize);
                    }
                }

                // Start sound if not playing yet (for looping sounds, keep them running)
                if (!ambientSounds[key]?.playing && ts.loop) {
                    const source = audioContext.createBufferSource();
                    source.buffer = soundBuffer;
                    source.loop = true;

                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = 0; // Start silent

                    source.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    source.start();

                    ambientSounds[key] = { source, gainNode, playing: true };
                }

                // For non-looping sounds, only start when in range
                if (!ambientSounds[key]?.playing && !ts.loop && targetVolume > 0) {
                    const source = audioContext.createBufferSource();
                    source.buffer = soundBuffer;
                    source.loop = false;

                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = targetVolume;

                    source.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    source.start();

                    ambientSounds[key] = { source, gainNode, playing: true };

                    source.onended = () => {
                        if (ambientSounds[key]) {
                            ambientSounds[key].playing = false;
                        }
                    };
                }

                // Smoothly adjust volume for playing sounds
                if (ambientSounds[key]?.playing && ambientSounds[key].gainNode) {
                    const gain = ambientSounds[key].gainNode.gain;
                    // Use linearRampToValueAtTime for smooth transitions
                    gain.cancelScheduledValues(audioContext.currentTime);
                    gain.setValueAtTime(gain.value, audioContext.currentTime);
                    gain.linearRampToValueAtTime(Math.max(0, targetVolume), audioContext.currentTime + fadeTime);
                }
            });
        }

        // === LIGHTING RENDERING (Classic 2D - no WebGL) ===
        function renderLighting() {
            const lighting = lightingSettingsData;

            // Get lighting values - use cycle if enabled, otherwise use darkness slider
            let preset;
            if (dayCycleEnabled) {
                preset = currentLighting;
            } else {
                // Use manual darkness slider (0-100 maps to 0-0.95 alpha)
                const alpha = manualDarkness / 100 * 0.95;
                preset = { r: 0, g: 0, b: 20, a: alpha };
            }

            // Skip if no darkness and no player light
            if (preset.a === 0 && !lighting.playerLight) return;

            // Create/resize offscreen canvas for lighting
            if (!lightCanvas || lightCanvas.width !== canvas.width || lightCanvas.height !== canvas.height) {
                lightCanvas = document.createElement('canvas');
                lightCanvas.width = canvas.width;
                lightCanvas.height = canvas.height;
                lightCtx = lightCanvas.getContext('2d');
            }

            // Clear and fill with ambient darkness
            lightCtx.clearRect(0, 0, lightCanvas.width, lightCanvas.height);
            lightCtx.fillStyle = 'rgba(' + preset.r + ',' + preset.g + ',' + preset.b + ',' + preset.a + ')';
            lightCtx.fillRect(0, 0, lightCanvas.width, lightCanvas.height);

            // Cut out light circles using destination-out compositing
            lightCtx.globalCompositeOperation = 'destination-out';

            const tileSize = gridSize * TILE_SCALE;
            const camX = Math.floor(player.x - canvas.width / (2 * cameraZoom) + player.width / 2);
            const camY = Math.floor(player.y - canvas.height / (2 * cameraZoom) + player.height / 2);

            // Player torch light (always follows player)
            if (lighting.playerLight) {
                const px = (player.x - camX + player.width / 2) * cameraZoom;
                const py = (player.y - camY + player.height / 2) * cameraZoom;
                const radius = lighting.playerLightRadius * tileSize * cameraZoom;

                const gradient = lightCtx.createRadialGradient(px, py, 0, px, py, radius);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.5, 'rgba(255,255,255,0.6)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                lightCtx.fillStyle = gradient;
                lightCtx.beginPath();
                lightCtx.arc(px, py, radius, 0, Math.PI * 2);
                lightCtx.fill();
            }

            // Cut out placed point lights
            const mapPrefix = currentGameMap + ':';
            Object.keys(pointLights).forEach(key => {
                if (!key.startsWith(mapPrefix)) return;

                const coords = key.split(':')[1];
                const [lx, ly] = coords.split(',').map(Number);
                const light = pointLights[key];

                const screenX = ((lx * tileSize + tileSize / 2) - camX) * cameraZoom;
                const screenY = ((ly * tileSize + tileSize / 2) - camY) * cameraZoom;
                let radius = light.radius * tileSize * cameraZoom;

                // Optional flicker effect (throttled for performance)
                if (light.flicker) {
                    const flickerAmt = light.flickerIntensity || 0.1;
                    radius *= getFlickerValue('point_' + key, flickerAmt);
                }

                const gradient = lightCtx.createRadialGradient(screenX, screenY, 0, screenX, screenY, radius);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.6, 'rgba(255,255,255,0.5)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                lightCtx.fillStyle = gradient;
                lightCtx.beginPath();
                lightCtx.arc(screenX, screenY, radius, 0, Math.PI * 2);
                lightCtx.fill();
            });

            // Cut out polygon lights
            const currentMapPolyLights = polyLights.filter(pl => pl.mapName === currentGameMap);

            // Debug: Log once per map
            if (!window._polyLightLoggedMap || window._polyLightLoggedMap !== currentGameMap) {
                console.log('[POLY LIGHTS] Map:', currentGameMap, 'Total polyLights:', polyLights.length, 'On this map:', currentMapPolyLights.length);
                currentMapPolyLights.forEach((pl, i) => console.log('  Poly', i, 'points:', pl.points?.length, 'intensity:', pl.intensity));
                window._polyLightLoggedMap = currentGameMap;
            }

            currentMapPolyLights.forEach(poly => {
                if (!poly.points || poly.points.length < 3) return;

                // Calculate screen coordinates for polygon points
                const screenPoints = poly.points.map(pt => ({
                    x: ((pt.x * tileSize) - camX) * cameraZoom,
                    y: ((pt.y * tileSize) - camY) * cameraZoom
                }));

                // Draw filled polygon with gradient-like intensity
                const intensity = poly.intensity || 0.8;

                // Apply flicker if enabled (throttled for performance)
                let flickerMult = 1;
                if (poly.flicker) {
                    const flickerAmt = poly.flickerIntensity || 0.2;
                    flickerMult = getFlickerValue('poly_' + poly.id, flickerAmt);
                }

                // Draw polygon as light cutout
                lightCtx.fillStyle = 'rgba(255,255,255,' + (intensity * flickerMult) + ')';
                lightCtx.beginPath();
                lightCtx.moveTo(screenPoints[0].x, screenPoints[0].y);
                for (let i = 1; i < screenPoints.length; i++) {
                    lightCtx.lineTo(screenPoints[i].x, screenPoints[i].y);
                }
                lightCtx.closePath();
                lightCtx.fill();
            });

            // Reset composite operation and draw darkness over game
            lightCtx.globalCompositeOperation = 'source-over';
            ctx.drawImage(lightCanvas, 0, 0);
        }

        // Initialize audio on first user interaction (key or touch)
        document.addEventListener('keydown', () => initAudio(), { once: true });
        document.addEventListener('touchstart', () => initAudio(), { once: true });
        document.addEventListener('click', () => initAudio(), { once: true });

        // Adjustable settings
        let playerScale = 1.7;
        let animSpeed = 7; // Lower = faster animation

        // Tile scale - how big to render tiles (zoom level)
        const TILE_SCALE = 4;

        // Camera zoom (1 = normal, 2 = 2x closer, etc)
        let cameraZoom = 1.0;

        // Item receive display settings
        let itemReceiveScale = 2;         // Scale of floating item sprite
        let itemReceiveHeight = 45;       // Height above player in pixels
        let itemReceiveDuration = 2;      // Total display time in seconds
        let itemReceiveFinalPause = 1;    // Pause on final frame in seconds

        // Item receive state
        let isReceivingItem = false;
        let receivingItemData = null;     // { itemIndex, startTime, item }
        let receiveItemAnimFrame = 0;
        let receiveItemAnimTimer = 0;

        // Debug panel toggle and slider handlers
        document.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') {
                document.getElementById('debugPanel').classList.toggle('visible');
            }
            if (e.key === 's' || e.key === 'S') {
                showSounds = !showSounds;
                console.log('Sound debug:', showSounds ? 'ON' : 'OFF');
            }
            if (e.key === 'l' || e.key === 'L') {
                showLayers = !showLayers;
                console.log('Layer debug:', showLayers ? 'ON' : 'OFF');
            }
        });

        document.getElementById('scaleSlider').addEventListener('input', (e) => {
            playerScale = parseFloat(e.target.value);
            document.getElementById('scaleVal').textContent = playerScale.toFixed(1);
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            player.speed = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = player.speed.toFixed(1);
        });

        document.getElementById('animSlider').addEventListener('input', (e) => {
            animSpeed = parseInt(e.target.value);
            document.getElementById('animVal').textContent = animSpeed;
        });

        document.getElementById('widthSlider').addEventListener('input', (e) => {
            player.width = parseInt(e.target.value);
            document.getElementById('widthVal').textContent = player.width;
        });

        document.getElementById('heightSlider').addEventListener('input', (e) => {
            player.height = parseInt(e.target.value);
            document.getElementById('heightVal').textContent = player.height;
        });

        // Per-direction hitbox sliders
        document.getElementById('hbRangeSlider').addEventListener('input', (e) => {
            playerHitboxRange[hitboxEditDir] = parseInt(e.target.value);
            document.getElementById('hbRangeVal').textContent = e.target.value;
        });
        document.getElementById('hbWidthSlider').addEventListener('input', (e) => {
            playerHitboxWidth[hitboxEditDir] = parseInt(e.target.value);
            document.getElementById('hbWidthVal').textContent = e.target.value;
        });
        document.getElementById('hbOffsetXSlider').addEventListener('input', (e) => {
            playerHitboxOffsetX[hitboxEditDir] = parseInt(e.target.value);
            document.getElementById('hbOffsetXVal').textContent = e.target.value;
        });
        document.getElementById('hbOffsetYSlider').addEventListener('input', (e) => {
            playerHitboxOffsetY[hitboxEditDir] = parseInt(e.target.value);
            document.getElementById('hbOffsetYVal').textContent = e.target.value;
        });

        // Attack slide settings
        document.getElementById('slideAmountSlider').addEventListener('input', (e) => {
            attackSlideAmount = parseInt(e.target.value);
            document.getElementById('slideAmountVal').textContent = attackSlideAmount;
        });
        document.getElementById('slideDurationSlider').addEventListener('input', (e) => {
            attackSlideDuration = parseInt(e.target.value);
            document.getElementById('slideDurationVal').textContent = attackSlideDuration;
        });

        document.getElementById('zoomSlider').addEventListener('input', (e) => {
            cameraZoom = parseFloat(e.target.value);
            document.getElementById('zoomVal').textContent = cameraZoom.toFixed(1);
        });

        // Lighting controls
        document.getElementById('darknessSlider').addEventListener('input', (e) => {
            manualDarkness = parseInt(e.target.value);
            document.getElementById('darknessVal').textContent = manualDarkness;
        });

        document.getElementById('torchEnabled').addEventListener('change', (e) => {
            lightingSettingsData.playerLight = e.target.checked;
            console.log('Player torch:', e.target.checked ? 'ON' : 'OFF');
        });

        document.getElementById('torchRadiusSlider').addEventListener('input', (e) => {
            lightingSettingsData.playerLightRadius = parseInt(e.target.value);
            document.getElementById('torchRadiusVal').textContent = e.target.value;
        });

        document.getElementById('cycleEnabled').addEventListener('change', (e) => {
            dayCycleEnabled = e.target.checked;
            lastCycleUpdate = Date.now(); // Reset timer
            if (!dayCycleEnabled) {
                document.getElementById('timeDisplay').textContent = '';
            }
        });

        document.getElementById('dayLengthSlider').addEventListener('input', (e) => {
            const minutes = parseFloat(e.target.value);
            dayLength = minutes * 60; // convert to seconds
            document.getElementById('dayLengthVal').textContent = minutes;
        });

        // Item receive display settings
        document.getElementById('itemScaleSlider').addEventListener('input', (e) => {
            itemReceiveScale = parseFloat(e.target.value);
            document.getElementById('itemScaleVal').textContent = itemReceiveScale.toFixed(2);
        });

        document.getElementById('itemHeightSlider').addEventListener('input', (e) => {
            itemReceiveHeight = parseInt(e.target.value);
            document.getElementById('itemHeightVal').textContent = itemReceiveHeight;
        });

        document.getElementById('itemDurationSlider').addEventListener('input', (e) => {
            itemReceiveDuration = parseFloat(e.target.value);
            document.getElementById('itemDurationVal').textContent = itemReceiveDuration.toFixed(2);
        });

        document.getElementById('itemPauseSlider').addEventListener('input', (e) => {
            itemReceiveFinalPause = parseFloat(e.target.value);
            document.getElementById('itemPauseVal').textContent = itemReceiveFinalPause.toFixed(2);
        });

        function copySettings() {
            const settings = \`Player Settings:
  scale: \${playerScale}
  speed: \${player.speed}
  animSpeed: \${animSpeed}
  width: \${player.width}
  height: \${player.height}
  cameraZoom: \${cameraZoom}
Attack Slide:
  slideAmount: \${attackSlideAmount}
  slideDuration: \${attackSlideDuration}
Item Receive Display:
  itemReceiveScale: \${itemReceiveScale}
  itemReceiveHeight: \${itemReceiveHeight}
  itemReceiveDuration: \${itemReceiveDuration}
  itemReceiveFinalPause: \${itemReceiveFinalPause}\`;
            navigator.clipboard.writeText(settings).then(() => {
                alert('Settings copied to clipboard!');
            });
        }

        // Find starting position - ONLY used for initial game start (not door transitions)
        // This uses the global playerPreviewPos from the editor
        function findStartPos() {
            const tileSize = gridSize * TILE_SCALE;

            console.log('findStartPos called - INITIAL GAME START on map:', currentGameMap);

            // Check if returning from external area (3D world)
            const returnInfoStr = localStorage.getItem('externalDoorReturn');
            if (returnInfoStr) {
                try {
                    const returnInfo = JSON.parse(returnInfoStr);
                    // Only use if less than 5 minutes old (in case of stale data)
                    if (Date.now() - returnInfo.timestamp < 5 * 60 * 1000) {
                        console.log('[EXTERNAL RETURN] Spawning at door:', returnInfo);
                        // Clear the return info so we don't use it again
                        localStorage.removeItem('externalDoorReturn');
                        // Switch to the return map if different
                        if (returnInfo.map && returnInfo.map !== currentGameMap) {
                            currentGameMap = returnInfo.map;
                            const mapData = mapsData[returnInfo.map];
                            if (mapData) {
                                // Note: collision data is global, not per-map
                                layers = mapData.layers || layers;
                                mapCols = mapData.mapCols || mapCols;
                                mapRows = mapData.mapRows || mapRows;
                            }
                        }
                        // Spawn at the door position
                        player.x = returnInfo.x * tileSize + tileSize / 2;
                        player.y = returnInfo.y * tileSize + tileSize / 2;
                        console.log('[EXTERNAL RETURN] Player spawned at:', player.x, player.y);
                        return;
                    } else {
                        console.log('[EXTERNAL RETURN] Return info too old, ignoring');
                        localStorage.removeItem('externalDoorReturn');
                    }
                } catch (e) {
                    console.error('[EXTERNAL RETURN] Failed to parse return info:', e);
                    localStorage.removeItem('externalDoorReturn');
                }
            }

            // Use global playerPreviewPos for initial spawn
            if (projectData.playerPreviewPos && (projectData.playerPreviewPos.x !== undefined)) {
                const pos = projectData.playerPreviewPos;
                player.x = pos.x * tileSize + tileSize / 2;
                player.y = pos.y * tileSize + tileSize / 2;
                // Store initial spawn for respawn on death
                initialSpawnX = player.x;
                initialSpawnY = player.y;
                initialSpawnMap = projectData.spawnMapName || currentGameMap;
                console.log('Initial spawn: tile', pos.x, pos.y, '-> pixel', player.x, player.y);
                return;
            }

            console.log('No playerPreviewPos found, using fallback');
            // Fallback: find first tile without collision
            const layer = layers[0];
            if (!layer) {
                console.error('No layers found for starting position');
                return;
            }
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y] && layer[y][x];
                    if (cell && cell.type === 'tile') {
                        const key = cell.x + ',' + cell.y;
                        if (!tileCollisions[key]) {
                            player.x = x * tileSize + tileSize / 2;
                            player.y = y * tileSize + tileSize / 2;
                            console.log('Start position: tile', x, y);
                            return;
                        }
                    }
                }
            }
            // If no safe tile, just start at first tile
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y] && layer[y][x];
                    if (cell) {
                        player.x = x * tileSize + tileSize / 2;
                        player.y = y * tileSize + tileSize / 2;
                        console.log('Start position (fallback): tile', x, y);
                        return;
                    }
                }
            }
        }

        // Camera
        const camera = { x: 0, y: 0 };

        // Input
        const keys = {};

        document.addEventListener('keydown', e => {
            keys[e.key] = true;

            if (e.key === 'Escape') window.close();
            if (e.key === 'c' || e.key === 'C') showCollision = !showCollision;
            if (e.key === 'h' || e.key === 'H') toggleAllUI();
            if (e.key === 'q' || e.key === 'Q') toggleQuestLog();
            // Interact key (A) - for dialogs, doors, and NPCs
            if ((e.key === 'a' || e.key === 'A') && !player.attacking) {
                handleInteract();
            }
            // Attack key (Space)
            if (e.key === ' ' && !player.attacking) {
                player.attacking = true;
                player.attackAnim = true;
                player.attackFrame = 0;
                player.attackFrameTimer = 0;
                player.attackTimer = 30; // Longer for animation to play
                player.attackHitNpcs = {}; // Reset hit tracking for new attack
                // Play attack sound
                if (playerSoundsData.attack && playerSoundsData.attack.soundIndex >= 0) {
                    playSound(playerSoundsData.attack.soundIndex, playerSoundsData.attack.volume || 0.7, playerSoundsData.attack.pitchVariation || 0.15, playerSoundsData.attack.lengthVariation || 0);
                }
            }
        });
        document.addEventListener('keyup', e => keys[e.key] = false);

        // Virtual Joystick controls - appears where user touches left half
        const joystickBase = document.getElementById('joystickBase');
        const joystickThumb = document.getElementById('joystickThumb');
        const leftTouchZone = document.getElementById('leftTouchZone');
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickTouchId = null;
        const joystickMaxDist = 40;
        const joystickDeadzone = 10;

        function updateJoystick(touchX, touchY) {
            const dx = touchX - joystickCenter.x;
            const dy = touchY - joystickCenter.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Clamp to max distance
            let clampedX = dx;
            let clampedY = dy;
            if (dist > joystickMaxDist) {
                clampedX = (dx / dist) * joystickMaxDist;
                clampedY = (dy / dist) * joystickMaxDist;
            }

            // Move thumb (relative to joystick center which is 60px from edge)
            joystickThumb.style.left = (60 + clampedX) + 'px';
            joystickThumb.style.top = (60 + clampedY) + 'px';

            // Reset keys
            keys['ArrowUp'] = false;
            keys['ArrowDown'] = false;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;

            // Set keys based on direction (if outside deadzone)
            if (dist > joystickDeadzone) {
                const angle = Math.atan2(dy, dx);
                // Right: -45 to 45 degrees
                if (angle > -Math.PI/4 && angle < Math.PI/4) keys['ArrowRight'] = true;
                // Down: 45 to 135 degrees
                if (angle > Math.PI/4 && angle < 3*Math.PI/4) keys['ArrowDown'] = true;
                // Left: 135 to -135 degrees
                if (angle > 3*Math.PI/4 || angle < -3*Math.PI/4) keys['ArrowLeft'] = true;
                // Up: -135 to -45 degrees
                if (angle > -3*Math.PI/4 && angle < -Math.PI/4) keys['ArrowUp'] = true;
            }
        }

        function resetJoystick() {
            joystickActive = false;
            joystickTouchId = null;
            joystickBase.classList.remove('active');
            joystickThumb.style.left = '50%';
            joystickThumb.style.top = '50%';
            joystickThumb.style.transform = 'translate(-50%, -50%)';
            keys['ArrowUp'] = false;
            keys['ArrowDown'] = false;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
        }

        // Touch on left half of screen - show joystick at touch position
        leftTouchZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            joystickTouchId = touch.identifier;
            joystickActive = true;

            // Position joystick centered on touch
            const x = touch.clientX - 60;
            const y = touch.clientY - 60;
            joystickBase.style.left = x + 'px';
            joystickBase.style.top = y + 'px';
            joystickBase.classList.add('active');

            // Set center for movement calculation
            joystickCenter = { x: touch.clientX, y: touch.clientY };
            joystickThumb.style.left = '50%';
            joystickThumb.style.top = '50%';
            joystickThumb.style.transform = 'translate(-50%, -50%)';
        }, { passive: false });

        leftTouchZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!joystickActive) return;
            // Find our touch
            for (let touch of e.touches) {
                if (touch.identifier === joystickTouchId) {
                    updateJoystick(touch.clientX, touch.clientY);
                    break;
                }
            }
        }, { passive: false });

        leftTouchZone.addEventListener('touchend', (e) => {
            // Check if our touch ended
            for (let touch of e.changedTouches) {
                if (touch.identifier === joystickTouchId) {
                    resetJoystick();
                    break;
                }
            }
        });
        leftTouchZone.addEventListener('touchcancel', resetJoystick);

        // Attack button (mobile)
        document.getElementById('attackBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!player.attacking) {
                player.attacking = true;
                player.attackAnim = true;
                player.attackFrame = 0;
                player.attackFrameTimer = 0;
                player.attackTimer = 30;
                if (playerSoundsData.attack && playerSoundsData.attack.soundIndex >= 0) {
                    playSound(playerSoundsData.attack.soundIndex, playerSoundsData.attack.volume || 0.7, playerSoundsData.attack.pitchVariation || 0.15, playerSoundsData.attack.lengthVariation || 0);
                }
            }
        }, { passive: false });
        document.getElementById('attackBtn').addEventListener('click', () => {
            if (!player.attacking) {
                player.attacking = true;
                player.attackAnim = true;
                player.attackFrame = 0;
                player.attackFrameTimer = 0;
                player.attackTimer = 30;
                if (playerSoundsData.attack && playerSoundsData.attack.soundIndex >= 0) {
                    playSound(playerSoundsData.attack.soundIndex, playerSoundsData.attack.volume || 0.7, playerSoundsData.attack.pitchVariation || 0.15, playerSoundsData.attack.lengthVariation || 0);
                }
            }
        });

        // Interact button (mobile) - for doors, NPCs, and dialogs
        const interactBtn = document.getElementById('interactBtn');
        if (interactBtn) {
            interactBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleInteract();
            }, { passive: false });
            interactBtn.addEventListener('click', () => {
                handleInteract();
            });
        }

        function handleInteract() {
            // If dialog is active, advance it
            if (activeDialog) {
                advanceDialog();
                return;
            }
            // Check for items first, then animated props, then dialogs, then triggers
            if (!checkItemInteraction()) {
                if (!checkAnimPropInteraction()) {
                    if (!checkDialogInteraction()) {
                        checkTriggerInteraction('interact');
                    }
                }
            }
        }

        // Check for nearby items and pick them up with receive animation
        function checkItemInteraction() {
            if (isReceivingItem) return false; // Already receiving an item

            const tileSize = gridSize * TILE_SCALE;
            const playerTileX = Math.floor((player.x + player.width / 2) / tileSize);
            const playerTileY = Math.floor((player.y + player.height * 0.8) / tileSize);

            for (let i = 0; i < placedItemsData.length; i++) {
                const placed = placedItemsData[i];
                if (placed.mapName && placed.mapName !== currentGameMap) continue;

                const state = itemStates[i];
                if (!state || state.used) continue;

                // Check if player is adjacent to item
                const dx = Math.abs(placed.x - playerTileX);
                const dy = Math.abs(placed.y - playerTileY);
                if (dx <= 1 && dy <= 1) {
                    // Mark item as used immediately (disappears from map)
                    state.used = true;

                    // Get item data for receive animation
                    const item = itemsData[placed.itemIndex];
                    if (item) {
                        // Start player receive item animation
                        startReceivingItem(placed.itemIndex, item);
                        console.log('[ITEM] Picked up item:', item.name, 'at', placed.x, placed.y);
                    }

                    // Broadcast to other players
                    if (mpSocket && mpConnected) {
                        mpSocket.send(JSON.stringify({
                            type: 'itemPickup',
                            itemIndex: i,
                            x: placed.x,
                            y: placed.y,
                            mapName: placed.mapName || currentGameMap
                        }));
                    }
                    return true;
                }
            }
            return false;
        }

        // Update item animations each frame
        function updateItemAnimations() {
            for (let i = 0; i < placedItemsData.length; i++) {
                const placed = placedItemsData[i];
                if (placed.mapName && placed.mapName !== currentGameMap) continue;

                const state = itemStates[i];
                if (!state || !state.animating) continue;

                const item = itemsData[placed.itemIndex];
                if (!item || !item.frames || item.frames.length === 0) continue;

                const fps = item.fps || 8;
                const animSpeed = Math.max(1, Math.round(60 / fps));

                state.frameTimer++;
                if (state.frameTimer >= animSpeed) {
                    state.frameTimer = 0;
                    state.frame++;

                    // Animation complete
                    if (state.frame >= item.frames.length) {
                        state.animating = false;
                        state.used = true;
                        state.frame = item.frames.length - 1; // Stay on last frame
                        console.log('[ITEM] Animation complete, item used');
                    }
                }
            }
        }

        // Check for nearby interactive animated props and trigger their animation
        function checkAnimPropInteraction() {
            const tileSize = gridSize * TILE_SCALE;
            const playerTileX = Math.floor((player.x + player.width / 2) / tileSize);
            const playerTileY = Math.floor((player.y + player.height * 0.8) / tileSize);

            // Search layers for interactive animated props near player
            for (let li = 0; li < layers.length; li++) {
                if (!layers[li]) continue;

                // Check tiles around player
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const tx = playerTileX + dx;
                        const ty = playerTileY + dy;

                        if (ty < 0 || ty >= layers[li].length) continue;
                        if (!layers[li][ty] || tx < 0 || tx >= layers[li][ty].length) continue;

                        const cell = layers[li][ty][tx];
                        if (!cell || (cell.type !== 'animTile' && cell.type !== 'animTrunk') || cell.propIndex === undefined) continue;

                        const propData = animatedPropsData[cell.propIndex];
                        if (!propData || propData.type !== 'interactive') continue;

                        // Use origin position for multi-tile props
                        const originX = tx - (cell.offsetX || 0);
                        const originY = ty - (cell.offsetY || 0);
                        const key = originX + ',' + originY + ',' + li;

                        // Check if already used
                        if (interactivePropStates[key] && interactivePropStates[key].used) continue;

                        // Initialize state if needed
                        if (!interactivePropStates[key]) {
                            interactivePropStates[key] = { used: false, animating: false, frame: 0, gaveItem: false };
                        }

                        // Skip if already animating
                        if (interactivePropStates[key].animating) continue;

                        // Trigger animation!
                        interactivePropStates[key].animating = true;
                        interactivePropStates[key].frame = 0;
                        console.log('[ANIM PROP] Interacted with', propData.name, 'at', originX, originY);

                        // Give item if configured - check for instance override first
                        if (propData.giveItem) {
                            // Find matching placed prop to check for instance-specific item
                            const placedProp = placedAnimPropsData.find(p =>
                                p.x === originX && p.y === originY &&
                                (!p.mapName || p.mapName === currentGameMap)
                            );
                            // Use instance item if set, otherwise use default from prop definition
                            let itemIdx = propData.giveItemIndex;
                            if (placedProp && placedProp.instanceItemIndex !== undefined && placedProp.instanceItemIndex >= 0) {
                                itemIdx = placedProp.instanceItemIndex;
                            }
                            if (itemIdx >= 0 && itemIdx < itemsData.length) {
                                const givenItem = itemsData[itemIdx];
                                console.log('[ANIM PROP] Giving item:', givenItem?.name || 'Item ' + itemIdx, placedProp?.instanceItemIndex !== undefined ? '(instance override)' : '(default)');
                                // Start receive item animation and display
                                startReceivingItem(itemIdx, givenItem);
                                interactivePropStates[key].gaveItem = true;
                            }
                        }

                        // Broadcast to other players
                        if (mpSocket && mpConnected) {
                            mpSocket.send(JSON.stringify({
                                type: 'propInteract',
                                key: key,
                                originX: originX,
                                originY: originY,
                                layer: li,
                                mapName: currentGameMap
                            }));
                        }

                        return true;
                    }
                }
            }
            return false;
        }

        // Update interactive animated prop animations each frame
        function updateAnimPropInteractions() {
            for (const key in interactivePropStates) {
                const state = interactivePropStates[key];
                if (!state.animating) continue;

                // Parse key to get prop info
                const parts = key.split(',');
                const originX = parseInt(parts[0]);
                const originY = parseInt(parts[1]);
                const li = parseInt(parts[2]);

                // Find the prop data from the cell
                if (!layers[li] || !layers[li][originY] || !layers[li][originY][originX]) continue;
                const cell = layers[li][originY][originX];
                if (!cell || cell.propIndex === undefined) continue;

                const propData = animatedPropsData[cell.propIndex];
                if (!propData || !propData.frames || propData.frames.length === 0) continue;

                const fps = propData.fps || 8;
                const frameDelay = Math.max(1, Math.round(60 / fps));

                state.timer = (state.timer || 0) + 1;
                if (state.timer >= frameDelay) {
                    state.timer = 0;
                    state.frame++;

                    // Update the frame timer so rendering uses the correct frame
                    if (!animPropFrameTimers[key]) {
                        animPropFrameTimers[key] = { frame: 0, timer: 0 };
                    }
                    animPropFrameTimers[key].frame = state.frame;

                    // Animation complete
                    if (state.frame >= propData.frames.length) {
                        state.animating = false;
                        state.used = true;
                        state.frame = propData.frames.length - 1;
                        animPropFrameTimers[key].frame = state.frame;
                        console.log('[ANIM PROP] Animation complete');
                    }
                }
            }
        }

        // Start the receive item animation and floating item display
        function startReceivingItem(itemIndex, itemData) {
            console.log('[RECEIVE ITEM] Starting receive animation for:', itemData?.name || itemIndex);
            isReceivingItem = true;
            receivingItemData = {
                itemIndex: itemIndex,
                item: itemData,
                startTime: Date.now(),
                frame: 0,
                frameTimer: 0,
                displayTimer: 0,
                floatOffset: 0,
                pausing: false  // True when on final frame pause
            };
            receiveItemAnimFrame = 0;
            receiveItemAnimTimer = 0;

            // Stop player movement during receive animation
            player.moving = false;
        }

        // Update receive item animation each frame
        function updateReceiveItemAnimation() {
            if (!isReceivingItem || !receivingItemData) return;

            const totalDurationMs = itemReceiveDuration * 1000;
            const finalPauseMs = itemReceiveFinalPause * 1000;
            const elapsed = Date.now() - receivingItemData.startTime;

            // Update floating item display timer for bob effect
            receivingItemData.displayTimer++;
            receivingItemData.floatOffset = Math.sin(receivingItemData.displayTimer * 0.1) * 5;

            // Get receive item animation frames based on direction
            const receiveDirMap = { down: 'receiveItemDown', up: 'receiveItemUp', left: 'receiveItemLeft', right: 'receiveItemRight' };
            const receiveKey = receiveDirMap[player.direction];
            let receiveFrames = [];

            if (playerAnimations) {
                // Try directional first, then fallback to receivedItem, then empty
                receiveFrames = playerAnimations[receiveKey] || playerAnimations.receivedItem || [];
            }

            // Update player animation frames
            if (receiveFrames.length > 0) {
                const fps = playerAnimFpsList[receiveKey] || playerAnimFpsList.receivedItem || 8;
                const frameDelay = Math.round(60 / fps);

                receivingItemData.frameTimer++;
                if (receivingItemData.frameTimer >= frameDelay) {
                    receivingItemData.frameTimer = 0;

                    // If not on last frame, advance
                    if (receivingItemData.frame < receiveFrames.length - 1) {
                        receivingItemData.frame++;
                    } else if (!receivingItemData.pausing) {
                        // Start final frame pause
                        receivingItemData.pausing = true;
                        receivingItemData.pauseStart = Date.now();
                    }
                }
            }

            // Check if animation complete (total duration or pause complete)
            const isPauseComplete = receivingItemData.pausing &&
                (Date.now() - receivingItemData.pauseStart >= finalPauseMs);

            if (elapsed >= totalDurationMs || isPauseComplete) {
                console.log('[RECEIVE ITEM] Animation complete');
                isReceivingItem = false;
                receivingItemData = null;
            }
        }

        // Draw floating item above player
        function drawFloatingItem(screenX, screenY) {
            if (!isReceivingItem || !receivingItemData || !receivingItemData.item) return;

            const item = receivingItemData.item;
            const itemIndex = receivingItemData.itemIndex;
            if (!item.frames || item.frames.length === 0) return;

            // Get the item's sprite image from preloaded itemImages
            const itemImg = itemImages[itemIndex];
            if (!itemImg || !itemImg.complete) return;

            // Get first frame of item (static display)
            const frame = item.frames[0];
            if (!frame) return;

            const scale = itemReceiveScale;
            const floatY = itemReceiveHeight + receivingItemData.floatOffset;

            // Center item above player
            const drawW = frame.w * scale;
            const drawH = frame.h * scale;
            const drawX = screenX - drawW / 2;
            const drawY = screenY - floatY - drawH;

            // Draw the item sprite
            ctx.drawImage(
                itemImg,
                frame.x, frame.y,
                frame.w, frame.h,
                drawX, drawY,
                drawW, drawH
            );
        }

        // Pixel-level collision check on ALL layers
        function checkCollision(x, y, w, h) {
            const tileSize = gridSize * TILE_SCALE;
            const pixelScale = tileSize / gridSize;

            // Check corners and edge midpoints
            const points = [
                { x: x, y: y },
                { x: x + w - 1, y: y },
                { x: x, y: y + h - 1 },
                { x: x + w - 1, y: y + h - 1 },
                { x: x + w / 2, y: y },
                { x: x + w / 2, y: y + h - 1 },
                { x: x, y: y + h / 2 },
                { x: x + w - 1, y: y + h / 2 }
            ];

            for (const point of points) {
                const tileX = Math.floor(point.x / tileSize);
                const tileY = Math.floor(point.y / tileSize);

                // Out of bounds = collision
                if (tileX < 0 || tileX >= mapCols || tileY < 0 || tileY >= mapRows) {
                    return true;
                }

                // Check static objects for collision (simple bounding box)
                for (let i = 0; i < placedStaticObjectsData.length; i++) {
                    const placed = placedStaticObjectsData[i];
                    if (placed.mapName && placed.mapName !== currentGameMap) continue;

                    const obj = staticObjectsData[placed.objIndex];
                    if (!obj) continue;

                    const scale = placed.scale || 1;
                    const objPixelX = placed.x * tileSize;
                    const objPixelY = placed.y * tileSize;
                    const objPixelW = obj.width * tileSize * scale;
                    const objPixelH = obj.height * tileSize * scale;

                    // Simple bounding box collision (whole object is solid)
                    // TODO: Later add per-object collision box editing
                    if (point.x >= objPixelX && point.x < objPixelX + objPixelW &&
                        point.y >= objPixelY && point.y < objPixelY + objPixelH) {
                        return true;
                    }
                }

                // Check ALL layers for collision
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li];
                    if (!layer) continue;

                    const cell = layer[tileY] && layer[tileY][tileX];
                    if (cell) {
                        // Include tileset index in key for tiles
                        const tilesetIdx = cell.tilesetIndex || 0;
                        const key = cell.type === 'tile'
                            ? tilesetIdx + ':' + cell.x + ',' + cell.y
                            : cell.x + ',' + cell.y;
                        // Use tile collision masks for tiles, prop collision masks for props (by propIndex)
                        let mask = null;
                        let maskOffsetX = 0;
                        let maskOffsetY = 0;

                        if (cell.type === 'prop') {
                            const propIdx = cell.propIndex || 0;
                            const propKey = cell.x + ',' + cell.y;
                            mask = propCollisionMasksAll[propIdx] ? propCollisionMasksAll[propIdx][propKey] : null;
                        } else if (cell.type === 'animTile') {
                            // Animated tile - get collision from prop data (per-frame)
                            const propData = animatedPropsData[cell.propIndex];
                            if (propData) {
                                // Get current animation frame for this prop
                                const animKey = tileX + ',' + tileY + ',' + li;
                                const timer = animPropFrameTimers[animKey] || { frame: 0 };
                                const currentFrame = timer.frame;

                                // Check for per-frame collision masks first, fall back to single mask
                                if (propData.collisionMasks && propData.collisionMasks[currentFrame]) {
                                    mask = propData.collisionMasks[currentFrame];
                                } else if (propData.collisionMask) {
                                    // Legacy single mask format
                                    mask = propData.collisionMask;
                                }

                                // For multi-tile props, offset into the mask
                                maskOffsetX = (cell.offsetX || 0) * gridSize;
                                maskOffsetY = (cell.offsetY || 0) * gridSize;
                            }
                        } else {
                            mask = collisionMasks[key];
                        }

                        if (mask) {
                            // Check pixel-level collision (works for both tiles and props)
                            const localX = Math.floor((point.x % tileSize) / pixelScale);
                            const localY = Math.floor((point.y % tileSize) / pixelScale);

                            // Apply offset for multi-tile animated props
                            const maskX = localX + maskOffsetX;
                            const maskY = localY + maskOffsetY;

                            if (maskY >= 0 && maskY < mask.length && mask[maskY]) {
                                if (maskX >= 0 && maskX < mask[maskY].length && mask[maskY][maskX]) {
                                    return true;
                                }
                            }
                        } else if (cell.type === 'tile' && tileCollisions[key]) {
                            // Full tile collision (no mask = solid tile)
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Check collision with all NPCs - uses collision box (simple AABB)
        function checkNPCCollision(x, y, w, h) {
            const tileSize = gridSize * TILE_SCALE;
            for (let i = 0; i < placedNpcs.length; i++) {
                const placed = placedNpcs[i];
                // Only check NPCs on current map
                if (placed.mapName && placed.mapName !== currentGameMap) continue;

                const state = npcRuntimeState[i];
                if (!state) continue;
                const npc = npcsData[placed.npcIndex];
                if (!npc) continue;

                // Skip collision with enemy NPCs on damage cooldown (lets player escape)
                if (placed.isEnemy && state.damageCooldown > 0) continue;

                // Get NPC dimensions - use same logic as debug draw for consistency
                // Get frame dimensions from animation data or npc settings
                const anims = npc.animations || {};
                const firstAnim = anims.walkDown || anims.idle || Object.values(anims).find(a => a && a.length > 0);
                const firstFrame = firstAnim && firstAnim[0];
                const frameW = (firstFrame && firstFrame.w) || npc.frameWidth || 32;
                const frameH = (firstFrame && firstFrame.h) || npc.frameHeight || 32;
                const npcScale = placed.scale || 1;
                const scaledW = tileSize * npcScale;
                const scaledH = tileSize * npcScale;
                // Use single scale like debug draw does (drawW / frameW)
                const pixelScale = scaledW / frameW;

                // Calculate NPC screen position (anchored at bottom-center) - same as drawNPC
                const npcBaseX = state.x * TILE_SCALE + (tileSize - scaledW) / 2;
                const npcBaseY = state.y * TILE_SCALE + tileSize - scaledH;

                // Use collision insets if defined (shrink from each edge)
                const insets = npc.collisionInsets;
                let npcX, npcY, npcW, npcH;
                if (insets && (insets.top > 0 || insets.bottom > 0 || insets.left > 0 || insets.right > 0)) {
                    npcX = npcBaseX + insets.left * pixelScale;
                    npcY = npcBaseY + insets.top * pixelScale;
                    npcW = scaledW - (insets.left + insets.right) * pixelScale;
                    npcH = scaledH - (insets.top + insets.bottom) * pixelScale;
                } else {
                    // No insets - use full NPC sprite bounds (the working default)
                    npcX = npcBaseX;
                    npcY = npcBaseY;
                    npcW = scaledW;
                    npcH = scaledH;
                }

                // AABB collision check
                if (x < npcX + npcW && x + w > npcX &&
                    y < npcY + npcH && y + h > npcY) {
                    return true;
                }
            }
            return false;
        }

        // Check if NPC at given position would collide with player
        function checkNPCPlayerCollision(npcTileX, npcTileY, npcIndex) {
            const tileSize = gridSize * TILE_SCALE;
            const placed = placedNpcs[npcIndex];
            const npc = npcsData[placed?.npcIndex];
            if (!npc) return false;

            // Get NPC dimensions
            const anims = npc.animations || {};
            const firstAnim = anims.walkDown || anims.idle || Object.values(anims).find(a => a && a.length > 0);
            const firstFrame = firstAnim && firstAnim[0];
            const frameW = (firstFrame && firstFrame.w) || npc.frameWidth || 32;
            const npcScale = placed.scale || 1;
            const scaledW = tileSize * npcScale;
            const scaledH = tileSize * npcScale;
            const pixelScale = scaledW / frameW;

            // Calculate NPC screen position (anchored at bottom-center)
            const npcBaseX = npcTileX * TILE_SCALE + (tileSize - scaledW) / 2;
            const npcBaseY = npcTileY * TILE_SCALE + tileSize - scaledH;

            // Use collision insets if defined
            const insets = npc.collisionInsets;
            let npcHitX, npcHitY, npcW, npcH;
            if (insets && (insets.top > 0 || insets.bottom > 0 || insets.left > 0 || insets.right > 0)) {
                npcHitX = npcBaseX + insets.left * pixelScale;
                npcHitY = npcBaseY + insets.top * pixelScale;
                npcW = scaledW - (insets.left + insets.right) * pixelScale;
                npcH = scaledH - (insets.top + insets.bottom) * pixelScale;
            } else {
                // No insets - use full NPC sprite bounds
                npcHitX = npcBaseX;
                npcHitY = npcBaseY;
                npcW = scaledW;
                npcH = scaledH;
            }

            // Player foot hitbox (bottom 1/3)
            const playerW = player.width * 0.7;
            const playerH = player.height / 3;
            const playerHitX = player.x + (player.width - playerW) / 2;
            const playerHitY = player.y + player.height * 2/3;

            // AABB collision check
            return npcHitX < playerHitX + playerW && npcHitX + npcW > playerHitX &&
                   npcHitY < playerHitY + playerH && npcHitY + npcH > playerHitY;
        }

        function update() {
            let dx = 0, dy = 0;
            player.moving = false;

            // Check if player can move (based on attack movement setting and receive item state)
            let canMove = !player.attacking && !isReceivingItem;
            let moveMultiplier = 1;

            if (player.attacking && playerAttackMovement !== 'stop') {
                if (playerAttackMovement === 'move') {
                    canMove = true; // Full movement during attack
                } else if (playerAttackMovement === 'slide') {
                    canMove = true;
                    // Slide: start at slideAmount% speed, slow down over slideDuration frames
                    const slideProgress = 1 - (player.attackTimer / attackSlideDuration); // 0 to 1
                    const startSpeed = attackSlideAmount / 100; // Convert percentage to 0-1
                    moveMultiplier = Math.max(0, startSpeed * (1 - slideProgress)); // Starts at slideAmount, goes to 0
                }
            }

            if (canMove) {
                if (keys['ArrowUp']) { dy = -1; player.direction = 'up'; player.moving = true; }
                if (keys['ArrowDown']) { dy = 1; player.direction = 'down'; player.moving = true; }
                if (keys['ArrowLeft']) { dx = -1; player.direction = 'left'; player.moving = true; }
                if (keys['ArrowRight']) { dx = 1; player.direction = 'right'; player.moving = true; }

                // Normalize diagonal movement so it's not faster
                if (dx !== 0 && dy !== 0) {
                    const diag = 0.7071; // 1/sqrt(2)
                    dx *= diag;
                    dy *= diag;
                }

                dx *= player.speed * moveMultiplier;
                dy *= player.speed * moveMultiplier;
            }

            // Move with collision - always use small foot hitbox (bottom 1/3 of player)
            // This allows walking behind objects naturally and prevents getting stuck
            const collisionHeight = player.height / 3;
            const collisionY = player.y + player.height * 2/3;

            let movedX = false;
            let movedY = false;

            // Check tile collision AND NPC collision
            if (dx !== 0 && !checkCollision(player.x + dx, collisionY, player.width, collisionHeight) &&
                !checkNPCCollision(player.x + dx, collisionY, player.width, collisionHeight)) {
                player.x += dx;
                movedX = true;
            }
            if (dy !== 0 && !checkCollision(player.x, collisionY + dy, player.width, collisionHeight) &&
                !checkNPCCollision(player.x, collisionY + dy, player.width, collisionHeight)) {
                player.y += dy;
                movedY = true;
            }

            // If player tried to move but was blocked in all directions, force idle
            if (player.moving && !movedX && !movedY) {
                player.moving = false;
            }

            // Animation - uses per-animation FPS if available
            player.frameTimer++;
            // Get FPS for current animation
            let currentAnimKey = 'walkDown';
            if (playerAnimations) {
                const dirMap = { down: 'walkDown', up: 'walkUp', left: 'walkLeft', right: 'walkRight' };
                const idleDirMap = { down: 'idleDown', up: 'idleUp', left: 'idleLeft', right: 'idleRight' };
                if (player.moving) {
                    currentAnimKey = dirMap[player.direction];
                } else {
                    const dirIdleKey = idleDirMap[player.direction];
                    if (playerAnimations[dirIdleKey] && playerAnimations[dirIdleKey].length > 0) {
                        currentAnimKey = dirIdleKey;
                    } else if (playerAnimations.idle && playerAnimations.idle.length > 0) {
                        currentAnimKey = 'idle';
                    } else {
                        currentAnimKey = dirMap[player.direction];
                    }
                }
            }
            const currentFps = playerAnimFpsList[currentAnimKey] || 8;
            const frameDelay = Math.max(1, Math.round(60 / currentFps));
            if (player.frameTimer >= frameDelay) {
                player.frameTimer = 0;
                player.frame = (player.frame + 1) % 4;
            }

            // Update animated tile animations - scan layers for animTile cells
            for (let li = 0; li < layers.length; li++) {
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell || cell.type !== 'animTile') continue;

                        const propData = animatedPropsData[cell.propIndex];
                        if (!propData || !propData.frames || propData.frames.length <= 1) continue;
                        if (propData.type !== 'loop') continue;

                        // Use origin tile position for multi-tile prop sync
                        const originX = x - (cell.offsetX || 0);
                        const originY = y - (cell.offsetY || 0);
                        const key = originX + ',' + originY + ',' + li;

                        // Only process animation once per prop (at origin tile)
                        if (cell.offsetX === 0 && cell.offsetY === 0 || (!cell.offsetX && !cell.offsetY)) {
                            if (!animPropFrameTimers[key]) {
                                animPropFrameTimers[key] = { frame: 0, timer: 0, waiting: false, waitTimer: 0, playCount: 0 };
                            }
                            const state = animPropFrameTimers[key];
                            const instanceSpeed = cell.instanceSpeed || 1;
                            const fps = (propData.fps || 8) * instanceSpeed;
                            const frameDelay = Math.round(60 / fps);
                            // Use instance settings if set, otherwise prop defaults
                            const playMode = cell.instancePlayMode || propData.playMode || 'loop';
                            const waitTime = ((cell.instanceWaitTime !== undefined ? cell.instanceWaitTime : propData.waitTime) || 2) * 60;
                            const targetPlayCount = cell.instancePlayCount || 1;

                            // Handle timed mode - wait between animation cycles
                            if (playMode === 'timed' && state.waiting) {
                                state.waitTimer++;
                                if (state.waitTimer >= waitTime) {
                                    state.waiting = false;
                                    state.waitTimer = 0;
                                    state.frame = 0;
                                    state.playCount = 0;
                                }
                            } else {
                                state.timer++;
                                if (state.timer >= frameDelay) {
                                    state.timer = 0;
                                    state.frame++;

                                    // Handle end of animation
                                    if (state.frame >= propData.frames.length) {
                                        if (playMode === 'loop') {
                                            state.frame = 0; // Loop forever
                                        } else if (playMode === 'timed') {
                                            state.playCount++;
                                            if (state.playCount >= targetPlayCount) {
                                                // Played enough times, now wait
                                                state.frame = 0;
                                                state.waiting = true;
                                                state.waitTimer = 0;
                                            } else {
                                                state.frame = 0; // Play again
                                            }
                                        } else {
                                            state.frame = 0; // Default: loop
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Attack timer and animation
            if (player.attacking) {
                player.attackTimer--;

                // Advance attack animation frames
                if (player.attackAnim && playerAnimations) {
                    const attackDirMap = { down: 'attackDown', up: 'attackUp', left: 'attackLeft', right: 'attackRight' };
                    const attackKey = attackDirMap[player.direction];
                    let attackFrames = playerAnimations[attackKey] || playerAnimations.attack || [];

                    if (attackFrames.length > 0) {
                        // Get FPS for attack animation
                        const attackFps = playerAnimFpsList[attackKey] || playerAnimFpsList.attack || 8;
                        const frameDelay = Math.round(60 / attackFps);

                        if (player.attackFrameTimer === undefined) player.attackFrameTimer = 0;
                        player.attackFrameTimer++;

                        if (player.attackFrameTimer >= frameDelay) {
                            player.attackFrameTimer = 0;
                            player.attackFrame++;

                            // If animation finished, end attack
                            if (player.attackFrame >= attackFrames.length) {
                                player.attacking = false;
                                player.attackAnim = false;
                                player.attackFrame = 0;
                            }
                        }
                        // Use attackFrame for drawing
                        player.frame = player.attackFrame;
                    } else {
                        // No attack animation, just use timer
                        if (player.attackTimer <= 0) {
                            player.attacking = false;
                            player.attackAnim = false;
                        }
                    }
                } else if (player.attackTimer <= 0) {
                    player.attacking = false;
                    player.attackAnim = false;
                }

                // Check for attack hitbox collisions with enemy NPCs
                checkAttackHitbox();
            }

            // Invincibility timer
            if (player.invincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                }
            }

            // Camera follow - adjust for zoom so player stays centered
            camera.x = player.x - (canvas.width / 2) / cameraZoom;
            camera.y = player.y - (canvas.height / 2) / cameraZoom;

            // Apply camera bounds if set for this map
            const currentMapData = mapsData[currentGameMap];
            if (currentMapData && currentMapData.cameraBounds) {
                const bounds = currentMapData.cameraBounds;
                const tileSize = gridSize * TILE_SCALE;
                const boundsPixelX = bounds.x * tileSize;
                const boundsPixelY = bounds.y * tileSize;
                const boundsPixelW = bounds.width * tileSize;
                const boundsPixelH = bounds.height * tileSize;

                const viewW = canvas.width / cameraZoom;
                const viewH = canvas.height / cameraZoom;

                // Clamp camera to bounds
                camera.x = Math.max(boundsPixelX, Math.min(camera.x, boundsPixelX + boundsPixelW - viewW));
                camera.y = Math.max(boundsPixelY, Math.min(camera.y, boundsPixelY + boundsPixelH - viewH));

                // If view is larger than bounds, center on bounds
                if (viewW >= boundsPixelW) {
                    camera.x = boundsPixelX + (boundsPixelW - viewW) / 2;
                }
                if (viewH >= boundsPixelH) {
                    camera.y = boundsPixelY + (boundsPixelH - viewH) / 2;
                }
            }

            // === UPDATE NPCs ===
            updateNPCs();

            // === SOUND UPDATES ===
            // Play walk sounds when moving
            if (player.moving && playerSoundsData.walk && playerSoundsData.walk.soundIndex >= 0) {
                const now = performance.now();
                const interval = playerSoundsData.walk.interval || 200;
                if (now - lastWalkSoundTime >= interval) {
                    playSound(
                        playerSoundsData.walk.soundIndex,
                        playerSoundsData.walk.volume || 0.5,
                        playerSoundsData.walk.pitchVariation || 0.1
                    );
                    lastWalkSoundTime = now;
                }
            }

            // Update ambient sounds based on proximity
            updateAmbientSounds();

            // === MULTIPLAYER UPDATES ===
            // Send position update to server
            sendMpUpdate();

            // Update other players - smooth lerp + animations
            const lerpSpeed = 0.15; // Smoothing factor (0.1 = smoother, 0.3 = snappier)
            otherPlayers.forEach((other, id) => {
                // Lerp position toward target
                other.x += (other.targetX - other.x) * lerpSpeed;
                other.y += (other.targetY - other.y) * lerpSpeed;

                // Update animation frame
                other.frameTimer++;
                if (other.frameTimer >= animSpeed) {
                    other.frameTimer = 0;
                    other.frame = (other.frame + 1) % 4;
                }
            });
        }

        // === MAP TRANSITION SYSTEM ===
        let isTransitioning = false;
        let transitionAlpha = 0;
        let transitionPhase = 'none'; // 'fadeOut', 'fadeIn', 'none', 'doorAnim'
        let pendingTransition = null;
        let pendingExternalUrl = null; // For external door navigation
        let inTavernMode = false; // True when player is in tavern (new tab)
        let tavernWindow = null; // Reference to tavern window

        // Check if player is on a trigger and interact
        // doorTypeFilter: 'interact' = only interact doors, 'walkover' = only walkover doors, null = all
        function checkTriggerInteraction(doorTypeFilter) {
            if (isTransitioning) return false;

            const tileSize = gridSize * TILE_SCALE;
            // Get player's foot position (center bottom)
            const playerTileX = Math.floor((player.x + player.width / 2) / tileSize);
            const playerTileY = Math.floor((player.y + player.height * 0.8) / tileSize);

            for (const trigger of placedTriggers) {
                if (trigger.mapName !== currentGameMap) continue;

                // Filter by door type if specified
                const triggerDoorType = trigger.doorType || 'walkover'; // Default to walkover for old triggers
                // External doors act like walkover doors (trigger on contact)
                const effectiveDoorType = triggerDoorType === 'external' ? 'walkover' : triggerDoorType;
                if (doorTypeFilter && effectiveDoorType !== doorTypeFilter) continue;

                // Check if player is in trigger zone
                if (playerTileX >= trigger.x && playerTileX < trigger.x + (trigger.width || 1) &&
                    playerTileY >= trigger.y && playerTileY < trigger.y + (trigger.height || 1)) {

                    // Skip if target map doesn't exist (unless external door)
                    if (trigger.doorType !== 'external' && !mapsData[trigger.targetMap]) {
                        // Only log once per door to avoid spam
                        if (!trigger._warnedMissing) {
                            console.warn('[TRIGGER] Door ' + trigger.doorNumber + ' target map "' + trigger.targetMap + '" not found');
                            trigger._warnedMissing = true;
                        }
                        return false;
                    }

                    // Skip if spawn point hasn't been set (targetX/Y are null)
                    if (trigger.doorType !== 'external' && (trigger.targetX === null || trigger.targetY === null)) {
                        if (!trigger._warnedNoSpawn) {
                            console.warn('[TRIGGER] Door ' + trigger.doorNumber + ' has no spawn point set - skipping');
                            trigger._warnedNoSpawn = true;
                        }
                        return false;
                    }

                    // Found a trigger - start transition
                    startMapTransition(trigger);
                    return true;
                }
            }
            return false;
        }

        // Check for walkover triggers (called every frame)
        function checkWalkoverTriggers() {
            return checkTriggerInteraction('walkover');
        }

        // === DIALOG INTERACTION SYSTEM ===
        let activeDialog = null; // { dialog, pageIndex, npc }
        let dialogCooldown = 0; // Prevent rapid re-trigger

        function checkDialogInteraction() {
            if (activeDialog || dialogCooldown > 0) return false;

            const tileSize = gridSize * TILE_SCALE;
            // Use player center for X, and upper-middle for Y (not feet)
            const playerTileX = Math.floor((player.x + player.width / 2) / tileSize);
            const playerTileY = Math.floor((player.y + player.height / 2) / tileSize);

            // Build interaction cone based on player facing direction
            // Cone checks tiles in front of player (generous reach for interaction)
            const dir = player.direction || 'down';
            const coneTiles = [];

            // Always include player's current tile (for overlapping/adjacent NPCs)
            coneTiles.push({ x: playerTileX, y: playerTileY });

            if (dir === 'up') {
                // Tiles above player
                coneTiles.push({ x: playerTileX, y: playerTileY - 1 });
                coneTiles.push({ x: playerTileX - 1, y: playerTileY - 1 });
                coneTiles.push({ x: playerTileX + 1, y: playerTileY - 1 });
                coneTiles.push({ x: playerTileX, y: playerTileY - 2 });
                coneTiles.push({ x: playerTileX - 1, y: playerTileY });
                coneTiles.push({ x: playerTileX + 1, y: playerTileY });
            } else if (dir === 'down') {
                // Tiles below player
                coneTiles.push({ x: playerTileX, y: playerTileY + 1 });
                coneTiles.push({ x: playerTileX - 1, y: playerTileY + 1 });
                coneTiles.push({ x: playerTileX + 1, y: playerTileY + 1 });
                coneTiles.push({ x: playerTileX, y: playerTileY + 2 });
                coneTiles.push({ x: playerTileX - 1, y: playerTileY });
                coneTiles.push({ x: playerTileX + 1, y: playerTileY });
            } else if (dir === 'left') {
                // Tiles to the left of player
                coneTiles.push({ x: playerTileX - 1, y: playerTileY });
                coneTiles.push({ x: playerTileX - 1, y: playerTileY - 1 });
                coneTiles.push({ x: playerTileX - 1, y: playerTileY + 1 });
                coneTiles.push({ x: playerTileX - 2, y: playerTileY });
                coneTiles.push({ x: playerTileX, y: playerTileY - 1 });
                coneTiles.push({ x: playerTileX, y: playerTileY + 1 });
            } else if (dir === 'right') {
                // Tiles to the right of player
                coneTiles.push({ x: playerTileX + 1, y: playerTileY });
                coneTiles.push({ x: playerTileX + 1, y: playerTileY - 1 });
                coneTiles.push({ x: playerTileX + 1, y: playerTileY + 1 });
                coneTiles.push({ x: playerTileX + 2, y: playerTileY });
                coneTiles.push({ x: playerTileX, y: playerTileY - 1 });
                coneTiles.push({ x: playerTileX, y: playerTileY + 1 });
            }

            // Check dialog tiles (signs) - must be in cone
            for (const tile of placedDialogTiles) {
                if (tile.mapName !== currentGameMap) continue;
                // Check if dialog tile is in the interaction cone
                const inCone = coneTiles.some(ct => ct.x === tile.x && ct.y === tile.y);
                if (inCone) {
                    const dialog = dialogs[tile.dialogIndex];
                    if (dialog) {
                        showDialog(dialog, null);
                        return true;
                    }
                }
            }

            // Check NPCs - quest dialogs take priority over regular dialogs
            for (let i = 0; i < placedNpcs.length; i++) {
                const npc = placedNpcs[i];
                // Skip NPCs on different maps (treat undefined/empty mapName as current map)
                if (npc.mapName && npc.mapName !== currentGameMap) continue;

                // Use NPC's current runtime position (where they are now), not spawn position
                // state.x/y are in gridSize pixels (unscaled), divide by gridSize to get tile coords
                const state = npcRuntimeState[i];
                const npcCurrentX = state ? Math.floor(state.x / gridSize) : npc.x;
                const npcCurrentY = state ? Math.floor(state.y / gridSize) : npc.y;

                // Check if NPC is in the interaction cone
                const inCone = coneTiles.some(ct => ct.x === npcCurrentX && ct.y === npcCurrentY);
                if (!inCone) continue;

                // Debug: show NPC info when in range
                const npcDef = npcsData[npc.npcIndex];
                console.log('[DIALOG] NPC in cone:', npcDef?.name || 'unknown', 'dialogIndex:', npc.dialogIndex, 'uid:', npc.uid);

                // Check for quest dialog first
                const questAction = getQuestDialogForNpc(npc);

                if (questAction) {
                    const dialog = dialogs[questAction.dialogIndex];
                    if (dialog) {
                        // Set up callback for quest action after dialog closes
                        pendingQuestAction = questAction;
                        showDialog(dialog, npc);
                        return true;
                    }
                }

                // Fall back to regular NPC dialog
                if (npc.dialogIndex !== undefined && npc.dialogIndex >= 0) {
                    if (npc.dialogTrigger === 'auto') continue; // Skip auto-trigger NPCs
                    const dialog = dialogs[npc.dialogIndex];
                    if (dialog) {
                        showDialog(dialog, npc);
                        return true;
                    }
                }
            }

            return false;
        }

        // Track pending quest action after dialog closes
        let pendingQuestAction = null;

        // Get the appropriate quest dialog for an NPC based on quest state
        function getQuestDialogForNpc(npc) {
            if (!npc.uid || !questsData) return null;

            for (const quest of questsData) {
                const state = gameProgress.questStates[quest.id];
                if (!state) continue;

                // Check if this NPC is the quest giver for an available quest
                if (quest.startNpcUid === npc.uid && state.status === QUEST_STATUS.AVAILABLE) {
                    const dialogIdx = parseInt(quest.startDialogId);
                    if (!isNaN(dialogIdx) && dialogIdx >= 0) {
                        return { type: 'offer', questId: quest.id, dialogIndex: dialogIdx };
                    }
                }

                // Check if this NPC is the quest giver for an active quest (reminder)
                if (quest.startNpcUid === npc.uid && state.status === QUEST_STATUS.ACTIVE) {
                    // Check if all conditions are met (can turn in to same NPC)
                    const turnInNpc = quest.turnInNpcUid || quest.startNpcUid;
                    if (turnInNpc === npc.uid && areAllConditionsMet(quest)) {
                        const dialogIdx = parseInt(quest.completeDialogId);
                        if (!isNaN(dialogIdx) && dialogIdx >= 0) {
                            return { type: 'complete', questId: quest.id, dialogIndex: dialogIdx };
                        }
                    } else {
                        // Show reminder dialog
                        const dialogIdx = parseInt(quest.activeDialogId);
                        if (!isNaN(dialogIdx) && dialogIdx >= 0) {
                            return { type: 'reminder', questId: quest.id, dialogIndex: dialogIdx };
                        }
                    }
                }

                // Check if this NPC is the turn-in NPC for an active quest
                if (quest.turnInNpcUid === npc.uid && quest.turnInNpcUid !== quest.startNpcUid && state.status === QUEST_STATUS.ACTIVE) {
                    if (areAllConditionsMet(quest)) {
                        const dialogIdx = parseInt(quest.completeDialogId);
                        if (!isNaN(dialogIdx) && dialogIdx >= 0) {
                            return { type: 'complete', questId: quest.id, dialogIndex: dialogIdx };
                        }
                    }
                }
            }

            return null;
        }

        // Check if all conditions are met for a quest
        function areAllConditionsMet(quest) {
            if (!quest.conditions || quest.conditions.length === 0) return true;
            return quest.conditions.every(c => isConditionMet(c));
        }

        function checkAutoDialogs() {
            if (activeDialog || dialogCooldown > 0) return false;

            const tileSize = gridSize * TILE_SCALE;
            const playerTileX = Math.floor((player.x + player.width / 2) / tileSize);
            const playerTileY = Math.floor((player.y + player.height * 0.8) / tileSize);

            // Check NPCs with auto-trigger dialogs
            for (let i = 0; i < placedNpcs.length; i++) {
                const npc = placedNpcs[i];
                // Skip NPCs on different maps (treat undefined/empty mapName as current map)
                if (npc.mapName && npc.mapName !== currentGameMap) continue;
                if (npc.dialogIndex === undefined || npc.dialogIndex < 0) continue;
                if (npc.dialogTrigger !== 'auto') continue;

                // Use NPC's current runtime position (where they are now), not spawn position
                // state.x/y are in gridSize pixels (unscaled), divide by gridSize to get tile coords
                const state = npcRuntimeState[i];
                const npcCurrentX = state ? Math.floor(state.x / gridSize) : npc.x;
                const npcCurrentY = state ? Math.floor(state.y / gridSize) : npc.y;

                // Check if player is on or adjacent to NPC's current position
                const dx = Math.abs(npcCurrentX - playerTileX);
                const dy = Math.abs(npcCurrentY - playerTileY);
                if (dx <= 1 && dy <= 1) {
                    const dialog = dialogs[npc.dialogIndex];
                    if (dialog) {
                        showDialog(dialog, npc);
                        return true;
                    }
                }
            }

            return false;
        }

        function showDialog(dialog, npc) {
            activeDialog = { dialog, pageIndex: 0, npc };
            // Pause NPC movement while talking
            if (npc) {
                // Find the NPC's runtime state and set pause flag there
                const npcIndex = placedNpcs.indexOf(npc);
                if (npcIndex >= 0 && npcRuntimeState[npcIndex]) {
                    npcRuntimeState[npcIndex]._dialogPaused = true;
                }
                // Track NPC interaction for quest system
                if (npc.uid) {
                    onNpcInteraction(npc.uid);
                }
            }
            renderDialogBox();
        }

        function advanceDialog() {
            if (!activeDialog) return;

            activeDialog.pageIndex++;
            if (activeDialog.pageIndex >= activeDialog.dialog.pages.length) {
                closeDialog();
            } else {
                renderDialogBox();
            }
        }

        function closeDialog() {
            // Resume NPC movement
            if (activeDialog && activeDialog.npc) {
                const npcIndex = placedNpcs.indexOf(activeDialog.npc);
                if (npcIndex >= 0 && npcRuntimeState[npcIndex]) {
                    npcRuntimeState[npcIndex]._dialogPaused = false;
                }
            }
            activeDialog = null;
            dialogCooldown = 30; // ~0.5 seconds at 60fps
            hideDialogBox();

            // Handle pending quest action
            if (pendingQuestAction) {
                const action = pendingQuestAction;
                pendingQuestAction = null;

                if (action.type === 'offer') {
                    // Accept the quest
                    acceptQuest(action.questId);
                    updateQuestTracker();
                } else if (action.type === 'complete') {
                    // Complete the quest
                    completeQuest(action.questId);
                    updateQuestTracker();
                }
                // 'reminder' type doesn't need any action
            }
        }

        // Complete a quest and give rewards
        function completeQuest(questId) {
            const quest = questsData?.find(q => q.id === questId);
            if (!quest) return;

            const state = gameProgress.questStates[questId];
            if (!state || state.status !== QUEST_STATUS.ACTIVE) return;

            // Mark as completed
            state.status = QUEST_STATUS.COMPLETED;

            // Give rewards
            if (quest.onComplete) {
                // Give items
                if (quest.onComplete.giveItems && quest.onComplete.giveItems.length > 0) {
                    quest.onComplete.giveItems.forEach(itemIndex => {
                        addToInventory(parseInt(itemIndex), 1);
                    });
                }
                // Remove items
                if (quest.onComplete.removeItems && quest.onComplete.removeItems.length > 0) {
                    quest.onComplete.removeItems.forEach(itemIndex => {
                        removeFromInventory(parseInt(itemIndex), 1);
                    });
                }
            }

            console.log('[QUEST] Completed quest:', quest.name);
            showQuestNotification('completed', quest.name);

            // Check if other quests become available
            initializeQuestStates();
        }

        function renderDialogBox() {
            if (!activeDialog) return;

            const dialog = activeDialog.dialog;
            const page = dialog.pages[activeDialog.pageIndex];
            const box = document.getElementById('dialogBox');

            if (!box) return;

            // Apply dialog styling
            const style = dialog.style || 1;
            const presets = {
                1: { bg: '#000000', border: '#ffffff', text: '#ffffff', accent: '#ffffff', radius: 0, borderW: 4 },
                2: { bg: '#000088', border: '#ffffff', text: '#ffffff', accent: '#ffff00', radius: 0, borderW: 2 },
                3: { bg: '#f8f8f8', border: '#303030', text: '#303030', accent: '#e03030', radius: 8, borderW: 3 },
                4: { bg: '#000000', border: '#a080ff', text: '#ffffff', accent: '#ffff00', radius: 0, borderW: 2 },
                5: { bg: '#1a1a4e', border: '#8888ff', text: '#ffffff', accent: '#ffcc00', radius: 4, borderW: 2 },
                6: { bg: '#2d2d2d', border: '#4a9eff', text: '#ffffff', accent: '#4a9eff', radius: 6, borderW: 2 }
            };
            const preset = presets[style] || presets[1];

            box.style.background = dialog.colors?.background || preset.bg;
            box.style.border = (preset.borderW || 3) + 'px solid ' + (dialog.colors?.border || preset.border);
            box.style.borderRadius = (preset.radius || 0) + 'px';
            box.style.color = dialog.colors?.text || preset.text;

            // Build content
            let html = '';
            if (page.speaker) {
                html += '<div style="color:' + (dialog.colors?.accent || preset.accent) + '; font-weight:bold; margin-bottom:8px;">' + page.speaker + '</div>';
            }
            html += '<div style="line-height:1.5;">' + page.text + '</div>';
            html += '<div style="text-align:right; margin-top:10px; font-size:10px; color:#888;">[A] ' + (activeDialog.pageIndex + 1) + '/' + dialog.pages.length + '</div>';

            box.innerHTML = html;
            box.style.display = 'block';
        }

        function hideDialogBox() {
            const box = document.getElementById('dialogBox');
            if (box) box.style.display = 'none';
        }

        // Forced walking state
        let forcedWalk = {
            active: false,
            direction: null,
            targetX: null, // Walk-out destination X (pixels)
            targetY: null, // Walk-out destination Y (pixels)
            duration: 0,
            elapsed: 0,
            speed: 2 // pixels per frame
        };

        // Start map transition
        function startMapTransition(trigger) {
            if (isTransitioning) return;

            isTransitioning = true;
            pendingTransition = trigger;

            // Handle external doors (navigate to another HTML file)
            if (trigger.doorType === 'external' && trigger.externalUrl) {
                // Resolve relative URLs using baseUrl from project data
                let externalUrl = trigger.externalUrl;
                if (!externalUrl.startsWith('http://') && !externalUrl.startsWith('https://')) {
                    // Relative URL - prefix with baseUrl
                    const baseUrl = projectData.baseUrl || '';
                    externalUrl = baseUrl + externalUrl;
                }
                console.log('[EXTERNAL DOOR] Navigating to:', externalUrl);

                // Save return coordinates so we can spawn back here
                // Use returnX/returnY if set, otherwise fall back to door position
                const returnInfo = {
                    map: currentGameMap,
                    x: trigger.returnX !== null ? trigger.returnX : trigger.x,
                    y: trigger.returnY !== null ? trigger.returnY : trigger.y,
                    timestamp: Date.now()
                };
                localStorage.setItem('externalDoorReturn', JSON.stringify(returnInfo));
                console.log('[EXTERNAL DOOR] Saved return info:', returnInfo);

                // Save multiplayer info for the external world (3D tavern)
                if (projectData.multiplayer && projectData.multiplayer.roomCode) {
                    const mpInfo = {
                        playerName: projectData.multiplayer.playerName,
                        roomCode: projectData.multiplayer.roomCode
                    };
                    localStorage.setItem('tavernMultiplayer', JSON.stringify(mpInfo));
                    console.log('[EXTERNAL DOOR] Saved multiplayer info:', mpInfo);
                }

                const fadeDuration = trigger.fadeDuration !== undefined ? trigger.fadeDuration : 0.5;

                if (fadeDuration > 0) {
                    // Fade to black, then navigate
                    transitionPhase = 'fadeOut';
                    transitionAlpha = 0;
                    // Store URL for navigation after fade completes
                    pendingExternalUrl = externalUrl;
                } else {
                    // Instant navigation
                    window.location.href = externalUrl;
                }
                return;
            }

            // Apply door animation tile changes (swap tiles to show "door open")
            if (trigger.animTiles && trigger.animTiles.length > 0) {
                console.log('[DOOR ANIM] Applying', trigger.animTiles.length, 'tile changes for door', trigger.doorNumber);
                trigger.animTiles.forEach(change => {
                    // Update the layers array with the "after" state
                    if (!layers[change.layer]) return;
                    if (!layers[change.layer][change.y]) {
                        layers[change.layer][change.y] = [];
                    }
                    layers[change.layer][change.y][change.x] = change.after;
                });
            }

            // Get fade duration (default to 0.5 if not set)
            const fadeDuration = trigger.fadeDuration !== undefined ? trigger.fadeDuration : 0.5;
            const tileSize = gridSize * TILE_SCALE;

            // Check if this is a walkover door with forced walking
            const hasWalkOut = trigger.walkOutX !== null && trigger.walkOutX !== undefined &&
                               trigger.walkOutY !== null && trigger.walkOutY !== undefined;
            const hasWalkDirection = trigger.walkDirection && trigger.walkDuration > 0;

            if (trigger.doorType === 'walkover' && (hasWalkOut || hasWalkDirection)) {
                // Start forced walking phase
                transitionPhase = 'forceWalk';
                forcedWalk.active = true;
                forcedWalk.elapsed = 0;

                if (hasWalkOut) {
                    // Walk to specific destination
                    forcedWalk.targetX = trigger.walkOutX * tileSize;
                    forcedWalk.targetY = trigger.walkOutY * tileSize;
                    forcedWalk.direction = null;

                    // Calculate duration based on distance if not manually set
                    const dx = forcedWalk.targetX - player.x;
                    const dy = forcedWalk.targetY - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const walkSpeed = forcedWalk.speed; // pixels per frame
                    const framesNeeded = dist / walkSpeed;
                    forcedWalk.duration = (framesNeeded / 60) * 1000; // Convert frames to ms

                    // Set initial facing
                    if (Math.abs(dx) > Math.abs(dy)) {
                        player.facing = dx > 0 ? 'right' : 'left';
                    } else {
                        player.facing = dy > 0 ? 'down' : 'up';
                    }
                } else {
                    // Walk in direction for duration
                    forcedWalk.targetX = null;
                    forcedWalk.targetY = null;
                    forcedWalk.direction = trigger.walkDirection;
                    forcedWalk.duration = trigger.walkDuration * 1000; // Convert to ms
                    player.facing = trigger.walkDirection;
                }
            } else if (fadeDuration === 0) {
                // Instant transition (no fade)
                executeMapTransition(trigger);
            } else {
                // Fade transition
                transitionPhase = 'fadeOut';
                transitionAlpha = 0;
            }
        }

        // Execute the actual map switch
        function executeMapTransition(trigger) {
            console.log('=== DOOR TRANSITION ===');
            console.log('Door ' + trigger.doorNumber + ' used: "' + trigger.mapName + '" -> "' + trigger.targetMap + '"');
            console.log('Player spawning at tile (' + trigger.targetX + ', ' + trigger.targetY + ')');

            const targetMapData = mapsData[trigger.targetMap];
            if (!targetMapData) {
                console.error('[GAME TRIGGER DEBUG] Target map not found:', trigger.targetMap);
                console.log('[GAME TRIGGER DEBUG] Available maps:', Object.keys(mapsData));
                isTransitioning = false;
                pendingTransition = null;
                return;
            }

            // Switch to new map
            currentGameMap = trigger.targetMap;
            onMapEnter(currentGameMap);  // Track for quest conditions

            // Stop all ambient sounds from previous map
            Object.keys(ambientSounds).forEach(key => {
                if (ambientSounds[key]?.source) {
                    try {
                        ambientSounds[key].source.stop();
                    } catch (e) { /* ignore */ }
                }
            });
            ambientSounds = {}; // Clear all ambient sounds
            console.log('[SOUND] Cleared ambient sounds for map transition');

            // Load the new map data
            // Note: tileCollisions, collisionMasks, tileSplitLines, tileSplitLineFlipped are GLOBAL
            // (per-tileset, not per-map) - they persist across map transitions
            layers = targetMapData.layers || layers;
            mapCols = targetMapData.mapCols || mapCols;
            mapRows = targetMapData.mapRows || mapRows;

            // Position player at target spawn
            const tileSize = gridSize * TILE_SCALE;

            player.x = trigger.targetX * tileSize;
            player.y = trigger.targetY * tileSize;
            console.log('Player pixel position: (' + player.x + ', ' + player.y + ')');

            // Reset camera to center on player
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;

            // Start fade in (or finish if instant)
            if (pendingTransition && pendingTransition.transitionStyle !== 'instant') {
                transitionPhase = 'fadeIn';
            } else {
                isTransitioning = false;
                pendingTransition = null;
            }
        }

        // Update transition animation
        function updateTransition(deltaTime) {
            if (!isTransitioning) return;

            // Get fade duration from trigger (default to 0.5 seconds)
            const fadeDuration = pendingTransition?.fadeDuration !== undefined ? pendingTransition.fadeDuration : 0.5;
            // Calculate fade speed (alpha change per frame at ~60fps)
            const fadeSpeed = fadeDuration > 0 ? (1 / (fadeDuration * 60)) : 1;

            if (transitionPhase === 'forceWalk') {
                // Update forced walking
                forcedWalk.elapsed += deltaTime;

                // Move player toward walk-out destination (if set) or in direction
                const moveSpeed = forcedWalk.speed;

                if (forcedWalk.targetX !== null && forcedWalk.targetY !== null) {
                    // Walk toward specific destination
                    const dx = forcedWalk.targetX - player.x;
                    const dy = forcedWalk.targetY - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > moveSpeed) {
                        // Move toward target
                        player.x += (dx / dist) * moveSpeed;
                        player.y += (dy / dist) * moveSpeed;

                        // Set facing based on dominant direction
                        if (Math.abs(dx) > Math.abs(dy)) {
                            player.facing = dx > 0 ? 'right' : 'left';
                        } else {
                            player.facing = dy > 0 ? 'down' : 'up';
                        }
                    } else {
                        // Reached destination
                        player.x = forcedWalk.targetX;
                        player.y = forcedWalk.targetY;
                        forcedWalk.elapsed = forcedWalk.duration; // Force completion
                    }
                } else {
                    // Walk in direction for duration
                    switch (forcedWalk.direction) {
                        case 'up':
                            player.y -= moveSpeed;
                            player.facing = 'up';
                            break;
                        case 'down':
                            player.y += moveSpeed;
                            player.facing = 'down';
                            break;
                        case 'left':
                            player.x -= moveSpeed;
                            player.facing = 'left';
                            break;
                        case 'right':
                            player.x += moveSpeed;
                            player.facing = 'right';
                            break;
                    }
                }

                // Animate walking - update frame timer
                player.isMoving = true;
                player.frameTimer++;
                const walkAnimKey = 'walk' + player.direction.charAt(0).toUpperCase() + player.direction.slice(1);
                const walkFps = playerAnimFpsList[walkAnimKey] || 8;
                const walkFrameDelay = Math.max(1, Math.round(60 / walkFps));
                if (player.frameTimer >= walkFrameDelay) {
                    player.frameTimer = 0;
                    player.frame = (player.frame + 1) % 4;
                }

                // Check if walk duration is complete
                if (forcedWalk.elapsed >= forcedWalk.duration) {
                    forcedWalk.active = false;
                    player.isMoving = false;

                    // Move to fade phase (or instant if fadeDuration is 0)
                    if (fadeDuration === 0) {
                        executeMapTransition(pendingTransition);
                    } else {
                        transitionPhase = 'fadeOut';
                        transitionAlpha = 0;
                    }
                }
            } else if (transitionPhase === 'fadeOut') {
                transitionAlpha += fadeSpeed;
                if (transitionAlpha >= 1) {
                    transitionAlpha = 1;
                    // Check if this is an external door navigation
                    if (pendingExternalUrl) {
                        // Open tavern in new tab instead of navigating
                        tavernWindow = window.open(pendingExternalUrl, '_blank');
                        inTavernMode = true;
                        pendingExternalUrl = null;
                        transitionPhase = 'tavern'; // Stay on black screen
                        return;
                    }
                    executeMapTransition(pendingTransition);
                }
            } else if (transitionPhase === 'fadeIn') {
                transitionAlpha -= fadeSpeed;
                if (transitionAlpha <= 0) {
                    transitionAlpha = 0;
                    transitionPhase = 'none';
                    isTransitioning = false;

                    // Restore door tiles on source map (close the door after transition)
                    if (pendingTransition && pendingTransition.animTiles && pendingTransition.animTiles.length > 0) {
                        const sourceMapName = pendingTransition.mapName;
                        const sourceMapData = mapsData[sourceMapName];
                        if (sourceMapData && sourceMapData.layers) {
                            console.log('[DOOR ANIM] Restoring', pendingTransition.animTiles.length, 'tiles on', sourceMapName, '(closing door)');
                            pendingTransition.animTiles.forEach(change => {
                                if (!sourceMapData.layers[change.layer]) return;
                                if (!sourceMapData.layers[change.layer][change.y]) {
                                    sourceMapData.layers[change.layer][change.y] = [];
                                }
                                sourceMapData.layers[change.layer][change.y][change.x] = change.before;
                            });
                        }
                    }

                    pendingTransition = null;
                }
            }
        }

        // Draw transition overlay
        function drawTransitionOverlay() {
            if (transitionAlpha > 0 || inTavernMode) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Show tavern message when in tavern mode
                if (inTavernMode) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 24px "Press Start 2P", monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText("YOU ARE IN THE TAVERN", canvas.width / 2, canvas.height / 2 - 30);
                    ctx.font = '12px "Press Start 2P", monospace';
                    ctx.fillStyle = '#888';
                    ctx.fillText("( DO NOT CLOSE THIS TAB )", canvas.width / 2, canvas.height / 2 + 20);
                    ctx.fillText("RETURN THROUGH THE BLUE DOOR", canvas.width / 2, canvas.height / 2 + 50);
                }
            }
        }

        // Listen for focus to detect return from tavern
        window.addEventListener('focus', () => {
            if (inTavernMode) {
                // Check if tavern window was closed
                if (!tavernWindow || tavernWindow.closed) {
                    inTavernMode = false;

                    // Spawn player at return point
                    const returnInfoStr = localStorage.getItem('externalDoorReturn');
                    if (returnInfoStr) {
                        try {
                            const returnInfo = JSON.parse(returnInfoStr);
                            const tileSize = gridSize * TILE_SCALE;

                            // Switch map if needed
                            if (returnInfo.map && returnInfo.map !== currentGameMap) {
                                currentGameMap = returnInfo.map;
                                const mapData = mapsData[returnInfo.map];
                                if (mapData) {
                                    layers = mapData.layers || [];
                                    triggers = mapData.triggers || [];
                                }
                            }

                            // Move player to return position
                            player.x = returnInfo.x * tileSize + tileSize / 2;
                            player.y = returnInfo.y * tileSize + tileSize / 2;
                            console.log('[TAVERN RETURN] Spawned at:', player.x, player.y);

                            // Clear the return info
                            localStorage.removeItem('externalDoorReturn');
                        } catch (e) {
                            console.error('[TAVERN RETURN] Error:', e);
                        }
                    }

                    transitionPhase = 'fadeIn';
                    transitionAlpha = 1;
                }
            }
        });

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const tileSize = gridSize * TILE_SCALE;
            ctx.imageSmoothingEnabled = false;

            // Check if all tilesets are ready
            let allTilesetsReady = true;
            for (let i = 0; i < tilesetImages.length; i++) {
                if (!tilesetImages[i] || !tilesetImages[i].complete) {
                    allTilesetsReady = false;
                    break;
                }
            }
            if (!allTilesetsReady) {
                ctx.fillStyle = '#4af';
                ctx.font = '20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Loading tilesets...', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Debug: Show message if no layers
            if (layers.length === 0) {
                ctx.fillStyle = '#f00';
                ctx.font = '16px monospace';
                ctx.fillText('ERROR: No layers loaded!', 20, 70);
                return;
            }

            // Apply camera zoom transform
            ctx.save();
            ctx.scale(cameraZoom, cameraZoom);

            // Draw tiles - use Math.round for camera to prevent seams
            const camX = Math.round(camera.x);
            const camY = Math.round(camera.y);

            // === 3-PASS RENDERING FOR Y-SORTING ===

            // PASS 1: Draw ground layer (layer 0) - always behind everything
            let tilesDrawn = drawLayer(0, camX, camY, tileSize);

            // PASS 2: Y-sort player with tiles from layers 1+
            tilesDrawn += drawYSortedEntities(camX, camY, tileSize);

            // PASS 3: Draw canopy overlay (split tile tops)
            drawCanopyOverlay(camX, camY, tileSize);

            // PASS 4: Redraw higher layer content that canopy covered
            redrawHigherLayerContent(camX, camY, tileSize);

            // PASS 5: Draw collision debug on top of everything (so canopy doesn't hide it)
            if (showCollision) {
                drawCollisionDebugOverlay(camX, camY, tileSize);
            }

            // Draw sound debug visualization
            if (showSounds) {
                Object.keys(tileSounds).forEach(key => {
                    // Filter by current map
                    let sx, sy;
                    if (key.includes(':')) {
                        const parts = key.split(':');
                        if (parts[0] !== currentGameMap) return;
                        [sx, sy] = parts[1].split(',').map(Number);
                    } else {
                        if (currentGameMap !== 'main') return;
                        [sx, sy] = key.split(',').map(Number);
                    }
                    const ts = tileSounds[key];
                    if (!ts) return;

                    const px = sx * tileSize - camX + tileSize / 2;
                    const py = sy * tileSize - camY + tileSize / 2;
                    const radius = (ts.radius || 3) * tileSize;

                    // Draw radius circle - filled purple gradient for visibility
                    const isPlaying = ambientSounds[key]?.playing;

                    // Filled gradient circle
                    const gradient = ctx.createRadialGradient(px, py, 0, px, py, radius);
                    if (isPlaying) {
                        gradient.addColorStop(0, 'rgba(100, 255, 100, 0.3)');
                        gradient.addColorStop(0.7, 'rgba(100, 255, 100, 0.15)');
                        gradient.addColorStop(1, 'rgba(100, 255, 100, 0)');
                    } else {
                        gradient.addColorStop(0, 'rgba(180, 100, 255, 0.3)');
                        gradient.addColorStop(0.7, 'rgba(180, 100, 255, 0.15)');
                        gradient.addColorStop(1, 'rgba(180, 100, 255, 0)');
                    }
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(px, py, radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Outer ring
                    ctx.strokeStyle = isPlaying ? 'rgba(100, 255, 100, 0.8)' : 'rgba(180, 100, 255, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Draw center marker
                    ctx.fillStyle = isPlaying ? '#0f0' : '#b464ff';
                    ctx.beginPath();
                    ctx.arc(px, py, tileSize / 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    const soundName = soundsData[ts.soundIndex]?.name || 'Sound ' + ts.soundIndex;
                    ctx.fillText(soundName, px, py - tileSize / 2);
                    ctx.fillText(isPlaying ? 'PLAYING' : 'idle', px, py + tileSize / 2 + 12);
                });
            }

            // Layer debug visualization
            if (showLayers) {
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li];
                    if (!layer) continue;
                    for (let y = 0; y < mapRows; y++) {
                        if (!layer[y]) continue;
                        for (let x = 0; x < mapCols; x++) {
                            const cell = layer[y][x];
                            if (!cell) continue;
                            const px = x * tileSize - camX + tileSize / 2;
                            const py = y * tileSize - camY + tileSize / 2;
                            // Skip off-screen tiles
                            if (px < -tileSize || px > canvas.width / cameraZoom + tileSize || py < -tileSize || py > canvas.height / cameraZoom + tileSize) continue;
                            // Different color for animTiles
                            if (cell.type === 'animTile') {
                                ctx.fillStyle = 'rgba(255, 0, 255, 0.8)'; // Magenta for animTiles
                                ctx.fillRect(px - 8, py - 6, 16, 12);
                                ctx.fillStyle = '#fff';
                                ctx.fillText('A' + li, px, py);
                            } else if (li > 0) {
                                // Only show layer number for non-ground tiles
                                ctx.fillStyle = 'rgba(0, 100, 255, 0.7)';
                                ctx.fillRect(px - 6, py - 6, 12, 12);
                                ctx.fillStyle = '#fff';
                                ctx.fillText(li, px, py);
                            }
                        }
                    }
                }
            }

            // Draw trigger zones when collision debug is enabled
            if (showCollision && placedTriggers) {
                const triggersOnMap = placedTriggers.filter(t => t.mapName === currentGameMap);

                triggersOnMap.forEach(trigger => {
                    const px = trigger.x * tileSize - camX;
                    const py = trigger.y * tileSize - camY;
                    const pw = (trigger.width || 1) * tileSize;
                    const ph = (trigger.height || 1) * tileSize;

                    // Draw trigger zone - bright magenta
                    ctx.fillStyle = 'rgba(255, 0, 255, 0.4)';
                    ctx.fillRect(px, py, pw, ph);
                    ctx.strokeStyle = '#f0f';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(px, py, pw, ph);

                    // Draw type label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(trigger.type.toUpperCase(), px + pw / 2, py + ph / 2 - 8);

                    // Show target info
                    ctx.font = '10px monospace';
                    const doorNum = trigger.doorNumber || '?';
                    ctx.fillText('Door ' + doorNum + ' > ' + trigger.targetMap, px + pw / 2, py + ph / 2 + 6);
                });

                // Draw GREEN spawn boxes for incoming doors (doors that lead TO this map)
                // Only draw if spawn has been set (not null)
                const incomingTriggers = placedTriggers.filter(t => t.targetMap === currentGameMap && t.targetX !== null && t.targetY !== null);
                incomingTriggers.forEach(trigger => {
                    const sx = trigger.targetX * tileSize - camX;
                    const sy = trigger.targetY * tileSize - camY;

                    // Green spawn box
                    ctx.fillStyle = 'rgba(0, 255, 100, 0.4)';
                    ctx.fillRect(sx, sy, tileSize, tileSize);
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(sx, sy, tileSize, tileSize);

                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const doorNum = trigger.doorNumber || '?';
                    ctx.fillText('Door ' + doorNum, sx + tileSize / 2, sy + tileSize / 2 - 6);
                    ctx.fillText('from ' + trigger.mapName, sx + tileSize / 2, sy + tileSize / 2 + 6);
                });
            }

            // Draw dialog tiles when collision debug is enabled
            if (showCollision && placedDialogTiles) {
                const dialogTilesOnMap = placedDialogTiles.filter(t => t.mapName === currentGameMap);

                dialogTilesOnMap.forEach(tile => {
                    const px = tile.x * tileSize - camX;
                    const py = tile.y * tileSize - camY;

                    // Draw dialog tile - orange/yellow
                    ctx.fillStyle = 'rgba(255, 180, 0, 0.4)';
                    ctx.fillRect(px, py, tileSize, tileSize);
                    ctx.strokeStyle = '#fa0';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(px, py, tileSize, tileSize);

                    // Speech bubble icon
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('💬', px + tileSize / 2, py + tileSize / 2 - 4);

                    // Show dialog name if available
                    const dialog = dialogs[tile.dialogIndex];
                    if (dialog && dialog.name) {
                        ctx.font = '8px monospace';
                        ctx.fillStyle = '#fa0';
                        ctx.fillText(dialog.name.substring(0, 10), px + tileSize / 2, py + tileSize / 2 + 10);
                    }
                });
            }

            // Draw INITIAL spawn point when collision debug is enabled
            // Only shows on the spawn map - this is where player spawns when game first loads
            // Door targets are separate (shown as magenta trigger zones with yellow coordinates)
            if (showCollision && projectData.playerPreviewPos) {
                // Only show initial spawn on the spawn map
                if (currentGameMap === spawnMapNameData) {
                    const spawnPos = projectData.playerPreviewPos;
                    const spawnX = spawnPos.x * tileSize - camX;
                    const spawnY = spawnPos.y * tileSize - camY;

                    // Green spawn marker
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
                    ctx.fillRect(spawnX, spawnY, tileSize, tileSize);
                    ctx.strokeStyle = '#0f0';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(spawnX, spawnY, tileSize, tileSize);

                    // Label with coordinates
                    ctx.fillStyle = '#0f0';
                    ctx.font = 'bold 10px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('START', spawnX + tileSize/2, spawnY + tileSize/2 - 6);
                    ctx.font = '9px monospace';
                    ctx.fillText('(' + spawnPos.x + ',' + spawnPos.y + ')', spawnX + tileSize/2, spawnY + tileSize/2 + 6);
                }
            }

            // DEBUG: Draw player position marker at player feet (only when UI visible)
            if (!uiHidden) {
                ctx.fillStyle = '#f0f';
                ctx.beginPath();
                ctx.arc(player.x - camX, player.y - camY, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();

            // DEBUG HUD: Show player position (only when UI visible)
            if (!uiHidden) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(10, 10, 200, 50);
                ctx.fillStyle = '#0ff';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText('PLAYER POS (for builder)', 15, 15);
                ctx.fillStyle = '#ff0';
                ctx.fillText('x:' + Math.round(player.x) + ' y:' + Math.round(player.y), 15, 35);
            }

            // === LIGHTING OVERLAY (drawn after all game content) ===
            renderLighting();

            // Debug info - stacked properly from bottom up
            if (!uiHidden) {
                ctx.font = '12px monospace';
                let debugY = canvas.height - 10;
                const lineHeight = 15;

                // Always show basic info at bottom
                ctx.fillStyle = '#fff';
                ctx.fillText('Layers: ' + layers.length + ' | Tiles: ' + tilesDrawn + ' | Zoom: ' + cameraZoom.toFixed(1) + 'x', 10, debugY);
                debugY -= lineHeight;

                // Health display (always visible when collision debug on)
                if (showCollision) {
                    ctx.fillStyle = player.health <= 25 ? '#f44' : (player.health <= 50 ? '#fa4' : '#4f4');
                    ctx.fillText('HEALTH: ' + player.health + '/' + player.maxHealth + (player.invincible ? ' [INV]' : ''), 10, debugY);
                    debugY -= lineHeight;

                    // Spawn and player position
                    const playerTileX = Math.floor(player.x / tileSize);
                    const playerTileY = Math.floor(player.y / tileSize);
                    const spawnPos = projectData.playerPreviewPos || {x: '?', y: '?'};
                    ctx.fillStyle = '#0f0';
                    ctx.fillText('START: (' + spawnPos.x + ',' + spawnPos.y + ') | PLAYER: (' + playerTileX + ',' + playerTileY + ') on "' + currentGameMap + '"', 10, debugY);
                    debugY -= lineHeight;
                }

                // Sound debug info
                if (showSounds) {
                    ctx.fillStyle = '#ff0';
                    ctx.fillText('Sounds: ' + soundsData.length + ' | Tile sounds: ' + Object.keys(tileSounds).length + ' | Audio: ' + (audioContext ? 'ON' : 'OFF'), 10, debugY);
                    debugY -= lineHeight;
                }

                // Layer debug info
                if (showLayers) {
                    let animCounts = [];
                    for (let li = 0; li < layers.length; li++) {
                        let count = 0;
                        const layer = layers[li];
                        if (layer) {
                            for (let y = 0; y < mapRows; y++) {
                                if (!layer[y]) continue;
                                for (let x = 0; x < mapCols; x++) {
                                    if (layer[y][x]?.type === 'animTile') count++;
                                }
                            }
                        }
                        if (count > 0) animCounts.push('L' + li + ':' + count);
                    }
                    ctx.fillStyle = '#4af';
                    ctx.fillText('AnimTiles: ' + (animCounts.length > 0 ? animCounts.join(', ') : 'none') + ' | Press L to toggle', 10, debugY);
                }
            }
        }

        // Helper for drawing tiles with rotation and flip in test game
        function drawTileWithEffects(ctx, img, srcX, srcY, srcSize, destX, destY, destSize, rotation, flipped) {
            ctx.save();
            ctx.translate(destX + destSize / 2, destY + destSize / 2);

            if (rotation !== 0) {
                ctx.rotate(rotation * Math.PI / 180);
            }
            if (flipped) {
                ctx.scale(-1, 1); // Flip horizontally
            }

            ctx.drawImage(img, srcX, srcY, srcSize, srcSize, -destSize / 2, -destSize / 2, destSize, destSize);
            ctx.restore();
        }

        function drawLayer(li, camX, camY, tileSize) {
            if (!layerVisibility[li]) return 0;
            const layer = layers[li];
            if (!layer) return 0;

            let count = 0;
            for (let y = 0; y < mapRows; y++) {
                if (!layer[y]) continue;
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y][x];
                    if (!cell) continue;

                    // Use exact integer positions - no overlap to avoid double-drawing semi-transparent pixels
                    const px = x * tileSize - camX;
                    const py = y * tileSize - camY;

                    // Account for zoom in off-screen check
                    if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                    if (cell.type === 'tile') {
                        count++;
                        // Use correct tileset for this tile
                        const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
                        if (cellTileset) {
                            // Draw at exact pixel positions - no overlap needed since tileSize is integer
                            drawTileWithEffects(ctx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize, cell.rotation || 0, cell.flipped || false);
                        } else {
                            // Fallback: draw colored rectangle if tileset not loaded
                            ctx.fillStyle = '#4a7c59';
                            ctx.fillRect(px, py, tileSize, tileSize);
                        }

                        // Draw collision overlay if debug enabled (all layers)
                        if (showCollision) {
                            // Include tileset index in collision key
                            const tilesetIdx = cell.tilesetIndex || 0;
                            const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                            const mask = collisionMasks[key];

                            if (mask) {
                                // Draw pixel-level collision
                                const pixelSize = tileSize / gridSize;
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                for (let my = 0; my < gridSize; my++) {
                                    for (let mx = 0; mx < gridSize; mx++) {
                                        if (mask[my] && mask[my][mx]) {
                                            ctx.fillRect(
                                                px + mx * pixelSize,
                                                py + my * pixelSize,
                                                pixelSize,
                                                pixelSize
                                            );
                                        }
                                    }
                                }
                            } else if (tileCollisions[key]) {
                                // Full tile collision
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                ctx.fillRect(px, py, tileSize, tileSize);
                            }
                        }
                    } else if (cell.type === 'prop') {
                        const propIdx = cell.propIndex || 0;
                        const propImg = propImages[propIdx];
                        if (propImg && propImg.complete) {
                            count++;
                            ctx.drawImage(propImg, cell.x, cell.y, gridSize, gridSize, px, py, tileSize, tileSize);
                        }

                        // Show collision in debug mode
                        if (showCollision) {
                            const key = cell.x + ',' + cell.y;
                            const mask = propCollisionMasksAll[propIdx] ? propCollisionMasksAll[propIdx][key] : null;
                            if (mask) {
                                const pixelSize = tileSize / gridSize;
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                for (let my = 0; my < gridSize; my++) {
                                    for (let mx = 0; mx < gridSize; mx++) {
                                        if (mask[my] && mask[my][mx]) {
                                            ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                                        }
                                    }
                                }
                            }
                        }
                    } else if (cell.type === 'animTile') {
                        // Animated tile - cycles through frames like a regular tile
                        const propData = animatedPropsData[cell.propIndex];
                        const propImg = animPropImages[cell.propIndex];
                        if (propData && propImg && propImg.complete && propData.frames && propData.frames.length > 0) {
                            // Use origin tile position for synced animation
                            const originX = x - (cell.offsetX || 0);
                            const originY = y - (cell.offsetY || 0);
                            const key = originX + ',' + originY + ',' + li;
                            const timer = animPropFrameTimers[key] || { frame: 0 };
                            const frameIdx = timer.frame % propData.frames.length;
                            const frame = propData.frames[frameIdx];

                            // Draw only this tile's portion of the frame
                            const offsetX = cell.offsetX || 0;
                            const offsetY = cell.offsetY || 0;
                            const srcX = frame.x + offsetX * gridSize;
                            const srcY = frame.y + offsetY * gridSize;

                            count++;
                            // Draw with rotation support
                            const rot = cell.rotation || 0;
                            if (rot === 0) {
                                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px, py, tileSize, tileSize);
                            } else {
                                ctx.save();
                                ctx.translate(px + tileSize / 2, py + tileSize / 2);
                                ctx.rotate(rot * Math.PI / 180);
                                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, -tileSize / 2, -tileSize / 2, tileSize, tileSize);
                                ctx.restore();
                            }
                        }
                    }
                }
            }

            return count;
        }

        // === Y-SORTING FUNCTIONS ===

        // Original Y-sorting: Y position is primary, layer is tiebreaker
        function drawYSortedEntities(camX, camY, tileSize) {
            const entities = [];

            // Add player
            const playerGridY = Math.floor((player.y + player.height) / (gridSize * TILE_SCALE));
            const playerLayer = playerLayerIndex || 1;
            entities.push({
                type: 'player',
                sortY: (playerGridY + 1) * 1000 + playerLayer + 0.5
            });

            // Add NPCs
            placedNpcs.forEach((placed, i) => {
                // Only show NPCs on current map
                if (placed.mapName && placed.mapName !== currentGameMap) return;

                const state = npcRuntimeState[i];
                if (!state) return;
                const npc = npcsData[placed.npcIndex];
                if (!npc) return;

                // state.y is in grid pixels (unscaled), so divide by gridSize to get tile Y
                // Add gridSize to get bottom of NPC (feet position) for proper Y-sorting
                const npcGridY = Math.floor((state.y + gridSize) / gridSize);
                entities.push({
                    type: 'npc',
                    npcIndex: i,
                    sortY: (npcGridY + 1) * 1000 + playerLayer + 0.4 // Slightly before player at same Y
                });
            });

            // Add items (interactive objects like chests)
            placedItemsData.forEach((placed, i) => {
                if (placed.mapName && placed.mapName !== currentGameMap) return;

                const item = itemsData[placed.itemIndex];
                if (!item) return;

                const itemGridY = placed.y + 1; // Bottom of item tile for Y-sorting
                entities.push({
                    type: 'item',
                    itemIndex: i,
                    sortY: (itemGridY + 1) * 1000 + (placed.layer || 1) + 0.3 // Before NPCs at same Y
                });
            });

            // Add static objects (multi-tile props from tilesets)
            placedStaticObjectsData.forEach((placed, i) => {
                if (placed.mapName && placed.mapName !== currentGameMap) return;

                const obj = staticObjectsData[placed.objIndex];
                if (!obj) return;

                // Bottom of object for Y-sorting (height in tiles)
                const objGridY = placed.y + (obj.height || 1);
                entities.push({
                    type: 'staticObj',
                    placedIndex: i,
                    sortY: (objGridY + 1) * 1000 + (placed.layer || 1) + 0.2 // Before items at same Y
                });
            });

            // Add other multiplayer players (only on same map, not in tavern)
            otherPlayers.forEach((other, odId) => {
                // Skip players in tavern or on different map
                if (other.inTavern || other.currentMap !== currentGameMap) return;

                const otherGridY = Math.floor((other.y + player.height) / (gridSize * TILE_SCALE));
                entities.push({
                    type: 'otherPlayer',
                    playerId: odId,
                    sortY: (otherGridY + 1) * 1000 + playerLayer + 0.45 // Between NPCs and player
                });
            });

            // Add tiles from all layers 1+
            for (let li = 1; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        const px = x * tileSize - camX;
                        const py = y * tileSize - camY;

                        // Skip off-screen tiles
                        if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                        // Y is primary, layer is tiebreaker
                        const baseSortY = (y + 1) * 1000 + li;

                        if (cell.type === 'tile') {
                            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
                            const splitData = tileSplitLines[key];
                            const hasSplit = splitData !== undefined && splitData !== null;

                            entities.push({
                                type: hasSplit ? 'trunk' : 'tile',
                                cell, x, y, layer: li,
                                sortY: baseSortY
                            });
                        } else if (cell.type === 'animTile') {
                            const propData = animatedPropsData[cell.propIndex];
                            const hasSplit = propData && propData.splitLine !== null && propData.splitLine !== undefined &&
                                (typeof propData.splitLine === 'number' ||
                                 (typeof propData.splitLine === 'object' && Object.keys(propData.splitLine).length > 0));

                            entities.push({
                                type: hasSplit ? 'animTrunk' : 'animTile',
                                cell, x, y, layer: li,
                                sortY: baseSortY
                            });
                        }
                    }
                }
            }

            // Sort by Y, then layer
            entities.sort((a, b) => a.sortY - b.sortY);

            // Draw in sorted order
            let count = 0;
            for (const e of entities) {
                if (e.type === 'player') {
                    drawPlayer();
                } else if (e.type === 'otherPlayer') {
                    drawOtherPlayer(e.playerId, camX, camY);
                } else if (e.type === 'npc') {
                    drawNPC(e.npcIndex, camX, camY, tileSize);
                } else if (e.type === 'item') {
                    drawItem(e.itemIndex, camX, camY, tileSize);
                } else if (e.type === 'staticObj') {
                    drawStaticObject(e.placedIndex, camX, camY, tileSize);
                } else if (e.type === 'trunk') {
                    drawTileTrunk(e.cell, e.x, e.y, camX, camY, tileSize);
                    count++;
                } else if (e.type === 'animTrunk') {
                    drawAnimTileTrunk(e.cell, e.x, e.y, e.layer, camX, camY, tileSize);
                    count++;
                } else if (e.type === 'animTile') {
                    drawAnimTile(e.cell, e.x, e.y, e.layer, camX, camY, tileSize);
                    count++;
                } else {
                    drawTileFull(e.cell, e.x, e.y, camX, camY, tileSize);
                    count++;
                }
            }

            return count;
        }

        // Redraw content from higher layers that overlaps with canopy from lower layers
        function redrawHigherLayerContent(camX, camY, tileSize) {
            // For each position that has canopy (split line), redraw any higher layer content
            for (let li = 1; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        // Check if this cell has canopy (split line)
                        let hasCanopy = false;
                        if (cell.type === 'tile') {
                            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
                            hasCanopy = tileSplitLines[key] !== undefined && tileSplitLines[key] !== null;
                        } else if (cell.type === 'animTile') {
                            const propData = animatedPropsData[cell.propIndex];
                            hasCanopy = propData && propData.splitLine !== null && propData.splitLine !== undefined;
                        }

                        if (!hasCanopy) continue;

                        // This cell has canopy - redraw any higher layer content at this position
                        for (let hi = li + 1; hi < layers.length; hi++) {
                            if (!layerVisibility[hi]) continue;
                            const higherLayer = layers[hi];
                            if (!higherLayer || !higherLayer[y] || !higherLayer[y][x]) continue;

                            const higherCell = higherLayer[y][x];
                            if (higherCell.type === 'animTile') {
                                drawAnimTile(higherCell, x, y, hi, camX, camY, tileSize);
                            } else if (higherCell.type === 'tile') {
                                drawTileFull(higherCell, x, y, camX, camY, tileSize);
                            }
                        }
                    }
                }
            }
        }

        function drawAnimTile(cell, tx, ty, li, camX, camY, tileSize) {
            const propData = animatedPropsData[cell.propIndex];
            const propImg = animPropImages[cell.propIndex];

            if (!propData || !propImg || !propImg.complete || !propData.frames || propData.frames.length === 0) {
                return;
            }

            const px = tx * tileSize - camX;
            const py = ty * tileSize - camY;

            // Use origin tile position for synced animation
            const originX = tx - (cell.offsetX || 0);
            const originY = ty - (cell.offsetY || 0);
            const key = originX + ',' + originY + ',' + li;
            const timer = animPropFrameTimers[key] || { frame: 0 };
            const frameIdx = timer.frame % propData.frames.length;
            const frame = propData.frames[frameIdx];

            // Draw only this tile's portion of the frame
            const offsetX = cell.offsetX || 0;
            const offsetY = cell.offsetY || 0;
            const srcX = frame.x + offsetX * gridSize;
            const srcY = frame.y + offsetY * gridSize;

            // Apply scale factor - scale from prop's origin, not each tile's center
            const propScale = cell.scale || 1;
            const scaledTileSize = tileSize * propScale;

            // Calculate prop's total size to find proper scale origin
            const tilesW = cell.tilesW || 1;
            const tilesH = cell.tilesH || 1;
            const propWidth = tilesW * tileSize;
            const propHeight = tilesH * tileSize;
            const scaledPropWidth = propWidth * propScale;
            const scaledPropHeight = propHeight * propScale;

            // Scale offset from prop's center (not individual tile center)
            const propCenterOffsetX = (scaledPropWidth - propWidth) / 2;
            const propCenterOffsetY = (scaledPropHeight - propHeight) / 2;

            // This tile's position relative to origin
            const tileOffsetX = offsetX * tileSize;
            const tileOffsetY = offsetY * tileSize;

            // Scale tile offset from prop origin
            const scaledTileOffsetX = tileOffsetX * propScale;
            const scaledTileOffsetY = tileOffsetY * propScale;

            // Origin tile's screen position
            const originPx = Math.floor(originX * tileSize - camX);
            const originPy = Math.floor(originY * tileSize - camY);

            // Draw position: origin - center offset + scaled tile offset
            const drawX = originPx - propCenterOffsetX + scaledTileOffsetX;
            const drawY = originPy - propCenterOffsetY + scaledTileOffsetY;

            ctx.imageSmoothingEnabled = false;

            // Draw with rotation support
            const rot = cell.rotation || 0;
            if (rot === 0) {
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, drawX, drawY, scaledTileSize, scaledTileSize);
            } else {
                ctx.save();
                const propCenterX = originPx + propWidth / 2;
                const propCenterY = originPy + propHeight / 2;
                ctx.translate(propCenterX, propCenterY);
                ctx.rotate(rot * Math.PI / 180);
                const rotDrawX = -scaledPropWidth / 2 + scaledTileOffsetX;
                const rotDrawY = -scaledPropHeight / 2 + scaledTileOffsetY;
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, rotDrawX, rotDrawY, scaledTileSize, scaledTileSize);
                ctx.restore();
            }
        }

        // Draw only the trunk (bottom) portion of an animated tile with split line
        function drawAnimTileTrunk(cell, tx, ty, li, camX, camY, tileSize) {
            const propData = animatedPropsData[cell.propIndex];
            const propImg = animPropImages[cell.propIndex];
            if (!propData || !propImg || !propImg.complete) return;
            if (!propData.frames || propData.frames.length === 0) return;
            if (!propData.splitLine) return;

            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const scale = tileSize / gridSize;

            // Use origin tile position for synced animation
            const originX = tx - (cell.offsetX || 0);
            const originY = ty - (cell.offsetY || 0);
            const key = originX + ',' + originY + ',' + li;
            const timer = animPropFrameTimers[key] || { frame: 0 };
            const frameIdx = timer.frame % propData.frames.length;
            const frame = propData.frames[frameIdx];

            // Calculate this tile's portion
            const offsetX = cell.offsetX || 0;
            const offsetY = cell.offsetY || 0;

            // Get split Y for this specific tile within the prop
            const tileKey = offsetX + ',' + offsetY;
            let splitY = null;

            if (typeof propData.splitLine === 'object' && !Array.isArray(propData.splitLine)) {
                // Try per-frame format first: "frameIndex:tileX,tileY"
                const perFrameKey = frameIdx + ':' + tileKey;
                splitY = propData.splitLine[perFrameKey];

                // Fall back to shared format: "tileX,tileY"
                if (splitY === undefined || splitY === null) {
                    splitY = propData.splitLine[tileKey];
                }
            } else if (typeof propData.splitLine === 'number') {
                // Old format: single number (only applies to tile 0,0)
                if (offsetX === 0 && offsetY === 0) splitY = propData.splitLine;
            }

            // If no split for this tile, draw full tile
            if (splitY === null || splitY === undefined) {
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px, py, tileSize, tileSize);
                return;
            }

            // Handle splitY being an array (freeform line) - use minimum for trunk rendering
            let localSplitY;
            if (Array.isArray(splitY)) {
                // Use minimum value for trunk rendering (draw trunk where split is lowest)
                localSplitY = Math.min(...splitY);
            } else {
                localSplitY = splitY;
            }

            // Only draw if split is within this tile
            if (localSplitY <= 0) {
                // Split is above this tile - draw full tile
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px, py, tileSize, tileSize);
            } else if (localSplitY < gridSize) {
                // Split is within this tile - draw only trunk (below split)
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize + localSplitY;
                const srcH = gridSize - localSplitY;
                const destY = py + localSplitY * scale;
                const destH = srcH * scale;

                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, srcH, px, destY, tileSize, destH);
            }
            // If localSplitY >= gridSize, split is below this tile - don't draw trunk here
        }

        function drawTileFull(cell, tx, ty, camX, camY, tileSize) {
            const px = tx * tileSize - camX;
            const py = ty * tileSize - camY;
            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];

            if (cellTileset) {
                ctx.imageSmoothingEnabled = false;
                drawTileWithEffects(ctx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize, cell.rotation || 0, cell.flipped || false);
            }

            // Draw collision overlay if debug enabled
            if (showCollision) {
                const tilesetIdx = cell.tilesetIndex || 0;
                const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                const mask = collisionMasks[key];

                if (mask) {
                    const pixelSize = tileSize / gridSize;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    for (let my = 0; my < gridSize; my++) {
                        for (let mx = 0; mx < gridSize; mx++) {
                            if (mask[my] && mask[my][mx]) {
                                ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                            }
                        }
                    }
                } else if (tileCollisions[key]) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(px, py, tileSize, tileSize);
                }
            }
        }

        function drawTileTrunk(cell, tx, ty, camX, camY, tileSize) {
            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
            const splitData = tileSplitLines[key];
            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
            const isFlipped = tileSplitLineFlipped[key] || false;

            if (!cellTileset || splitData === undefined) return;

            const px = tx * tileSize - camX;
            const py = ty * tileSize - camY;
            const scale = tileSize / gridSize;

            ctx.imageSmoothingEnabled = false;

            // Handle rotation or flip
            const rot = cell.rotation || 0;
            if (rot !== 0 || cell.flipped) {
                // For rotated/flipped tiles, just draw full tile (rotation + split is complex)
                drawTileWithEffects(ctx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize, rot, cell.flipped || false);
                return;
            }

            // Draw trunk using clipping path for freeform line
            ctx.save();
            ctx.beginPath();

            const splitYArray = Array.isArray(splitData) ? splitData : new Array(gridSize).fill(splitData);

            if (isFlipped) {
                // FLIPPED: Trunk is ABOVE the split line (top portion is Y-sorted)
                // Start at top-left, go along top edge
                ctx.moveTo(px, py);
                ctx.lineTo(px + tileSize, py);
                // Go down right edge to last split point
                ctx.lineTo(px + tileSize, py + splitYArray[gridSize - 1] * scale);
                // Draw along the split line (right to left)
                for (let col = gridSize - 1; col >= 0; col--) {
                    const splitY = splitYArray[col];
                    ctx.lineTo(px + (col + 1) * scale, py + splitY * scale);
                    ctx.lineTo(px + col * scale, py + splitY * scale);
                }
                // Close back to top-left
                ctx.lineTo(px, py);
            } else {
                // NORMAL: Trunk is BELOW the split line (bottom portion is Y-sorted)
                // Start at bottom-left, go up the left edge to first split point
                ctx.moveTo(px, py + tileSize);
                ctx.lineTo(px, py + splitYArray[0] * scale);
                // Draw along the split line (left to right)
                for (let col = 0; col < gridSize; col++) {
                    const splitY = splitYArray[col];
                    ctx.lineTo(px + col * scale, py + splitY * scale);
                    ctx.lineTo(px + (col + 1) * scale, py + splitY * scale);
                }
                // Go down right edge and close
                ctx.lineTo(px + tileSize, py + tileSize);
            }
            ctx.closePath();
            ctx.clip();

            // Draw the full tile, clipped to trunk region
            ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tileSize, tileSize);
            ctx.restore();

            // Draw collision overlay if debug enabled
            if (showCollision) {
                const mask = collisionMasks[key];
                if (mask) {
                    const pixelSize = tileSize / gridSize;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    for (let my = 0; my < gridSize; my++) {
                        for (let mx = 0; mx < gridSize; mx++) {
                            if (mask[my] && mask[my][mx]) {
                                ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                            }
                        }
                    }
                } else if (tileCollisions[key]) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(px, py, tileSize, tileSize);
                }
            }
        }

        function drawCanopyOverlay(camX, camY, tileSize) {
            // Draw canopy portions (above split line) for all split tiles
            for (let li = 1; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        const px = x * tileSize - camX;
                        const py = y * tileSize - camY;
                        const scale = tileSize / gridSize;

                        // Skip off-screen
                        if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                        if (cell.type === 'tile') {
                            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
                            const splitData = tileSplitLines[key];
                            if (splitData === undefined || splitData === null) continue;

                            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
                            if (!cellTileset) continue;
                            const isFlipped = tileSplitLineFlipped[key] || false;

                            ctx.imageSmoothingEnabled = false;

                            // Handle rotation
                            const rot = cell.rotation || 0;
                            if (rot !== 0) continue; // Skip rotated tiles (already drawn full in trunk pass)

                            // Draw canopy using clipping path for freeform line
                            ctx.save();
                            ctx.beginPath();

                            const splitYArray = Array.isArray(splitData) ? splitData : new Array(gridSize).fill(splitData);

                            if (isFlipped) {
                                // FLIPPED: Canopy is BELOW the split line (bottom portion covers player)
                                // Start at bottom-left, go up the left edge to first split point
                                ctx.moveTo(px, py + tileSize);
                                ctx.lineTo(px, py + splitYArray[0] * scale);
                                // Draw along the split line (left to right)
                                for (let col = 0; col < gridSize; col++) {
                                    const splitY = splitYArray[col];
                                    ctx.lineTo(px + col * scale, py + splitY * scale);
                                    ctx.lineTo(px + (col + 1) * scale, py + splitY * scale);
                                }
                                // Go down right edge and close
                                ctx.lineTo(px + tileSize, py + tileSize);
                            } else {
                                // NORMAL: Canopy is ABOVE the split line (top portion covers player)
                                // Start at top-left, go along top edge
                                ctx.moveTo(px, py);
                                ctx.lineTo(px + tileSize, py);
                                // Go down right edge to last split point
                                ctx.lineTo(px + tileSize, py + splitYArray[gridSize - 1] * scale);
                                // Draw along the split line (right to left)
                                for (let col = gridSize - 1; col >= 0; col--) {
                                    const splitY = splitYArray[col];
                                    ctx.lineTo(px + (col + 1) * scale, py + splitY * scale);
                                    ctx.lineTo(px + col * scale, py + splitY * scale);
                                }
                                // Go up left edge and close
                                ctx.lineTo(px, py);
                            }
                            ctx.closePath();
                            ctx.clip();

                            // Draw the full tile, clipped to canopy region
                            ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tileSize, tileSize);
                            ctx.restore();

                        } else if (cell.type === 'animTile') {
                            // Animated tile canopy
                            const propData = animatedPropsData[cell.propIndex];
                            const propImg = animPropImages[cell.propIndex];
                            if (!propData || !propImg || !propImg.complete) continue;
                            if (propData.splitLine === null || propData.splitLine === undefined) continue;
                            if (!propData.frames || propData.frames.length === 0) continue;

                            // Get current animation frame
                            const originX = x - (cell.offsetX || 0);
                            const originY = y - (cell.offsetY || 0);
                            const key = originX + ',' + originY + ',' + li;
                            const timer = animPropFrameTimers[key] || { frame: 0 };
                            const frameIdx = timer.frame % propData.frames.length;
                            const frame = propData.frames[frameIdx];

                            const offsetX = cell.offsetX || 0;
                            const offsetY = cell.offsetY || 0;

                            // Get split Y for this specific tile within the prop
                            const tileKey = offsetX + ',' + offsetY;
                            let splitY = null;

                            if (typeof propData.splitLine === 'object' && !Array.isArray(propData.splitLine)) {
                                // Try per-frame format first: "frameIndex:tileX,tileY"
                                const perFrameKey = frameIdx + ':' + tileKey;
                                splitY = propData.splitLine[perFrameKey];

                                // Fall back to shared format: "tileX,tileY"
                                if (splitY === undefined || splitY === null) {
                                    splitY = propData.splitLine[tileKey];
                                }
                            } else if (typeof propData.splitLine === 'number') {
                                // Old format: single number (only applies to tile 0,0)
                                if (offsetX === 0 && offsetY === 0) splitY = propData.splitLine;
                            }

                            // If no split for this tile, skip canopy
                            if (splitY === null || splitY === undefined) continue;

                            // Handle splitY being an array (freeform line) - use maximum for canopy rendering
                            let localSplitY;
                            if (Array.isArray(splitY)) {
                                // Use maximum value for canopy rendering (draw canopy where split is highest)
                                localSplitY = Math.max(...splitY);
                            } else {
                                localSplitY = splitY;
                            }

                            // Only draw canopy if split is within this tile
                            if (localSplitY > 0 && localSplitY < gridSize) {
                                const srcX = frame.x + offsetX * gridSize;
                                const srcY = frame.y + offsetY * gridSize;
                                const srcH = localSplitY;
                                const destH = srcH * scale;

                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(propImg, srcX, srcY, gridSize, srcH, px, py, tileSize, destH);
                            } else if (localSplitY >= gridSize) {
                                // Full tile is canopy (split at bottom)
                                const srcX = frame.x + offsetX * gridSize;
                                const srcY = frame.y + offsetY * gridSize;

                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px, py, tileSize, tileSize);
                            }
                        }
                    }
                }
            }
        }

        // Draw collision debug overlay on top of everything (for split tiles that get covered by canopy)
        function drawCollisionDebugOverlay(camX, camY, tileSize) {
            const pixelSize = tileSize / gridSize;

            // Draw collision for all tiles in all layers (on top of canopy)
            for (let li = 0; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        const px = x * tileSize - camX;
                        const py = y * tileSize - camY;

                        // Skip off-screen
                        if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                        if (cell.type === 'tile') {
                            const tilesetIdx = cell.tilesetIndex || 0;
                            const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                            const mask = collisionMasks[key];

                            if (mask) {
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                for (let my = 0; my < gridSize; my++) {
                                    for (let mx = 0; mx < gridSize; mx++) {
                                        if (mask[my] && mask[my][mx]) {
                                            ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                                        }
                                    }
                                }
                            } else if (tileCollisions[key]) {
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                ctx.fillRect(px, py, tileSize, tileSize);
                            }
                        } else if (cell.type === 'prop') {
                            const propIdx = cell.propIndex || 0;
                            const propKey = cell.x + ',' + cell.y;
                            const mask = propCollisionMasksAll[propIdx] ? propCollisionMasksAll[propIdx][propKey] : null;
                            if (mask) {
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                for (let my = 0; my < gridSize; my++) {
                                    for (let mx = 0; mx < gridSize; mx++) {
                                        if (mask[my] && mask[my][mx]) {
                                            ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Draw static object collision boxes (dark green outline)
            if (placedStaticObjectsData) {
                placedStaticObjectsData.forEach((placed, i) => {
                    if (placed.mapName && placed.mapName !== currentGameMap) return;

                    const obj = staticObjectsData[placed.objIndex];
                    if (!obj) return;

                    const scale = placed.scale || 1;
                    const objPixelX = placed.x * tileSize - camX;
                    const objPixelY = placed.y * tileSize - camY;
                    const objPixelW = obj.width * tileSize * scale;
                    const objPixelH = obj.height * tileSize * scale;

                    // Skip off-screen
                    if (objPixelX + objPixelW < 0 || objPixelX > canvas.width / cameraZoom ||
                        objPixelY + objPixelH < 0 || objPixelY > canvas.height / cameraZoom) return;

                    // Draw dark green collision outline (same as builder)
                    ctx.strokeStyle = '#4a7c59';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(objPixelX, objPixelY, objPixelW, objPixelH);

                    // Also fill with semi-transparent green to show collision area
                    ctx.fillStyle = 'rgba(74, 124, 89, 0.2)';
                    ctx.fillRect(objPixelX, objPixelY, objPixelW, objPixelH);
                });
            }
        }

        function drawPlayer() {
            const camX = Math.round(camera.x);
            const camY = Math.round(camera.y);
            const sx = Math.round(player.x - camX);
            const sy = Math.round(player.y - camY);

            // Use player character animation if available, otherwise use legacy layout
            let srcX = 0, srcY = 0, srcW = playerFrameWidth, srcH = playerFrameHeight;
            let flipX = false;

            if (playerAnimations) {
                // New animation system: use frame data from playerAnimations
                const dirMap = {
                    down: 'walkDown',
                    up: 'walkUp',
                    left: 'walkLeft',
                    right: 'walkRight'
                };
                const idleDirMap = {
                    down: 'idleDown',
                    up: 'idleUp',
                    left: 'idleLeft',
                    right: 'idleRight'
                };
                const attackDirMap = {
                    down: 'attackDown',
                    up: 'attackUp',
                    left: 'attackLeft',
                    right: 'attackRight'
                };
                let animKey;
                let useDeathFrame = false;
                if (playerDying) {
                    // Death animation
                    animKey = 'death';
                    useDeathFrame = true;
                } else if (player.attacking && player.attackAnim) {
                    // Check for directional attack animation
                    const attackKey = attackDirMap[player.direction];
                    if (playerAnimations[attackKey] && playerAnimations[attackKey].length > 0) {
                        animKey = attackKey;
                    } else if (playerAnimations.attack && playerAnimations.attack.length > 0) {
                        // Fall back to generic attack
                        animKey = 'attack';
                    } else {
                        // No attack animation, use walk
                        animKey = dirMap[player.direction];
                    }
                } else if (isReceivingItem && receivingItemData) {
                    // Receive item animation
                    const receiveItemDirMap = {
                        down: 'receiveItemDown',
                        up: 'receiveItemUp',
                        left: 'receiveItemLeft',
                        right: 'receiveItemRight'
                    };
                    const receiveKey = receiveItemDirMap[player.direction];
                    if (playerAnimations[receiveKey] && playerAnimations[receiveKey].length > 0) {
                        animKey = receiveKey;
                    } else if (playerAnimations.receivedItem && playerAnimations.receivedItem.length > 0) {
                        animKey = 'receivedItem';
                    } else {
                        // No receive animation, use idle
                        const dirIdleKey = idleDirMap[player.direction];
                        if (playerAnimations[dirIdleKey] && playerAnimations[dirIdleKey].length > 0) {
                            animKey = dirIdleKey;
                        } else {
                            animKey = 'idle';
                        }
                    }
                } else if (player.moving) {
                    animKey = dirMap[player.direction];
                } else {
                    // Check for directional idle first, then fall back to generic idle
                    const dirIdleKey = idleDirMap[player.direction];
                    if (playerAnimations[dirIdleKey] && playerAnimations[dirIdleKey].length > 0) {
                        animKey = dirIdleKey;
                    } else {
                        animKey = 'idle';
                    }
                }
                let frames = playerAnimations[animKey];

                // Fallback: if no idle frames, use first frame of walkDown
                if (!frames || frames.length === 0) {
                    frames = playerAnimations.walkDown || [];
                }
                // Fallback for left: use right and flip
                if ((!frames || frames.length === 0) && player.direction === 'left') {
                    frames = playerAnimations.walkRight || [];
                    flipX = true;
                }

                let currentSheetIndex = 0;
                if (frames && frames.length > 0) {
                    // Use attackFrame for attack animations, deathAnimFrame for death, receiveItemFrame for receive, otherwise use regular frame
                    let frameIndex;
                    if (useDeathFrame) {
                        frameIndex = Math.min(deathAnimFrame, frames.length - 1);
                    } else if (player.attacking && player.attackAnim) {
                        frameIndex = (player.attackFrame || 0) % frames.length;
                    } else if (isReceivingItem && receivingItemData) {
                        frameIndex = Math.min(receivingItemData.frame || 0, frames.length - 1);
                    } else {
                        frameIndex = player.frame % frames.length;
                    }
                    const frame = frames[frameIndex];
                    srcX = frame.x;
                    srcY = frame.y;
                    srcW = frame.w;
                    srcH = frame.h;
                    currentSheetIndex = frame.sheet || 0;
                }

                // Use the correct sprite sheet for this frame
                if (playerSpriteSheets && playerSpriteSheets[currentSheetIndex]) {
                    playerImg = playerSpriteSheets[currentSheetIndex];
                }

                // Check if this animation should be mirrored (from player editor mirror toggle)
                if (playerAnimMirrors && playerAnimMirrors[animKey]) {
                    flipX = !flipX; // Toggle flip - if already flipping, unflip; if not, flip
                }

                // Handle left direction by mirroring right (fallback if no walkLeft defined)
                if (player.direction === 'left' && (!playerAnimations.walkLeft || playerAnimations.walkLeft.length === 0)) {
                    flipX = true;
                }
            } else {
                // Legacy sprite layout: 1024x512, 16 cols x 8 rows = 64x64 each
                const frameWidth = 64;
                const frameHeight = 64;

                // Idle frames (Row 0)
                const idleFrames = {
                    down: [0, 1, 2],
                    up: [3, 4, 5],
                    right: [6, 7, 8],
                    left: [6, 7, 8]
                };

                // Walk frames
                const walkFrames = {
                    down: { row: 0, cols: [9, 10, 11, 12] },
                    up: { row: 0, cols: [13, 14, 15] },
                    right: { row: 1, cols: [1, 2, 3, 4] },
                    left: { row: 1, cols: [1, 2, 3, 4] }
                };

                let row = 0;
                let col = 0;

                if (player.attacking) {
                    row = walkFrames[player.direction].row;
                    col = walkFrames[player.direction].cols[Math.min(player.frame, walkFrames[player.direction].cols.length - 1)];
                    if (player.direction === 'left') flipX = true;
                } else if (player.moving) {
                    const walk = walkFrames[player.direction];
                    row = walk.row;
                    col = walk.cols[player.frame % walk.cols.length];
                    if (player.direction === 'left') flipX = true;
                } else {
                    row = 0;
                    col = idleFrames[player.direction][player.frame % idleFrames[player.direction].length];
                    if (player.direction === 'left') flipX = true;
                }

                srcX = col * frameWidth;
                srcY = row * frameHeight;
                srcW = frameWidth;
                srcH = frameHeight;
            }

            const drawW = Math.round(playerFrameWidth * playerScale);
            const drawH = Math.round(playerFrameHeight * playerScale);

            // Center sprite on collision box
            // Collision box should cover body from feet to near head
            // Sprite is drawn so collision box aligns with the character body
            const spriteX = sx + player.width / 2 - drawW / 2;
            const spriteY = sy - 15; // shift sprite up so collision box covers body properly

            // Simple ellipse shadow under hero
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(
                spriteX + drawW / 2,
                spriteY + drawH - shadowYOffset,
                drawW * (shadowWidth / 100),
                drawW * (shadowHeight / 100),
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // Invincibility flashing effect - blink every 4 frames
            const shouldDraw = !player.invincible || (Math.floor(player.invincibleTimer / 4) % 2 === 0);

            if (playerImg.complete && shouldDraw) {
                // Tint red briefly when just hit
                if (player.invincible && player.invincibleTimer > 80) {
                    ctx.globalAlpha = 0.7;
                }
                if (flipX) {
                    ctx.save();
                    ctx.translate(spriteX + drawW, spriteY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(playerImg, srcX, srcY, srcW, srcH, 0, 0, drawW, drawH);
                    ctx.restore();
                } else {
                    ctx.drawImage(playerImg, srcX, srcY, srcW, srcH, spriteX, spriteY, drawW, drawH);
                }
                ctx.globalAlpha = 1;
            } else if (!playerImg.complete) {
                ctx.fillStyle = '#4a7';
                ctx.fillRect(sx, sy, player.width, player.height);
            }

            // Draw floating item above player when receiving
            if (isReceivingItem && receivingItemData) {
                const floatX = spriteX + drawW / 2;
                const floatY = spriteY;
                drawFloatingItem(floatX, floatY);
            }

            // Attack effect removed - using attack animation instead

            // DEBUG: Draw collision box (shows actual foot hitbox used for collision)
            if (showCollision) {
                // Always show the small foot hitbox (bottom 1/3)
                const collisionHeight = player.height / 3;
                const collisionOffsetY = player.height * 2/3;

                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.strokeRect(sx, sy + collisionOffsetY, player.width, collisionHeight);

                // Draw center point of collision box
                ctx.fillStyle = '#0f0';
                ctx.beginPath();
                ctx.arc(sx + player.width / 2, sy + collisionOffsetY + collisionHeight / 2, 3, 0, Math.PI * 2);
                ctx.fill();

                // Draw attack hitbox preview (dark blue, always visible in debug)
                const dir = player.direction;
                const hbRange = playerHitboxRange[dir] || 40;
                const hbWidth = playerHitboxWidth[dir] || 60;
                const hbOffX = playerHitboxOffsetX[dir] || 0;
                const hbOffY = playerHitboxOffsetY[dir] || 0;

                if (hbRange > 0) {
                    const range = hbRange * TILE_SCALE;
                    const halfAngle = (hbWidth / 2) * (Math.PI / 180);
                    const dirAngles = { right: 0, down: Math.PI / 2, left: Math.PI, up: -Math.PI / 2 };
                    const baseAngle = dirAngles[dir] || 0;

                    const centerX = sx + player.width / 2 + hbOffX * TILE_SCALE;
                    const centerY = sy + player.height / 2 + hbOffY * TILE_SCALE;

                    // Draw preview cone (dark blue, semi-transparent)
                    ctx.fillStyle = 'rgba(30, 60, 120, 0.3)';
                    ctx.strokeStyle = 'rgba(60, 120, 200, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(
                        centerX + Math.cos(baseAngle - halfAngle) * range,
                        centerY + Math.sin(baseAngle - halfAngle) * range
                    );
                    ctx.arc(centerX, centerY, range, baseAngle - halfAngle, baseAngle + halfAngle);
                    ctx.lineTo(centerX, centerY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw yellow origin dot
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Draw player attack hitbox cone when attacking (magenta - active)
                if (player.attacking && player.attackAnim && hbRange > 0) {
                    const range = hbRange * TILE_SCALE;
                    const halfAngle = (hbWidth / 2) * (Math.PI / 180);
                    const dirAngles = { right: 0, down: Math.PI / 2, left: Math.PI, up: -Math.PI / 2 };
                    const baseAngle = dirAngles[dir] || 0;

                    const centerX = sx + player.width / 2 + hbOffX * TILE_SCALE;
                    const centerY = sy + player.height / 2 + hbOffY * TILE_SCALE;

                    // Draw cone/triangle shape
                    ctx.fillStyle = 'rgba(255, 0, 255, 0.35)';
                    ctx.strokeStyle = 'rgba(255, 0, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    // Left edge of cone
                    ctx.lineTo(
                        centerX + Math.cos(baseAngle - halfAngle) * range,
                        centerY + Math.sin(baseAngle - halfAngle) * range
                    );
                    // Arc at the end of the cone
                    ctx.arc(centerX, centerY, range, baseAngle - halfAngle, baseAngle + halfAngle);
                    // Right edge back to center
                    ctx.lineTo(centerX, centerY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }

        // Draw other multiplayer player
        function drawOtherPlayer(playerId, camX, camY) {
            const other = otherPlayers.get(playerId);
            if (!other) return;

            const sx = Math.round(other.x - camX);
            const sy = Math.round(other.y - camY);
            const dir = other.direction || 'down';

            // Use player character animation if available, otherwise use legacy layout
            let srcX = 0, srcY = 0, srcW = playerFrameWidth, srcH = playerFrameHeight;
            let flipX = false;

            if (playerAnimations) {
                // New animation system
                const dirMap = { down: 'walkDown', up: 'walkUp', left: 'walkLeft', right: 'walkRight' };
                let animKey = other.animation === 'walk' ? dirMap[dir] : 'idle';
                let frames = playerAnimations[animKey];

                if (!frames || frames.length === 0) frames = playerAnimations.walkDown || [];
                if ((!frames || frames.length === 0) && dir === 'left') {
                    frames = playerAnimations.walkRight || [];
                    flipX = true;
                }

                if (frames && frames.length > 0) {
                    const frame = frames[other.frame % frames.length];
                    srcX = frame.x;
                    srcY = frame.y;
                    srcW = frame.w;
                    srcH = frame.h;
                }

                if (dir === 'left' && (!playerAnimations.walkLeft || playerAnimations.walkLeft.length === 0)) {
                    flipX = true;
                }
            } else {
                // Legacy sprite layout
                const frameWidth = 64;
                const frameHeight = 64;

                const idleFrames = {
                    down: [0, 1, 2], up: [3, 4, 5], right: [6, 7, 8], left: [6, 7, 8]
                };
                const walkFrames = {
                    down: { row: 0, cols: [9, 10, 11, 12] },
                    up: { row: 0, cols: [13, 14, 15] },
                    right: { row: 1, cols: [1, 2, 3, 4] },
                    left: { row: 1, cols: [1, 2, 3, 4] }
                };

                let row = 0, col = 0;
                if (other.animation === 'walk') {
                    const walk = walkFrames[dir];
                    row = walk.row;
                    col = walk.cols[other.frame % walk.cols.length];
                    if (dir === 'left') flipX = true;
                } else {
                    row = 0;
                    col = idleFrames[dir][other.frame % idleFrames[dir].length];
                    if (dir === 'left') flipX = true;
                }

                srcX = col * frameWidth;
                srcY = row * frameHeight;
                srcW = frameWidth;
                srcH = frameHeight;
            }

            const drawW = Math.round(playerFrameWidth * playerScale);
            const drawH = Math.round(playerFrameHeight * playerScale);
            const spriteX = sx + player.width / 2 - drawW / 2;
            const spriteY = sy - 15;

            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(spriteX + drawW / 2, spriteY + drawH - shadowYOffset, drawW * 0.2, drawW * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();

            // Draw sprite
            if (playerImg.complete) {
                ctx.save();
                if (flipX) {
                    ctx.translate(spriteX + drawW, spriteY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(playerImg, srcX, srcY, srcW, srcH, 0, 0, drawW, drawH);
                } else {
                    ctx.drawImage(playerImg, srcX, srcY, srcW, srcH, spriteX, spriteY, drawW, drawH);
                }
                ctx.restore();
            }

            // Draw nametag above player
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            const nameWidth = ctx.measureText(other.name).width + 8;
            ctx.fillRect(spriteX + drawW / 2 - nameWidth / 2, spriteY - 18, nameWidth, 14);
            ctx.fillStyle = '#fff';
            ctx.fillText(other.name, spriteX + drawW / 2, spriteY - 8);
        }

        // Draw NPC with correct animation based on direction
        function drawNPC(npcIdx, camX, camY, tileSize) {
            const placed = placedNpcs[npcIdx];
            const state = npcRuntimeState[npcIdx];
            const npc = npcsData[placed.npcIndex];
            const img = npcImages[placed.npcIndex];

            if (!placed || !state || !npc || !img || !img.complete) return;

            // Skip dead enemies
            if (state.dead) return;

            const sx = Math.round(state.x * TILE_SCALE - camX);
            const sy = Math.round(state.y * TILE_SCALE - camY);

            // Get correct animation based on direction or waypoint animation
            const anims = npc.animations || {};
            const dirMap = {
                'down': 'walkDown',
                'up': 'walkUp',
                'left': 'walkLeft',
                'right': 'walkRight'
            };
            const attackDirMap = {
                'down': 'attackDown',
                'up': 'attackUp',
                'left': 'attackLeft',
                'right': 'attackRight'
            };
            // Use waypoint animation if set AND has frames, otherwise use walk/idle based on state
            let animKey;
            let useAttackFrame = false;
            // Check if playing attack animation (enemy attacking)
            if (state.attackAnimTimer > 0 && placed.isEnemy) {
                const attackKey = attackDirMap[state.direction];
                if (anims[attackKey] && anims[attackKey].length > 0) {
                    animKey = attackKey;
                    useAttackFrame = true;
                } else {
                    // No attack anim, use walk anim
                    animKey = dirMap[state.direction];
                }
            } else if (state.waypointAnimation && state.waypointAnimation !== 'walk' &&
                anims[state.waypointAnimation] && anims[state.waypointAnimation].length > 0) {
                animKey = state.waypointAnimation;
            } else {
                animKey = state.moving ? dirMap[state.direction] : 'idle';
            }
            let anim = anims[animKey];

            // Fallback to any available animation
            if (!anim || anim.length === 0) {
                anim = (anims.walkDown?.length > 0 ? anims.walkDown : null) ||
                       (anims.idle?.length > 0 ? anims.idle : null) ||
                       Object.values(anims).find(a => a && a.length > 0);
            }
            if (!anim || anim.length === 0) return;

            // Get current frame (use attack frame counter for attack anims)
            let frameIdx;
            if (useAttackFrame) {
                // Attack anims cycle through frames based on attack timer
                const attackAnimSpeed = Math.floor(30 / Math.max(anim.length, 1));
                frameIdx = Math.min(Math.floor(state.attackAnimFrame / Math.max(attackAnimSpeed, 1)), anim.length - 1);
            } else {
                frameIdx = state.frame % anim.length;
            }
            const frame = anim[frameIdx];
            if (!frame) return;

            // Apply NPC scale (default 1.0)
            const npcScale = placed.scale || 1;
            const drawW = tileSize * npcScale;
            const drawH = tileSize * npcScale;

            // Adjust position so NPC is centered and feet stay on ground
            const offsetX = (drawW - tileSize) / 2;
            const offsetY = drawH - tileSize; // Bottom-aligned
            const drawX = sx - offsetX;
            const drawY = sy - offsetY;

            // Draw shadow (scales with NPC, uses per-NPC shadow settings)
            const shadowOffsetX = npc.shadowOffsetX ?? 0;
            const shadowOffsetY = npc.shadowOffsetY ?? 4;
            const shadowWidthRatio = npc.shadowWidth ?? 0.35;
            const shadowHeightRatio = npc.shadowHeight ?? 0.12;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(
                drawX + drawW / 2 + shadowOffsetX,
                drawY + drawH - shadowOffsetY,
                drawW * shadowWidthRatio,
                drawW * shadowHeightRatio,
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // Handle horizontal flip - either for left fallback OR if animation is marked as mirrored
            const animMirrors = npc.animMirrors || {};
            const isMirrored = animMirrors[animKey];
            const flipX = isMirrored || (state.direction === 'left' && !anims.walkLeft?.length);

            // Blink effect when NPC takes damage (skip drawing on odd frames)
            if (state.hitFlash > 0) {
                state.hitFlash--;
                if (Math.floor(state.hitFlash / 2) % 2 === 1) {
                    return; // Skip drawing this frame - creates blink effect
                }
            }

            if (flipX) {
                ctx.save();
                ctx.translate(drawX + drawW, drawY);
                ctx.scale(-1, 1);
                ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, drawW, drawH);
                ctx.restore();
            } else {
                ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);
            }

            // DEBUG: Draw NPC collision/hurtbox when C is pressed (cyan overlay)
            if (showCollision) {
                // Use collision insets if defined (shrink from each edge)
                const insets = npc.collisionInsets;
                if (insets && (insets.top > 0 || insets.bottom > 0 || insets.left > 0 || insets.right > 0)) {
                    const frameW = frame.w || npc.frameWidth || 32;
                    const pixelScale = drawW / frameW;
                    const boxX = drawX + insets.left * pixelScale;
                    const boxY = drawY + insets.top * pixelScale;
                    const boxW = drawW - (insets.left + insets.right) * pixelScale;
                    const boxH = drawH - (insets.top + insets.bottom) * pixelScale;
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.4)';
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    ctx.fillRect(boxX, boxY, boxW, boxH);
                    ctx.strokeRect(boxX, boxY, boxW, boxH);
                } else {
                    // No insets - draw cyan bounding box around full sprite
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.4)';
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    ctx.fillRect(drawX, drawY, drawW, drawH);
                    ctx.strokeRect(drawX, drawY, drawW, drawH);
                }

                // Draw enemy health bar
                if (placed.isEnemy && state && state.hp !== undefined) {
                    const barWidth = drawW * 0.8;
                    const barHeight = 6;
                    const barX = drawX + (drawW - barWidth) / 2;
                    const barY = drawY - 12;
                    const hpPercent = Math.max(0, state.hp / (state.maxHp || 30));

                    // Background (dark)
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2);

                    // Health bar background (red)
                    ctx.fillStyle = '#400';
                    ctx.fillRect(barX, barY, barWidth, barHeight);

                    // Health bar fill (green to red gradient based on HP)
                    const hpColor = hpPercent > 0.5 ? '#0f0' : (hpPercent > 0.25 ? '#ff0' : '#f00');
                    ctx.fillStyle = hpColor;
                    ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

                    // HP text
                    ctx.fillStyle = '#fff';
                    ctx.font = '8px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(Math.ceil(state.hp) + '/' + (state.maxHp || 30), drawX + drawW / 2, barY - 2);
                }
            }

            // Draw quest indicator icon above NPC
            const questIndicator = getQuestIndicatorForNpc(placed);
            if (questIndicator) {
                const iconX = drawX + drawW / 2;
                const iconY = drawY - 20;

                // Floating animation
                const bobOffset = Math.sin(Date.now() / 300) * 3;

                // Draw icon background glow
                ctx.beginPath();
                ctx.arc(iconX, iconY + bobOffset, 12, 0, Math.PI * 2);
                ctx.fillStyle = questIndicator.glowColor;
                ctx.fill();

                // Draw icon
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = questIndicator.color;
                ctx.fillText(questIndicator.symbol, iconX, iconY + bobOffset);
            }
        }

        // Get quest indicator for an NPC (! = available, ? = can turn in)
        function getQuestIndicatorForNpc(npc) {
            if (!npc.uid || !questsData) return null;

            for (const quest of questsData) {
                const state = gameProgress.questStates[quest.id];
                if (!state) continue;

                // Quest giver with available quest - yellow !
                if (quest.startNpcUid === npc.uid && state.status === QUEST_STATUS.AVAILABLE) {
                    return { symbol: '!', color: '#FFD700', glowColor: 'rgba(255, 215, 0, 0.4)' };
                }

                // Turn-in NPC with completable quest - yellow ?
                const turnInNpc = quest.turnInNpcUid || quest.startNpcUid;
                if (turnInNpc === npc.uid && state.status === QUEST_STATUS.ACTIVE) {
                    if (areAllConditionsMet(quest)) {
                        return { symbol: '?', color: '#FFD700', glowColor: 'rgba(255, 215, 0, 0.4)' };
                    } else if (quest.startNpcUid === npc.uid) {
                        // Quest giver for active quest (reminder) - gray ?
                        return { symbol: '?', color: '#888888', glowColor: 'rgba(136, 136, 136, 0.3)' };
                    }
                }
            }

            return null;
        }

        // Draw a placed item (simple sprite - disappears when picked up)
        function drawItem(itemIdx, camX, camY, tileSize) {
            const placed = placedItemsData[itemIdx];
            if (!placed) return;

            const state = itemStates[itemIdx];
            if (!state || state.used) return; // Don't draw used/picked up items

            const item = itemsData[placed.itemIndex];
            if (!item || !item.frames || item.frames.length === 0) return;

            const img = itemImages[placed.itemIndex];
            if (!img || !img.complete) return;

            // Always show first frame (simple static item on map)
            const frame = item.frames[0];

            // Draw position
            const drawX = placed.x * tileSize - camX;
            const drawY = placed.y * tileSize - camY;
            const drawW = (item.frameWidth / gridSize) * tileSize;
            const drawH = (item.frameHeight / gridSize) * tileSize;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);
        }

        function drawStaticObject(placedIdx, camX, camY, tileSize) {
            const placed = placedStaticObjectsData[placedIdx];
            if (!placed) return;

            const obj = staticObjectsData[placed.objIndex];
            if (!obj) return;

            const img = staticObjectImages[placed.objIndex];
            if (!img || !img.complete) return;

            // Object dimensions in pixels
            const objW = obj.width * gridSize;
            const objH = obj.height * gridSize;

            // Scale factor (like items)
            const scale = placed.scale || 1;

            // Draw position
            const drawX = placed.x * tileSize - camX;
            const drawY = placed.y * tileSize - camY;
            const drawW = (objW / gridSize) * tileSize * scale;
            const drawH = (objH / gridSize) * tileSize * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(img, 0, 0, objW, objH, drawX, drawY, drawW, drawH);
        }

        let lastFrameTime = 0;
        let perfUpdateCounter = 0;
        function gameLoop(timestamp) {
            if (!timestamp) timestamp = performance.now();
            const deltaTime = lastFrameTime ? timestamp - lastFrameTime : 16.67;
            lastFrameTime = timestamp;

            // Log frame time for network recording (outside perf panel check)
            const currentFps = deltaTime > 0 ? Math.round(1000 / deltaTime) : 60;
            if (networkRecording) logFrameTime(deltaTime, currentFps);

            // Update performance panel
            if (perfPanelVisible) {
                perfUpdateCounter++;
                fpsHistory.push(currentFps);
                if (fpsHistory.length > FPS_HISTORY_SIZE) fpsHistory.shift();

                // Update display every 10 frames for performance
                if (perfUpdateCounter % 10 === 0) {
                    const avgFps = Math.round(fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length);
                    const fpsEl = document.getElementById('perfFPS');
                    fpsEl.textContent = avgFps;
                    fpsEl.className = 'perf-value' + (avgFps < 30 ? ' critical' : avgFps < 50 ? ' warning' : '');

                    const frameTimeEl = document.getElementById('perfFrameTime');
                    frameTimeEl.textContent = deltaTime.toFixed(1) + 'ms';
                    frameTimeEl.className = 'perf-value' + (deltaTime > 33 ? ' critical' : deltaTime > 20 ? ' warning' : '');

                    document.getElementById('perfNPCs').textContent = placedNpcs ? placedNpcs.length : 0;
                    document.getElementById('perfTriggers').textContent = placedTriggers ? placedTriggers.length : 0;
                    document.getElementById('perfLights').textContent = pointLights ? Object.keys(pointLights).length : 0;
                    document.getElementById('perfLayers').textContent = layers ? layers.length : 0;

                    // Update FPS graph
                    const bars = document.querySelectorAll('#fpsGraph .fps-bar');
                    fpsHistory.forEach((fps, i) => {
                        if (bars[i]) {
                            const height = Math.min(30, (fps / 60) * 30);
                            bars[i].style.height = height + 'px';
                            bars[i].style.background = fps < 30 ? '#f44' : fps < 50 ? '#fa4' : '#4f8';
                        }
                    });
                }
            }

            updateDayCycle();
            updateDeathAnimation();
            updateTransition(deltaTime);

            // Dialog cooldown
            if (dialogCooldown > 0) dialogCooldown--;

            if (!isTransitioning || transitionPhase === 'fadeIn' || transitionPhase === 'forceWalk') {
                // Allow player to be visible during forced walk but don't allow input
                // Don't update if player is dying or game over
                if (transitionPhase !== 'forceWalk' && !playerDying && !gameOverShown) {
                    update();
                }
                // Check for walkover triggers after movement (but not during forced walk)
                if (transitionPhase !== 'forceWalk' && !playerDying && !gameOverShown) {
                    checkWalkoverTriggers();
                    // Check for auto-trigger dialogs (NPCs with auto trigger)
                    checkAutoDialogs();
                    // Track player tile for quest location conditions
                    checkPlayerTileForQuests();
                }
                // Update item animations
                updateItemAnimations();
                // Update interactive animated prop animations
                updateAnimPropInteractions();
                // Update receive item animation
                updateReceiveItemAnimation();
            }
            draw();
            drawTransitionOverlay();
            requestAnimationFrame(gameLoop);
        }

        // Game loop is started when all tilesets load (see tileset loading code above)
        } // end initGame()
    <\/script>
</body>
</html>
            `;

            // Open test game window and write HTML directly
            // Data is streamed via postMessage after the page loads (prevents iPad memory crash)
            const testWindow = window.open('', '_blank');
            if (testWindow) {
                testWindow.document.write(loaderHTML);
                testWindow.document.close();
                testGameWindow = testWindow; // Store reference for live sync
                logTestEvent('Test window opened (live sync enabled)');
            } else {
                logTestEvent('Failed to open test window - popup blocked?', 'error');
                alert('Could not open test window. Please allow popups for this site.');
            }
        }

        // Stream sounds via postMessage (called when test game signals ready)
        function streamSoundsToWindow(targetWindow, sounds) {
            logTestEvent('Starting to stream ' + sounds.length + ' sounds...');
            let index = 0;

            function sendNext() {
                if (index >= sounds.length) {
                    logTestEvent('All sounds streamed');
                    targetWindow.postMessage({ type: 'sounds-complete' }, '*');
                    return;
                }

                const sound = sounds[index];
                logTestEvent('Streaming sound ' + (index + 1) + '/' + sounds.length + ': ' + sound.name);
                targetWindow.postMessage({
                    type: 'sound-data',
                    index: index,
                    data: sound.data,
                    name: sound.name
                }, '*');

                index++;
                // Delay between sounds to let iPad breathe
                setTimeout(sendNext, 500);
            }

            sendNext();
        }
    </script>
</body>
</html>
