<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>World Builder</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        /* Phase screens */
        .phase { display: none; height: 100vh; }
        .phase.active { display: flex; }

        /* LOAD PHASE */
        #loadPhase {
            justify-content: center;
            align-items: center;
        }

        .load-box {
            text-align: center;
            padding: 40px;
            border: 2px dashed #555;
            border-radius: 15px;
            background: #2a2a4e;
        }

        .load-box h1 { color: #4af; margin-bottom: 10px; }
        .load-box p { color: #888; margin-bottom: 20px; }

        /* COLLISION PHASE */
        #collisionPhase {
            flex-direction: column;
        }

        .collision-header {
            background: #2a2a4e;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #4af;
        }

        .collision-header h2 { color: #4af; }

        .collision-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .collision-sidebar {
            width: 280px;
            background: #2a2a4e;
            padding: 15px;
            overflow-y: auto;
        }

        .collision-main {
            flex: 1;
            overflow: auto;
            padding: 20px;
            background: #111;
        }

        #collisionTilesetCanvas {
            cursor: crosshair;
            image-rendering: pixelated;
            border: 2px solid #555;
        }

        .tool-buttons {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .tool-buttons button.active {
            background: #4af;
            color: #000;
        }

        /* BUILD PHASE */
        #buildPhase {
            flex-direction: row;
        }

        .panel {
            background: #2a2a4e;
            padding: 15px;
            overflow-y: auto;
        }

        .left-panel { width: 320px; }

        .map-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .toolbar {
            padding: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            background: #2a2a4e;
            flex-wrap: wrap;
        }

        .map-viewport {
            flex: 1;
            overflow: auto;
            background: #111;
            padding: 40px;
            position: relative;
        }

        #mapCanvas {
            border: 2px solid #555;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        #mapCanvas.grabbing {
            cursor: grab;
        }

        #mapCanvas.grabbing:active {
            cursor: grabbing;
        }

        /* Expand buttons */
        .expand-btn {
            position: absolute;
            background: #4a7c59;
            color: white;
            border: none;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.6;
            z-index: 10;
            padding: 0;
        }

        .expand-btn:hover {
            opacity: 1;
            background: #5a9c69;
        }

        .expand-top {
            top: 10px;
            width: 60px;
            height: 25px;
        }

        .expand-bottom {
            width: 60px;
            height: 25px;
        }

        .expand-left {
            left: 10px;
            width: 25px;
            height: 60px;
        }

        .expand-right {
            width: 25px;
            height: 60px;
        }

        /* Common */
        button {
            background: #4a7c59;
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover { background: #5a9c69; }
        button.danger { background: #a55; }
        button.primary { background: #4af; color: #000; }

        h2 { color: #4af; font-size: 14px; margin: 15px 0 8px; }
        h3 { color: #8af; font-size: 12px; margin: 10px 0 5px; }

        input[type="file"] { display: none; }

        select, input[type="text"] {
            padding: 6px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }

        .info {
            color: #888;
            font-size: 11px;
            padding: 10px;
            background: #1a1a3e;
            border-radius: 5px;
            margin: 10px 0;
        }

        .tileset-container {
            background: #111;
            padding: 5px;
            border-radius: 5px;
            overflow: auto;
            max-height: 300px;
        }

        #paintTilesetCanvas {
            cursor: crosshair;
            image-rendering: pixelated;
            border: 1px solid #444;
        }

        .selected-preview {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            margin: 10px 0;
        }

        .selected-preview canvas {
            border: 2px solid #0f0;
            image-rendering: pixelated;
        }

        .mode-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .mode-tabs button { flex: 1; }
        .mode-tabs button.active { background: #4af; color: #000; }

        .prop-item {
            background: #333;
            padding: 8px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 11px;
        }

        .prop-item .name { color: #4af; font-weight: bold; }

        .state-picker {
            position: fixed;
            background: #2a2a4e;
            border: 2px solid #4af;
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            display: none;
        }

        .state-picker.visible { display: block; }

        .state-option {
            padding: 8px 12px;
            margin: 3px 0;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
        }

        .state-option:hover { background: #444; }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .zoom-controls button { padding: 4px 10px; }
        .zoom-controls span { color: #888; font-size: 12px; min-width: 30px; text-align: center; }

        .toolbar span { color: #888; font-size: 11px; }

        /* Animated Prop Editor Modal */
        .anim-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
        }
        .anim-modal.visible { display: flex; }

        .anim-modal-content {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .anim-sidebar {
            width: 280px;
            background: #2a2a4e;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #4af;
        }

        .anim-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1a1a2e;
            overflow: hidden;
            min-width: 0;
        }

        .anim-header {
            padding: 15px 20px;
            background: #2a2a4e;
            border-bottom: 2px solid #4af;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .anim-header h2 { color: #4af; margin: 0; }

        .anim-canvas-area {
            flex: 1;
            overflow: auto;
            padding: 20px;
            display: block;
            min-height: 0;
        }

        .anim-canvas-area canvas {
            border: 2px solid #555;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .anim-frames-bar {
            background: #2a2a4e;
            padding: 15px 20px;
            border-top: 2px solid #4af;
        }

        .anim-frames-list {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            min-height: 50px;
            background: #111;
            padding: 10px;
            border-radius: 5px;
        }

        .anim-frame-thumb {
            border: 2px solid #4af;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .anim-frame-thumb:hover { border-color: #fff; }

        .anim-frame-thumb .frame-num {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0,0,0,0.8);
            color: #4af;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <!-- PHASE 1: LOAD -->
    <div id="loadPhase" class="phase active">
        <div class="load-box">
            <h1>World Builder</h1>
            <p>Load a tileset to begin</p>
            <input type="file" id="fileInput" accept="image/*" onchange="loadTileset(event)">
            <button onclick="document.getElementById('fileInput').click()" style="padding:15px 30px; font-size:14px;">Load Tileset</button>
            <br><br>
            <button onclick="console.log('Button clicked'); loadProject();" style="background:#555;">Load Saved Project</button>
            <button onclick="document.getElementById('projectFileInputWelcome').click()" style="background:#2a7;">Load From File</button>
            <input type="file" id="projectFileInputWelcome" accept=".json" style="display:none;" onchange="uploadProject(event)">
        </div>
    </div>

    <!-- PHASE 2: COLLISION SETUP -->
    <div id="collisionPhase" class="phase">
        <div class="collision-header">
            <div>
                <h2>Step 1: Define Collision</h2>
                <span style="color:#888; font-size:12px;">Paint collision on tiles with brush</span>
            </div>
            <div>
                <label style="color:#aaa; margin-right:10px;">Tile Size:</label>
                <select id="gridSize" onchange="rebuildCollisionView()">
                    <option value="16" selected>16x16</option>
                    <option value="32">32x32</option>
                </select>
                <button onclick="finishCollisionSetup()" class="primary" style="margin-left:20px; padding:10px 25px;">
                    Done - Start Building →
                </button>
            </div>
        </div>
        <div class="collision-body">
            <div class="collision-sidebar">
                <div class="info">
                    <strong>Simple Tile Collision:</strong><br>
                    Left-click: Add collision<br>
                    Right-click: Remove collision<br>
                    Drag to paint multiple tiles
                </div>

                <h3>Tool</h3>
                <div class="tool-buttons">
                    <button id="collisionToolPaint" class="active" onclick="setCollisionTool('paint')">Add Collision</button>
                    <button id="collisionToolErase" onclick="setCollisionTool('erase')">Remove</button>
                    <button id="collisionToolSplit" onclick="setCollisionTool('split')" style="background:#0aa;">Depth Split</button>
                </div>

                <div id="splitControls" style="display:none; margin:10px 0; padding:10px; background:#1a3a3e; border-radius:5px;">
                    <div style="font-size:11px; color:#0ff; margin-bottom:5px;">Draw split line on tiles (drag to draw)</div>
                    <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                        <label style="font-size:11px; display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="checkbox" id="flatLineToggle" checked onchange="toggleFlatLineMode()">
                            <span>Flat Line</span>
                        </label>
                        <span style="font-size:11px;">Y:</span>
                        <input type="number" id="splitYInput" value="8" min="0" max="16" style="width:50px; padding:3px;">
                        <button onclick="setSplitLineY()" style="padding:3px 8px; font-size:10px; background:#0aa;">Set Y</button>
                        <button onclick="clearSelectedSplit()" style="padding:3px 8px; font-size:10px; background:#a55;">Clear</button>
                    </div>
                    <div style="font-size:10px; color:#888; margin-top:5px;">C = Canopy (top) | T = Trunk (bottom, Y-sorted with player)</div>
                </div>

                <h3>Brush Size (pixels)</h3>
                <div class="tool-buttons">
                    <button id="brush2" onclick="setBrushSize(2)">2</button>
                    <button id="brush4" class="active" onclick="setBrushSize(4)">4</button>
                    <button id="brush8" onclick="setBrushSize(8)">8</button>
                    <button id="brush16" onclick="setBrushSize(16)">16</button>
                </div>

                <h3>Zoom (Q/E or +/-)</h3>
                <div class="tool-buttons">
                    <button onclick="setCollisionZoom(2)">2x</button>
                    <button onclick="setCollisionZoom(4)">4x</button>
                    <button id="collisionZoom8" class="active" onclick="setCollisionZoom(6)">6x</button>
                    <button onclick="setCollisionZoom(8)">8x</button>
                </div>
                <div style="font-size:10px; color:#666; margin-top:5px;">Middle-click drag or Shift+drag to pan</div>

                <h3>Quick Actions</h3>
                <div class="tool-buttons">
                    <button onclick="selectAllCollision()">All Solid</button>
                    <button onclick="clearAllCollision()" class="danger">Clear All</button>
                </div>

                <h3 style="margin-top:20px;">Stats</h3>
                <div id="collisionStats" style="background:#111; padding:10px; border-radius:5px; font-size:12px; color:#888;">
                    0 tiles with collision
                </div>
            </div>

            <div class="collision-main">
                <canvas id="collisionTilesetCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- PHASE 3: BUILD -->
    <div id="buildPhase" class="phase">
        <div class="panel left-panel">
            <div class="mode-tabs">
                <button id="tileMode" class="active" onclick="setMode('tile')">Tiles</button>
                <button id="propMode" onclick="setMode('prop')">Props</button>
                <button id="animPropMode" onclick="setMode('animProp')">Animated</button>
            </div>

            <!-- TILE MODE -->
            <div id="tileModeContent">
                <h3>Selected Tile</h3>
                <div class="selected-preview" id="selectedPreview" style="display:none;">
                    <canvas id="selectedTile" width="48" height="48"></canvas>
                    <div>
                        <div id="selectedInfo">No tile</div>
                        <div id="selectedCollisionInfo" style="color:#888; font-size:10px;">No collision</div>
                    </div>
                </div>

                <h3>Rotation (R key)</h3>
                <div class="tool-buttons">
                    <button id="rot0" class="active" onclick="setRotation(0)">0°</button>
                    <button id="rot90" onclick="setRotation(90)">90°</button>
                    <button id="rot180" onclick="setRotation(180)">180°</button>
                    <button id="rot270" onclick="setRotation(270)">270°</button>
                </div>

                <h3>Tileset</h3>
                <div style="display:flex; gap:5px; margin-bottom:5px; align-items:center;">
                    <select id="tilesetSelect" onchange="switchTileset()" style="flex:1;"></select>
                    <input type="file" id="addTilesetInput" accept="image/*" onchange="addTileset(event)" style="display:none;">
                    <button onclick="document.getElementById('addTilesetInput').click()" style="padding:5px 10px;" title="Add tileset">+</button>
                    <button onclick="deleteTileset()" style="padding:5px 10px; background:#a55;" title="Delete tileset">×</button>
                </div>
                <div class="tileset-container">
                    <canvas id="paintTilesetCanvas"></canvas>
                </div>

                <div style="margin-top:10px;">
                    <button id="copyFromMapBtn" onclick="startCopyFromMap()" style="background:#666;">Copy from Map</button>
                    <span id="copyModeInfo" style="display:none; font-size:11px; color:#4af; margin-left:8px;">Click & drag on map to select area</span>
                </div>

                <button onclick="goBackToCollision()" style="margin-top:15px; background:#555;">Edit Tile Collisions</button>

                <h3 style="margin-top:15px;">Layers</h3>
                <div id="layerList"></div>
                <button onclick="addLayer()" style="margin-top:5px;">+ Add Layer</button>
            </div>

            <!-- PROP MODE - Multiple props support -->
            <div id="propModeContent" style="display:none;">
                <h3>Props</h3>

                <div style="display:flex; gap:5px; margin-bottom:10px; align-items:center;">
                    <select id="propSelect" onchange="switchProp()" style="flex:1;"></select>
                    <input type="file" id="propImageInput" accept="image/*" onchange="loadPropImage(event)" style="display:none;">
                    <button onclick="document.getElementById('propImageInput').click()" style="padding:5px 10px;" title="Add New Prop">+</button>
                </div>

                <div id="propControls" style="display:none;">
                    <div style="margin:10px 0;">
                        <button id="propToolSelect" class="active" onclick="setPropTool('select')" style="padding:5px 10px;">Select</button>
                        <button id="propToolCollision" onclick="setPropTool('collision')" style="padding:5px 10px;">Paint Collision</button>
                        <button id="propToolErase" onclick="setPropTool('erase')" style="padding:5px 10px;">Erase Collision</button>
                    </div>

                    <div id="propBrushControls" style="display:none; margin:5px 0;">
                        <span style="font-size:11px; color:#888;">Brush:</span>
                        <button id="propBrush2" onclick="setPropBrushSize(2)" style="padding:3px 8px;">2</button>
                        <button id="propBrush4" class="active" onclick="setPropBrushSize(4)" style="padding:3px 8px;">4</button>
                        <button id="propBrush8" onclick="setPropBrushSize(8)" style="padding:3px 8px;">8</button>
                        <button id="propBrush16" onclick="setPropBrushSize(16)" style="padding:3px 8px;">16</button>
                    </div>

                    <div style="background:#111; padding:5px; border-radius:5px; margin-top:10px; max-height:400px; overflow:auto;">
                        <canvas id="propTilesetCanvas" style="cursor:crosshair;"></canvas>
                    </div>

                    <p style="font-size:10px; color:#666; margin-top:10px;">Select: click to pick tiles | Collision: paint red collision areas | Then paint props on map</p>
                </div>

                <div id="noPropMessage" style="color:#888; font-size:12px; padding:20px; text-align:center;">
                    Click + to add a prop image
                </div>
            </div>

            <!-- ANIMATED PROPS MODE -->
            <div id="animPropModeContent" style="display:none;">
                <h3>Animated Props</h3>

                <!-- Animated Prop List -->
                <div id="animPropListContainer">
                    <div id="animPropList" style="margin-bottom:10px;"></div>
                    <button onclick="openAnimPropEditor()" style="width:100%;">+ Create Animated Prop</button>
                </div>

                <p style="font-size:10px; color:#666; margin-top:10px;">Select prop from list, then click map to place. Right-click to remove.</p>

                <h3 style="margin-top:15px;">Layers</h3>
                <div id="animPropLayerList"></div>
                <button onclick="addLayer()" style="margin-top:5px;">+ Add Layer</button>
            </div>
        </div>

        <div class="map-panel">
            <div class="toolbar">
                <button onclick="undo()" id="undoBtn" title="Undo (Ctrl+Z)" style="background:#555;">↶ Undo</button>
                <button onclick="redo()" id="redoBtn" title="Redo (Ctrl+Y)" style="background:#555;">↷ Redo</button>
                <button onclick="clearMap()">Clear</button>
                <button onclick="saveProject()">Quick Save</button>
                <button onclick="downloadProject()" style="background:#2a7;">Download File</button>
                <button onclick="document.getElementById('projectFileInput').click()" style="background:#555;">Load File</button>
                <input type="file" id="projectFileInput" accept=".json" style="display:none;" onchange="uploadProject(event)">
                <button onclick="exportConfig()">Export</button>
                <button onclick="testMap()" style="background:#e74c3c;">Test Map</button>
                <button id="grabToolBtn" onclick="toggleGrabTool()" style="background:#555;">✋ Grab</button>
                <div class="zoom-controls">
                    <button onclick="zoomOut()">-</button>
                    <span id="zoomLevel">2x</span>
                    <button onclick="zoomIn()">+</button>
                </div>
                <span id="toolHint">Left: paint | Right: erase</span>
            </div>
            <div class="map-viewport" id="mapViewport">
                <!-- Expand buttons -->
                <button class="expand-btn expand-top" onclick="expandMap('top')" title="Expand up">+</button>
                <button class="expand-btn expand-bottom" onclick="expandMap('bottom')" title="Expand down">+</button>
                <button class="expand-btn expand-left" onclick="expandMap('left')" title="Expand left">+</button>
                <button class="expand-btn expand-right" onclick="expandMap('right')" title="Expand right">+</button>
                <canvas id="mapCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- State picker popup -->
    <div class="state-picker" id="statePicker">
        <h3 style="margin-bottom:10px;">Select State</h3>
        <div id="stateOptions"></div>
    </div>

    <!-- Animated Prop Editor Modal -->
    <div class="anim-modal" id="animPropModal">
        <div class="anim-modal-content">
            <!-- Sidebar -->
            <div class="anim-sidebar">
                <h2 style="margin-top:0;">Animated Prop</h2>

                <!-- Step 1: Load Sprite Sheet -->
                <div style="margin-bottom:20px;">
                    <h3>1. Sprite Sheet</h3>
                    <input type="file" id="animPropFileInput" accept="image/*" onchange="animPropLoadSheet(event)">
                    <button onclick="document.getElementById('animPropFileInput').click()" style="width:100%;">Load Image</button>
                    <div id="animPropFileName" style="font-size:11px; color:#4af; margin-top:5px;"></div>
                </div>

                <!-- Step 2: Frame Size -->
                <div id="animPropFrameSection" style="margin-bottom:20px; display:none;">
                    <h3>2. Frame Size</h3>
                    <div style="display:flex; gap:10px; margin-bottom:10px;">
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Width:</label>
                            <input type="number" id="animPropFrameW" value="16" min="8" max="256" onchange="animPropUpdateGrid()" style="width:100%;">
                        </div>
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Height:</label>
                            <input type="number" id="animPropFrameH" value="16" min="8" max="256" onchange="animPropUpdateGrid()" style="width:100%;">
                        </div>
                    </div>
                    <div style="font-size:11px; color:#888;" id="animPropGridInfo"></div>
                </div>

                <!-- Step 3: Animation Type -->
                <div id="animPropTypeSection" style="margin-bottom:20px; display:none;">
                    <h3>3. Animation Type</h3>
                    <select id="animPropType" style="width:100%;" onchange="animPropTypeChanged()">
                        <option value="loop">Loop (continuous)</option>
                        <option value="interactive">Interactive (on trigger)</option>
                    </select>
                    <p style="font-size:10px; color:#666; margin-top:5px;">Adjust speed with slider in preview below</p>
                </div>

                <!-- Step 4: Collision & Depth -->
                <div id="animPropCollisionSection" style="margin-bottom:20px; display:none;">
                    <h3>4. Collision & Depth</h3>
                    <div style="display:flex; gap:5px; flex-wrap:wrap; margin-bottom:10px;">
                        <button id="animPropToolNone" class="active" onclick="setAnimPropTool('none')" style="padding:5px 8px; font-size:11px;">Select</button>
                        <button id="animPropToolCollision" onclick="setAnimPropTool('collision')" style="padding:5px 8px; font-size:11px; background:#a55;">Collision</button>
                        <button id="animPropToolErase" onclick="setAnimPropTool('erase')" style="padding:5px 8px; font-size:11px;">Erase</button>
                        <button id="animPropToolSplit" onclick="setAnimPropTool('split')" style="padding:5px 8px; font-size:11px; background:#0aa;">Split</button>
                    </div>

                    <!-- Brush Size for Collision -->
                    <div id="animPropBrushSection" style="display:none; margin-bottom:10px;">
                        <span style="font-size:10px; color:#aaa;">Brush:</span>
                        <button id="animPropBrush1" onclick="setAnimPropBrush(1)" style="padding:3px 6px; font-size:10px;">1</button>
                        <button id="animPropBrush2" onclick="setAnimPropBrush(2)" style="padding:3px 6px; font-size:10px;">2</button>
                        <button id="animPropBrush4" class="active" onclick="setAnimPropBrush(4)" style="padding:3px 6px; font-size:10px;">4</button>
                        <button id="animPropBrush8" onclick="setAnimPropBrush(8)" style="padding:3px 6px; font-size:10px;">8</button>
                    </div>

                    <!-- Split Controls -->
                    <div id="animPropSplitControls" style="display:none; margin-bottom:10px; padding:8px; background:#1a3a3e; border-radius:5px;">
                        <div style="font-size:10px; color:#0ff; margin-bottom:5px;">Draw split line on tiles (drag to draw)</div>
                        <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                            <label style="font-size:10px; display:flex; align-items:center; gap:4px; cursor:pointer;">
                                <input type="checkbox" id="animPropFlatLine" checked>
                                <span>Flat Line</span>
                            </label>
                            <span style="font-size:10px;">Y:</span>
                            <input type="number" id="animPropSplitY" value="8" min="0" max="16" style="width:40px; padding:2px; font-size:10px;">
                            <button onclick="setAnimPropSplitY()" style="padding:2px 6px; font-size:9px; background:#0aa;">Set Y</button>
                            <button onclick="clearAnimPropSplit()" style="padding:2px 6px; font-size:9px; background:#a55;">Clear</button>
                        </div>
                        <div style="font-size:9px; color:#888; margin-top:4px;">C = Canopy (top) | T = Trunk (Y-sorted)</div>
                    </div>

                    <p style="font-size:10px; color:#666;">Paint on any frame. Collision/split data applies to all frames.</p>
                </div>

                <!-- Step 5: Name -->
                <div id="animPropNameSection" style="margin-bottom:20px; display:none;">
                    <h3>5. Name</h3>
                    <input type="text" id="animPropNameInput" placeholder="e.g. torch, chest, door" style="width:100%;">
                </div>

                <!-- Actions -->
                <div style="margin-top:auto;">
                    <button onclick="animPropSave()" style="width:100%; background:#4af; color:#000; margin-bottom:10px;">Save Prop</button>
                    <button onclick="animPropCancel()" style="width:100%; background:#a55;">Cancel</button>
                </div>
            </div>

            <!-- Main Area -->
            <div class="anim-main">
                <div class="anim-header">
                    <h2>Sprite Sheet</h2>
                    <span style="color:#888; font-size:12px;">Click or drag to select frames (multi-tile supported)</span>
                </div>

                <div class="anim-canvas-area">
                    <canvas id="animPropEditorCanvas"></canvas>
                </div>

                <!-- Bottom Bar: Animation Frames -->
                <div class="anim-frames-bar">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span>Animation Frames: <strong id="animPropFrameCount" style="color:#4af;">0</strong></span>
                        <div style="display:flex; align-items:center; gap:15px;">
                            <!-- Live Preview -->
                            <div style="display:flex; align-items:center; gap:8px;">
                                <canvas id="animPropLivePreview" width="48" height="48" style="border:2px solid #4af; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                                <div style="font-size:11px;">
                                    <div style="display:flex; align-items:center; gap:5px;">
                                        <span style="color:#888;">Speed:</span>
                                        <input type="range" id="animPropSpeedSlider" min="1" max="24" value="8" style="width:80px;" oninput="animPropUpdateSpeed()">
                                        <span id="animPropSpeedLabel" style="color:#4af; min-width:35px;">8 fps</span>
                                    </div>
                                </div>
                            </div>
                            <button onclick="animPropClearFrames()" style="background:#a55; padding:5px 10px; font-size:11px;">Clear</button>
                        </div>
                    </div>
                    <div class="anim-frames-list" id="animPropFramesList"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== GLOBALS =====
        let currentPhase = 'load'; // 'load', 'collision', 'build'
        let gridSize = 16;
        let zoom = 2;
        let mapCols = 40;
        let mapRows = 30;

        let tilesetImg = null;
        let tilesets = []; // Array of { name, img, data } for multiple tilesets
        let currentTilesetIndex = 0;
        let tileCollisions = {}; // "tilesetIndex:x,y" -> [{x,y}, ...]
        let selectedTileData = null;
        let selectionStart = null; // For multi-tile selection
        let selectedTiles = []; // Array of {x, y} for multi-tile selection
        let hoverMapPos = null; // Current hover position on map for preview
        let tileRotation = 0; // 0, 90, 180, 270 degrees

        // Layers
        let layers = []; // Array of layer data, each layer is a 2D array like map
        let currentLayer = 0;
        let layerVisibility = []; // Which layers are visible
        let layerNames = []; // Custom names for layers

        // Player layer (for visualization - uneditable, undeletable)
        let playerLayerIndex = 1; // Which layer position the player appears at
        let playerPreviewPos = { x: 5, y: 5 }; // Position on map for player preview
        let playerPreviewVisible = true;
        let draggingPlayer = false; // For dragging player preview

        // Brush settings
        let brushPainting = false;
        let brushErasing = false;
        let collisionZoom = 6;
        let collisionTool = 'paint'; // 'paint' or 'erase'
        let brushSize = 4; // Brush size in pixels

        // Pixel collision masks per tile
        let collisionMasks = {}; // "x,y" -> 2D array of booleans

        // Depth split lines for Y-sorting (trunk vs canopy)
        let tileSplitLines = {}; // "tilesetIndex:x,y" -> array of Y values per column (freeform line)
        let selectedSplitTile = null; // {x, y, tilesetIndex} - currently selected tile for splitting
        let draggingSplitLine = false; // true when dragging the split line
        let flatLineMode = true; // when true, split lines are always horizontal

        // Panning
        let collisionPanX = 0;
        let collisionPanY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;

        let mode = 'tile';

        // Copy from map mode
        let copyMode = false;
        let copyStart = null;
        let copyEnd = null;
        let copiedTiles = null; // 2D array of copied tile data

        // Multiple props system - array of prop images like tilesets
        let props = []; // Array of { name, img, data, collisionMasks }
        let currentPropIndex = -1;
        let propImage = null; // Current prop image (shortcut)
        let propImageData = null; // Current prop data (shortcut)
        let propSelection = null; // {x, y, width, height}
        let propCollisionMasks = {}; // Current prop's collision masks
        let propTool = 'select'; // 'select', 'collision', 'erase'
        let propBrushSize = 4;
        let propPainting = false;

        // Animated Props System
        let animatedProps = []; // Array of animated prop definitions { name, spriteData, frameWidth, frameHeight, frames: [{x,y,w,h},...], type: 'loop'|'interactive', fps }
        let currentAnimPropIndex = -1;
        let animPropSpriteSheet = null; // Current sprite sheet Image
        let animPropSpriteData = null; // Current sprite data URL
        let animPropFrames = []; // Frames being edited
        let animPropPreviewPlaying = false;
        let animPropPreviewFrame = 0;
        let animPropPreviewInterval = null;
        let placedAnimProps = []; // Animated props placed on map: { propIndex, x, y, layer } (grid coords like tiles)
        // Drag selection for multi-tile frames
        let animPropDragStart = null; // {gridX, gridY}
        let animPropDragEnd = null; // {gridX, gridY}
        let animPropIsDragging = false;
        // Animation state for placed props in editor
        let placedAnimPropFrames = {}; // key: "x,y,layer" -> { frame: 0, timer: 0 }
        let editorAnimInterval = null;

        let map = [];

        // Canvas refs
        const collisionTilesetCanvas = document.getElementById('collisionTilesetCanvas');
        const collisionTilesetCtx = collisionTilesetCanvas.getContext('2d');
        const paintTilesetCanvas = document.getElementById('paintTilesetCanvas');
        const paintTilesetCtx = paintTilesetCanvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        const propTilesetCanvas = document.getElementById('propTilesetCanvas');
        const propTilesetCtx = propTilesetCanvas.getContext('2d');

        // ===== PROP TOOLS =====
        function setPropTool(tool) {
            propTool = tool;
            document.getElementById('propToolSelect').classList.remove('active');
            document.getElementById('propToolCollision').classList.remove('active');
            document.getElementById('propToolErase').classList.remove('active');
            document.getElementById('propTool' + tool.charAt(0).toUpperCase() + tool.slice(1)).classList.add('active');

            // Show/hide brush controls
            document.getElementById('propBrushControls').style.display =
                (tool === 'collision' || tool === 'erase') ? 'block' : 'none';

            // Update cursor
            propTilesetCanvas.style.cursor = (tool === 'select') ? 'crosshair' : 'cell';

            drawPropTileset();
        }

        function setPropBrushSize(size) {
            propBrushSize = size;
            document.querySelectorAll('[id^="propBrush"]').forEach(b => b.classList.remove('active'));
            document.getElementById('propBrush' + size).classList.add('active');
        }

        // ===== PHASE MANAGEMENT =====
        function setPhase(phase) {
            currentPhase = phase;
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('active'));
            document.getElementById(phase + 'Phase').classList.add('active');

            // Start/stop editor animation loop based on phase
            if (phase === 'build') {
                startEditorAnimLoop();
            } else {
                stopEditorAnimLoop();
            }
        }

        // Animation loop for animated props in the editor
        function startEditorAnimLoop() {
            if (editorAnimInterval) return;
            editorAnimInterval = setInterval(() => {
                let needsRender = false;

                // Scan all layers for animTile cells
                for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {
                    const layer = layers[layerIdx];
                    if (!layer) continue;

                    for (let y = 0; y < layer.length; y++) {
                        if (!layer[y]) continue;
                        for (let x = 0; x < layer[y].length; x++) {
                            const cell = layer[y][x];
                            if (!cell || cell.type !== 'animTile') continue;

                            const prop = animatedProps[cell.propIndex];
                            if (!prop || !prop.frames || prop.frames.length <= 1) continue;
                            if (prop.type !== 'loop') continue;

                            const key = x + ',' + y + ',' + layerIdx;
                            if (!placedAnimPropFrames[key]) {
                                placedAnimPropFrames[key] = { frame: 0, timer: 0 };
                            }
                            placedAnimPropFrames[key].timer++;

                            const fps = prop.fps || 8;
                            const frameDelay = Math.round(60 / fps);

                            if (placedAnimPropFrames[key].timer >= frameDelay) {
                                placedAnimPropFrames[key].timer = 0;
                                placedAnimPropFrames[key].frame++;
                                needsRender = true;
                            }
                        }
                    }
                }

                if (needsRender) renderMap();
            }, 1000 / 60); // 60fps update
        }

        function stopEditorAnimLoop() {
            if (editorAnimInterval) {
                clearInterval(editorAnimInterval);
                editorAnimInterval = null;
            }
        }

        // ===== LOAD PHASE =====
        function loadTileset(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Add as first tileset
                    tilesets = [{ name: file.name, img: img, data: e.target.result }];
                    currentTilesetIndex = 0;
                    tilesetImg = img;
                    updateTilesetDropdown();
                    setPhase('collision');
                    rebuildCollisionView();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function addTileset(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    tilesets.push({ name: file.name, img: img, data: e.target.result });
                    currentTilesetIndex = tilesets.length - 1;
                    tilesetImg = img;
                    updateTilesetDropdown();
                    drawPaintTileset();
                    drawPropTileset();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = ''; // Reset input so same file can be selected again
        }

        function switchTileset() {
            const select = document.getElementById('tilesetSelect');
            currentTilesetIndex = parseInt(select.value);
            tilesetImg = tilesets[currentTilesetIndex].img;
            selectedTileData = null; // Clear selection
            selectedTiles = [];
            drawPaintTileset();
            drawPropTileset();
            renderMap();
        }

        function updateTilesetDropdown() {
            const select = document.getElementById('tilesetSelect');
            if (!select) return;
            select.innerHTML = '';
            tilesets.forEach((ts, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = ts.name;
                if (i === currentTilesetIndex) opt.selected = true;
                select.appendChild(opt);
            });
        }

        function deleteTileset() {
            if (tilesets.length === 0) {
                alert('No tileset to delete');
                return;
            }
            if (tilesets.length === 1) {
                alert('Cannot delete the only tileset. Add another one first.');
                return;
            }

            const tileset = tilesets[currentTilesetIndex];
            if (!confirm('Delete tileset "' + tileset.name + '"?\n\nTiles from this tileset on the map will become empty.')) return;

            // Remove tiles from map that use this tileset
            layers.forEach(layer => {
                for (let y = 0; y < layer.length; y++) {
                    for (let x = 0; x < layer[y].length; x++) {
                        const tile = layer[y][x];
                        if (tile && tile.tilesetIndex === currentTilesetIndex) {
                            layer[y][x] = null;
                        } else if (tile && tile.tilesetIndex > currentTilesetIndex) {
                            // Adjust indices for tilesets after the deleted one
                            tile.tilesetIndex--;
                        }
                    }
                }
            });

            // Remove collision data for this tileset
            const keysToDelete = [];
            for (const key in tileCollisions) {
                const [tsIdx] = key.split(':');
                if (parseInt(tsIdx) === currentTilesetIndex) {
                    keysToDelete.push(key);
                }
            }
            keysToDelete.forEach(key => delete tileCollisions[key]);

            // Update collision keys for tilesets after deleted one
            const updatedCollisions = {};
            for (const key in tileCollisions) {
                const [tsIdx, coords] = key.split(':');
                const idx = parseInt(tsIdx);
                if (idx > currentTilesetIndex) {
                    updatedCollisions[(idx - 1) + ':' + coords] = tileCollisions[key];
                } else {
                    updatedCollisions[key] = tileCollisions[key];
                }
            }
            tileCollisions = updatedCollisions;

            // Remove the tileset
            tilesets.splice(currentTilesetIndex, 1);

            // Update current index
            if (currentTilesetIndex >= tilesets.length) {
                currentTilesetIndex = tilesets.length - 1;
            }
            tilesetImg = tilesets[currentTilesetIndex].img;

            // Update UI
            updateTilesetDropdown();
            selectedTileData = null;
            selectedTiles = [];
            drawPaintTileset();
            renderMap();
        }

        // ===== COLLISION PHASE =====
        function rebuildCollisionView() {
            gridSize = parseInt(document.getElementById('gridSize').value);
            drawCollisionTileset();
            updateCollisionStats();
        }

        function drawCollisionTileset() {
            if (!tilesetImg) return;

            collisionTilesetCanvas.width = tilesetImg.naturalWidth * collisionZoom;
            collisionTilesetCanvas.height = tilesetImg.naturalHeight * collisionZoom;

            collisionTilesetCtx.imageSmoothingEnabled = false;
            collisionTilesetCtx.drawImage(tilesetImg, 0, 0, collisionTilesetCanvas.width, collisionTilesetCanvas.height);

            // Grid
            collisionTilesetCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            const cols = Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = Math.floor(tilesetImg.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(x * gridSize * collisionZoom, 0);
                collisionTilesetCtx.lineTo(x * gridSize * collisionZoom, collisionTilesetCanvas.height);
                collisionTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(0, y * gridSize * collisionZoom);
                collisionTilesetCtx.lineTo(collisionTilesetCanvas.width, y * gridSize * collisionZoom);
                collisionTilesetCtx.stroke();
            }

            // Draw pixel collision masks (only for current tileset)
            collisionTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            const keyPrefix = currentTilesetIndex + ':';
            for (let key in collisionMasks) {
                // Only show collisions for current tileset
                if (!key.startsWith(keyPrefix)) continue;

                const mask = collisionMasks[key];
                if (!mask) continue;

                // Parse key format: "tilesetIndex:x,y"
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                for (let py = 0; py < gridSize; py++) {
                    for (let px = 0; px < gridSize; px++) {
                        if (mask[py] && mask[py][px]) {
                            collisionTilesetCtx.fillRect(
                                (tx + px) * collisionZoom,
                                (ty + py) * collisionZoom,
                                collisionZoom,
                                collisionZoom
                            );
                        }
                    }
                }
            }

            // Draw depth split lines (cyan freeform lines)
            collisionTilesetCtx.strokeStyle = '#0ff';
            collisionTilesetCtx.lineWidth = 2;
            for (let key in tileSplitLines) {
                if (!key.startsWith(keyPrefix)) continue;

                const splitYArray = tileSplitLines[key];
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                // Draw freeform line connecting all column Y values
                collisionTilesetCtx.beginPath();
                for (let col = 0; col < gridSize; col++) {
                    const splitY = Array.isArray(splitYArray) ? splitYArray[col] : splitYArray;
                    const lineX = (tx + col + 0.5) * collisionZoom;
                    const lineY = (ty + splitY) * collisionZoom;
                    if (col === 0) {
                        collisionTilesetCtx.moveTo(lineX, lineY);
                    } else {
                        collisionTilesetCtx.lineTo(lineX, lineY);
                    }
                }
                collisionTilesetCtx.stroke();

                // Fill canopy region with semi-transparent cyan
                collisionTilesetCtx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(tx * collisionZoom, ty * collisionZoom);
                for (let col = 0; col < gridSize; col++) {
                    const splitY = Array.isArray(splitYArray) ? splitYArray[col] : splitYArray;
                    const lineX = (tx + col + 0.5) * collisionZoom;
                    const lineY = (ty + splitY) * collisionZoom;
                    collisionTilesetCtx.lineTo(lineX, lineY);
                }
                collisionTilesetCtx.lineTo((tx + gridSize) * collisionZoom, ty * collisionZoom);
                collisionTilesetCtx.closePath();
                collisionTilesetCtx.fill();

                // Draw "C" for canopy and "T" for trunk
                const avgSplitY = Array.isArray(splitYArray)
                    ? splitYArray.reduce((a, b) => a + b, 0) / splitYArray.length
                    : splitYArray;
                collisionTilesetCtx.fillStyle = '#0ff';
                collisionTilesetCtx.font = (collisionZoom * 2) + 'px sans-serif';
                collisionTilesetCtx.textAlign = 'center';
                collisionTilesetCtx.fillText('C', tx * collisionZoom + gridSize * collisionZoom / 2, (ty + avgSplitY / 2) * collisionZoom);
                collisionTilesetCtx.fillText('T', tx * collisionZoom + gridSize * collisionZoom / 2, (ty + avgSplitY + (gridSize - avgSplitY) / 2) * collisionZoom);
            }

            // Highlight selected split tile
            if (selectedSplitTile && collisionTool === 'split') {
                collisionTilesetCtx.strokeStyle = '#ff0';
                collisionTilesetCtx.lineWidth = 3;
                collisionTilesetCtx.strokeRect(
                    selectedSplitTile.x * collisionZoom,
                    selectedSplitTile.y * collisionZoom,
                    gridSize * collisionZoom,
                    gridSize * collisionZoom
                );
            }
        }

        function setCollisionZoom(z) {
            collisionZoom = z;
            document.querySelectorAll('[id^="collisionZoom"]').forEach(b => b.classList.remove('active'));
            const btn = document.querySelector(`[onclick="setCollisionZoom(${z})"]`);
            if (btn) btn.classList.add('active');
            drawCollisionTileset();
        }

        function setCollisionTool(tool) {
            collisionTool = tool;
            document.getElementById('collisionToolPaint').classList.toggle('active', tool === 'paint');
            document.getElementById('collisionToolErase').classList.toggle('active', tool === 'erase');
            document.getElementById('collisionToolSplit').classList.toggle('active', tool === 'split');

            // Show/hide split controls
            document.getElementById('splitControls').style.display = tool === 'split' ? 'block' : 'none';

            // Update cursor based on tool
            if (tool === 'split') {
                collisionTilesetCanvas.style.cursor = 'pointer';
            } else if (tool === 'erase') {
                collisionTilesetCanvas.style.cursor = 'not-allowed';
            } else {
                collisionTilesetCanvas.style.cursor = 'crosshair';
            }

            // Clear split selection when switching away
            if (tool !== 'split') {
                selectedSplitTile = null;
            }

            drawCollisionTileset();
        }

        function setBrushSize(size) {
            brushSize = size;
            document.querySelectorAll('[id^="brush"]').forEach(b => b.classList.remove('active'));
            document.getElementById('brush' + size).classList.add('active');
        }

        function updateCollisionStats() {
            // Only count collisions for current tileset
            const keyPrefix = currentTilesetIndex + ':';
            const count = Object.keys(tileCollisions).filter(k => k.startsWith(keyPrefix) && tileCollisions[k]).length;
            document.getElementById('collisionStats').textContent = count + ' tiles with collision (tileset ' + currentTilesetIndex + ')';
        }

        function selectAllCollision() {
            if (!tilesetImg) return;
            const cols = Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = Math.floor(tilesetImg.naturalHeight / gridSize);

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const tileX = col * gridSize;
                    const tileY = row * gridSize;
                    // Include tileset index in key
                    const key = currentTilesetIndex + ':' + tileX + ',' + tileY;
                    tileCollisions[key] = true;
                }
            }

            drawCollisionTileset();
            updateCollisionStats();
        }

        function clearAllCollision() {
            if (!confirm('Clear all collision for current tileset?')) return;
            // Only clear collisions for current tileset
            const keyPrefix = currentTilesetIndex + ':';
            for (let key in tileCollisions) {
                if (key.startsWith(keyPrefix)) {
                    delete tileCollisions[key];
                }
            }
            for (let key in collisionMasks) {
                if (key.startsWith(keyPrefix)) {
                    delete collisionMasks[key];
                }
            }
            drawCollisionTileset();
            updateCollisionStats();
        }

        // Collision canvas mouse events - pixel brush painting + pan
        collisionTilesetCanvas.addEventListener('mousedown', (e) => {
            e.preventDefault();

            // Middle mouse or shift+left = pan
            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                isPanning = true;
                panStartX = e.clientX + collisionPanX;
                panStartY = e.clientY + collisionPanY;
                collisionTilesetCanvas.style.cursor = 'grabbing';
                return;
            }

            // Handle split tool mode
            if (collisionTool === 'split' && e.button === 0) {
                handleSplitClick(e);
                return;
            }

            if (e.button === 0) {
                brushPainting = true;
                paintCollisionAt(e, collisionTool === 'paint');
            } else if (e.button === 2) {
                brushErasing = true;
                paintCollisionAt(e, false);
            }
        });

        collisionTilesetCanvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                collisionPanX = panStartX - e.clientX;
                collisionPanY = panStartY - e.clientY;
                updateCollisionScroll();
                return;
            }

            // Handle dragging split line
            if (draggingSplitLine && selectedSplitTile) {
                handleSplitDrag(e);
                return;
            }

            if (brushPainting) paintCollisionAt(e, collisionTool === 'paint');
            if (brushErasing) paintCollisionAt(e, false);
        });

        collisionTilesetCanvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                collisionTilesetCanvas.style.cursor = collisionTool === 'split' ? 'pointer' : 'crosshair';
            }
            draggingSplitLine = false;
            brushPainting = false;
            brushErasing = false;
        });

        collisionTilesetCanvas.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                collisionTilesetCanvas.style.cursor = 'crosshair';
            }
            brushPainting = false;
            brushErasing = false;
        });

        collisionTilesetCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Paint collision pixels with brush
        function paintCollisionAt(e, addCollision) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            // Find which tile this pixel is in
            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;
            // Include tileset index in key so each tileset has separate collisions
            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;

            // Get or create mask for this tile
            if (!collisionMasks[key]) {
                collisionMasks[key] = [];
                for (let y = 0; y < gridSize; y++) {
                    collisionMasks[key][y] = new Array(gridSize).fill(false);
                }
            }
            const mask = collisionMasks[key];

            // Paint pixels with brush
            const half = Math.floor(brushSize / 2);
            const localX = px - tileX;
            const localY = py - tileY;

            for (let dy = -half; dy < half; dy++) {
                for (let dx = -half; dx < half; dx++) {
                    const mx = localX + dx;
                    const my = localY + dy;
                    if (mx >= 0 && mx < gridSize && my >= 0 && my < gridSize) {
                        mask[my][mx] = addCollision;
                    }
                }
            }

            // Update tileCollisions (true if any pixel is set)
            let hasCollision = false;
            for (let y = 0; y < gridSize && !hasCollision; y++) {
                for (let x = 0; x < gridSize && !hasCollision; x++) {
                    if (mask[y][x]) hasCollision = true;
                }
            }
            if (hasCollision) {
                tileCollisions[key] = true;
            } else {
                delete tileCollisions[key];
                delete collisionMasks[key];
            }

            drawCollisionTileset();
            updateCollisionStats();
        }

        // ===== DEPTH SPLIT FUNCTIONS =====
        // tileSplitLines stores an array of Y values per column for freeform lines
        // Format: "tilesetIndex:x,y" -> [y0, y1, y2, ..., y15] (one Y per column)

        function toggleFlatLineMode() {
            flatLineMode = document.getElementById('flatLineToggle').checked;
        }

        function handleSplitClick(e) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            // Find which tile was clicked
            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;

            // Select this tile for splitting
            selectedSplitTile = { x: tileX, y: tileY, tilesetIndex: currentTilesetIndex };
            draggingSplitLine = true;

            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;

            // Calculate local Y position within the tile
            const localY = py - tileY;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            // Initialize or set split line
            if (flatLineMode) {
                // Flat line mode: set entire line to clicked Y
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                // Update the Y input to show current value
                document.getElementById('splitYInput').value = clampedY;
            } else {
                // Freeform mode: initialize if doesn't exist, then set clicked column
                if (!tileSplitLines[key]) {
                    const defaultY = parseInt(document.getElementById('splitYInput').value) || Math.floor(gridSize / 2);
                    tileSplitLines[key] = new Array(gridSize).fill(defaultY);
                }
                const localX = px - tileX;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            // Update UI
            document.getElementById('splitYInput').max = gridSize;

            drawCollisionTileset();
        }

        function handleSplitDrag(e) {
            if (!selectedSplitTile || !draggingSplitLine) return;

            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            if (!tileSplitLines[key]) return;

            // Calculate local position within the tile
            const localY = py - selectedSplitTile.y;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            if (flatLineMode) {
                // Flat line mode: set entire line to current Y
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                document.getElementById('splitYInput').value = clampedY;
            } else {
                // Freeform mode: set only this column
                const localX = px - selectedSplitTile.x;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            drawCollisionTileset();
        }

        function setSplitLineY() {
            // Set a flat horizontal line at the specified Y
            if (!selectedSplitTile) {
                alert('Click a tile first to select it');
                return;
            }

            const splitY = parseInt(document.getElementById('splitYInput').value) || Math.floor(gridSize / 2);
            const clampedY = Math.max(0, Math.min(gridSize, splitY));

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            tileSplitLines[key] = new Array(gridSize).fill(clampedY);

            drawCollisionTileset();
        }

        function clearSelectedSplit() {
            if (!selectedSplitTile) return;

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            delete tileSplitLines[key];
            selectedSplitTile = null;

            drawCollisionTileset();
        }

        // Keyboard controls for build phase
        document.addEventListener('keydown', (e) => {
            if (currentPhase === 'build') {
                if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    rotateNext();
                }
            }
        });

        // Keyboard controls for collision painter
        document.addEventListener('keydown', (e) => {
            if (currentPhase !== 'collision') return;

            // Zoom with Q/E or +/-
            if (e.key === 'e' || e.key === 'E' || e.key === '=' || e.key === '+') {
                e.preventDefault();
                if (collisionZoom < 12) setCollisionZoom(collisionZoom + 1);
                return;
            }
            if (e.key === 'q' || e.key === 'Q' || e.key === '-' || e.key === '_') {
                e.preventDefault();
                if (collisionZoom > 1) setCollisionZoom(collisionZoom - 1);
                return;
            }

            // Arrow keys to pan
            const panSpeed = 50;
            let moved = false;

            if (e.key === 'ArrowLeft') { collisionPanX -= panSpeed; moved = true; }
            if (e.key === 'ArrowRight') { collisionPanX += panSpeed; moved = true; }
            if (e.key === 'ArrowUp') { collisionPanY -= panSpeed; moved = true; }
            if (e.key === 'ArrowDown') { collisionPanY += panSpeed; moved = true; }

            if (moved) {
                e.preventDefault();
                updateCollisionScroll();
            }
        });

        function updateCollisionScroll() {
            const container = document.querySelector('.collision-main');
            // Clamp pan values
            const maxX = Math.max(0, collisionTilesetCanvas.width - container.clientWidth);
            const maxY = Math.max(0, collisionTilesetCanvas.height - container.clientHeight);
            collisionPanX = Math.max(0, Math.min(maxX, collisionPanX));
            collisionPanY = Math.max(0, Math.min(maxY, collisionPanY));

            container.scrollLeft = collisionPanX;
            container.scrollTop = collisionPanY;
        }

        let mapInitialized = false;

        function finishCollisionSetup() {
            // Only initialize map if it hasn't been created yet
            if (!mapInitialized) {
                initMap();
                mapInitialized = true;
            }
            setPhase('build');
            drawPaintTileset();
            renderMap();
            updateAnimPropListDisplay();
        }

        function goBackToCollision() {
            setPhase('collision');
            rebuildCollisionView();
        }

        // ===== BUILD PHASE =====
        function initMap() {
            // Initialize with one layer
            layers = [createEmptyLayer()];
            layerVisibility = [true];
            layerNames = [''];
            currentLayer = 0;
            map = layers[0]; // map points to current layer for compatibility
            renderLayerList();
        }

        function createEmptyLayer() {
            const layer = [];
            for (let y = 0; y < mapRows; y++) {
                layer[y] = [];
                for (let x = 0; x < mapCols; x++) {
                    layer[y][x] = null;
                }
            }
            return layer;
        }

        function addLayer() {
            layers.push(createEmptyLayer());
            layerVisibility.push(true);
            layerNames.push('');
            currentLayer = layers.length - 1;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function selectLayer(index) {
            currentLayer = index;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function toggleLayerVisibility(index) {
            layerVisibility[index] = !layerVisibility[index];
            renderLayerList();
            renderMap();
        }

        function deleteLayer(index) {
            if (layers.length <= 1) return alert('Need at least one layer');
            const layerLabel = layerNames[index] ? `"${layerNames[index]}"` : `Layer ${index}`;
            if (!confirm('Delete ' + layerLabel + '?')) return;
            layers.splice(index, 1);
            layerVisibility.splice(index, 1);
            layerNames.splice(index, 1);
            if (currentLayer >= layers.length) currentLayer = layers.length - 1;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function moveLayerUp(index) {
            if (index <= 0) return;
            [layers[index], layers[index-1]] = [layers[index-1], layers[index]];
            [layerVisibility[index], layerVisibility[index-1]] = [layerVisibility[index-1], layerVisibility[index]];
            [layerNames[index], layerNames[index-1]] = [layerNames[index-1], layerNames[index]];
            if (currentLayer === index) currentLayer--;
            else if (currentLayer === index - 1) currentLayer++;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function moveLayerDown(index) {
            if (index >= layers.length - 1) return;
            [layers[index], layers[index+1]] = [layers[index+1], layers[index]];
            [layerVisibility[index], layerVisibility[index+1]] = [layerVisibility[index+1], layerVisibility[index]];
            [layerNames[index], layerNames[index+1]] = [layerNames[index+1], layerNames[index]];
            if (currentLayer === index) currentLayer++;
            else if (currentLayer === index + 1) currentLayer--;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function renderLayerList() {
            // Render to both layer lists (tileset mode and animProp mode)
            const lists = [
                document.getElementById('layerList'),
                document.getElementById('animPropLayerList')
            ];

            for (const list of lists) {
                if (!list) continue;
                list.innerHTML = '';

                // Insert player layer row at the right position
                // Player layer is rendered BETWEEN layers[playerLayerIndex-1] and layers[playerLayerIndex]
                // So we need to show it after displaying layer playerLayerIndex-1

                for (let i = 0; i < layers.length; i++) {
                    // If this is where the player layer should appear, show it first
                    if (i === playerLayerIndex) {
                        list.appendChild(createPlayerLayerRow());
                    }

                    const div = document.createElement('div');
                    div.style.cssText = 'display:flex; align-items:center; gap:5px; padding:5px; margin:3px 0; background:' + (i === currentLayer ? '#4af' : '#333') + '; border-radius:4px; font-size:11px;';

                    const layerLabel = layerNames[i] ? `Layer ${i} (${layerNames[i]})` : `Layer ${i}`;

                    div.innerHTML = `
                        <input type="checkbox" ${layerVisibility[i] ? 'checked' : ''} onclick="toggleLayerVisibility(${i})" title="Visibility">
                        <span style="flex:1; cursor:pointer; color:${i === currentLayer ? '#000' : '#fff'};" onclick="selectLayer(${i})">${layerLabel}</span>
                        <button onclick="renameLayer(${i})" style="padding:2px 5px; font-size:10px;" title="Rename">✎</button>
                        <button onclick="moveLayerUp(${i})" style="padding:2px 5px; font-size:10px;">↑</button>
                        <button onclick="moveLayerDown(${i})" style="padding:2px 5px; font-size:10px;">↓</button>
                        <button onclick="deleteLayer(${i})" style="padding:2px 5px; font-size:10px; background:#a55;">X</button>
                    `;
                    list.appendChild(div);
                }

                // If player layer is at the end (beyond all layers)
                if (playerLayerIndex >= layers.length) {
                    list.appendChild(createPlayerLayerRow());
                }
            }
        }

        function createPlayerLayerRow() {
            const div = document.createElement('div');
            div.style.cssText = 'display:flex; align-items:center; gap:5px; padding:5px; margin:3px 0; background:#f0a; border-radius:4px; font-size:11px;';

            div.innerHTML = `
                <input type="checkbox" ${playerPreviewVisible ? 'checked' : ''} onclick="togglePlayerPreview()" title="Visibility">
                <span style="flex:1; color:#000;">🧍 PLAYER</span>
                <span style="color:#000; font-size:9px; opacity:0.7;">locked</span>
                <button onclick="movePlayerLayerUp()" style="padding:2px 5px; font-size:10px;">↑</button>
                <button onclick="movePlayerLayerDown()" style="padding:2px 5px; font-size:10px;">↓</button>
            `;
            return div;
        }

        function togglePlayerPreview() {
            playerPreviewVisible = !playerPreviewVisible;
            renderLayerList();
            renderMap();
        }

        function movePlayerLayerUp() {
            if (playerLayerIndex > 0) {
                playerLayerIndex--;
                renderLayerList();
                renderMap();
            }
        }

        function movePlayerLayerDown() {
            if (playerLayerIndex < layers.length) {
                playerLayerIndex++;
                renderLayerList();
                renderMap();
            }
        }

        function renameLayer(index) {
            const currentName = layerNames[index] || '';
            const newName = prompt('Enter nickname for Layer ' + index + ':', currentName);
            if (newName !== null) {
                layerNames[index] = newName.trim();
                renderLayerList();
            }
        }

        function setMode(m) {
            mode = m;
            document.getElementById('tileMode').classList.toggle('active', m === 'tile');
            document.getElementById('propMode').classList.toggle('active', m === 'prop');
            document.getElementById('animPropMode').classList.toggle('active', m === 'animProp');
            document.getElementById('tileModeContent').style.display = m === 'tile' ? 'block' : 'none';
            document.getElementById('propModeContent').style.display = m === 'prop' ? 'block' : 'none';
            document.getElementById('animPropModeContent').style.display = m === 'animProp' ? 'block' : 'none';

            // Redraw map to show appropriate overlays
            renderMap();
        }

        function setRotation(deg) {
            tileRotation = deg;
            document.querySelectorAll('[id^="rot"]').forEach(b => b.classList.remove('active'));
            document.getElementById('rot' + deg).classList.add('active');
            updateSelectedPreview();
            renderMap(); // Update preview
        }

        function rotateNext() {
            const rotations = [0, 90, 180, 270];
            const idx = rotations.indexOf(tileRotation);
            setRotation(rotations[(idx + 1) % 4]);
        }

        // Draw a tile with rotation
        function drawRotatedTile(ctx, img, srcX, srcY, srcSize, destX, destY, destSize, rotation) {
            if (rotation === 0) {
                ctx.drawImage(img, srcX, srcY, srcSize, srcSize, destX, destY, destSize, destSize);
            } else {
                ctx.save();
                ctx.translate(destX + destSize / 2, destY + destSize / 2);
                ctx.rotate(rotation * Math.PI / 180);
                ctx.drawImage(img, srcX, srcY, srcSize, srcSize, -destSize / 2, -destSize / 2, destSize, destSize);
                ctx.restore();
            }
        }

        // Draw player preview placeholder on map
        function drawPlayerPreview(tileSize) {
            mapCtx.globalAlpha = 1;

            const playerWidth = 28;
            const playerHeight = 64;
            const px = playerPreviewPos.x * tileSize;
            const py = playerPreviewPos.y * tileSize;

            // Draw player silhouette (simple humanoid shape)
            const scale = zoom;

            // Body
            mapCtx.fillStyle = '#f0a';
            mapCtx.fillRect(px + 6 * scale, py + 16 * scale, 16 * scale, 32 * scale);

            // Head
            mapCtx.beginPath();
            mapCtx.arc(px + 14 * scale, py + 10 * scale, 8 * scale, 0, Math.PI * 2);
            mapCtx.fill();

            // Legs
            mapCtx.fillRect(px + 6 * scale, py + 48 * scale, 6 * scale, 14 * scale);
            mapCtx.fillRect(px + 16 * scale, py + 48 * scale, 6 * scale, 14 * scale);

            // Arms
            mapCtx.fillRect(px + 0 * scale, py + 20 * scale, 6 * scale, 20 * scale);
            mapCtx.fillRect(px + 22 * scale, py + 20 * scale, 6 * scale, 20 * scale);

            // Outline
            mapCtx.strokeStyle = '#fff';
            mapCtx.lineWidth = 2;
            mapCtx.strokeRect(px, py, 28 * scale, 64 * scale);

            // Label
            mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
            mapCtx.font = '10px sans-serif';
            mapCtx.textAlign = 'center';
            const labelWidth = mapCtx.measureText('PLAYER').width + 6;
            mapCtx.fillRect(px + 14 * scale - labelWidth / 2, py - 16, labelWidth, 14);
            mapCtx.fillStyle = '#f0a';
            mapCtx.fillText('PLAYER', px + 14 * scale, py - 5);

            // Drag handle indicator
            if (mode === 'tile') {
                mapCtx.strokeStyle = '#fff';
                mapCtx.setLineDash([3, 3]);
                mapCtx.strokeRect(px - 2, py - 2, 28 * scale + 4, 64 * scale + 4);
                mapCtx.setLineDash([]);
            }
        }

        // Check if a click is within the player preview bounds
        function isClickOnPlayer(clickX, clickY, tileSize) {
            const px = playerPreviewPos.x * tileSize;
            const py = playerPreviewPos.y * tileSize;
            const playerWidth = 28 * zoom;
            const playerHeight = 64 * zoom;

            return clickX >= px && clickX <= px + playerWidth &&
                   clickY >= py && clickY <= py + playerHeight;
        }

        function drawPaintTileset() {
            if (!tilesetImg) return;

            const displayZoom = 2;
            paintTilesetCanvas.width = tilesetImg.naturalWidth * displayZoom;
            paintTilesetCanvas.height = tilesetImg.naturalHeight * displayZoom;

            paintTilesetCtx.imageSmoothingEnabled = false;
            paintTilesetCtx.drawImage(tilesetImg, 0, 0, paintTilesetCanvas.width, paintTilesetCanvas.height);

            // Grid
            paintTilesetCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            const cols = Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = Math.floor(tilesetImg.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(x * gridSize * displayZoom, 0);
                paintTilesetCtx.lineTo(x * gridSize * displayZoom, paintTilesetCanvas.height);
                paintTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(0, y * gridSize * displayZoom);
                paintTilesetCtx.lineTo(paintTilesetCanvas.width, y * gridSize * displayZoom);
                paintTilesetCtx.stroke();
            }

            // Mark collision tiles
            for (let key in tileCollisions) {
                if (tileCollisions[key] && tileCollisions[key].length >= 3) {
                    const [tx, ty] = key.split(',').map(Number);
                    paintTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.25)';
                    paintTilesetCtx.fillRect(tx * displayZoom, ty * displayZoom, gridSize * displayZoom, gridSize * displayZoom);
                }
            }

            // Mark tiles with depth split lines (cyan indicator)
            const keyPrefix = currentTilesetIndex + ':';
            for (let key in tileSplitLines) {
                if (!key.startsWith(keyPrefix)) continue;

                const splitY = tileSplitLines[key];
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                // Draw cyan horizontal line
                paintTilesetCtx.strokeStyle = '#0ff';
                paintTilesetCtx.lineWidth = 2;
                const lineY = (ty + splitY) * displayZoom;
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(tx * displayZoom, lineY);
                paintTilesetCtx.lineTo((tx + gridSize) * displayZoom, lineY);
                paintTilesetCtx.stroke();

                // Draw small cyan dot in corner to indicate split tile
                paintTilesetCtx.fillStyle = '#0ff';
                paintTilesetCtx.beginPath();
                paintTilesetCtx.arc(tx * displayZoom + 6, ty * displayZoom + 6, 4, 0, Math.PI * 2);
                paintTilesetCtx.fill();
            }

            // Highlight selected tiles
            if (selectedTileData) {
                paintTilesetCtx.strokeStyle = '#0f0';
                paintTilesetCtx.lineWidth = 3;
                const w = (selectedTileData.width || 1) * gridSize * displayZoom;
                const h = (selectedTileData.height || 1) * gridSize * displayZoom;
                paintTilesetCtx.strokeRect(
                    selectedTileData.x * displayZoom,
                    selectedTileData.y * displayZoom,
                    w,
                    h
                );
                paintTilesetCtx.lineWidth = 1;
            }
        }

        // Multi-tile selection on tileset
        let tilesetSelecting = false;

        paintTilesetCanvas.addEventListener('mousedown', (e) => {
            if (mode !== 'tile') return;
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            selectionStart = { x, y };
            tilesetSelecting = true;
        });

        paintTilesetCanvas.addEventListener('mousemove', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            updateTileSelection(e);
        });

        paintTilesetCanvas.addEventListener('mouseup', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            updateTileSelection(e);
            tilesetSelecting = false;
        });

        function updateTileSelection(e) {
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            // Calculate selection rectangle
            const minX = Math.min(selectionStart.x, x);
            const minY = Math.min(selectionStart.y, y);
            const maxX = Math.max(selectionStart.x, x);
            const maxY = Math.max(selectionStart.y, y);

            // Build array of selected tiles
            selectedTiles = [];
            for (let ty = minY; ty <= maxY; ty += gridSize) {
                for (let tx = minX; tx <= maxX; tx += gridSize) {
                    selectedTiles.push({ x: tx, y: ty });
                }
            }

            // Calculate selection dimensions
            const selWidth = (maxX - minX) / gridSize + 1;
            const selHeight = (maxY - minY) / gridSize + 1;

            document.getElementById('selectedPreview').style.display = 'flex';
            document.getElementById('selectedInfo').textContent = `${selWidth}x${selHeight} tiles`;
            document.getElementById('selectedCollisionInfo').textContent = '';

            // Store selection bounds for painting
            selectedTileData = { x: minX, y: minY, width: selWidth, height: selHeight };

            updateSelectedPreview();
            drawPaintTileset();
        }

        function updateSelectedPreview() {
            if (!selectedTileData || !tilesetImg) return;

            const selWidth = selectedTileData.width || 1;
            const selHeight = selectedTileData.height || 1;

            const preview = document.getElementById('selectedTile');
            const previewSize = Math.max(48, selWidth * 16, selHeight * 16);
            preview.width = previewSize;
            preview.height = previewSize;
            const ctx = preview.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, previewSize, previewSize);

            // Draw selected tiles to preview with rotation
            const scale = Math.min(previewSize / (selWidth * gridSize), previewSize / (selHeight * gridSize));
            for (const tile of selectedTiles) {
                const drawX = ((tile.x - selectedTileData.x) / gridSize) * gridSize * scale;
                const drawY = ((tile.y - selectedTileData.y) / gridSize) * gridSize * scale;
                drawRotatedTile(ctx, tilesetImg, tile.x, tile.y, gridSize, drawX, drawY, gridSize * scale, tileRotation);
            }
        }

        // ===== UNDO/REDO SYSTEM =====
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO = 50;
        let currentStrokeChanges = []; // Track changes during a single stroke

        function saveForUndo(x, y, oldValue) {
            currentStrokeChanges.push({ x, y, layer: currentLayer, oldValue: oldValue ? { ...oldValue } : null });
        }

        function commitStroke() {
            if (currentStrokeChanges.length > 0) {
                // Also save new values for redo
                const changes = currentStrokeChanges.map(c => ({
                    ...c,
                    newValue: layers[c.layer][c.y][c.x] ? { ...layers[c.layer][c.y][c.x] } : null
                }));
                undoStack.push(changes);
                if (undoStack.length > MAX_UNDO) undoStack.shift();
                redoStack = []; // Clear redo stack on new action
                currentStrokeChanges = [];
                updateUndoRedoButtons();
            }
        }

        function undo() {
            if (undoStack.length === 0) return;
            const changes = undoStack.pop();

            // Apply old values
            changes.forEach(c => {
                if (c.y >= 0 && c.y < layers[c.layer].length && c.x >= 0 && c.x < layers[c.layer][c.y].length) {
                    layers[c.layer][c.y][c.x] = c.oldValue ? { ...c.oldValue } : null;
                }
            });

            redoStack.push(changes);
            map = layers[currentLayer];
            renderMap();
            updateUndoRedoButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;
            const changes = redoStack.pop();

            // Apply new values
            changes.forEach(c => {
                if (c.y >= 0 && c.y < layers[c.layer].length && c.x >= 0 && c.x < layers[c.layer][c.y].length) {
                    layers[c.layer][c.y][c.x] = c.newValue ? { ...c.newValue } : null;
                }
            });

            undoStack.push(changes);
            map = layers[currentLayer];
            renderMap();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            undoBtn.style.opacity = undoStack.length > 0 ? '1' : '0.5';
            redoBtn.style.opacity = redoStack.length > 0 ? '1' : '0.5';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                } else if (e.key === 'y' || (e.key === 'z' && e.shiftKey)) {
                    e.preventDefault();
                    redo();
                }
            }
        });

        // Map painting
        let painting = false;
        let erasing = false;

        mapCanvas.addEventListener('mousedown', (e) => {
            // Skip painting when grab tool is active
            if (grabToolActive) return;

            e.preventDefault();
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((e.clientX - rect.left) / tileSize);
            const y = Math.floor((e.clientY - rect.top) / tileSize);

            // Check if clicking on player preview (to drag it)
            if (playerPreviewVisible && isClickOnPlayer(e.clientX - rect.left, e.clientY - rect.top, tileSize)) {
                draggingPlayer = true;
                mapCanvas.style.cursor = 'move';
                return;
            }

            if (copyMode) {
                // Start copy selection
                copyStart = { x, y };
                copyEnd = { x, y };
                renderMap();
                return;
            }

            // Animated prop mode - click to place, right-click to remove (no dragging)
            if (mode === 'animProp') {
                if (e.button === 0 && currentAnimPropIndex >= 0) {
                    placeAnimPropAt(x, y);
                } else if (e.button === 2) {
                    removeAnimPropAt(x, y);
                }
                return;
            }

            if (e.button === 0) {
                painting = true;
                paintAt(x, y);
            }
            if (e.button === 2) {
                erasing = true;
                paintAt(x, y);
            }
        });

        mapCanvas.addEventListener('mousemove', (e) => {
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((e.clientX - rect.left) / tileSize);
            const y = Math.floor((e.clientY - rect.top) / tileSize);

            // Handle dragging player preview
            if (draggingPlayer) {
                playerPreviewPos.x = x;
                playerPreviewPos.y = y;
                renderMap();
                return;
            }

            if (copyMode && copyStart) {
                // Update copy selection
                copyEnd = { x, y };
                renderMap();
                return;
            }

            // Update hover position for preview
            if (hoverMapPos?.x !== x || hoverMapPos?.y !== y) {
                hoverMapPos = { x, y };
                renderMap();
            }

            if (painting || erasing) {
                paintAt(x, y);
            }
        });

        mapCanvas.addEventListener('mouseleave', () => {
            hoverMapPos = null;
            renderMap();
        });

        window.addEventListener('mouseup', (e) => {
            // Stop dragging player
            if (draggingPlayer) {
                draggingPlayer = false;
                mapCanvas.style.cursor = grabToolActive ? 'grab' : 'crosshair';
            }
            if (copyMode && copyStart && copyEnd) {
                // Finish copy selection
                finishCopyFromMap();
            }
            if (painting || erasing) {
                commitStroke(); // Save undo state after stroke is complete
            }
            painting = false;
            erasing = false;
        });
        mapCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Animated prop placement helpers - stores directly in layer like tiles
        // Supports multi-tile props based on frame size
        function placeAnimPropAt(x, y) {
            if (x < 0 || y < 0 || x >= mapCols || y >= mapRows) return;
            if (!layers[currentLayer]) return;
            if (currentAnimPropIndex < 0 || !animatedProps[currentAnimPropIndex]) return;

            const prop = animatedProps[currentAnimPropIndex];
            const frames = prop.frames || [];
            if (frames.length === 0) return;

            // Calculate how many tiles this prop spans based on first frame size
            const frame = frames[0];
            const tilesW = Math.ceil(frame.w / gridSize);
            const tilesH = Math.ceil(frame.h / gridSize);

            // Place the origin tile (stores the propIndex)
            for (let ty = 0; ty < tilesH; ty++) {
                for (let tx = 0; tx < tilesW; tx++) {
                    const px = x + tx;
                    const py = y + ty;
                    if (px >= mapCols || py >= mapRows) continue;

                    if (!layers[currentLayer][py]) layers[currentLayer][py] = [];

                    // Origin tile (0,0) stores the prop reference
                    // Other tiles store offset to know which part to draw
                    layers[currentLayer][py][px] = {
                        type: 'animTile',
                        propIndex: currentAnimPropIndex,
                        offsetX: tx,  // Which tile within the prop (0-based)
                        offsetY: ty,
                        tilesW: tilesW,  // Total size of prop in tiles
                        tilesH: tilesH
                    };
                }
            }
            renderMap();
        }

        function removeAnimPropAt(x, y) {
            if (x < 0 || y < 0 || x >= mapCols || y >= mapRows) return;
            if (!layers[currentLayer] || !layers[currentLayer][y]) return;

            const cell = layers[currentLayer][y][x];
            if (cell && cell.type === 'animTile') {
                // Remove all tiles of this multi-tile prop
                const originX = x - (cell.offsetX || 0);
                const originY = y - (cell.offsetY || 0);
                const tilesW = cell.tilesW || 1;
                const tilesH = cell.tilesH || 1;

                for (let ty = 0; ty < tilesH; ty++) {
                    for (let tx = 0; tx < tilesW; tx++) {
                        const px = originX + tx;
                        const py = originY + ty;
                        if (px < 0 || py < 0 || px >= mapCols || py >= mapRows) continue;
                        if (layers[currentLayer][py]) {
                            layers[currentLayer][py][px] = null;
                        }
                    }
                }
            }
            renderMap();
        }

        // Copy from map functions
        function startCopyFromMap() {
            copyMode = true;
            copyStart = null;
            copyEnd = null;
            copiedTiles = null;
            document.getElementById('copyFromMapBtn').classList.add('active');
            document.getElementById('copyFromMapBtn').textContent = 'Selecting...';
            document.getElementById('copyModeInfo').style.display = 'inline';
            mapCanvas.style.cursor = 'copy';
        }

        function finishCopyFromMap() {
            if (!copyStart || !copyEnd) {
                cancelCopyMode();
                return;
            }

            const minX = Math.min(copyStart.x, copyEnd.x);
            const maxX = Math.max(copyStart.x, copyEnd.x);
            const minY = Math.min(copyStart.y, copyEnd.y);
            const maxY = Math.max(copyStart.y, copyEnd.y);

            const width = maxX - minX + 1;
            const height = maxY - minY + 1;

            // Copy tiles from current layer
            copiedTiles = [];
            for (let dy = 0; dy < height; dy++) {
                copiedTiles[dy] = [];
                for (let dx = 0; dx < width; dx++) {
                    const mx = minX + dx;
                    const my = minY + dy;
                    if (my >= 0 && my < mapRows && mx >= 0 && mx < mapCols) {
                        copiedTiles[dy][dx] = map[my][mx] ? { ...map[my][mx] } : null;
                    } else {
                        copiedTiles[dy][dx] = null;
                    }
                }
            }

            // Set as selected tile data for painting
            selectedTileData = {
                isCopied: true,
                width: width,
                height: height
            };

            // Update preview
            updateCopiedPreview();

            // Exit copy mode
            copyMode = false;
            copyStart = null;
            copyEnd = null;
            document.getElementById('copyFromMapBtn').classList.remove('active');
            document.getElementById('copyFromMapBtn').textContent = 'Copy from Map';
            document.getElementById('copyModeInfo').style.display = 'none';
            mapCanvas.style.cursor = 'crosshair';
            renderMap();
        }

        function cancelCopyMode() {
            copyMode = false;
            copyStart = null;
            copyEnd = null;
            document.getElementById('copyFromMapBtn').classList.remove('active');
            document.getElementById('copyFromMapBtn').textContent = 'Copy from Map';
            document.getElementById('copyModeInfo').style.display = 'none';
            mapCanvas.style.cursor = 'crosshair';
            renderMap();
        }

        function updateCopiedPreview() {
            if (!copiedTiles || copiedTiles.length === 0) return;

            const previewCanvas = document.getElementById('selectedTile');
            const previewCtx = previewCanvas.getContext('2d');
            const previewSize = 48;

            // Calculate tile size to fit preview
            const width = copiedTiles[0].length;
            const height = copiedTiles.length;
            const tilePreviewSize = Math.min(previewSize / width, previewSize / height, 16);

            previewCanvas.width = previewSize;
            previewCanvas.height = previewSize;

            previewCtx.fillStyle = '#333';
            previewCtx.fillRect(0, 0, previewSize, previewSize);
            previewCtx.imageSmoothingEnabled = false;

            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    const cell = copiedTiles[dy][dx];
                    if (cell) {
                        const px = dx * tilePreviewSize;
                        const py = dy * tilePreviewSize;

                        if (cell.type === 'tile') {
                            const cellTileset = tilesets[cell.tilesetIndex || 0]?.img || tilesetImg;
                            if (cellTileset) {
                                previewCtx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tilePreviewSize, tilePreviewSize);
                            }
                        } else if (cell.type === 'prop' && propImage) {
                            previewCtx.drawImage(propImage, cell.x, cell.y, gridSize, gridSize, px, py, tilePreviewSize, tilePreviewSize);
                        }
                    }
                }
            }

            document.getElementById('selectedPreview').style.display = 'flex';
            document.getElementById('selectedInfo').textContent = width + 'x' + height + ' copied';
            document.getElementById('selectedCollisionInfo').textContent = 'From map';
        }

        function paintAt(x, y) {
            if (!selectedTileData) {
                if (erasing && x >= 0 && x < mapCols && y >= 0 && y < mapRows) {
                    saveForUndo(x, y, map[y][x]); // Save for undo
                    map[y][x] = null;
                    renderMap();
                }
                return;
            }

            const selW = selectedTileData.width || 1;
            const selH = selectedTileData.height || 1;

            if (erasing) {
                // Erase area matching selection size
                for (let dy = 0; dy < selH; dy++) {
                    for (let dx = 0; dx < selW; dx++) {
                        const mx = x + dx;
                        const my = y + dy;
                        if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                            saveForUndo(mx, my, map[my][mx]); // Save for undo
                            map[my][mx] = null;
                        }
                    }
                }
            } else if (painting) {
                // Check if painting with copied tiles
                if (selectedTileData.isCopied && copiedTiles) {
                    // Paint copied tiles
                    for (let dy = 0; dy < selH; dy++) {
                        for (let dx = 0; dx < selW; dx++) {
                            const mx = x + dx;
                            const my = y + dy;

                            // Auto-expand map if painting at or beyond edge
                            if (my >= mapRows - 2) expandMapRows();
                            if (mx >= mapCols - 2) expandMapCols();

                            if (mx >= 0 && my >= 0 && mx < mapCols && my < mapRows) {
                                const srcCell = copiedTiles[dy] && copiedTiles[dy][dx];
                                if (srcCell) {
                                    saveForUndo(mx, my, map[my][mx]); // Save for undo
                                    map[my][mx] = { ...srcCell };
                                }
                            }
                        }
                    }
                } else {
                    // Paint from tileset selection
                    for (let dy = 0; dy < selH; dy++) {
                        for (let dx = 0; dx < selW; dx++) {
                            const mx = x + dx;
                            const my = y + dy;

                            // Auto-expand map if painting at or beyond edge
                            if (my >= mapRows - 2) expandMapRows();
                            if (mx >= mapCols - 2) expandMapCols();

                            if (mx >= 0 && my >= 0 && mx < mapCols && my < mapRows) {
                                const tileX = selectedTileData.x + dx * gridSize;
                                const tileY = selectedTileData.y + dy * gridSize;

                                saveForUndo(mx, my, map[my][mx]); // Save for undo

                                if (selectedTileData.isProp) {
                                    // Paint as prop with propIndex (collision is painted separately in prop panel)
                                    map[my][mx] = { type: 'prop', x: tileX, y: tileY, propIndex: currentPropIndex };
                                } else {
                                    // Paint as tile with rotation
                                    map[my][mx] = { type: 'tile', x: tileX, y: tileY, rotation: tileRotation, tilesetIndex: currentTilesetIndex };
                                }
                            }
                        }
                    }
                }
            }
            renderMap();
        }

        function renderMap() {
            const tileSize = gridSize * zoom;
            mapCanvas.width = mapCols * tileSize;
            mapCanvas.height = mapRows * tileSize;

            // Background
            mapCtx.fillStyle = '#1a1a1a';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    if ((x + y) % 2 === 0) {
                        mapCtx.fillStyle = '#222';
                        mapCtx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }

            // Grid
            mapCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            for (let x = 0; x <= mapCols; x++) {
                mapCtx.beginPath();
                mapCtx.moveTo(x * tileSize, 0);
                mapCtx.lineTo(x * tileSize, mapCanvas.height);
                mapCtx.stroke();
            }
            for (let y = 0; y <= mapRows; y++) {
                mapCtx.beginPath();
                mapCtx.moveTo(0, y * tileSize);
                mapCtx.lineTo(mapCanvas.width, y * tileSize);
                mapCtx.stroke();
            }

            // Draw all visible layers (bottom to top)
            if (tilesetImg) {
                mapCtx.imageSmoothingEnabled = false;

                for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {
                    // Draw player preview at the right layer position
                    if (layerIdx === playerLayerIndex && playerPreviewVisible) {
                        drawPlayerPreview(tileSize);
                    }

                    if (!layerVisibility[layerIdx]) continue;

                    const layerData = layers[layerIdx];
                    // Dim non-current layers slightly
                    mapCtx.globalAlpha = (layerIdx === currentLayer) ? 1 : 0.7;

                    for (let y = 0; y < mapRows; y++) {
                        for (let x = 0; x < mapCols; x++) {
                            const cell = layerData[y] && layerData[y][x];
                            if (!cell) continue;

                            const px = x * tileSize;
                            const py = y * tileSize;

                            if (cell.type === 'tile') {
                                // Use the correct tileset for this tile
                                const cellTileset = tilesets[cell.tilesetIndex || 0]?.img || tilesetImg;
                                drawRotatedTile(mapCtx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize, cell.rotation || 0);

                                // Show collision only on current layer
                                if (layerIdx === currentLayer) {
                                    // Include tileset index in collision key lookup
                                    const tilesetIdx = cell.tilesetIndex || 0;
                                    const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                                    const collision = tileCollisions[key];
                                    if (collision && collision.length >= 3) {
                                        const scale = tileSize / gridSize;
                                        mapCtx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                                        mapCtx.beginPath();
                                        mapCtx.moveTo(px + collision[0].x * scale, py + collision[0].y * scale);
                                        for (let i = 1; i < collision.length; i++) {
                                            mapCtx.lineTo(px + collision[i].x * scale, py + collision[i].y * scale);
                                        }
                                        mapCtx.closePath();
                                        mapCtx.fill();
                                    }
                                }
                            } else if (cell.type === 'prop') {
                                // Draw prop from the correct prop image
                                const propIdx = cell.propIndex || 0;
                                const propImg = props[propIdx]?.img;
                                if (propImg) {
                                    mapCtx.drawImage(propImg, cell.x, cell.y, gridSize, gridSize, px, py, tileSize, tileSize);
                                }
                            } else if (cell.type === 'animTile') {
                                // Animated tile - cycles through frames (supports multi-tile)
                                const prop = animatedProps[cell.propIndex];
                                if (prop && prop._spriteImg && prop.frames && prop.frames.length > 0) {
                                    // Use origin tile's position for animation sync
                                    const originX = x - (cell.offsetX || 0);
                                    const originY = y - (cell.offsetY || 0);
                                    const key = originX + ',' + originY + ',' + layerIdx;
                                    const animState = placedAnimPropFrames[key] || { frame: 0 };
                                    const frameIdx = animState.frame % prop.frames.length;
                                    const frame = prop.frames[frameIdx];

                                    // Draw only this tile's portion of the frame
                                    const offsetX = cell.offsetX || 0;
                                    const offsetY = cell.offsetY || 0;
                                    const srcX = frame.x + offsetX * gridSize;
                                    const srcY = frame.y + offsetY * gridSize;

                                    mapCtx.imageSmoothingEnabled = false;
                                    mapCtx.drawImage(prop._spriteImg, srcX, srcY, gridSize, gridSize, px, py, tileSize, tileSize);

                                    // Show label in animProp mode (only on origin tile)
                                    if (mode === 'animProp' && offsetX === 0 && offsetY === 0) {
                                        mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
                                        mapCtx.font = '10px sans-serif';
                                        mapCtx.textAlign = 'center';
                                        const nameWidth = mapCtx.measureText(prop.name).width + 4;
                                        mapCtx.fillRect(px + tileSize / 2 - nameWidth / 2, py - 14, nameWidth, 14);
                                        mapCtx.fillStyle = '#fff';
                                        mapCtx.fillText(prop.name, px + tileSize / 2, py - 3);
                                    }
                                }
                            }
                        }
                    }
                }

                // Draw player preview at end if it's beyond all layers
                if (playerLayerIndex >= layers.length && playerPreviewVisible) {
                    drawPlayerPreview(tileSize);
                }

                mapCtx.globalAlpha = 1;
            }

            // Draw copy selection rectangle if in copy mode
            if (copyMode && copyStart && copyEnd) {
                const minX = Math.min(copyStart.x, copyEnd.x);
                const maxX = Math.max(copyStart.x, copyEnd.x);
                const minY = Math.min(copyStart.y, copyEnd.y);
                const maxY = Math.max(copyStart.y, copyEnd.y);

                mapCtx.fillStyle = 'rgba(74, 175, 255, 0.3)';
                mapCtx.fillRect(minX * tileSize, minY * tileSize, (maxX - minX + 1) * tileSize, (maxY - minY + 1) * tileSize);

                mapCtx.strokeStyle = '#4af';
                mapCtx.lineWidth = 3;
                mapCtx.setLineDash([5, 5]);
                mapCtx.strokeRect(minX * tileSize, minY * tileSize, (maxX - minX + 1) * tileSize, (maxY - minY + 1) * tileSize);
                mapCtx.setLineDash([]);
            }

            // Draw transparent preview of selected tiles at hover position
            if (hoverMapPos && selectedTileData && !copyMode) {
                mapCtx.globalAlpha = 0.5;
                const selW = selectedTileData.width || 1;
                const selH = selectedTileData.height || 1;

                // Check if using copied tiles
                if (selectedTileData.isCopied && copiedTiles) {
                    // Draw preview of copied tiles
                    for (let dy = 0; dy < selH; dy++) {
                        for (let dx = 0; dx < selW; dx++) {
                            const mx = hoverMapPos.x + dx;
                            const my = hoverMapPos.y + dy;
                            if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                                const srcCell = copiedTiles[dy] && copiedTiles[dy][dx];
                                if (srcCell) {
                                    const px = mx * tileSize;
                                    const py = my * tileSize;
                                    if (srcCell.type === 'tile') {
                                        const cellTileset = tilesets[srcCell.tilesetIndex || 0]?.img || tilesetImg;
                                        if (cellTileset) {
                                            drawRotatedTile(mapCtx, cellTileset, srcCell.x, srcCell.y, gridSize, px, py, tileSize, srcCell.rotation || 0);
                                        }
                                    } else if (srcCell.type === 'prop') {
                                        const propIdx = srcCell.propIndex || 0;
                                        const propImg = props[propIdx]?.img;
                                        if (propImg) {
                                            mapCtx.drawImage(propImg, srcCell.x, srcCell.y, gridSize, gridSize, px, py, tileSize, tileSize);
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Draw preview from tileset/prop selection
                    const sourceImg = selectedTileData.isProp ? propImage : tilesetImg;

                    if (sourceImg) {
                        for (let dy = 0; dy < selH; dy++) {
                            for (let dx = 0; dx < selW; dx++) {
                                const mx = hoverMapPos.x + dx;
                                const my = hoverMapPos.y + dy;
                                if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                                    const tileX = selectedTileData.x + dx * gridSize;
                                    const tileY = selectedTileData.y + dy * gridSize;
                                    const px = mx * tileSize;
                                    const py = my * tileSize;
                                    if (selectedTileData.isProp) {
                                        mapCtx.drawImage(sourceImg, tileX, tileY, gridSize, gridSize, px, py, tileSize, tileSize);
                                    } else {
                                        drawRotatedTile(mapCtx, sourceImg, tileX, tileY, gridSize, px, py, tileSize, tileRotation);
                                    }
                                }
                            }
                        }
                    }
                }

                // Draw outline
                mapCtx.globalAlpha = 1;
                mapCtx.strokeStyle = selectedTileData.isCopied ? '#ff0' : (selectedTileData.isProp ? '#4af' : '#0f0');
                mapCtx.lineWidth = 2;
                mapCtx.strokeRect(
                    hoverMapPos.x * tileSize,
                    hoverMapPos.y * tileSize,
                    selW * tileSize,
                    selH * tileSize
                );
            }

            // Draw animated prop placement preview when hovering in animProp mode
            if (mode === 'animProp' && hoverMapPos && currentAnimPropIndex >= 0 && !copyMode) {
                const prop = animatedProps[currentAnimPropIndex];
                if (prop) {
                    const frames = prop.frames || [];
                    const spriteImg = prop._spriteImg;
                    const drawX = hoverMapPos.x * tileSize;
                    const drawY = hoverMapPos.y * tileSize;

                    mapCtx.globalAlpha = 0.5;
                    if (spriteImg && frames.length > 0) {
                        const frame = frames[0];
                        // Calculate how many tiles this prop spans
                        const tilesW = Math.ceil(frame.w / gridSize);
                        const tilesH = Math.ceil(frame.h / gridSize);
                        const drawW = tilesW * tileSize;
                        const drawH = tilesH * tileSize;

                        mapCtx.imageSmoothingEnabled = false;
                        mapCtx.drawImage(spriteImg, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);

                        mapCtx.globalAlpha = 1;
                        // Draw outline around full prop area
                        mapCtx.strokeStyle = '#f0a';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(drawX, drawY, drawW, drawH);
                    } else {
                        // Placeholder preview
                        mapCtx.fillStyle = '#f0a';
                        mapCtx.fillRect(drawX + 2, drawY + 2, tileSize - 4, tileSize - 4);
                        mapCtx.globalAlpha = 1;
                        mapCtx.strokeStyle = '#f0a';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(drawX, drawY, tileSize, tileSize);
                    }
                }
            }

            // Update expand button positions after canvas resize
            positionExpandButtons();
        }

        // Zoom
        function zoomIn() { if (zoom < 4) { zoom++; document.getElementById('zoomLevel').textContent = zoom + 'x'; renderMap(); } }
        function zoomOut() { if (zoom > 1) { zoom--; document.getElementById('zoomLevel').textContent = zoom + 'x'; renderMap(); } }

        // Only zoom with scroll when grab tool is active
        document.getElementById('mapViewport').addEventListener('wheel', (e) => {
            if (grabToolActive) {
                e.preventDefault();
                if (e.deltaY < 0) zoomIn(); else zoomOut();
            }
        });

        function clearMap() { if (confirm('Clear entire map?')) { initMap(); mapInitialized = true; renderMap(); } }

        // ===== GRAB TOOL =====
        let grabToolActive = false;
        let grabbing = false;
        let grabStartX = 0;
        let grabStartY = 0;
        let grabScrollX = 0;
        let grabScrollY = 0;

        function toggleGrabTool() {
            grabToolActive = !grabToolActive;
            const btn = document.getElementById('grabToolBtn');
            const canvas = document.getElementById('mapCanvas');
            const hint = document.getElementById('toolHint');

            if (grabToolActive) {
                btn.style.background = '#4af';
                btn.style.color = '#000';
                canvas.classList.add('grabbing');
                hint.textContent = 'Drag to pan | Scroll to zoom';
            } else {
                btn.style.background = '#555';
                btn.style.color = 'white';
                canvas.classList.remove('grabbing');
                hint.textContent = 'Left: paint | Right: erase';
            }
        }

        // Grab/pan handlers
        const mapViewport = document.getElementById('mapViewport');

        mapCanvas.addEventListener('mousedown', (e) => {
            if (grabToolActive && e.button === 0) {
                grabbing = true;
                grabStartX = e.clientX;
                grabStartY = e.clientY;
                grabScrollX = mapViewport.scrollLeft;
                grabScrollY = mapViewport.scrollTop;
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (grabbing) {
                const dx = e.clientX - grabStartX;
                const dy = e.clientY - grabStartY;
                mapViewport.scrollLeft = grabScrollX - dx;
                mapViewport.scrollTop = grabScrollY - dy;
            }
        });

        document.addEventListener('mouseup', () => {
            grabbing = false;
        });

        // ===== EXPAND MAP =====
        function expandMap(direction) {
            const expandAmount = 5; // Add 5 rows/cols at a time

            if (direction === 'right') {
                mapCols += expandAmount;
                layers.forEach(layer => {
                    for (let y = 0; y < layer.length; y++) {
                        for (let i = 0; i < expandAmount; i++) {
                            layer[y].push(null);
                        }
                    }
                });
            } else if (direction === 'left') {
                mapCols += expandAmount;
                layers.forEach(layer => {
                    for (let y = 0; y < layer.length; y++) {
                        for (let i = 0; i < expandAmount; i++) {
                            layer[y].unshift(null);
                        }
                    }
                });
                // Shift placed animated props
                placedAnimProps.forEach(ap => ap.x += expandAmount);
                // Shift placed props
                placedProps.forEach(prop => prop.x += expandAmount);
            } else if (direction === 'bottom') {
                mapRows += expandAmount;
                layers.forEach(layer => {
                    for (let i = 0; i < expandAmount; i++) {
                        const newRow = [];
                        for (let x = 0; x < mapCols; x++) newRow.push(null);
                        layer.push(newRow);
                    }
                });
            } else if (direction === 'top') {
                mapRows += expandAmount;
                layers.forEach(layer => {
                    for (let i = 0; i < expandAmount; i++) {
                        const newRow = [];
                        for (let x = 0; x < mapCols; x++) newRow.push(null);
                        layer.unshift(newRow);
                    }
                });
                // Shift placed animated props
                placedAnimProps.forEach(ap => ap.y += expandAmount);
                // Shift placed props
                placedProps.forEach(prop => prop.y += expandAmount);
            }

            renderMap();
        }

        // Position expand buttons at map edges
        function positionExpandButtons() {
            const canvas = document.getElementById('mapCanvas');
            const viewport = document.getElementById('mapViewport');
            if (!canvas || !viewport) return;

            const padding = 40; // viewport padding
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            const topBtn = document.querySelector('.expand-top');
            const bottomBtn = document.querySelector('.expand-bottom');
            const leftBtn = document.querySelector('.expand-left');
            const rightBtn = document.querySelector('.expand-right');

            if (topBtn) {
                topBtn.style.left = (padding + canvasWidth / 2 - 30) + 'px';
            }
            if (bottomBtn) {
                bottomBtn.style.left = (padding + canvasWidth / 2 - 30) + 'px';
                bottomBtn.style.top = (padding + canvasHeight + 5) + 'px';
            }
            if (leftBtn) {
                leftBtn.style.top = (padding + canvasHeight / 2 - 30) + 'px';
            }
            if (rightBtn) {
                rightBtn.style.left = (padding + canvasWidth + 5) + 'px';
                rightBtn.style.top = (padding + canvasHeight / 2 - 30) + 'px';
            }
        }

        // ===== MULTIPLE PROPS SYSTEM =====
        // Props work just like tilesets - load images, select area, paint on map
        // Each prop has its own collision masks

        function loadPropImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Save current prop's collision masks before switching
                    if (currentPropIndex >= 0 && props[currentPropIndex]) {
                        props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
                    }

                    // Add new prop to array
                    const newProp = {
                        name: file.name,
                        img: img,
                        data: e.target.result,
                        collisionMasks: {}
                    };
                    props.push(newProp);
                    currentPropIndex = props.length - 1;

                    // Set current prop shortcuts
                    propImage = img;
                    propImageData = e.target.result;
                    propCollisionMasks = newProp.collisionMasks;
                    propSelection = null;

                    updatePropDropdown();
                    updatePropUI();
                    drawPropTileset();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function switchProp() {
            const select = document.getElementById('propSelect');
            const newIndex = parseInt(select.value);

            // Save current prop's collision masks
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Switch to new prop
            currentPropIndex = newIndex;
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                propImage = props[currentPropIndex].img;
                propImageData = props[currentPropIndex].data;
                propCollisionMasks = props[currentPropIndex].collisionMasks || {};
            } else {
                propImage = null;
                propImageData = null;
                propCollisionMasks = {};
            }

            propSelection = null;
            updatePropUI();
            drawPropTileset();
            renderMap();
        }

        function updatePropDropdown() {
            const select = document.getElementById('propSelect');
            if (!select) return;
            select.innerHTML = '';

            if (props.length === 0) {
                const opt = document.createElement('option');
                opt.value = -1;
                opt.textContent = 'No props loaded';
                select.appendChild(opt);
            } else {
                props.forEach((prop, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = prop.name;
                    if (i === currentPropIndex) opt.selected = true;
                    select.appendChild(opt);
                });
            }
        }

        function updatePropUI() {
            const propControls = document.getElementById('propControls');
            const noPropMessage = document.getElementById('noPropMessage');
            if (!propControls || !noPropMessage) return;
            const hasProps = props.length > 0 && currentPropIndex >= 0;
            propControls.style.display = hasProps ? 'block' : 'none';
            noPropMessage.style.display = hasProps ? 'none' : 'block';
        }

        function drawPropTileset() {
            if (!propImage) {
                propTilesetCanvas.width = 200;
                propTilesetCanvas.height = 50;
                propTilesetCtx.fillStyle = '#333';
                propTilesetCtx.fillRect(0, 0, 200, 50);
                propTilesetCtx.fillStyle = '#888';
                propTilesetCtx.font = '12px sans-serif';
                propTilesetCtx.fillText('Load a prop image...', 20, 30);
                return;
            }

            const displayZoom = 3; // Larger zoom for easier collision painting
            propTilesetCanvas.width = propImage.naturalWidth * displayZoom;
            propTilesetCanvas.height = propImage.naturalHeight * displayZoom;

            propTilesetCtx.imageSmoothingEnabled = false;
            propTilesetCtx.drawImage(propImage, 0, 0, propTilesetCanvas.width, propTilesetCanvas.height);

            // Draw collision overlay (red pixels where collision is set)
            if (propTool === 'collision' || propTool === 'erase') {
                const cols = Math.floor(propImage.naturalWidth / gridSize);
                const rows = Math.floor(propImage.naturalHeight / gridSize);

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const tileX = col * gridSize;
                        const tileY = row * gridSize;
                        const key = tileX + ',' + tileY;
                        const mask = propCollisionMasks[key];

                        if (mask) {
                            for (let py = 0; py < gridSize; py++) {
                                for (let px = 0; px < gridSize; px++) {
                                    if (mask[py] && mask[py][px]) {
                                        propTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                                        propTilesetCtx.fillRect(
                                            (tileX + px) * displayZoom,
                                            (tileY + py) * displayZoom,
                                            displayZoom,
                                            displayZoom
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Grid
            propTilesetCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            const cols = Math.floor(propImage.naturalWidth / gridSize);
            const rows = Math.floor(propImage.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                propTilesetCtx.beginPath();
                propTilesetCtx.moveTo(x * gridSize * displayZoom, 0);
                propTilesetCtx.lineTo(x * gridSize * displayZoom, propTilesetCanvas.height);
                propTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                propTilesetCtx.beginPath();
                propTilesetCtx.moveTo(0, y * gridSize * displayZoom);
                propTilesetCtx.lineTo(propTilesetCanvas.width, y * gridSize * displayZoom);
                propTilesetCtx.stroke();
            }

            // Highlight selection (only in select mode)
            if (propSelection && propTool === 'select') {
                propTilesetCtx.fillStyle = 'rgba(74, 175, 255, 0.4)';
                propTilesetCtx.strokeStyle = '#4af';
                propTilesetCtx.lineWidth = 2;
                propTilesetCtx.fillRect(
                    propSelection.x * displayZoom,
                    propSelection.y * displayZoom,
                    propSelection.width * displayZoom,
                    propSelection.height * displayZoom
                );
                propTilesetCtx.strokeRect(
                    propSelection.x * displayZoom,
                    propSelection.y * displayZoom,
                    propSelection.width * displayZoom,
                    propSelection.height * displayZoom
                );
            }
        }

        // Prop tileset selection and collision painting
        let propSelectionStart = null;

        function paintPropCollisionAt(canvasX, canvasY, isErasing) {
            const displayZoom = 3;
            const imgX = Math.floor(canvasX / displayZoom);
            const imgY = Math.floor(canvasY / displayZoom);

            // Find which tile this pixel belongs to
            const tileCol = Math.floor(imgX / gridSize);
            const tileRow = Math.floor(imgY / gridSize);
            const tileX = tileCol * gridSize;
            const tileY = tileRow * gridSize;
            const key = tileX + ',' + tileY;

            // Initialize mask if needed
            if (!propCollisionMasks[key]) {
                propCollisionMasks[key] = [];
                for (let y = 0; y < gridSize; y++) {
                    propCollisionMasks[key][y] = new Array(gridSize).fill(false);
                }
            }

            // Paint with brush
            const halfBrush = Math.floor(propBrushSize / 2);
            for (let dy = -halfBrush; dy < halfBrush; dy++) {
                for (let dx = -halfBrush; dx < halfBrush; dx++) {
                    const px = imgX + dx;
                    const py = imgY + dy;

                    // Get the tile for this pixel
                    const ptileCol = Math.floor(px / gridSize);
                    const ptileRow = Math.floor(py / gridSize);
                    const ptileX = ptileCol * gridSize;
                    const ptileY = ptileRow * gridSize;
                    const pkey = ptileX + ',' + ptileY;

                    // Local coords within tile
                    const localX = px - ptileX;
                    const localY = py - ptileY;

                    if (localX >= 0 && localX < gridSize && localY >= 0 && localY < gridSize) {
                        if (!propCollisionMasks[pkey]) {
                            propCollisionMasks[pkey] = [];
                            for (let y = 0; y < gridSize; y++) {
                                propCollisionMasks[pkey][y] = new Array(gridSize).fill(false);
                            }
                        }
                        propCollisionMasks[pkey][localY][localX] = !isErasing;
                    }
                }
            }

            drawPropTileset();
        }

        propTilesetCanvas.addEventListener('mousedown', (e) => {
            if (!propImage) return;
            const rect = propTilesetCanvas.getBoundingClientRect();
            const displayZoom = 3;

            if (propTool === 'select') {
                // Tile selection mode
                const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
                const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;
                propSelectionStart = { x, y };
            } else {
                // Collision painting mode
                propPainting = true;
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                paintPropCollisionAt(canvasX, canvasY, propTool === 'erase');
            }
        });

        propTilesetCanvas.addEventListener('mousemove', (e) => {
            if (!propImage || !propPainting) return;
            if (propTool === 'collision' || propTool === 'erase') {
                const rect = propTilesetCanvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                paintPropCollisionAt(canvasX, canvasY, propTool === 'erase');
            }
        });

        propTilesetCanvas.addEventListener('mouseup', (e) => {
            if (!propImage) return;

            if (propTool === 'select' && propSelectionStart) {
                const rect = propTilesetCanvas.getBoundingClientRect();
                const displayZoom = 3;
                const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
                const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

                const minX = Math.min(propSelectionStart.x, x);
                const minY = Math.min(propSelectionStart.y, y);
                const maxX = Math.max(propSelectionStart.x, x) + gridSize;
                const maxY = Math.max(propSelectionStart.y, y) + gridSize;

                propSelection = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };

                // When in prop mode, set this as the selected tile data for painting
                if (mode === 'prop') {
                    selectedTileData = {
                        x: minX,
                        y: minY,
                        width: (maxX - minX) / gridSize,
                        height: (maxY - minY) / gridSize,
                        isProp: true // Flag to indicate this is from prop image
                    };
                }

                propSelectionStart = null;
                drawPropTileset();
            }

            propPainting = false;
        });

        propTilesetCanvas.addEventListener('mouseleave', () => {
            propPainting = false;
        });

        propTilesetCanvas.style.cursor = 'crosshair';

        // Expand map size
        function expandMapRows() {
            mapRows += 10;
            layers.forEach(layer => {
                while (layer.length < mapRows) {
                    layer.push(new Array(mapCols).fill(null));
                }
            });
        }

        function expandMapCols() {
            mapCols += 10;
            layers.forEach(layer => {
                layer.forEach((row, i) => {
                    if (row) {
                        while (row.length < mapCols) row.push(null);
                    }
                });
            });
        }

        // ===== ANIMATED PROPS FUNCTIONS =====
        let animPropEditorImage = null;
        let animPropEditorData = null;
        let animPropEditorFrameW = 16;
        let animPropEditorFrameH = 16;
        let animPropEditorEditingIndex = -1;
        let animPropTool = 'none'; // 'none', 'collision', 'erase', 'split'
        let animPropCollisionMask = null; // 2D array for collision pixels
        let animPropSplitLine = null; // Array of Y values per column (like tileSplitLines)
        let animPropPainting = false;

        function openAnimPropEditor(editIndex = -1) {
            // Stop any running preview from previous session
            animPropStopPreview();

            animPropEditorEditingIndex = editIndex;
            animPropFrames = [];

            // Reset collision/split tool state
            animPropTool = 'none';
            setAnimPropTool('none');

            if (editIndex >= 0 && animatedProps[editIndex]) {
                // Editing existing
                const prop = animatedProps[editIndex];
                animPropEditorFrameW = prop.frameWidth || 16;
                animPropEditorFrameH = prop.frameHeight || 16;
                animPropFrames = JSON.parse(JSON.stringify(prop.frames || []));
                animPropEditorData = prop.spriteData;
                document.getElementById('animPropNameInput').value = prop.name;
                document.getElementById('animPropType').value = prop.type || 'loop';
                const fps = prop.fps || 8;
                document.getElementById('animPropSpeedSlider').value = fps;
                document.getElementById('animPropSpeedLabel').textContent = fps + ' fps';

                // Load existing collision/split data
                animPropCollisionMask = prop.collisionMask ? JSON.parse(JSON.stringify(prop.collisionMask)) : null;
                animPropSplitLine = prop.splitLine ? JSON.parse(JSON.stringify(prop.splitLine)) : null;

                if (prop.spriteData) {
                    animPropEditorImage = new Image();
                    animPropEditorImage.onload = () => {
                        document.getElementById('animPropFrameSection').style.display = 'block';
                        document.getElementById('animPropTypeSection').style.display = 'block';
                        document.getElementById('animPropCollisionSection').style.display = 'block';
                        document.getElementById('animPropNameSection').style.display = 'block';
                        animPropDrawCanvas();
                        animPropUpdateFramesList();
                    };
                    animPropEditorImage.src = prop.spriteData;
                    document.getElementById('animPropFileName').textContent = 'Sprite loaded';
                }
            } else {
                // New prop - default frame size to match grid size
                animPropEditorImage = null;
                animPropEditorData = null;
                animPropEditorFrameW = gridSize;
                animPropEditorFrameH = gridSize;
                animPropCollisionMask = null;
                animPropSplitLine = null;
                animPropFrames = []; // Ensure frames list is cleared
                document.getElementById('animPropNameInput').value = '';
                document.getElementById('animPropType').value = 'loop';
                document.getElementById('animPropSpeedSlider').value = 8;
                document.getElementById('animPropSpeedLabel').textContent = '8 fps';
                document.getElementById('animPropFileName').textContent = '';
                document.getElementById('animPropFrameSection').style.display = 'none';
                document.getElementById('animPropTypeSection').style.display = 'none';
                document.getElementById('animPropCollisionSection').style.display = 'none';
                document.getElementById('animPropNameSection').style.display = 'none';
                // Clear live preview
                const previewCtx = document.getElementById('animPropLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 48, 48);
                // Clear editor canvas
                const editorCanvas = document.getElementById('animPropEditorCanvas');
                const editorCtx = editorCanvas.getContext('2d');
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                // Clear frames list display
                const framesList = document.getElementById('animPropFramesList');
                if (framesList) framesList.innerHTML = '';
                // Reset file input
                const fileInput = document.getElementById('animPropFileInput');
                if (fileInput) fileInput.value = '';
            }

            document.getElementById('animPropFrameW').value = animPropEditorFrameW;
            document.getElementById('animPropFrameH').value = animPropEditorFrameH;
            animPropUpdateFramesList();

            document.getElementById('animPropModal').classList.add('visible');
        }

        function animPropLoadSheet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                animPropEditorData = e.target.result;
                animPropEditorImage = new Image();
                animPropEditorImage.onload = () => {
                    document.getElementById('animPropFileName').textContent = file.name + ' (' + animPropEditorImage.naturalWidth + 'x' + animPropEditorImage.naturalHeight + ')';
                    document.getElementById('animPropFrameSection').style.display = 'block';
                    document.getElementById('animPropTypeSection').style.display = 'block';
                    document.getElementById('animPropCollisionSection').style.display = 'block';
                    document.getElementById('animPropNameSection').style.display = 'block';

                    // Reset collision/split for new sheet
                    animPropCollisionMask = null;
                    animPropSplitLine = null;

                    // Auto-suggest frame size
                    const w = animPropEditorImage.naturalWidth;
                    const h = animPropEditorImage.naturalHeight;
                    const sizes = [16, 32, 24, 48, 64];
                    for (const size of sizes) {
                        if (w % size === 0 && h % size === 0) {
                            animPropEditorFrameW = size;
                            animPropEditorFrameH = size;
                            break;
                        }
                    }
                    document.getElementById('animPropFrameW').value = animPropEditorFrameW;
                    document.getElementById('animPropFrameH').value = animPropEditorFrameH;

                    animPropUpdateGrid();
                    animPropDrawCanvas();
                };
                animPropEditorImage.src = animPropEditorData;
            };
            reader.readAsDataURL(file);
        }

        function animPropUpdateGrid() {
            animPropEditorFrameW = parseInt(document.getElementById('animPropFrameW').value) || 16;
            animPropEditorFrameH = parseInt(document.getElementById('animPropFrameH').value) || 16;

            if (animPropEditorImage) {
                const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
                const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);
                document.getElementById('animPropGridInfo').textContent = cols + ' cols x ' + rows + ' rows';
            }

            animPropDrawCanvas();
        }

        function animPropDrawCanvas() {
            const canvas = document.getElementById('animPropEditorCanvas');
            const ctx = canvas.getContext('2d');

            if (!animPropEditorImage) {
                canvas.width = 400;
                canvas.height = 300;
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Load a sprite sheet to begin', 200, 150);
                return;
            }

            const scale = 3;
            canvas.width = animPropEditorImage.naturalWidth * scale;
            canvas.height = animPropEditorImage.naturalHeight * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(animPropEditorImage, 0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
            const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);

            for (let x = 0; x <= cols; x++) {
                ctx.beginPath();
                ctx.moveTo(x * animPropEditorFrameW * scale, 0);
                ctx.lineTo(x * animPropEditorFrameW * scale, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * animPropEditorFrameH * scale);
                ctx.lineTo(canvas.width, y * animPropEditorFrameH * scale);
                ctx.stroke();
            }

            // Highlight selected frames
            ctx.strokeStyle = '#4af';
            ctx.lineWidth = 3;
            animPropFrames.forEach((frame, i) => {
                ctx.strokeRect(frame.x * scale + 2, frame.y * scale + 2, frame.w * scale - 4, frame.h * scale - 4);
                ctx.fillStyle = '#4af';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(i + 1, frame.x * scale + 6, frame.y * scale + 18);
            });

            // Draw current drag selection
            if (animPropIsDragging && animPropDragStart && animPropDragEnd) {
                const startGX = Math.min(animPropDragStart.gridX, animPropDragEnd.gridX);
                const startGY = Math.min(animPropDragStart.gridY, animPropDragEnd.gridY);
                const endGX = Math.max(animPropDragStart.gridX, animPropDragEnd.gridX);
                const endGY = Math.max(animPropDragStart.gridY, animPropDragEnd.gridY);

                const selX = startGX * animPropEditorFrameW * scale;
                const selY = startGY * animPropEditorFrameH * scale;
                const selW = (endGX - startGX + 1) * animPropEditorFrameW * scale;
                const selH = (endGY - startGY + 1) * animPropEditorFrameH * scale;

                ctx.fillStyle = 'rgba(74, 170, 255, 0.3)';
                ctx.fillRect(selX, selY, selW, selH);
                ctx.strokeStyle = '#4af';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(selX, selY, selW, selH);
                ctx.setLineDash([]);
            }

            // Draw collision mask overlay on first frame area
            if (animPropFrames.length > 0 && animPropCollisionMask) {
                const frame = animPropFrames[0];
                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                for (let py = 0; py < animPropCollisionMask.length; py++) {
                    if (!animPropCollisionMask[py]) continue;
                    for (let px = 0; px < animPropCollisionMask[py].length; px++) {
                        if (animPropCollisionMask[py][px]) {
                            ctx.fillRect(
                                (frame.x + px) * scale,
                                (frame.y + py) * scale,
                                scale, scale
                            );
                        }
                    }
                }
            }

            // Draw split line overlay on ALL frames - per tile
            if (animPropFrames.length > 0 && animPropSplitLine && typeof animPropSplitLine === 'object') {
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                ctx.font = 'bold 10px sans-serif';
                ctx.fillStyle = '#0ff';

                // Draw on every frame
                for (const frame of animPropFrames) {
                    const tilesW = Math.ceil(frame.w / gridSize);
                    const tilesH = Math.ceil(frame.h / gridSize);

                    for (let ty = 0; ty < tilesH; ty++) {
                        for (let tx = 0; tx < tilesW; tx++) {
                            const key = tx + ',' + ty;
                            const splitY = animPropSplitLine[key];
                            if (splitY === undefined || splitY === null) continue;

                            const tileStartX = frame.x + tx * gridSize;
                            const tileStartY = frame.y + ty * gridSize;

                            // Draw horizontal line across this tile
                            ctx.beginPath();
                            ctx.moveTo(tileStartX * scale, (tileStartY + splitY) * scale);
                            ctx.lineTo((tileStartX + gridSize) * scale, (tileStartY + splitY) * scale);
                            ctx.stroke();

                            // Draw C/T labels (smaller for per-tile)
                            ctx.fillText('C', tileStartX * scale + 2, (tileStartY + splitY / 2) * scale + 5);
                            ctx.fillText('T', tileStartX * scale + 2, (tileStartY + splitY + (gridSize - splitY) / 2) * scale + 5);
                        }
                    }
                }
            }
        }

        // Animated prop editor brush size
        let animPropBrushSize = 4;
        let animPropFlatLineY = null; // Y position locked when flat line mode + dragging

        // Tool switching for animated prop editor
        function setAnimPropTool(tool) {
            animPropTool = tool;
            ['None', 'Collision', 'Erase', 'Split'].forEach(t => {
                const btn = document.getElementById('animPropTool' + t);
                if (btn) btn.classList.toggle('active', t.toLowerCase() === tool);
            });

            // Show/hide brush section for collision/erase tools
            const brushSection = document.getElementById('animPropBrushSection');
            if (brushSection) {
                brushSection.style.display = (tool === 'collision' || tool === 'erase') ? 'block' : 'none';
            }

            // Show/hide split controls
            const splitControls = document.getElementById('animPropSplitControls');
            if (splitControls) {
                splitControls.style.display = (tool === 'split') ? 'block' : 'none';
            }
        }

        function setAnimPropBrush(size) {
            animPropBrushSize = size;
            [1, 2, 4, 8].forEach(s => {
                const btn = document.getElementById('animPropBrush' + s);
                if (btn) btn.classList.toggle('active', s === size);
            });
        }

        function setAnimPropSplitY() {
            const yVal = parseInt(document.getElementById('animPropSplitY').value) || 8;
            if (animPropFrames.length === 0) return;

            // Initialize split lines object if needed
            if (!animPropSplitLine || typeof animPropSplitLine !== 'object' || Array.isArray(animPropSplitLine)) {
                animPropSplitLine = {};
            }

            // Set same Y for all tiles in the prop
            const frame = animPropFrames[0];
            const tilesW = Math.ceil(frame.w / gridSize);
            const tilesH = Math.ceil(frame.h / gridSize);

            for (let ty = 0; ty < tilesH; ty++) {
                for (let tx = 0; tx < tilesW; tx++) {
                    const key = tx + ',' + ty;
                    animPropSplitLine[key] = Math.max(0, Math.min(gridSize, yVal));
                }
            }
            animPropDrawCanvas();
        }

        function clearAnimPropSplit() {
            animPropSplitLine = null;
            animPropDrawCanvas();
        }

        // Collision/split painting helpers
        function animPropPaintCollision(px, py, erase) {
            if (animPropFrames.length === 0) return;

            // Find which frame was clicked (can be any frame)
            let clickedFrame = null;
            for (const frame of animPropFrames) {
                if (px >= frame.x && px < frame.x + frame.w &&
                    py >= frame.y && py < frame.y + frame.h) {
                    clickedFrame = frame;
                    break;
                }
            }
            if (!clickedFrame) return;

            // Use first frame dimensions for mask size
            const frame0 = animPropFrames[0];

            // Initialize mask if needed
            if (!animPropCollisionMask) {
                animPropCollisionMask = [];
                for (let y = 0; y < frame0.h; y++) {
                    animPropCollisionMask[y] = new Array(frame0.w).fill(false);
                }
            }

            // Calculate position relative to clicked frame
            const localX = px - clickedFrame.x;
            const localY = py - clickedFrame.y;

            if (localX < 0 || localX >= frame0.w || localY < 0 || localY >= frame0.h) return;

            // Paint with brush size
            const halfBrush = Math.floor(animPropBrushSize / 2);
            for (let dy = -halfBrush; dy < animPropBrushSize - halfBrush; dy++) {
                for (let dx = -halfBrush; dx < animPropBrushSize - halfBrush; dx++) {
                    const bx = localX + dx;
                    const by = localY + dy;
                    if (bx >= 0 && bx < frame0.w && by >= 0 && by < frame0.h) {
                        if (!animPropCollisionMask[by]) animPropCollisionMask[by] = [];
                        animPropCollisionMask[by][bx] = !erase;
                    }
                }
            }
        }

        function animPropPaintSplit(px, py, isStart = false) {
            if (animPropFrames.length === 0) return;

            // Find which frame was clicked (can be any frame, not just first)
            let clickedFrame = null;
            for (const frame of animPropFrames) {
                if (px >= frame.x && px < frame.x + frame.w &&
                    py >= frame.y && py < frame.y + frame.h) {
                    clickedFrame = frame;
                    break;
                }
            }
            if (!clickedFrame) return;

            // Calculate which tile within the frame was clicked
            const localX = px - clickedFrame.x;
            const localY = py - clickedFrame.y;

            const tileX = Math.floor(localX / gridSize);
            const tileY = Math.floor(localY / gridSize);

            // Y position within the tile
            const tileLocalY = localY - (tileY * gridSize);
            // Round to nearest pixel, and snap to gridSize if in bottom 2 pixels (allows full tile split)
            let clampedY = Math.round(tileLocalY);
            if (tileLocalY >= gridSize - 2) clampedY = gridSize;
            clampedY = Math.max(0, Math.min(gridSize, clampedY));

            // Check flat line mode
            const flatLineCheckbox = document.getElementById('animPropFlatLine');
            const flatLineMode = flatLineCheckbox && flatLineCheckbox.checked;

            if (flatLineMode) {
                if (isStart) {
                    // Lock Y on first click
                    animPropFlatLineY = clampedY;
                } else if (animPropFlatLineY !== null) {
                    // Use locked Y for subsequent drags
                    clampedY = animPropFlatLineY;
                }
            }

            // Initialize split lines object if needed: key "tileX,tileY" -> splitY
            if (!animPropSplitLine || typeof animPropSplitLine !== 'object' || Array.isArray(animPropSplitLine)) {
                animPropSplitLine = {};
            }

            const key = tileX + ',' + tileY;
            animPropSplitLine[key] = clampedY;
        }

        // Canvas drag handlers for animated prop editor (multi-tile selection)
        document.getElementById('animPropEditorCanvas').addEventListener('mousedown', function(e) {
            if (!animPropEditorImage) return;

            const rect = this.getBoundingClientRect();
            const scale = 3;
            const clickX = (e.clientX - rect.left) / scale;
            const clickY = (e.clientY - rect.top) / scale;

            if (animPropTool === 'collision' || animPropTool === 'erase') {
                animPropPainting = true;
                animPropPaintCollision(Math.floor(clickX), Math.floor(clickY), animPropTool === 'erase');
                animPropDrawCanvas();
            } else if (animPropTool === 'split') {
                animPropPainting = true;
                animPropPaintSplit(Math.floor(clickX), Math.floor(clickY), true); // isStart = true
                animPropDrawCanvas();
            } else {
                // Frame selection mode
                const gridX = Math.floor(clickX / animPropEditorFrameW);
                const gridY = Math.floor(clickY / animPropEditorFrameH);

                animPropDragStart = { gridX, gridY };
                animPropDragEnd = { gridX, gridY };
                animPropIsDragging = true;
                animPropDrawCanvas();
            }
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mousemove', function(e) {
            if (!animPropEditorImage) return;

            const rect = this.getBoundingClientRect();
            const scale = 3;
            const clickX = (e.clientX - rect.left) / scale;
            const clickY = (e.clientY - rect.top) / scale;

            if (animPropPainting) {
                if (animPropTool === 'collision' || animPropTool === 'erase') {
                    animPropPaintCollision(Math.floor(clickX), Math.floor(clickY), animPropTool === 'erase');
                    animPropDrawCanvas();
                } else if (animPropTool === 'split') {
                    animPropPaintSplit(Math.floor(clickX), Math.floor(clickY));
                    animPropDrawCanvas();
                }
            } else if (animPropIsDragging) {
                const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
                const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);

                const gridX = Math.max(0, Math.min(cols - 1, Math.floor(clickX / animPropEditorFrameW)));
                const gridY = Math.max(0, Math.min(rows - 1, Math.floor(clickY / animPropEditorFrameH)));

                animPropDragEnd = { gridX, gridY };
                animPropDrawCanvas();
            }
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mouseup', function(e) {
            if (!animPropEditorImage) return;

            if (animPropPainting) {
                animPropPainting = false;
                animPropFlatLineY = null; // Reset flat line Y lock
                return;
            }

            if (!animPropIsDragging) return;
            animPropIsDragging = false;

            // Calculate selection rectangle
            const startGX = Math.min(animPropDragStart.gridX, animPropDragEnd.gridX);
            const startGY = Math.min(animPropDragStart.gridY, animPropDragEnd.gridY);
            const endGX = Math.max(animPropDragStart.gridX, animPropDragEnd.gridX);
            const endGY = Math.max(animPropDragStart.gridY, animPropDragEnd.gridY);

            const frameX = startGX * animPropEditorFrameW;
            const frameY = startGY * animPropEditorFrameH;
            const frameW = (endGX - startGX + 1) * animPropEditorFrameW;
            const frameH = (endGY - startGY + 1) * animPropEditorFrameH;

            if (frameX >= animPropEditorImage.naturalWidth || frameY >= animPropEditorImage.naturalHeight) return;

            animPropFrames.push({
                x: frameX,
                y: frameY,
                w: frameW,
                h: frameH
            });

            animPropDragStart = null;
            animPropDragEnd = null;
            animPropDrawCanvas();
            animPropUpdateFramesList();
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mouseleave', function(e) {
            animPropPainting = false;
            if (animPropIsDragging) {
                animPropIsDragging = false;
                animPropDragStart = null;
                animPropDragEnd = null;
                animPropDrawCanvas();
            }
        });

        function animPropUpdateFramesList() {
            const container = document.getElementById('animPropFramesList');
            container.innerHTML = '';
            document.getElementById('animPropFrameCount').textContent = animPropFrames.length;

            if (animPropFrames.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px;">Click or drag on sprite sheet to select frames</div>';
                animPropStopPreview();
                // Clear live preview
                const previewCtx = document.getElementById('animPropLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 48, 48);
                return;
            }

            animPropFrames.forEach((frame, i) => {
                const thumb = document.createElement('div');
                thumb.className = 'anim-frame-thumb';

                const canvas = document.createElement('canvas');
                canvas.width = 48;
                canvas.height = 48;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;

                const scale = Math.min(48 / frame.w, 48 / frame.h);
                const drawW = frame.w * scale;
                const drawH = frame.h * scale;
                const drawX = (48 - drawW) / 2;
                const drawY = (48 - drawH) / 2;

                ctx.drawImage(animPropEditorImage, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);

                const num = document.createElement('span');
                num.className = 'frame-num';
                num.textContent = i + 1;

                thumb.appendChild(canvas);
                thumb.appendChild(num);
                thumb.onclick = () => {
                    animPropFrames.splice(i, 1);
                    animPropUpdateFramesList();
                    animPropDrawCanvas();
                };
                thumb.title = 'Click to remove';

                container.appendChild(thumb);
            });

            // Auto-start live preview when frames exist
            animPropStartLivePreview();
        }

        function animPropClearFrames() {
            if (!confirm('Clear all frames?')) return;
            animPropFrames = [];
            animPropUpdateFramesList();
            animPropDrawCanvas();
        }

        // Live animation preview - starts automatically when frames are added
        function animPropStartLivePreview() {
            if (animPropPreviewInterval) return; // Already running
            if (animPropFrames.length === 0) return;

            animPropPreviewFrame = 0;
            const fps = parseInt(document.getElementById('animPropSpeedSlider').value) || 8;

            animPropPreviewInterval = setInterval(() => {
                animPropPreviewFrame = (animPropPreviewFrame + 1) % animPropFrames.length;
                animPropDrawLivePreview();

                // Highlight current frame in list
                const thumbs = document.querySelectorAll('.anim-frame-thumb');
                thumbs.forEach((t, i) => {
                    t.style.borderColor = i === animPropPreviewFrame ? '#0f0' : '#4af';
                });
            }, 1000 / fps);
        }

        function animPropStopPreview() {
            if (animPropPreviewInterval) {
                clearInterval(animPropPreviewInterval);
                animPropPreviewInterval = null;
            }
            const thumbs = document.querySelectorAll('.anim-frame-thumb');
            thumbs.forEach(t => t.style.borderColor = '#4af');
        }

        function animPropDrawLivePreview() {
            const canvas = document.getElementById('animPropLivePreview');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 48, 48);

            if (!animPropEditorImage || animPropFrames.length === 0) return;

            const frame = animPropFrames[animPropPreviewFrame];
            if (!frame) return;

            ctx.imageSmoothingEnabled = false;
            // Scale to fit 48x48 preview
            const scale = Math.min(48 / frame.w, 48 / frame.h);
            const drawW = frame.w * scale;
            const drawH = frame.h * scale;
            const drawX = (48 - drawW) / 2;
            const drawY = (48 - drawH) / 2;
            ctx.drawImage(animPropEditorImage, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);
        }

        function animPropUpdateSpeed() {
            const fps = parseInt(document.getElementById('animPropSpeedSlider').value) || 8;
            document.getElementById('animPropSpeedLabel').textContent = fps + ' fps';
            document.getElementById('animPropSpeed').value = fps; // Sync with hidden input

            // Restart preview with new speed
            if (animPropPreviewInterval) {
                animPropStopPreview();
                animPropStartLivePreview();
            }
        }

        function animPropTypeChanged() {
            // Could show/hide different options based on type
        }

        function animPropSave() {
            const name = document.getElementById('animPropNameInput').value.trim();
            if (!name) {
                alert('Please enter a name for the prop');
                return;
            }

            if (!animPropEditorImage) {
                alert('Please load a sprite sheet first');
                return;
            }

            if (animPropFrames.length === 0) {
                alert('Please add at least one frame');
                return;
            }

            const propData = {
                name: name,
                spriteData: animPropEditorData,
                frameWidth: animPropEditorFrameW,
                frameHeight: animPropEditorFrameH,
                frames: [...animPropFrames],
                type: document.getElementById('animPropType').value,
                fps: parseInt(document.getElementById('animPropSpeedSlider').value) || 8,
                collisionMask: animPropCollisionMask ? JSON.parse(JSON.stringify(animPropCollisionMask)) : null,
                splitLine: animPropSplitLine ? JSON.parse(JSON.stringify(animPropSplitLine)) : null,
                _spriteImg: animPropEditorImage // Store the loaded image
            };

            if (animPropEditorEditingIndex >= 0) {
                animatedProps[animPropEditorEditingIndex] = propData;
            } else {
                animatedProps.push(propData);
                currentAnimPropIndex = animatedProps.length - 1; // Select the new prop
            }

            animPropStopPreview();
            document.getElementById('animPropModal').classList.remove('visible');
            updateAnimPropListDisplay();
            renderMap();
        }

        function animPropCancel() {
            animPropStopPreview();
            document.getElementById('animPropModal').classList.remove('visible');
        }

        function updateAnimPropListDisplay() {
            const container = document.getElementById('animPropList');
            if (!container) return;
            container.innerHTML = '';

            if (animatedProps.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; padding:10px;">No animated props yet</div>';
                return;
            }

            animatedProps.forEach((prop, i) => {
                const item = document.createElement('div');
                const isSelected = (currentAnimPropIndex === i);
                item.style.cssText = 'display:flex; align-items:center; gap:10px; padding:8px; background:' + (isSelected ? '#4a4a6e' : '#333') + '; border:2px solid ' + (isSelected ? '#4af' : 'transparent') + '; border-radius:5px; margin-bottom:5px; cursor:pointer;';
                item.onclick = () => { currentAnimPropIndex = i; updateAnimPropListDisplay(); };

                // Preview thumbnail
                if (prop.frames && prop.frames.length > 0) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 32;
                    canvas.height = 32;
                    canvas.style.cssText = 'border:1px solid #555; image-rendering:pixelated;';
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;

                    const frame = prop.frames[0];
                    if (prop._spriteImg) {
                        ctx.drawImage(prop._spriteImg, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                    } else if (prop.spriteData) {
                        // Fallback: load image if _spriteImg not available
                        const img = new Image();
                        img.onload = () => {
                            prop._spriteImg = img;
                            ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                        };
                        img.src = prop.spriteData;
                    }
                    item.appendChild(canvas);
                }

                const info = document.createElement('div');
                info.style.flex = '1';
                info.innerHTML = '<div style="color:#4af; font-weight:bold;">' + prop.name + '</div>' +
                    '<div style="font-size:10px; color:#888;">' + prop.frames.length + ' frames | ' + prop.type + '</div>';
                item.appendChild(info);

                // Edit button
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.style.cssText = 'padding:4px 8px; font-size:10px;';
                editBtn.onclick = (e) => { e.stopPropagation(); openAnimPropEditor(i); };
                item.appendChild(editBtn);

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = '×';
                delBtn.style.cssText = 'padding:4px 8px; font-size:10px; background:#a55;';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Delete "' + prop.name + '"?')) {
                        animatedProps.splice(i, 1);
                        placedAnimProps = placedAnimProps.filter(p => p.propIndex !== i);
                        placedAnimProps.forEach(p => { if (p.propIndex > i) p.propIndex--; });
                        updateAnimPropListDisplay();
                        renderMap();
                    }
                };
                item.appendChild(delBtn);

                container.appendChild(item);
            });
        }

        // ===== SAVE/LOAD =====
        function saveProject() {
            // Count tiles in first layer for debugging
            let tileCount = 0;
            if (layers[0]) {
                for (let y = 0; y < layers[0].length; y++) {
                    if (layers[0][y]) {
                        for (let x = 0; x < layers[0][y].length; x++) {
                            if (layers[0][y][x]) tileCount++;
                        }
                    }
                }
            }
            console.log('Saving project with', layers.length, 'layers,', tileCount, 'tiles in first layer,', tilesets.length, 'tilesets,', props.length, 'props');

            // Save current prop's collision masks before saving
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Save all tilesets
            const tilesetsData = tilesets.map(ts => ({ name: ts.name, data: ts.data }));

            // Save all props
            const propsData = props.map(p => ({
                name: p.name,
                data: p.data,
                collisionMasks: p.collisionMasks || {}
            }));

            // Save all animated props
            const animPropsData = animatedProps.map(prop => ({
                name: prop.name,
                spriteData: prop.spriteData,
                frameWidth: prop.frameWidth,
                frameHeight: prop.frameHeight,
                frames: prop.frames,
                type: prop.type,
                fps: prop.fps,
                collisionMask: prop.collisionMask || null,
                splitLine: prop.splitLine || null
            }));

            const data = {
                gridSize, mapCols, mapRows,
                layers, layerVisibility, layerNames, currentLayer,
                tileCollisions, collisionMasks,
                tileSplitLines, // Depth split lines for Y-sorting
                tilesets: tilesetsData,
                currentTilesetIndex,
                // Keep for backwards compatibility
                tilesetData: tilesets[0]?.data,
                // Save multiple props
                props: propsData,
                currentPropIndex,
                // Keep old format for backwards compatibility
                propImageData: props[0]?.data || null,
                propCollisionMasks: props[0]?.collisionMasks || {},
                // Save animated props
                animatedProps: animPropsData,
                currentAnimPropIndex,
                placedAnimProps,
                // Save player layer settings
                playerLayerIndex,
                playerPreviewPos,
                playerPreviewVisible
            };
            console.log('Saving playerPreviewPos:', playerPreviewPos);
            localStorage.setItem('worldBuilderProject', JSON.stringify(data));
            console.log('Project saved to localStorage');
            alert('Saved! Player spawn: (' + playerPreviewPos.x + ', ' + playerPreviewPos.y + ')');
            return data; // Return for file download
        }

        function downloadProject() {
            // Get save data
            const data = getProjectData();
            const json = JSON.stringify(data, null, 2);

            // Create download
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'world-project-' + new Date().toISOString().slice(0,10) + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function getProjectData() {
            // Save current prop's collision masks before saving
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Save all tilesets
            const tilesetsData = tilesets.map(ts => ({ name: ts.name, data: ts.data }));

            // Save all props
            const propsData = props.map(p => ({
                name: p.name,
                data: p.data,
                collisionMasks: p.collisionMasks || {}
            }));

            // Save all animated props
            const animPropsData = animatedProps.map(prop => ({
                name: prop.name,
                spriteData: prop.spriteData,
                frameWidth: prop.frameWidth,
                frameHeight: prop.frameHeight,
                frames: prop.frames,
                type: prop.type,
                fps: prop.fps,
                collisionMask: prop.collisionMask || null,
                splitLine: prop.splitLine || null
            }));

            return {
                gridSize, mapCols, mapRows,
                layers, layerVisibility, layerNames, currentLayer,
                tileCollisions, collisionMasks,
                tileSplitLines, // Depth split lines for Y-sorting
                tilesets: tilesetsData,
                currentTilesetIndex,
                // Keep for backwards compatibility
                tilesetData: tilesets[0]?.data,
                // Save multiple props
                props: propsData,
                currentPropIndex,
                // Keep old format for backwards compatibility
                propImageData: props[0]?.data || null,
                propCollisionMasks: props[0]?.collisionMasks || {},
                // Save animated props
                animatedProps: animPropsData,
                currentAnimPropIndex,
                placedAnimProps,
                // Save player layer settings
                playerLayerIndex,
                playerPreviewPos,
                playerPreviewVisible
            };
        }

        function uploadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    // Save to localStorage so Test Map works
                    localStorage.setItem('worldBuilderProject', JSON.stringify(data));
                    // Load into editor
                    loadProject(data);
                } catch (err) {
                    alert('Error loading file: ' + err.message);
                }
            };
            reader.readAsText(file);

            // Clear input so same file can be loaded again
            event.target.value = '';
        }

        function loadProject(projectData) {
            // If no data passed, load from localStorage
            let p;
            if (projectData) {
                p = projectData;
            } else {
                const data = localStorage.getItem('worldBuilderProject');
                if (!data) {
                    alert('No saved project found in browser storage. Use "Load File" to load from a downloaded file.');
                    return;
                }
                try {
                    p = JSON.parse(data);
                } catch (err) {
                    alert('Error parsing saved data: ' + err.message);
                    return;
                }
            }

            console.log('Loading project:', p);
            gridSize = p.gridSize || 16;
            mapCols = p.mapCols || 40;
            mapRows = p.mapRows || 30;
            tileCollisions = p.tileCollisions || {};
            collisionMasks = p.collisionMasks || {};
            tileSplitLines = p.tileSplitLines || {}; // Depth split lines for Y-sorting

            // Load multiple props (new format)
            props = [];
            propImage = null;
            propImageData = null;
            propCollisionMasks = {};
            currentPropIndex = -1;

            if (p.props && p.props.length > 0) {
                console.log('Loading', p.props.length, 'props');
                let propsLoaded = 0;
                p.props.forEach((propData, i) => {
                    const img = new Image();
                    img.onload = () => {
                        props[i] = {
                            name: propData.name,
                            img: img,
                            data: propData.data,
                            collisionMasks: propData.collisionMasks || {}
                        };
                        propsLoaded++;
                        if (propsLoaded === p.props.length) {
                            // All props loaded
                            currentPropIndex = p.currentPropIndex >= 0 ? p.currentPropIndex : 0;
                            if (props[currentPropIndex]) {
                                propImage = props[currentPropIndex].img;
                                propImageData = props[currentPropIndex].data;
                                propCollisionMasks = props[currentPropIndex].collisionMasks;
                            }
                            updatePropDropdown();
                            updatePropUI();
                            drawPropTileset();
                            renderMap();
                        }
                    };
                    img.onerror = () => {
                        console.error('Failed to load prop', i);
                        propsLoaded++;
                    };
                    img.src = propData.data;
                });
            } else if (p.propImageData) {
                // Old format - single prop image (backwards compatibility)
                console.log('Loading single prop (old format)');
                const img = new Image();
                img.onload = () => {
                    props = [{
                        name: 'prop',
                        img: img,
                        data: p.propImageData,
                        collisionMasks: p.propCollisionMasks || {}
                    }];
                    currentPropIndex = 0;
                    propImage = img;
                    propImageData = p.propImageData;
                    propCollisionMasks = p.propCollisionMasks || {};
                    updatePropDropdown();
                    updatePropUI();
                    drawPropTileset();
                    renderMap();
                };
                img.onerror = () => console.error('Failed to load prop image');
                img.src = p.propImageData;
            } else {
                console.log('No props in saved project');
                updatePropDropdown();
                updatePropUI();
            }

            // Load animated props
            animatedProps = [];
            animPropSpriteSheet = null;
            animPropSpriteData = null;
            currentAnimPropIndex = -1;
            placedAnimProps = p.placedAnimProps || [];

            if (p.animatedProps && p.animatedProps.length > 0) {
                console.log('Loading', p.animatedProps.length, 'animated props');
                let propsLoaded = 0;
                p.animatedProps.forEach((propData, i) => {
                    animatedProps[i] = {
                        name: propData.name,
                        spriteData: propData.spriteData,
                        frameWidth: propData.frameWidth || 16,
                        frameHeight: propData.frameHeight || 16,
                        frames: propData.frames || [],
                        type: propData.type || 'loop',
                        fps: propData.fps || 8,
                        collisionMask: propData.collisionMask || null,
                        splitLine: propData.splitLine || null
                    };

                    // Load sprite sheet image if present
                    if (propData.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            animatedProps[i]._spriteImg = img;
                            propsLoaded++;
                            if (propsLoaded === p.animatedProps.length) {
                                currentAnimPropIndex = p.currentAnimPropIndex >= 0 ? p.currentAnimPropIndex : 0;
                                if (animatedProps[currentAnimPropIndex] && animatedProps[currentAnimPropIndex]._spriteImg) {
                                    animPropSpriteSheet = animatedProps[currentAnimPropIndex]._spriteImg;
                                    animPropSpriteData = animatedProps[currentAnimPropIndex].spriteData;
                                }
                                updateAnimPropListDisplay();
                                renderMap();
                            }
                        };
                        img.onerror = () => {
                            console.error('Failed to load animated prop sprite', i);
                            propsLoaded++;
                        };
                        img.src = propData.spriteData;
                    } else {
                        propsLoaded++;
                        if (propsLoaded === p.animatedProps.length) {
                            currentAnimPropIndex = p.currentAnimPropIndex >= 0 ? p.currentAnimPropIndex : 0;
                            updateAnimPropListDisplay();
                            renderMap();
                        }
                    }
                });
            } else {
                console.log('No animated props in saved project');
                updateAnimPropListDisplay();
            }

            // Load layers (backwards compatible with old saves)
            if (p.layers) {
                layers = p.layers;
                layerVisibility = p.layerVisibility || layers.map(() => true);
                layerNames = p.layerNames || layers.map(() => '');
                currentLayer = p.currentLayer || 0;
            } else if (p.map) {
                // Old format - single map
                layers = [p.map];
                layerVisibility = [true];
                layerNames = [''];
                currentLayer = 0;
            } else {
                layers = [createEmptyLayer()];
                layerVisibility = [true];
                layerNames = [''];
                currentLayer = 0;
            }
            map = layers[currentLayer];

            // Load player layer settings
            playerLayerIndex = p.playerLayerIndex !== undefined ? p.playerLayerIndex : 1;
            playerPreviewPos = p.playerPreviewPos || { x: 5, y: 5 };
            playerPreviewVisible = p.playerPreviewVisible !== undefined ? p.playerPreviewVisible : true;

            // Load tilesets (new format with multiple tilesets)
            if (p.tilesets && p.tilesets.length > 0) {
                let loadedCount = 0;
                tilesets = [];
                p.tilesets.forEach((tsData, i) => {
                    const img = new Image();
                    img.onload = () => {
                        tilesets[i] = { name: tsData.name, img: img, data: tsData.data };
                        loadedCount++;
                        if (loadedCount === p.tilesets.length) {
                            // All tilesets loaded
                            currentTilesetIndex = p.currentTilesetIndex || 0;
                            tilesetImg = tilesets[currentTilesetIndex].img;
                            mapInitialized = true; // Mark map as loaded
                            updateTilesetDropdown();
                            setPhase('build');
                            drawPaintTileset();
                            renderLayerList();
                            renderMap();
                            updateAnimPropListDisplay();
                            alert('Project loaded!');
                        }
                    };
                    img.src = tsData.data;
                });
            } else if (p.tilesetData) {
                // Old format - single tileset
                const img = new Image();
                img.onload = () => {
                    tilesets = [{ name: 'tileset', img: img, data: p.tilesetData }];
                    currentTilesetIndex = 0;
                    tilesetImg = img;
                    mapInitialized = true; // Mark map as loaded
                    updateTilesetDropdown();
                    setPhase('build');
                    drawPaintTileset();
                    renderLayerList();
                    renderMap();
                    updateAnimPropListDisplay();
                    alert('Project loaded!');
                };
                img.src = p.tilesetData;
            } else {
                alert('No tileset data found in save');
            }
        }

        function exportConfig() {
            const config = { gridSize, mapSize: { cols: mapCols, rows: mapRows }, tileCollisions, layers };
            navigator.clipboard.writeText(JSON.stringify(config, null, 2)).then(() => alert('Copied!'));
        }

        // ===== TEST MAP =====
        function testMap() {
            // Save current state
            saveProject();

            // Close existing test window if any, then open fresh (fullscreen)
            const testWindow = window.open('about:blank', 'MapTest', 'width=' + screen.width + ',height=' + screen.height);
            testWindow.document.open();
            testWindow.document.write(`
<!DOCTYPE html>
<html>
<head>
    <title>Map Test</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #111; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #debugPanel {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            min-width: 200px;
            display: none;
        }
        #debugPanel.visible { display: block; }
        #debugPanel h3 { margin: 0 0 10px 0; color: #4af; font-size: 14px; }
        #debugPanel label { display: block; margin: 8px 0 4px 0; color: #aaa; }
        #debugPanel input[type="range"] { width: 100%; }
        #debugPanel .value { color: #4f8; float: right; }
        #debugPanel button {
            margin-top: 10px;
            padding: 5px 10px;
            background: #4a7c59;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        #debugPanel button:hover { background: #5a9c69; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <div id="info">WASD/Arrows to move | SPACE to attack | C to toggle collision | P to toggle debug panel | ESC to close</div>
    <div id="debugPanel">
        <h3>Player Settings</h3>
        <label>Scale: <span class="value" id="scaleVal">1.7</span></label>
        <input type="range" id="scaleSlider" min="0.5" max="4" step="0.1" value="1.7">
        <label>Move Speed: <span class="value" id="speedVal">4</span></label>
        <input type="range" id="speedSlider" min="1" max="15" step="0.5" value="4">
        <label>Anim Speed: <span class="value" id="animVal">10</span></label>
        <input type="range" id="animSlider" min="1" max="20" step="1" value="10">
        <label>Hitbox Width: <span class="value" id="widthVal">28</span></label>
        <input type="range" id="widthSlider" min="10" max="60" step="2" value="28">
        <label>Hitbox Height: <span class="value" id="heightVal">76</span></label>
        <input type="range" id="heightSlider" min="20" max="100" step="2" value="76">
        <h3 style="margin-top:15px;">Camera</h3>
        <label>Zoom: <span class="value" id="zoomVal">0.9</span></label>
        <input type="range" id="zoomSlider" min="0.5" max="3" step="0.1" value="0.9">
        <button onclick="copySettings()">Copy Settings</button>
    </div>
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Fullscreen canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Show loading message
        function showLoading(current, total) {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#4af';
            ctx.font = '24px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Loading... ' + current + '/' + total, canvas.width / 2, canvas.height / 2);
        }
        showLoading(0, 1);

        // Load project data fresh
        const projectData = JSON.parse(localStorage.getItem('worldBuilderProject'));
        console.log('Loaded project data:', projectData);

        const gridSize = projectData.gridSize || 16;
        const mapRows = projectData.mapRows || 30;
        const mapCols = projectData.mapCols || 40;

        // Load layers
        let layers = [];
        if (projectData.layers && projectData.layers.length > 0) {
            layers = projectData.layers;
            console.log('Loaded layers from projectData.layers');
        } else if (projectData.map && projectData.map.length > 0) {
            layers = [projectData.map];
            console.log('Loaded map from projectData.map (old format)');
        } else {
            console.error('No map data found!');
        }

        const layerVisibility = projectData.layerVisibility || layers.map(() => true);

        console.log('Layers:', layers.length, 'MapRows:', mapRows, 'MapCols:', mapCols);

        // Debug: Check layer content
        if (layers.length > 0) {
            const firstLayer = layers[0];
            console.log('First layer type:', typeof firstLayer, 'isArray:', Array.isArray(firstLayer));
            if (Array.isArray(firstLayer) && firstLayer.length > 0) {
                console.log('First layer rows:', firstLayer.length);
                // Count non-null cells
                let tileCount = 0;
                for (let y = 0; y < firstLayer.length; y++) {
                    if (firstLayer[y]) {
                        for (let x = 0; x < firstLayer[y].length; x++) {
                            if (firstLayer[y][x]) tileCount++;
                        }
                    }
                }
                console.log('Tiles in first layer:', tileCount);
            }
        }

        const tileCollisions = projectData.tileCollisions || {};
        const collisionMasks = projectData.collisionMasks || {};
        const tileSplitLines = projectData.tileSplitLines || {}; // Depth split for Y-sorting

        console.log('Tiles with collision:', Object.keys(tileCollisions).length);
        console.log('Tiles with depth split:', Object.keys(tileSplitLines).length);

        // Multiple props system
        const propImages = [];
        const propsData = projectData.props || [];
        const propCollisionMasksAll = {}; // propIndex -> collision masks

        // Load tilesets (support multiple)
        const tilesetImages = [];
        const tilesetsData = projectData.tilesets || [{ data: projectData.tilesetData }];

        // Animated props data (needed for counting)
        const animatedPropsData = projectData.animatedProps || [];

        // Track all images that need to load before starting the game
        let imagesToLoad = 0;
        let imagesLoaded = 0;
        let gameStarted = false;

        function checkAllImagesLoaded() {
            showLoading(imagesLoaded, imagesToLoad);
            if (imagesLoaded >= imagesToLoad && !gameStarted) {
                console.log('All images loaded, starting game...');
                gameStarted = true;
                findStartPos();
                gameLoop();
            }
        }

        // Count all images to load
        imagesToLoad += tilesetsData.filter(ts => ts && ts.data).length; // Tilesets with valid data
        imagesToLoad += animatedPropsData.filter(p => p && p.spriteData).length; // Animated props
        imagesToLoad += propsData.filter(p => p && p.data).length; // Regular props with valid data
        if (projectData.propImageData && propsData.length === 0) imagesToLoad += 1; // Legacy single prop
        imagesToLoad += 1; // Player sprite

        console.log('Total images to load:', imagesToLoad);

        // Safety check - if somehow no images to load, start anyway
        if (imagesToLoad === 0) {
            console.warn('No images to load, starting game immediately');
            imagesToLoad = 1;
            imagesLoaded = 1;
            findStartPos();
            gameLoop();
        }

        // Fallback timeout - start game after 5 seconds even if some images failed
        setTimeout(() => {
            if (!gameStarted) {
                console.warn('Timeout reached, starting game with', imagesLoaded, '/', imagesToLoad, 'images loaded');
                gameStarted = true;
                findStartPos();
                gameLoop();
            }
        }, 5000);

        // Load all prop images
        if (propsData.length > 0) {
            propsData.forEach((propData, i) => {
                if (!propData || !propData.data) {
                    console.warn('Prop', i, 'has no data, skipping');
                    return;
                }
                const img = new Image();
                img.onload = () => {
                    console.log('Prop', i, 'loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error('Failed to load prop', i);
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.src = propData.data;
                propImages[i] = img;
                propCollisionMasksAll[i] = propData.collisionMasks || {};
            });
        } else if (projectData.propImageData) {
            // Backwards compatibility - single prop
            const img = new Image();
            img.onload = () => {
                console.log('Prop image loaded (legacy) (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.onerror = () => {
                console.error('Failed to load legacy prop');
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.src = projectData.propImageData;
            propImages[0] = img;
            propCollisionMasksAll[0] = projectData.propCollisionMasks || {};
        }

        tilesetsData.forEach((ts, i) => {
            if (!ts || !ts.data) {
                console.warn('Tileset', i, 'has no data, skipping');
                return;
            }
            const img = new Image();
            img.onload = () => {
                tilesetImages[i] = img;
                imagesLoaded++;
                console.log('Tileset', i, 'loaded (' + imagesLoaded + '/' + imagesToLoad + ')');
                checkAllImagesLoaded();
            };
            img.onerror = () => {
                console.error('Failed to load tileset', i);
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.src = ts.data;
        });

        // For backwards compat
        const tilesetImg = { complete: false };

        // Load animated props (stored as animTile cells in layers)
        const animPropImages = [];
        const animPropFrameTimers = {}; // key: "x,y,layer" -> { frame: 0, timer: 0 }

        animatedPropsData.forEach((propData, i) => {
            if (propData && propData.spriteData) {
                const img = new Image();
                img.onload = () => {
                    console.log('AnimProp', i, propData.name, 'loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error('Failed to load AnimProp', i);
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.src = propData.spriteData;
                animPropImages[i] = img;
            }
        });

        console.log('Animated props:', animatedPropsData.length);

        // Load player sprite - use opener's location for correct path
        const playerImg = new Image();
        const basePath = window.opener ? window.opener.location.href.replace(/[^/]*$/, '') : '';
        playerImg.onload = () => {
            console.log('Player sprite loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
            imagesLoaded++;
            checkAllImagesLoaded();
        };
        playerImg.onerror = () => {
            console.error('Failed to load player sprite from:', basePath + 'assets/player_sprite.png');
            imagesLoaded++;
            checkAllImagesLoaded();
        };
        playerImg.src = basePath + 'assets/player_sprite.png';

        // Player state (matching game.js)
        const player = {
            x: 100,
            y: 100,
            width: 28,
            height: 76,
            speed: 4,
            direction: 'down',
            frame: 0,
            frameTimer: 0,
            moving: false,
            attacking: false,
            attackTimer: 0
        };

        // Adjustable settings
        let playerScale = 1.7;
        let animSpeed = 10; // Lower = faster animation

        // Tile scale - how big to render tiles (zoom level)
        const TILE_SCALE = 4;

        // Camera zoom (1 = normal, 2 = 2x closer, etc)
        let cameraZoom = 1.0;

        // Debug panel toggle and slider handlers
        document.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') {
                document.getElementById('debugPanel').classList.toggle('visible');
            }
        });

        document.getElementById('scaleSlider').addEventListener('input', (e) => {
            playerScale = parseFloat(e.target.value);
            document.getElementById('scaleVal').textContent = playerScale.toFixed(1);
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            player.speed = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = player.speed.toFixed(1);
        });

        document.getElementById('animSlider').addEventListener('input', (e) => {
            animSpeed = parseInt(e.target.value);
            document.getElementById('animVal').textContent = animSpeed;
        });

        document.getElementById('widthSlider').addEventListener('input', (e) => {
            player.width = parseInt(e.target.value);
            document.getElementById('widthVal').textContent = player.width;
        });

        document.getElementById('heightSlider').addEventListener('input', (e) => {
            player.height = parseInt(e.target.value);
            document.getElementById('heightVal').textContent = player.height;
        });

        document.getElementById('zoomSlider').addEventListener('input', (e) => {
            cameraZoom = parseFloat(e.target.value);
            document.getElementById('zoomVal').textContent = cameraZoom.toFixed(1);
        });

        function copySettings() {
            const settings = \`Player Settings:
  scale: \${playerScale}
  speed: \${player.speed}
  animSpeed: \${animSpeed}
  width: \${player.width}
  height: \${player.height}
  cameraZoom: \${cameraZoom}\`;
            navigator.clipboard.writeText(settings).then(() => {
                alert('Settings copied to clipboard!');
            });
        }

        // Find starting position - use player marker position from editor
        function findStartPos() {
            const tileSize = gridSize * TILE_SCALE;

            console.log('findStartPos called, projectData.playerPreviewPos =', projectData.playerPreviewPos);

            // Use the player preview position saved in project data
            if (projectData.playerPreviewPos && (projectData.playerPreviewPos.x !== undefined)) {
                const pos = projectData.playerPreviewPos;
                player.x = pos.x * tileSize + tileSize / 2;
                player.y = pos.y * tileSize + tileSize / 2;
                console.log('Start position from marker: tile', pos.x, pos.y, '-> pixel', player.x, player.y);
                return;
            }

            console.log('No playerPreviewPos found, using fallback');
            // Fallback: find first tile without collision
            const layer = layers[0];
            if (!layer) {
                console.error('No layers found for starting position');
                return;
            }
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y] && layer[y][x];
                    if (cell && cell.type === 'tile') {
                        const key = cell.x + ',' + cell.y;
                        if (!tileCollisions[key]) {
                            player.x = x * tileSize + tileSize / 2;
                            player.y = y * tileSize + tileSize / 2;
                            console.log('Start position: tile', x, y);
                            return;
                        }
                    }
                }
            }
            // If no safe tile, just start at first tile
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y] && layer[y][x];
                    if (cell) {
                        player.x = x * tileSize + tileSize / 2;
                        player.y = y * tileSize + tileSize / 2;
                        console.log('Start position (fallback): tile', x, y);
                        return;
                    }
                }
            }
        }

        // Camera
        const camera = { x: 0, y: 0 };

        // Debug
        let showCollision = true;

        // Input
        const keys = {};

        document.addEventListener('keydown', e => {
            keys[e.key] = true;

            if (e.key === 'Escape') window.close();
            if (e.key === 'c' || e.key === 'C') showCollision = !showCollision;
            if (e.key === ' ' && !player.attacking) {
                player.attacking = true;
                player.attackTimer = 18;
            }
        });
        document.addEventListener('keyup', e => keys[e.key] = false);

        // Pixel-level collision check on ALL layers
        function checkCollision(x, y, w, h) {
            const tileSize = gridSize * TILE_SCALE;
            const pixelScale = tileSize / gridSize;

            // Check corners and edge midpoints
            const points = [
                { x: x, y: y },
                { x: x + w - 1, y: y },
                { x: x, y: y + h - 1 },
                { x: x + w - 1, y: y + h - 1 },
                { x: x + w / 2, y: y },
                { x: x + w / 2, y: y + h - 1 },
                { x: x, y: y + h / 2 },
                { x: x + w - 1, y: y + h / 2 }
            ];

            for (const point of points) {
                const tileX = Math.floor(point.x / tileSize);
                const tileY = Math.floor(point.y / tileSize);

                // Out of bounds = collision
                if (tileX < 0 || tileX >= mapCols || tileY < 0 || tileY >= mapRows) {
                    return true;
                }

                // Check ALL layers for collision
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li];
                    if (!layer) continue;

                    const cell = layer[tileY] && layer[tileY][tileX];
                    if (cell) {
                        // Include tileset index in key for tiles
                        const tilesetIdx = cell.tilesetIndex || 0;
                        const key = cell.type === 'tile'
                            ? tilesetIdx + ':' + cell.x + ',' + cell.y
                            : cell.x + ',' + cell.y;
                        // Use tile collision masks for tiles, prop collision masks for props (by propIndex)
                        let mask = null;
                        let maskOffsetX = 0;
                        let maskOffsetY = 0;

                        if (cell.type === 'prop') {
                            const propIdx = cell.propIndex || 0;
                            const propKey = cell.x + ',' + cell.y;
                            mask = propCollisionMasksAll[propIdx] ? propCollisionMasksAll[propIdx][propKey] : null;
                        } else if (cell.type === 'animTile') {
                            // Animated tile - get collision from prop data
                            const propData = animatedPropsData[cell.propIndex];
                            if (propData && propData.collisionMask) {
                                mask = propData.collisionMask;
                                // For multi-tile props, offset into the mask
                                maskOffsetX = (cell.offsetX || 0) * gridSize;
                                maskOffsetY = (cell.offsetY || 0) * gridSize;
                            }
                        } else {
                            mask = collisionMasks[key];
                        }

                        if (mask) {
                            // Check pixel-level collision (works for both tiles and props)
                            const localX = Math.floor((point.x % tileSize) / pixelScale);
                            const localY = Math.floor((point.y % tileSize) / pixelScale);

                            // Apply offset for multi-tile animated props
                            const maskX = localX + maskOffsetX;
                            const maskY = localY + maskOffsetY;

                            if (maskY >= 0 && maskY < mask.length && mask[maskY]) {
                                if (maskX >= 0 && maskX < mask[maskY].length && mask[maskY][maskX]) {
                                    return true;
                                }
                            }
                        } else if (cell.type === 'tile' && tileCollisions[key]) {
                            // Full tile collision (no mask = solid tile)
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function update() {
            let dx = 0, dy = 0;
            player.moving = false;

            if (!player.attacking) {
                if (keys['w'] || keys['W'] || keys['ArrowUp']) { dy = -1; player.direction = 'up'; player.moving = true; }
                if (keys['s'] || keys['S'] || keys['ArrowDown']) { dy = 1; player.direction = 'down'; player.moving = true; }
                if (keys['a'] || keys['A'] || keys['ArrowLeft']) { dx = -1; player.direction = 'left'; player.moving = true; }
                if (keys['d'] || keys['D'] || keys['ArrowRight']) { dx = 1; player.direction = 'right'; player.moving = true; }

                // Normalize diagonal movement so it's not faster
                if (dx !== 0 && dy !== 0) {
                    const diag = 0.7071; // 1/sqrt(2)
                    dx *= diag;
                    dy *= diag;
                }

                dx *= player.speed;
                dy *= player.speed;
            }

            // Move with collision - always use small foot hitbox (bottom 1/3 of player)
            // This allows walking behind objects naturally and prevents getting stuck
            const collisionHeight = player.height / 3;
            const collisionY = player.y + player.height * 2/3;

            let movedX = false;
            let movedY = false;

            if (dx !== 0 && !checkCollision(player.x + dx, collisionY, player.width, collisionHeight)) {
                player.x += dx;
                movedX = true;
            }
            if (dy !== 0 && !checkCollision(player.x, collisionY + dy, player.width, collisionHeight)) {
                player.y += dy;
                movedY = true;
            }

            // If player tried to move but was blocked in all directions, force idle
            if (player.moving && !movedX && !movedY) {
                player.moving = false;
            }

            // Animation - uses animSpeed variable (lower = faster)
            player.frameTimer++;
            if (player.frameTimer >= animSpeed) {
                player.frameTimer = 0;
                player.frame = (player.frame + 1) % 4;
            }

            // Update animated tile animations - scan layers for animTile cells
            for (let li = 0; li < layers.length; li++) {
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell || cell.type !== 'animTile') continue;

                        const propData = animatedPropsData[cell.propIndex];
                        if (!propData || !propData.frames || propData.frames.length <= 1) continue;
                        if (propData.type !== 'loop') continue;

                        // Use origin tile position for multi-tile prop sync
                        const originX = x - (cell.offsetX || 0);
                        const originY = y - (cell.offsetY || 0);
                        const key = originX + ',' + originY + ',' + li;

                        // Only process animation once per prop (at origin tile)
                        if (cell.offsetX === 0 && cell.offsetY === 0 || (!cell.offsetX && !cell.offsetY)) {
                            if (!animPropFrameTimers[key]) {
                                animPropFrameTimers[key] = { frame: 0, timer: 0 };
                            }
                            animPropFrameTimers[key].timer++;

                            const fps = propData.fps || 8;
                            const frameDelay = Math.round(60 / fps);

                            if (animPropFrameTimers[key].timer >= frameDelay) {
                                animPropFrameTimers[key].timer = 0;
                                animPropFrameTimers[key].frame = (animPropFrameTimers[key].frame + 1) % propData.frames.length;
                            }
                        }
                    }
                }
            }

            // Attack timer
            if (player.attacking) {
                player.attackTimer--;
                if (player.attackTimer <= 0) {
                    player.attacking = false;
                }
            }

            // Camera follow - adjust for zoom so player stays centered
            camera.x = player.x - (canvas.width / 2) / cameraZoom;
            camera.y = player.y - (canvas.height / 2) / cameraZoom;
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const tileSize = gridSize * TILE_SCALE;
            ctx.imageSmoothingEnabled = false;

            // Check if all tilesets are ready
            let allTilesetsReady = true;
            for (let i = 0; i < tilesetImages.length; i++) {
                if (!tilesetImages[i] || !tilesetImages[i].complete) {
                    allTilesetsReady = false;
                    break;
                }
            }
            if (!allTilesetsReady) {
                ctx.fillStyle = '#4af';
                ctx.font = '20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Loading tilesets...', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Debug: Show message if no layers
            if (layers.length === 0) {
                ctx.fillStyle = '#f00';
                ctx.font = '16px monospace';
                ctx.fillText('ERROR: No layers loaded!', 20, 70);
                return;
            }

            // Apply camera zoom transform
            ctx.save();
            ctx.scale(cameraZoom, cameraZoom);

            // Draw tiles - use Math.round for camera to prevent seams
            const camX = Math.round(camera.x);
            const camY = Math.round(camera.y);

            // === 3-PASS RENDERING FOR Y-SORTING ===

            // PASS 1: Draw ground layer (layer 0) - always behind everything
            let tilesDrawn = drawLayer(0, camX, camY, tileSize);

            // PASS 2: Y-sort player with tiles from layers 1+
            tilesDrawn += drawYSortedEntities(camX, camY, tileSize);

            // PASS 3: Draw canopy overlay (split tile tops) - always on top
            drawCanopyOverlay(camX, camY, tileSize);

            ctx.restore();

            // Debug info (drawn after restore so it's not zoomed)
            ctx.fillStyle = '#fff';
            ctx.font = '12px monospace';
            ctx.fillText('Layers: ' + layers.length + ' | Tiles: ' + tilesDrawn + ' | Zoom: ' + cameraZoom.toFixed(1) + 'x', 10, canvas.height - 10);
        }

        function drawLayer(li, camX, camY, tileSize) {
            if (!layerVisibility[li]) return 0;
            const layer = layers[li];
            if (!layer) return 0;

            let count = 0;
            for (let y = 0; y < mapRows; y++) {
                if (!layer[y]) continue;
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y][x];
                    if (!cell) continue;

                    const px = Math.floor(x * tileSize - camX);
                    const py = Math.floor(y * tileSize - camY);

                    // Account for zoom in off-screen check
                    if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                    // Overlap to prevent seams when zoomed
                    const overlap = 1;

                    if (cell.type === 'tile') {
                        count++;
                        // Use correct tileset for this tile
                        const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
                        if (cellTileset) {
                            // Draw with rotation
                            const rot = cell.rotation || 0;
                            if (rot === 0) {
                                ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
                            } else {
                                ctx.save();
                                ctx.translate(px + tileSize / 2, py + tileSize / 2);
                                ctx.rotate(rot * Math.PI / 180);
                                ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, -tileSize / 2, -tileSize / 2, tileSize + overlap, tileSize + overlap);
                                ctx.restore();
                            }
                        } else {
                            // Fallback: draw colored rectangle if tileset not loaded
                            ctx.fillStyle = '#4a7c59';
                            ctx.fillRect(px, py, tileSize, tileSize);
                        }

                        // Draw collision overlay if debug enabled (all layers)
                        if (showCollision) {
                            // Include tileset index in collision key
                            const tilesetIdx = cell.tilesetIndex || 0;
                            const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                            const mask = collisionMasks[key];

                            if (mask) {
                                // Draw pixel-level collision
                                const pixelSize = tileSize / gridSize;
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                for (let my = 0; my < gridSize; my++) {
                                    for (let mx = 0; mx < gridSize; mx++) {
                                        if (mask[my] && mask[my][mx]) {
                                            ctx.fillRect(
                                                px + mx * pixelSize,
                                                py + my * pixelSize,
                                                pixelSize,
                                                pixelSize
                                            );
                                        }
                                    }
                                }
                            } else if (tileCollisions[key]) {
                                // Full tile collision
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                ctx.fillRect(px, py, tileSize, tileSize);
                            }
                        }
                    } else if (cell.type === 'prop') {
                        const propIdx = cell.propIndex || 0;
                        const propImg = propImages[propIdx];
                        if (propImg && propImg.complete) {
                            count++;
                            ctx.drawImage(propImg, cell.x, cell.y, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
                        }

                        // Show collision in debug mode
                        if (showCollision) {
                            const key = cell.x + ',' + cell.y;
                            const mask = propCollisionMasksAll[propIdx] ? propCollisionMasksAll[propIdx][key] : null;
                            if (mask) {
                                const pixelSize = tileSize / gridSize;
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                for (let my = 0; my < gridSize; my++) {
                                    for (let mx = 0; mx < gridSize; mx++) {
                                        if (mask[my] && mask[my][mx]) {
                                            ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                                        }
                                    }
                                }
                            }
                        }
                    } else if (cell.type === 'animTile') {
                        // Animated tile - cycles through frames like a regular tile
                        const propData = animatedPropsData[cell.propIndex];
                        const propImg = animPropImages[cell.propIndex];
                        if (propData && propImg && propImg.complete && propData.frames && propData.frames.length > 0) {
                            // Use origin tile position for synced animation
                            const originX = x - (cell.offsetX || 0);
                            const originY = y - (cell.offsetY || 0);
                            const key = originX + ',' + originY + ',' + li;
                            const timer = animPropFrameTimers[key] || { frame: 0 };
                            const frameIdx = timer.frame % propData.frames.length;
                            const frame = propData.frames[frameIdx];

                            // Draw only this tile's portion of the frame
                            const offsetX = cell.offsetX || 0;
                            const offsetY = cell.offsetY || 0;
                            const srcX = frame.x + offsetX * gridSize;
                            const srcY = frame.y + offsetY * gridSize;

                            count++;
                            ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
                        }
                    }
                }
            }

            return count;
        }

        // === Y-SORTING FUNCTIONS ===

        function drawYSortedEntities(camX, camY, tileSize) {
            const entities = [];

            // Add player to sortable list
            entities.push({
                type: 'player',
                sortY: player.y + player.height  // Bottom of collision box
            });

            // Add tiles from layers 1+ (layer 0 is ground, already drawn)
            for (let li = 1; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        const px = x * tileSize - camX;
                        const py = y * tileSize - camY;

                        // Skip off-screen tiles
                        if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                        if (cell.type === 'tile') {
                            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
                            const splitData = tileSplitLines[key];
                            const hasSplit = splitData !== undefined && splitData !== null;

                            if (hasSplit) {
                                entities.push({
                                    type: 'trunk',
                                    cell, x, y, layer: li,
                                    sortY: (y + 1) * gridSize
                                });
                            } else {
                                entities.push({
                                    type: 'tile',
                                    cell, x, y, layer: li,
                                    sortY: (y + 1) * gridSize
                                });
                            }
                        } else if (cell.type === 'animTile') {
                            // Check if this animated prop has a split line
                            const propData = animatedPropsData[cell.propIndex];
                            // splitLine can be: number (old), object with "tileX,tileY" keys (new per-tile), or null/undefined
                            const hasSplit = propData && propData.splitLine !== null && propData.splitLine !== undefined &&
                                (typeof propData.splitLine === 'number' ||
                                 (typeof propData.splitLine === 'object' && Object.keys(propData.splitLine).length > 0));

                            if (hasSplit) {
                                // Has split - draw trunk portion Y-sorted, canopy later
                                entities.push({
                                    type: 'animTrunk',
                                    cell, x, y, layer: li,
                                    sortY: (y + 1) * gridSize
                                });
                            } else {
                                // No split - draw full animated tile Y-sorted
                                entities.push({
                                    type: 'animTile',
                                    cell, x, y, layer: li,
                                    sortY: (y + 1) * gridSize
                                });
                            }
                        }
                    }
                }
            }

            // Sort by Y (items lower on screen draw later = in front)
            entities.sort((a, b) => a.sortY - b.sortY);

            // Draw in sorted order
            let count = 0;
            for (const e of entities) {
                if (e.type === 'player') {
                    drawPlayer();
                } else if (e.type === 'trunk') {
                    drawTileTrunk(e.cell, e.x, e.y, camX, camY, tileSize);
                    count++;
                } else if (e.type === 'animTrunk') {
                    drawAnimTileTrunk(e.cell, e.x, e.y, e.layer, camX, camY, tileSize);
                    count++;
                } else if (e.type === 'animTile') {
                    drawAnimTile(e.cell, e.x, e.y, e.layer, camX, camY, tileSize);
                    count++;
                } else {
                    drawTileFull(e.cell, e.x, e.y, camX, camY, tileSize);
                    count++;
                }
            }

            return count;
        }

        function drawAnimTile(cell, tx, ty, li, camX, camY, tileSize) {
            const propData = animatedPropsData[cell.propIndex];
            const propImg = animPropImages[cell.propIndex];
            if (!propData || !propImg || !propImg.complete) return;
            if (!propData.frames || propData.frames.length === 0) return;

            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const overlap = 1;

            // Use origin tile position for synced animation
            const originX = tx - (cell.offsetX || 0);
            const originY = ty - (cell.offsetY || 0);
            const key = originX + ',' + originY + ',' + li;
            const timer = animPropFrameTimers[key] || { frame: 0 };
            const frameIdx = timer.frame % propData.frames.length;
            const frame = propData.frames[frameIdx];

            // Draw only this tile's portion of the frame
            const offsetX = cell.offsetX || 0;
            const offsetY = cell.offsetY || 0;
            const srcX = frame.x + offsetX * gridSize;
            const srcY = frame.y + offsetY * gridSize;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px - overlap, py - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
        }

        // Draw only the trunk (bottom) portion of an animated tile with split line
        function drawAnimTileTrunk(cell, tx, ty, li, camX, camY, tileSize) {
            const propData = animatedPropsData[cell.propIndex];
            const propImg = animPropImages[cell.propIndex];
            if (!propData || !propImg || !propImg.complete) return;
            if (!propData.frames || propData.frames.length === 0) return;
            if (!propData.splitLine) return;

            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const scale = tileSize / gridSize;

            // Use origin tile position for synced animation
            const originX = tx - (cell.offsetX || 0);
            const originY = ty - (cell.offsetY || 0);
            const key = originX + ',' + originY + ',' + li;
            const timer = animPropFrameTimers[key] || { frame: 0 };
            const frameIdx = timer.frame % propData.frames.length;
            const frame = propData.frames[frameIdx];

            // Calculate this tile's portion
            const offsetX = cell.offsetX || 0;
            const offsetY = cell.offsetY || 0;

            // Get split Y for this specific tile within the prop
            const tileKey = offsetX + ',' + offsetY;
            let splitY = null;

            if (typeof propData.splitLine === 'object' && !Array.isArray(propData.splitLine)) {
                // New format: object with "tileX,tileY" -> splitY
                splitY = propData.splitLine[tileKey];
            } else if (typeof propData.splitLine === 'number') {
                // Old format: single number (only applies to tile 0,0)
                if (offsetX === 0 && offsetY === 0) splitY = propData.splitLine;
            }

            // If no split for this tile, draw full tile
            if (splitY === null || splitY === undefined) {
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize;
                const overlap = 1;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px - overlap, py - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
                return;
            }

            // splitY is already local to this tile (0 to gridSize)
            const localSplitY = splitY;

            // Only draw if split is within this tile
            const overlap = 1;
            if (localSplitY <= 0) {
                // Split is above this tile - draw full tile
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px - overlap, py - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
            } else if (localSplitY < gridSize) {
                // Split is within this tile - draw only trunk (below split)
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize + localSplitY;
                const srcH = gridSize - localSplitY;
                const destY = py + localSplitY * scale;
                const destH = srcH * scale;

                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, srcH, px - overlap, destY, tileSize + overlap * 2, destH + overlap);
            }
            // If localSplitY >= gridSize, split is below this tile - don't draw trunk here
        }

        function drawTileFull(cell, tx, ty, camX, camY, tileSize) {
            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
            // Overlap to prevent seams when zoomed
            const overlap = 1;

            if (cellTileset) {
                ctx.imageSmoothingEnabled = false;
                const rot = cell.rotation || 0;
                if (rot === 0) {
                    ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
                } else {
                    ctx.save();
                    ctx.translate(px + tileSize / 2, py + tileSize / 2);
                    ctx.rotate(rot * Math.PI / 180);
                    ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, -tileSize / 2, -tileSize / 2, tileSize + overlap, tileSize + overlap);
                    ctx.restore();
                }
            }

            // Draw collision overlay if debug enabled
            if (showCollision) {
                const tilesetIdx = cell.tilesetIndex || 0;
                const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                const mask = collisionMasks[key];

                if (mask) {
                    const pixelSize = tileSize / gridSize;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    for (let my = 0; my < gridSize; my++) {
                        for (let mx = 0; mx < gridSize; mx++) {
                            if (mask[my] && mask[my][mx]) {
                                ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                            }
                        }
                    }
                } else if (tileCollisions[key]) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(px, py, tileSize, tileSize);
                }
            }
        }

        function drawTileTrunk(cell, tx, ty, camX, camY, tileSize) {
            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
            const splitData = tileSplitLines[key];
            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];

            if (!cellTileset || splitData === undefined) return;

            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const scale = tileSize / gridSize;
            // Overlap to prevent seams when zoomed
            const overlap = 1;

            ctx.imageSmoothingEnabled = false;

            // Handle rotation
            const rot = cell.rotation || 0;
            if (rot !== 0) {
                // For rotated tiles, just draw full tile (rotation + split is complex)
                ctx.save();
                ctx.translate(px + tileSize / 2, py + tileSize / 2);
                ctx.rotate(rot * Math.PI / 180);
                ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, -tileSize / 2, -tileSize / 2, tileSize + overlap, tileSize + overlap);
                ctx.restore();
                return;
            }

            // Draw trunk using clipping path for freeform line
            ctx.save();
            ctx.beginPath();

            // Create clip path for trunk (below the split line)
            const splitYArray = Array.isArray(splitData) ? splitData : new Array(gridSize).fill(splitData);

            // Start at bottom-left, go up the left edge to first split point
            ctx.moveTo(px - overlap, py + tileSize + overlap);
            ctx.lineTo(px - overlap, py + splitYArray[0] * scale);

            // Draw along the split line (left to right)
            for (let col = 0; col < gridSize; col++) {
                const splitY = splitYArray[col];
                ctx.lineTo(px + col * scale, py + splitY * scale);
                ctx.lineTo(px + (col + 1) * scale, py + splitY * scale);
            }

            // Go down right edge and close
            ctx.lineTo(px + tileSize + overlap, py + tileSize + overlap);
            ctx.closePath();
            ctx.clip();

            // Draw the full tile, clipped to trunk region
            ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
            ctx.restore();

            // Draw collision overlay if debug enabled
            if (showCollision) {
                const mask = collisionMasks[key];
                if (mask) {
                    const pixelSize = tileSize / gridSize;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    for (let my = 0; my < gridSize; my++) {
                        for (let mx = 0; mx < gridSize; mx++) {
                            if (mask[my] && mask[my][mx]) {
                                ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                            }
                        }
                    }
                } else if (tileCollisions[key]) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(px, py, tileSize, tileSize);
                }
            }
        }

        function drawCanopyOverlay(camX, camY, tileSize) {
            // Draw canopy portions (above split line) for all split tiles - always on top
            for (let li = 1; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        const px = Math.floor(x * tileSize - camX);
                        const py = Math.floor(y * tileSize - camY);
                        const overlap = 1;
                        const scale = tileSize / gridSize;

                        // Skip off-screen
                        if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                        if (cell.type === 'tile') {
                            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
                            const splitData = tileSplitLines[key];
                            if (splitData === undefined || splitData === null) continue;

                            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
                            if (!cellTileset) continue;

                            ctx.imageSmoothingEnabled = false;

                            // Handle rotation
                            const rot = cell.rotation || 0;
                            if (rot !== 0) continue; // Skip rotated tiles (already drawn full in trunk pass)

                            // Draw canopy using clipping path for freeform line
                            ctx.save();
                            ctx.beginPath();

                            // Create clip path for canopy (above the split line)
                            const splitYArray = Array.isArray(splitData) ? splitData : new Array(gridSize).fill(splitData);

                            // Start at top-left, go along top edge
                            ctx.moveTo(px - overlap, py - overlap);
                            ctx.lineTo(px + tileSize + overlap, py - overlap);

                            // Go down right edge to last split point
                            ctx.lineTo(px + tileSize + overlap, py + splitYArray[gridSize - 1] * scale);

                            // Draw along the split line (right to left)
                            for (let col = gridSize - 1; col >= 0; col--) {
                                const splitY = splitYArray[col];
                                ctx.lineTo(px + (col + 1) * scale, py + splitY * scale);
                                ctx.lineTo(px + col * scale, py + splitY * scale);
                            }

                            // Go up left edge and close
                            ctx.lineTo(px - overlap, py - overlap);
                            ctx.closePath();
                            ctx.clip();

                            // Draw the full tile, clipped to canopy region
                            ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
                            ctx.restore();

                        } else if (cell.type === 'animTile') {
                            // Animated tile canopy
                            const propData = animatedPropsData[cell.propIndex];
                            const propImg = animPropImages[cell.propIndex];
                            if (!propData || !propImg || !propImg.complete) continue;
                            if (propData.splitLine === null || propData.splitLine === undefined) continue;
                            if (!propData.frames || propData.frames.length === 0) continue;

                            // Get current animation frame
                            const originX = x - (cell.offsetX || 0);
                            const originY = y - (cell.offsetY || 0);
                            const key = originX + ',' + originY + ',' + li;
                            const timer = animPropFrameTimers[key] || { frame: 0 };
                            const frameIdx = timer.frame % propData.frames.length;
                            const frame = propData.frames[frameIdx];

                            const offsetX = cell.offsetX || 0;
                            const offsetY = cell.offsetY || 0;

                            // Get split Y for this specific tile within the prop
                            const tileKey = offsetX + ',' + offsetY;
                            let splitY = null;

                            if (typeof propData.splitLine === 'object' && !Array.isArray(propData.splitLine)) {
                                // New format: object with "tileX,tileY" -> splitY
                                splitY = propData.splitLine[tileKey];
                            } else if (typeof propData.splitLine === 'number') {
                                // Old format: single number (only applies to tile 0,0)
                                if (offsetX === 0 && offsetY === 0) splitY = propData.splitLine;
                            }

                            // If no split for this tile, skip canopy
                            if (splitY === null || splitY === undefined) continue;

                            // splitY is already local to this tile (0 to gridSize)
                            const localSplitY = splitY;

                            // Only draw canopy if split is within this tile
                            if (localSplitY > 0 && localSplitY < gridSize) {
                                const srcX = frame.x + offsetX * gridSize;
                                const srcY = frame.y + offsetY * gridSize;
                                const srcH = localSplitY;
                                const destH = srcH * scale;

                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(propImg, srcX, srcY, gridSize, srcH, px - overlap, py - overlap, tileSize + overlap * 2, destH + overlap * 2);
                            } else if (localSplitY >= gridSize) {
                                // Full tile is canopy (split at bottom)
                                const srcX = frame.x + offsetX * gridSize;
                                const srcY = frame.y + offsetY * gridSize;

                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px - overlap, py - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
                            }
                        }
                    }
                }
            }
        }

        function drawPlayer() {
            const camX = Math.round(camera.x);
            const camY = Math.round(camera.y);
            const sx = Math.round(player.x - camX);
            const sy = Math.round(player.y - camY);

            // Player sprite: 1024x512, 16 cols x 8 rows = 64x64 each
            const frameWidth = 64;
            const frameHeight = 64;
            // playerScale is now a global variable controlled by slider

            // Idle frames (Row 0)
            const idleFrames = {
                down: [0, 1, 2],
                up: [3, 4, 5],
                right: [6, 7, 8],
                left: [6, 7, 8]
            };

            // Walk frames
            const walkFrames = {
                down: { row: 0, cols: [9, 10, 11, 12] },
                up: { row: 0, cols: [13, 14, 15] },
                right: { row: 1, cols: [1, 2, 3, 4] },
                left: { row: 1, cols: [1, 2, 3, 4] }
            };

            let row = 0;
            let col = 0;
            let flipX = false;

            if (player.attacking) {
                row = walkFrames[player.direction].row;
                col = walkFrames[player.direction].cols[Math.min(player.frame, walkFrames[player.direction].cols.length - 1)];
                if (player.direction === 'left') flipX = true;
            } else if (player.moving) {
                const walk = walkFrames[player.direction];
                row = walk.row;
                col = walk.cols[player.frame % walk.cols.length];
                if (player.direction === 'left') flipX = true;
            } else {
                row = 0;
                col = idleFrames[player.direction][player.frame % idleFrames[player.direction].length];
                if (player.direction === 'left') flipX = true;
            }

            const drawW = Math.round(64 * playerScale);
            const drawH = Math.round(64 * playerScale);

            // Center sprite on collision box
            // Collision box should cover body from feet to near head
            // Sprite is drawn so collision box aligns with the character body
            const spriteX = sx + player.width / 2 - drawW / 2;
            const spriteY = sy - 15; // shift sprite up so collision box covers body properly

            if (playerImg.complete) {
                if (flipX) {
                    ctx.save();
                    ctx.translate(spriteX + drawW, spriteY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(playerImg, col * frameWidth, row * frameHeight, frameWidth, frameHeight, 0, 0, drawW, drawH);
                    ctx.restore();
                } else {
                    ctx.drawImage(playerImg, col * frameWidth, row * frameHeight, frameWidth, frameHeight, spriteX, spriteY, drawW, drawH);
                }
            } else {
                ctx.fillStyle = '#4a7';
                ctx.fillRect(sx, sy, player.width, player.height);
            }

            // Attack effect
            if (player.attacking) {
                ctx.save();
                ctx.strokeStyle = '#adf';
                ctx.lineWidth = 3;
                ctx.globalAlpha = player.attackTimer / 18;
                ctx.beginPath();
                const cx = sx + player.width / 2;
                const cy = sy + player.height / 2;
                switch (player.direction) {
                    case 'up': ctx.arc(cx, cy - 30, 30, Math.PI * 1.2, Math.PI * 1.8); break;
                    case 'down': ctx.arc(cx, cy + 30, 30, Math.PI * 0.2, Math.PI * 0.8); break;
                    case 'left': ctx.arc(cx - 30, cy, 30, Math.PI * 0.7, Math.PI * 1.3); break;
                    case 'right': ctx.arc(cx + 30, cy, 30, -Math.PI * 0.3, Math.PI * 0.3); break;
                }
                ctx.stroke();
                ctx.restore();
            }

            // DEBUG: Draw collision box (shows actual foot hitbox used for collision)
            if (showCollision) {
                // Always show the small foot hitbox (bottom 1/3)
                const collisionHeight = player.height / 3;
                const collisionOffsetY = player.height * 2/3;

                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.strokeRect(sx, sy + collisionOffsetY, player.width, collisionHeight);

                // Draw center point of collision box
                ctx.fillStyle = '#0f0';
                ctx.beginPath();
                ctx.arc(sx + player.width / 2, sy + collisionOffsetY + collisionHeight / 2, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Game loop is started when all tilesets load (see tileset loading code above)
    <\/script>
</body>
</html>
            `);
            testWindow.document.close();
        }
    </script>
</body>
</html>
