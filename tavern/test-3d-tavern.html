<!DOCTYPE html>
<html>
<head>
    <title>3D Tavern Test</title>
    <style>
        * { margin: 0; padding: 0; }
        body {
            background: #111;
            overflow: hidden;
            font-family: monospace;
        }
        canvas { display: block; }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            max-width: 280px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 100;
        }
        #info::-webkit-scrollbar { width: 6px; }
        #info::-webkit-scrollbar-track { background: #222; }
        #info::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
        #info::-webkit-scrollbar-thumb:hover { background: #777; }
        #info h2 { color: #4af; margin-bottom: 10px; }
        #info p { margin: 5px 0; color: #aaa; font-size: 12px; }
        #info .controls { margin-top: 15px; border-top: 1px solid #444; padding-top: 10px; }
        #info label { display: block; margin: 8px 0 4px 0; color: #888; }
        #info input[type="range"] { width: 100%; }
        #info .value { color: #4f8; float: right; }
        #info button {
            margin-top: 8px;
            padding: 8px 15px;
            background: #4a7c59;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        #info button:hover { background: #5a9c69; }
        #info button.active { background: #c44; }
        #info button.spawn-btn { background: #c84; }
        #info button.spawn-btn:hover { background: #ea6; }
        #info .position-display {
            background: #1a1a2e;
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 11px;
        }
        #info .position-display div { margin: 3px 0; }
        #info .position-display span { color: #4f8; }
        @font-face {
            font-family: 'PressStart';
            src: local('Press Start 2P'), local('PressStart2P');
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-family: 'Courier New', monospace;
            image-rendering: pixelated;
        }
        #loading .pixel-art {
            font-size: 8px;
            line-height: 1;
            letter-spacing: 0;
            color: #fff;
            white-space: pre;
            margin-bottom: 30px;
            animation: blink 1s steps(1) infinite;
        }
        @keyframes blink {
            50% { opacity: 0.7; }
        }
        #loading .title {
            font-size: 16px;
            color: #fff;
            margin-bottom: 20px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        #loading .progress {
            width: 200px;
            height: 16px;
            background: #000;
            border: 4px solid #fff;
        }
        #loading .bar {
            height: 100%;
            background: #fff;
            width: 0%;
            transition: width 0.1s steps(10);
        }
        #loading #loadPercent {
            margin-top: 12px;
            font-size: 14px;
            color: #fff;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.5);
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
            top: 0;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            left: 0;
            top: 9px;
        }
        #modeIndicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #4af;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
        }
        #spawnMarker {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0f0;
            font-size: 48px;
            pointer-events: none;
            z-index: 60;
            text-shadow: 0 0 10px #0f0;
            display: none;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/+esm"
        }
    }
    </script>
</head>
<body>
    <div id="loading">
<div class="pixel-art">
   _______
  |       |_
  |  ~~~  | |
  |  ~~~  | |
  |  ~~~  |_|
  |_______|
</div>
        <div class="title">Tavern</div>
        <div class="progress"><div class="bar" id="loadBar"></div></div>
        <div id="loadPercent">0%</div>
    </div>

    <div id="crosshair" style="display:none;"></div>
    <div id="spawnMarker">+</div>

    <div id="info" style="display:none;">
        <h2>3D Tavern Test</h2>

        <!-- CONTROLS (Always visible) -->
        <div style="border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 10px;">
            <label style="color:#4af; font-size:12px;">Controls</label>
            <div class="position-display" style="margin-top:8px;">
                <div>Position: <span id="posDisplay">0, 0, 0</span></div>
                <div>Height (Y): <span id="heightDisplay">1.6</span></div>
                <div>Looking: <span id="lookDisplay">0, 0</span></div>
                <div>Ground: <span id="groundedDisplay" style="color:#f44;">NOT GROUNDED</span></div>
            </div>
            <button onclick="resetCamera()" style="width:100%; margin-top:8px; padding:6px; font-size:11px;">Reset Camera</button>
            <button id="musicBtn" onclick="toggleMusic()" style="width:100%; margin-top:4px; padding:6px; font-size:11px; background:#555;">ðŸŽµ Music: OFF</button>
        </div>

        <!-- HELP SECTION (Collapsible) -->
        <div style="border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 10px;">
            <label onclick="toggleHelpSection()" style="color:#4af; cursor:pointer; font-size:12px;"><span id="helpArrow" style="margin-right:5px;">+</span>Help</label>
            <div id="helpContent" style="display:none;">
                <p style="color:#f84; margin:8px 0 4px 0; font-size:11px;"><b>H</b> - Hide/Show UI</p>
                <p style="font-size:11px; margin:2px 0;"><b>Click canvas</b> - Enter look mode</p>
                <p style="font-size:11px; margin:2px 0;"><b>ESC</b> - Exit look mode</p>
                <p style="font-size:11px; margin:2px 0;"><b>WASD</b> - Move | <b>Space</b> - Jump | <b>Shift</b> - Run</p>
                <div class="controls" style="margin-top:8px;">
                    <label>Move Speed: <span class="value" id="speedVal">5</span></label>
                    <input type="range" id="speedSlider" min="1" max="20" step="0.5" value="5">
                    <label>Look Sensitivity: <span class="value" id="sensVal">2</span></label>
                    <input type="range" id="sensSlider" min="0.5" max="5" step="0.1" value="2">
                </div>
            </div>
        </div>

        <!-- SPAWN SECTION (Collapsible) -->
        <div style="border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 10px;">
            <label onclick="toggleSpawnSection()" style="color:#c84; cursor:pointer; font-size:12px;"><span id="spawnArrow" style="margin-right:5px;">+</span>Spawn</label>
            <div id="spawnContent" style="display:none;">
                <button class="spawn-btn" id="setSpawnBtn" onclick="toggleSetSpawn()" style="margin-top:8px;">Set Spawn Point</button>
                <div id="spawnInfo" style="color:#888; font-size:11px; margin-top:5px;">
                    Spawn: <span id="spawnDisplay">Not set</span>
                </div>
                <button onclick="goToSpawn()" style="width:100%; margin-top:8px;">Go To Spawn</button>
                <button onclick="copySpawnData()" style="margin-top:5px;">Copy Spawn Data</button>
            </div>
        </div>

        <!-- CAMERA SECTION (Collapsible) -->
        <div style="border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 10px;">
            <label onclick="toggleCameraSection()" style="color:#8af; cursor:pointer; font-size:12px;"><span id="cameraArrow" style="margin-right:5px;">+</span>Camera</label>
            <div id="cameraContent" style="display:none;">
                <div style="margin-top:8px; background:#1a1a3a; padding:8px; border-radius:4px;">
                    <label style="color:#888; font-size:11px;">Camera Offset (from player)</label>
                    <div style="margin-top:6px;">
                        <label style="color:#666; font-size:10px;">X: <span id="camXVal">0</span></label>
                        <input type="range" id="camXSlider" min="-1.5" max="1.5" step="0.05" value="0" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Y (Height): <span id="camYVal">0</span></label>
                        <input type="range" id="camYSlider" min="-2" max="2" step="0.05" value="0" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Z (Forward): <span id="camZVal">0</span></label>
                        <input type="range" id="camZSlider" min="-1.5" max="1.5" step="0.05" value="0" style="width:100%;">
                    </div>
                    <button onclick="copyCameraSettings()" style="width:100%; margin-top:6px; padding:5px; font-size:10px; background:#48a;">Copy Camera Settings</button>
                </div>
                <!-- FPS Hands Position -->
                <div style="margin-top:8px; background:#1a3a2a; padding:8px; border-radius:4px;">
                    <label style="color:#8f8; font-size:11px;">FPS Hands Position</label>
                    <div style="margin-top:6px;">
                        <label style="color:#666; font-size:10px;">X: <span id="handsXVal">0</span></label>
                        <input type="range" id="handsXSlider" min="-1.5" max="1.5" step="0.05" value="0" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Y: <span id="handsYVal">-0.85</span></label>
                        <input type="range" id="handsYSlider" min="-2" max="1" step="0.05" value="-0.85" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Z: <span id="handsZVal">-1.35</span></label>
                        <input type="range" id="handsZSlider" min="-2" max="1" step="0.05" value="-1.35" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Scale: <span id="handsScaleVal">1.5</span></label>
                        <input type="range" id="handsScaleSlider" min="0.2" max="3" step="0.1" value="1.5" style="width:100%;">
                    </div>
                    <div style="margin-top:6px; border-top:1px solid #2a4a3a; padding-top:6px;">
                        <label style="color:#8f8; font-size:10px;">Rotation</label>
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Pitch (X): <span id="handsRotXVal">60</span>Â°</label>
                        <input type="range" id="handsRotXSlider" min="-180" max="180" step="5" value="60" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Yaw (Y): <span id="handsRotYVal">180</span>Â°</label>
                        <input type="range" id="handsRotYSlider" min="-180" max="180" step="5" value="180" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Roll (Z): <span id="handsRotZVal">0</span>Â°</label>
                        <input type="range" id="handsRotZSlider" min="-180" max="180" step="5" value="0" style="width:100%;">
                    </div>
                    <div style="margin-top:6px; border-top:1px solid #2a4a3a; padding-top:6px;">
                        <label style="color:#8f8; font-size:10px;">Animation</label>
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Speed: <span id="animSpeedVal">1.0</span>x</label>
                        <input type="range" id="animSpeedSlider" min="0.25" max="2.5" step="0.05" value="1.0" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Blend: <span id="animBlendVal">0.2</span>s</label>
                        <input type="range" id="animBlendSlider" min="0.05" max="1.0" step="0.05" value="0.2" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Intensity: <span id="animIntensityVal">100</span>%</label>
                        <input type="range" id="animIntensitySlider" min="0" max="100" step="5" value="100" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Force Anim:</label>
                        <select id="forceAnimSelect" style="width:100%; margin-top:2px; padding:3px; font-size:10px; background:#333; color:#fff; border:1px solid #555;">
                            <option value="auto">Auto (movement based)</option>
                            <option value="idle">Idle</option>
                            <option value="walk">Walk</option>
                            <option value="run">Run</option>
                        </select>
                    </div>
                    <div style="display:flex; gap:5px; margin-top:6px;">
                        <button id="toggleHandsBtn" onclick="toggleHandsVisible()" style="flex:1; padding:5px; font-size:10px; background:#555;">Hide Hands</button>
                        <button onclick="copyHandsSettings()" style="flex:1; padding:5px; font-size:10px; background:#48a;">Copy Settings</button>
                    </div>
                </div>
                <!-- Camera Marker -->
                <div style="margin-top:8px;">
                    <button id="toggleCamMarkerBtn" onclick="toggleCameraMarker()" style="width:100%; padding:5px; font-size:10px; background:#555;">Show Camera Marker</button>
                </div>
            </div>
        </div>

        <!-- PLAYER BODY SECTION (Collapsible) -->
        <div style="border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 10px;">
            <label onclick="togglePlayerBodySection()" style="color:#f84; cursor:pointer; font-size:12px;"><span id="playerBodyArrow" style="margin-right:5px;">+</span>Player Body</label>
            <div id="playerBodyContent" style="display:none;">
                <!-- View Toggle -->
                <div style="display:flex; gap:3px; margin-top:8px;">
                    <button id="viewFP" onclick="setViewMode('fp')" style="flex:1; padding:6px; background:#4a4; font-size:11px;">First Person</button>
                    <button id="viewTP" onclick="setViewMode('tp')" style="flex:1; padding:6px; background:#555; font-size:11px;">Third Person</button>
                </div>

                <!-- Player Body Dimensions -->
                <div style="margin-top:10px; background:#1a2a3a; border-radius:4px; padding:8px;">
                    <label style="color:#888; font-size:11px;">Visual Body</label>
                    <div style="margin-top:6px;">
                        <label style="color:#666; font-size:10px;">Width: <span id="playerWidthVal">0.5</span></label>
                        <input type="range" id="playerWidth" min="0.2" max="2.0" step="0.1" value="0.5" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Depth: <span id="playerDepthVal">0.8</span></label>
                        <input type="range" id="playerDepth" min="0.2" max="2.0" step="0.1" value="0.8" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Height: <span id="playerHeightVal">1.4</span></label>
                        <input type="range" id="playerHeight" min="0.5" max="3.0" step="0.1" value="1.4" style="width:100%;">
                    </div>
                    <div style="margin-top:6px; display:flex; gap:5px;">
                        <button id="toggleBodyBtn" onclick="togglePlayerBody()" style="flex:1; padding:5px; font-size:10px; background:#555;">Hide Body</button>
                        <button id="toggleCollBtn" onclick="toggleCollisionVis()" style="flex:1; padding:5px; font-size:10px; background:#555;">Hide Coll</button>
                    </div>
                </div>

                <!-- Collision Box Settings (ACTUAL COLLISION) -->
                <div style="margin-top:8px; background:#2a1a3a; padding:8px; border-radius:4px;">
                    <label style="color:#f84; font-size:11px;">Collision Box (ACTUAL)</label>
                    <div style="margin-top:6px;">
                        <label style="color:#666; font-size:10px;">Width: <span id="collWidthVal">0.6</span></label>
                        <input type="range" id="collWidthSlider2" min="0.2" max="2.0" step="0.1" value="0.6" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Depth: <span id="collDepthVal2">0.4</span></label>
                        <input type="range" id="collDepthSlider2" min="0.2" max="2.0" step="0.1" value="0.4" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Height: <span id="collHeightVal">3</span></label>
                        <input type="range" id="collHeight" min="0.5" max="5.0" step="0.1" value="3" style="width:100%;">
                    </div>
                    <div style="margin-top:4px;">
                        <label style="color:#666; font-size:10px;">Offset Y: <span id="collOffsetVal">-1</span></label>
                        <input type="range" id="collOffset" min="-2.0" max="1.0" step="0.05" value="-1" style="width:100%;">
                    </div>
                </div>
            </div>
        </div>

        <!-- COLLISION SECTION (Collapsible) -->
        <div>
            <label onclick="toggleCollisionSection()" style="color:#0f0; cursor:pointer; font-size:12px;"><span id="collisionArrow" style="margin-right:5px;">+</span>Collision</label>
            <div id="collisionContent" style="display:none;">
                <button id="collPlaceModeBtn" onclick="startCollisionPlacement()" style="width:100%; margin-top:8px; padding:8px; background:#383; font-size:12px;">Place Collision Box</button>
                <button id="toggleBucketCollBtn" onclick="toggleBucketCollisionVis()" style="width:100%; margin-top:5px; padding:5px; font-size:10px; background:#a84;">Show Collision Boxes</button>
                <button id="testModeBtn" onclick="toggleTestMode()" style="width:100%; margin-top:5px; background:#4a4;">Collision: ON</button>
                <button id="copyObjectBtn" onclick="startCopyMode()" style="width:100%; margin-top:5px; padding:8px; background:#a48; font-size:12px;">Copy Object</button>
                <button id="farkleTableBtn" onclick="startFarklePlacement()" style="width:100%; margin-top:5px; padding:8px; background:#b86; font-size:12px;">Place Farkle Table</button>
                <div style="font-size:10px; color:#888; margin-top:5px;">
                    View: <span id="currentViewDisplay">First Person</span> | Collisions: <span id="collisionCount">0</span>
                </div>
            </div>
        </div>
    </div>

    <div id="modeIndicator">Click to enable mouse look</div>

    <!-- Collision Placement Panel (separate from main UI) -->
    <div id="collisionPlacementPanel" style="display:none; position:fixed; top:10px; left:10px; background:rgba(0,30,0,0.95); padding:15px; border-radius:8px; border:2px solid #0f0; max-width:280px; z-index:150;">
        <h3 style="color:#0f0; margin:0 0 12px 0; font-size:14px;">â¬› Collision Box Placement</h3>

        <!-- Preview Mode UI (before clicking to place) -->
        <div id="previewModeUI">
            <div style="color:#8f8; font-size:12px; text-align:center; padding:12px; background:#1a3a1a; border-radius:4px; margin-bottom:12px;">
                Look at a surface<br>then <b>CLICK</b> to place box
            </div>

            <!-- Shape Presets -->
            <label style="color:#888; font-size:11px;">Shape Presets:</label>
            <div style="display:flex; gap:4px; margin-top:5px; flex-wrap:wrap;">
                <button onclick="setCollShape('box')" class="collShapeBtn" data-shape="box" style="flex:1; padding:6px; font-size:10px; background:#4a4; border:none; color:white; border-radius:3px; cursor:pointer;">Box</button>
                <button onclick="setCollShape('tallBox')" class="collShapeBtn" data-shape="tallBox" style="flex:1; padding:6px; font-size:10px; background:#555; border:none; color:white; border-radius:3px; cursor:pointer;">Tall</button>
                <button onclick="setCollShape('wideBox')" class="collShapeBtn" data-shape="wideBox" style="flex:1; padding:6px; font-size:10px; background:#555; border:none; color:white; border-radius:3px; cursor:pointer;">Wide</button>
                <button onclick="setCollShape('wall')" class="collShapeBtn" data-shape="wall" style="flex:1; padding:6px; font-size:10px; background:#555; border:none; color:white; border-radius:3px; cursor:pointer;">Wall</button>
                <button onclick="setCollShape('cylinder')" class="collShapeBtn" data-shape="cylinder" style="flex:1; padding:6px; font-size:10px; background:#558; border:none; color:white; border-radius:3px; cursor:pointer;">Cylinder</button>
            </div>

            <!-- Initial Size (before placing) -->
            <div style="margin-top:12px; background:#001a00; padding:10px; border-radius:5px;">
                <label style="color:#0f0; font-size:11px; font-weight:bold;">Initial Size</label>
                <div style="margin-top:8px;">
                    <label style="color:#aaa; font-size:10px;">Width: <span id="initWidthVal" style="color:#0f0;">1.0</span></label>
                    <input type="range" id="initWidthSlider" min="0.2" max="10" step="0.1" value="1.0" style="width:100%; margin-top:3px;">
                </div>
                <div style="margin-top:6px;">
                    <label style="color:#aaa; font-size:10px;">Height: <span id="initHeightVal" style="color:#0f0;">1.0</span></label>
                    <input type="range" id="initHeightSlider" min="0.2" max="10" step="0.1" value="1.0" style="width:100%; margin-top:3px;">
                </div>
                <div style="margin-top:6px;">
                    <label style="color:#aaa; font-size:10px;">Depth: <span id="initDepthVal" style="color:#0f0;">1.0</span></label>
                    <input type="range" id="initDepthSlider" min="0.2" max="10" step="0.1" value="1.0" style="width:100%; margin-top:3px;">
                </div>
            </div>
        </div>

        <!-- Adjust Mode UI (after placing, before confirming) -->
        <div id="adjustModeUI" style="display:none;">
            <div style="color:#ff8; font-size:12px; text-align:center; padding:12px; background:#3a3a1a; border-radius:4px; margin-bottom:12px;">
                Adjust size & position<br>then click <b>SET</b> to confirm
            </div>

            <!-- Adjust Size -->
            <div style="background:#001a00; padding:10px; border-radius:5px;">
                <label style="color:#0f0; font-size:11px; font-weight:bold;">Size</label>
                <div style="margin-top:8px;">
                    <label style="color:#aaa; font-size:10px;">Width: <span id="adjustWidthVal" style="color:#0f0;">1.0</span></label>
                    <input type="range" id="adjustWidthSlider" min="0.2" max="10" step="0.1" value="1.0" style="width:100%; margin-top:3px;">
                </div>
                <div style="margin-top:6px;">
                    <label style="color:#aaa; font-size:10px;">Height: <span id="adjustHeightVal" style="color:#0f0;">1.0</span></label>
                    <input type="range" id="adjustHeightSlider" min="0.2" max="10" step="0.1" value="1.0" style="width:100%; margin-top:3px;">
                </div>
                <div style="margin-top:6px;">
                    <label style="color:#aaa; font-size:10px;">Depth: <span id="adjustDepthVal" style="color:#0f0;">1.0</span></label>
                    <input type="range" id="adjustDepthSlider" min="0.2" max="10" step="0.1" value="1.0" style="width:100%; margin-top:3px;">
                </div>
            </div>

            <!-- Adjust Position -->
            <div style="margin-top:10px; background:#001a00; padding:10px; border-radius:5px;">
                <label style="color:#0f0; font-size:11px; font-weight:bold;">Position Offset</label>
                <div style="margin-top:8px;">
                    <label style="color:#aaa; font-size:10px;">X: <span id="adjustOffsetXVal" style="color:#0f0;">0.0</span></label>
                    <input type="range" id="adjustOffsetXSlider" min="-5" max="5" step="0.1" value="0" style="width:100%; margin-top:3px;">
                </div>
                <div style="margin-top:6px;">
                    <label style="color:#aaa; font-size:10px;">Y: <span id="adjustOffsetYVal" style="color:#0f0;">0.0</span></label>
                    <input type="range" id="adjustOffsetYSlider" min="-5" max="5" step="0.1" value="0" style="width:100%; margin-top:3px;">
                </div>
                <div style="margin-top:6px;">
                    <label style="color:#aaa; font-size:10px;">Z: <span id="adjustOffsetZVal" style="color:#0f0;">0.0</span></label>
                    <input type="range" id="adjustOffsetZSlider" min="-5" max="5" step="0.1" value="0" style="width:100%; margin-top:3px;">
                </div>
            </div>

            <!-- Rotation -->
            <div style="margin-top:10px; background:#1a1a00; padding:10px; border-radius:5px;">
                <label style="color:#ff0; font-size:11px; font-weight:bold;">Rotation</label>
                <div style="margin-top:8px;">
                    <label style="color:#aaa; font-size:10px;">X (Pitch): <span id="adjustRotationXVal" style="color:#ff0;">0</span></label>
                    <input type="range" id="adjustRotationXSlider" min="0" max="360" step="15" value="0" style="width:100%; margin-top:3px;">
                </div>
                <div style="margin-top:6px;">
                    <label style="color:#aaa; font-size:10px;">Y (Yaw): <span id="adjustRotationYVal" style="color:#ff0;">0</span></label>
                    <input type="range" id="adjustRotationYSlider" min="0" max="360" step="15" value="0" style="width:100%; margin-top:3px;">
                </div>
                <div style="margin-top:6px;">
                    <label style="color:#aaa; font-size:10px;">Z (Roll): <span id="adjustRotationZVal" style="color:#ff0;">0</span></label>
                    <input type="range" id="adjustRotationZSlider" min="0" max="360" step="15" value="0" style="width:100%; margin-top:3px;">
                </div>
            </div>

            <!-- Walk/Slider toggle button -->
            <button id="walkModeBtn" onclick="toggleAdjustWalkMode()" style="width:100%; margin-top:10px; padding:10px; background:#4a4; border:none; color:white; border-radius:4px; cursor:pointer; font-size:12px;">Switch to Sliders (TAB)</button>

            <!-- Confirm/Cancel buttons -->
            <div style="margin-top:12px; display:flex; gap:8px;">
                <button onclick="confirmPlacement()" style="flex:2; padding:12px; background:#4a4; border:none; color:white; border-radius:4px; cursor:pointer; font-size:14px; font-weight:bold;">âœ“ SET</button>
                <button onclick="cancelPlacement()" style="flex:1; padding:12px; background:#a44; border:none; color:white; border-radius:4px; cursor:pointer; font-size:12px;">âœ• Cancel</button>
            </div>
        </div>

        <button onclick="exitCollisionPlacement()" style="width:100%; margin-top:12px; padding:10px; background:#c44; border:none; color:white; border-radius:3px; cursor:pointer; font-size:12px;">âœ• Exit Placement Mode</button>

        <p style="color:#666; font-size:9px; margin-top:10px; text-align:center;">Boxes placed: <span id="placedBoxCount">0</span></p>
    </div>

    <!-- Copy Object Panel -->
    <div id="copyPanel" style="display:none; position:fixed; top:10px; left:10px; background:rgba(30,0,30,0.95); padding:15px; border-radius:8px; border:2px solid #a4f; max-width:280px; z-index:150;">
        <h3 style="color:#a4f; margin:0 0 12px 0; font-size:14px;">Copy Object</h3>

        <!-- Select Phase -->
        <div id="copySelectUI">
            <div style="color:#c8f; font-size:12px; text-align:center; padding:12px; background:#2a1a3a; border-radius:4px; margin-bottom:12px;">
                Look at an object<br>Press <b>C</b> to copy it
            </div>
        </div>

        <!-- Selection Phase - adjust sphere size -->
        <div id="copySelectionUI" style="display:none;">
            <div style="color:#8f8; font-size:12px; text-align:center; padding:8px; background:#1a3a1a; border-radius:4px; margin-bottom:8px;">
                Move around to view<br>
                <b>ESC</b> to adjust sliders
            </div>
            <!-- Shape Selection -->
            <div style="margin-bottom:6px;">
                <label style="color:#8f8; font-size:11px;">Shape:</label>
                <select id="selectionShapeSelect" style="width:100%; margin-top:2px; padding:3px; font-size:10px; background:#333; color:#fff; border:1px solid #555;">
                    <option value="sphere">Sphere</option>
                    <option value="box">Box</option>
                </select>
            </div>
            <!-- Sphere Size (shown when sphere selected) -->
            <div id="sphereSizeUI">
                <div style="margin-bottom:6px;">
                    <label style="color:#8f8; font-size:11px;">Radius: <span id="selectionRadiusVal">0.50</span></label>
                    <input type="range" id="selectionRadiusSlider" min="0.1" max="5" step="0.05" value="0.5" style="width:100%;">
                </div>
            </div>
            <!-- Box Size (shown when box selected) -->
            <div id="boxSizeUI" style="display:none;">
                <div style="margin-bottom:4px;">
                    <label style="color:#666; font-size:10px;">Width (X): <span id="selectionBoxWVal">1.00</span></label>
                    <input type="range" id="selectionBoxWSlider" min="0.1" max="5" step="0.05" value="1" style="width:100%;">
                </div>
                <div style="margin-bottom:4px;">
                    <label style="color:#666; font-size:10px;">Height (Y): <span id="selectionBoxHVal">1.00</span></label>
                    <input type="range" id="selectionBoxHSlider" min="0.1" max="5" step="0.05" value="1" style="width:100%;">
                </div>
                <div style="margin-bottom:6px;">
                    <label style="color:#666; font-size:10px;">Depth (Z): <span id="selectionBoxDVal">1.00</span></label>
                    <input type="range" id="selectionBoxDSlider" min="0.1" max="5" step="0.05" value="1" style="width:100%;">
                </div>
            </div>
            <!-- Position Offset -->
            <div style="margin-bottom:6px; border-top:1px solid #2a4a2a; padding-top:6px;">
                <label style="color:#8f8; font-size:11px;">Position Offset</label>
            </div>
            <div style="margin-bottom:4px;">
                <label style="color:#666; font-size:10px;">X: <span id="selectionOffsetXVal">0.00</span></label>
                <input type="range" id="selectionOffsetXSlider" min="-3" max="3" step="0.05" value="0" style="width:100%;">
            </div>
            <div style="margin-bottom:4px;">
                <label style="color:#666; font-size:10px;">Y: <span id="selectionOffsetYVal">0.00</span></label>
                <input type="range" id="selectionOffsetYSlider" min="-3" max="3" step="0.05" value="0" style="width:100%;">
            </div>
            <div style="margin-bottom:8px;">
                <label style="color:#666; font-size:10px;">Z: <span id="selectionOffsetZVal">0.00</span></label>
                <input type="range" id="selectionOffsetZSlider" min="-3" max="3" step="0.05" value="0" style="width:100%;">
            </div>
            <div style="display:flex; gap:8px;">
                <button onclick="confirmSelection()" style="flex:1; padding:8px; font-size:12px; background:#4a4; border:none; color:#fff; border-radius:4px; cursor:pointer;">Confirm</button>
                <button onclick="cancelSelection()" style="flex:1; padding:8px; font-size:12px; background:#a44; border:none; color:#fff; border-radius:4px; cursor:pointer;">Cancel</button>
            </div>
        </div>

        <!-- Preview Phase -->
        <div id="copyPreviewUI" style="display:none;">
            <div style="color:#8fc; font-size:12px; text-align:center; padding:12px; background:#1a3a2a; border-radius:4px; margin-bottom:12px;">
                Clone follows aim<br><b>Click</b> to place
            </div>
        </div>

        <!-- Adjust Phase -->
        <div id="copyAdjustUI" style="display:none;">
            <div style="color:#ff8; font-size:12px; text-align:center; padding:8px; background:#3a3a1a; border-radius:4px; margin-bottom:12px;">
                Adjust position & rotation
            </div>

            <!-- Position -->
            <div style="background:#1a1a2a; padding:8px; border-radius:4px; margin-bottom:8px;">
                <label style="color:#88f; font-size:10px;">Position Offset</label>
                <div style="margin-top:6px;">
                    <label style="color:#666; font-size:9px;">X: <span id="copyOffsetXVal">0</span></label>
                    <input type="range" id="copyOffsetXSlider" min="-10" max="10" step="0.1" value="0" style="width:100%;">
                </div>
                <div style="margin-top:4px;">
                    <label style="color:#666; font-size:9px;">Y: <span id="copyOffsetYVal">0</span></label>
                    <input type="range" id="copyOffsetYSlider" min="-10" max="10" step="0.1" value="0" style="width:100%;">
                </div>
                <div style="margin-top:4px;">
                    <label style="color:#666; font-size:9px;">Z: <span id="copyOffsetZVal">0</span></label>
                    <input type="range" id="copyOffsetZSlider" min="-10" max="10" step="0.1" value="0" style="width:100%;">
                </div>
            </div>

            <!-- Rotation -->
            <div style="background:#2a1a1a; padding:8px; border-radius:4px; margin-bottom:8px;">
                <label style="color:#f88; font-size:10px;">Rotation</label>
                <div style="margin-top:6px;">
                    <label style="color:#666; font-size:9px;">Y (Yaw): <span id="copyRotationYVal">0</span>Â°</label>
                    <input type="range" id="copyRotationYSlider" min="0" max="360" step="15" value="0" style="width:100%;">
                </div>
            </div>

            <!-- Scale -->
            <div style="background:#1a2a1a; padding:8px; border-radius:4px; margin-bottom:8px;">
                <label style="color:#8f8; font-size:10px;">Scale: <span id="copyScaleVal">1.0</span></label>
                <input type="range" id="copyScaleSlider" min="0.1" max="3" step="0.1" value="1" style="width:100%;">
            </div>

            <!-- Confirm/Cancel -->
            <div style="display:flex; gap:8px;">
                <button onclick="confirmCopyPlacement()" style="flex:2; padding:10px; background:#484; border:none; color:white; border-radius:4px; cursor:pointer; font-size:12px; font-weight:bold;">SET</button>
                <button onclick="cancelCopy()" style="flex:1; padding:10px; background:#844; border:none; color:white; border-radius:4px; cursor:pointer; font-size:11px;">Cancel</button>
            </div>
        </div>

        <button onclick="exitCopyMode()" style="width:100%; margin-top:12px; padding:10px; background:#c44; border:none; color:white; border-radius:3px; cursor:pointer; font-size:12px;">Exit Copy Mode</button>

        <p style="color:#666; font-size:9px; margin-top:10px; text-align:center;">Objects copied: <span id="copiedCount">0</span></p>
    </div>

    <!-- Farkle Table Placement Panel -->
    <div id="farklePanel" style="display:none; position:fixed; top:10px; left:10px; background:rgba(40,25,10,0.95); padding:15px; border-radius:8px; border:2px solid #b86; max-width:280px; z-index:150;">
        <h3 style="color:#db8; margin:0 0 12px 0; font-size:14px;">Farkle Table Placement</h3>

        <div style="color:#ca7; font-size:12px; text-align:center; padding:12px; background:#2a1a0a; border-radius:4px; margin-bottom:12px;">
            Look at a surface<br>Click to place dice tray
        </div>

        <!-- Rotation slider -->
        <div style="background:#1a1008; padding:10px; border-radius:5px; margin-bottom:10px;">
            <label style="color:#db8; font-size:11px;">Rotation</label>
            <div style="margin-top:6px;">
                <label style="color:#aaa; font-size:10px;">Y: <span id="farkleRotationVal" style="color:#db8;">0</span>Â°</label>
                <input type="range" id="farkleRotationSlider" min="0" max="360" step="15" value="0" style="width:100%; margin-top:3px;">
            </div>
        </div>

        <!-- Table Leg Height -->
        <div style="background:#1a1008; padding:10px; border-radius:5px; margin-bottom:10px;">
            <label style="color:#db8; font-size:11px;">Table Leg Height</label>
            <div style="margin-top:6px;">
                <label style="color:#aaa; font-size:10px;">Height: <span id="legHeightVal" style="color:#db8;">0.95</span>m</label>
                <input type="range" id="legHeightSlider" min="0.5" max="2.0" step="0.05" value="0.95" style="width:100%; margin-top:3px;">
            </div>
        </div>

        <!-- Felt Surface Height -->
        <div style="background:#1a1008; padding:10px; border-radius:5px; margin-bottom:10px;">
            <label style="color:#4f8; font-size:11px;">Felt Surface Height (Physics)</label>
            <div style="margin-top:6px;">
                <label style="color:#aaa; font-size:10px;">Height: <span id="feltHeightVal" style="color:#4f8;">1.07</span>m</label>
                <input type="range" id="feltHeightSlider" min="0.5" max="2.0" step="0.01" value="1.07" style="width:100%; margin-top:3px;">
            </div>
        </div>

        <!-- Felt Color Picker -->
        <div style="background:#1a1008; padding:10px; border-radius:5px; margin-bottom:10px;">
            <label style="color:#4f8; font-size:11px;">Felt Color</label>
            <div style="margin-top:6px; display:flex; align-items:center; gap:10px;">
                <input type="color" id="feltColorPicker" value="#22DD44" style="width:50px; height:30px; border:none; cursor:pointer;">
                <span id="feltColorVal" style="color:#4f8; font-size:10px;">#22DD44</span>
            </div>
            <div style="margin-top:8px;">
                <label style="color:#aaa; font-size:10px;">Emissive (glow): <span id="feltEmissiveVal" style="color:#4f8;">0.8</span></label>
                <input type="range" id="feltEmissiveSlider" min="0" max="2.0" step="0.1" value="0.8" style="width:100%; margin-top:3px;">
            </div>
        </div>

        <!-- Confirm/Cancel buttons -->
        <div style="display:flex; gap:8px;">
            <button onclick="confirmFarklePlacement()" style="flex:2; padding:12px; background:#684; border:none; color:white; border-radius:4px; cursor:pointer; font-size:14px; font-weight:bold;">Place Table</button>
            <button onclick="exitFarklePlacement()" style="flex:1; padding:12px; background:#a44; border:none; color:white; border-radius:4px; cursor:pointer; font-size:12px;">Cancel</button>
        </div>

        <p style="color:#666; font-size:9px; margin-top:10px; text-align:center;">Tables placed: <span id="farkleTableCount">0</span></p>
        <button onclick="copyAllFarkleTables()" style="width:100%; margin-top:8px; padding:8px; background:#486; border:none; color:white; border-radius:4px; cursor:pointer; font-size:11px;">Copy All Tables Info</button>
    </div>

    <!-- Farkle Camera Setting Panel -->
    <div id="farkleCameraPanel" style="display:none; position:fixed; top:10px; left:10px; background:rgba(20,30,50,0.95); padding:15px; border-radius:8px; border:2px solid #8cf; max-width:300px; z-index:150;">
        <h3 style="color:#8cf; margin:0 0 12px 0; font-size:14px;">Set Farkle Camera Position</h3>

        <div style="color:#acd; font-size:12px; padding:12px; background:#1a2030; border-radius:4px; margin-bottom:12px;">
            Walk to where you want the camera<br>
            when playing Farkle at this table.<br><br>
            <b>WASD</b> - Move around<br>
            <b>Q/E</b> - Lower/Raise camera<br>
            <b>Mouse</b> - Look around<br><br>
            Look at the dice tray, then <b>click</b><br>
            to set this as the play view.
        </div>

        <div style="display:flex; gap:8px;">
            <button onclick="setFarkleCameraPosition()" style="flex:2; padding:12px; background:#468; border:none; color:white; border-radius:4px; cursor:pointer; font-size:14px; font-weight:bold;">Set Camera</button>
            <button onclick="cancelFarkleCamera()" style="flex:1; padding:12px; background:#a44; border:none; color:white; border-radius:4px; cursor:pointer; font-size:12px;">Cancel</button>
        </div>
    </div>

    <!-- Copy Table Info Result Panel -->
    <div id="copyTablePanel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:rgba(20,30,20,0.98); padding:20px 30px; border-radius:12px; border:3px solid #4a8; max-width:500px; z-index:200; text-align:center;">
        <h3 style="color:#8f8; margin:0 0 15px 0; font-size:16px;">Table Info Copied!</h3>
        <p style="color:#aaa; font-size:11px; margin-bottom:15px;">Add this to your farkleTables array to save permanently:</p>
        <textarea id="tableInfoOutput" readonly style="width:100%; height:200px; background:#1a2a1a; color:#8f8; border:1px solid #4a8; border-radius:4px; padding:10px; font-family:monospace; font-size:10px; resize:vertical;"></textarea>
        <button onclick="closeCopyTablePanel()" style="margin-top:15px; padding:10px 30px; background:#486; border:none; color:white; border-radius:6px; cursor:pointer; font-size:14px;">Close</button>
    </div>

    <!-- Farkle UI Rotation Panel -->
    <div id="farkleUIRotatePanel" style="display:none; position:fixed; top:10px; left:10px; background:rgba(40,30,50,0.95); padding:15px; border-radius:8px; border:2px solid #a8f; max-width:300px; z-index:150;">
        <h3 style="color:#a8f; margin:0 0 12px 0; font-size:14px;">Adjust UI Orientation</h3>

        <div style="color:#caf; font-size:12px; padding:12px; background:#2a1a3a; border-radius:4px; margin-bottom:12px;">
            Rotate the score displays to face you.<br>
            <b>Hot dog</b> = long side facing you<br>
            <b>Hamburger</b> = short side facing you
        </div>

        <!-- UI Rotation slider -->
        <div style="background:#1a1020; padding:10px; border-radius:5px; margin-bottom:10px;">
            <label style="color:#a8f; font-size:11px;">UI Rotation</label>
            <div style="margin-top:6px;">
                <label style="color:#aaa; font-size:10px;">Angle: <span id="uiRotationVal" style="color:#a8f;">0</span>Â°</label>
                <input type="range" id="uiRotationSlider" min="0" max="270" step="90" value="0" style="width:100%; margin-top:3px;">
            </div>
            <div style="display:flex; justify-content:space-between; margin-top:8px;">
                <button onclick="setUIRotation(0)" style="padding:5px 10px; background:#446; border:none; color:white; border-radius:3px; cursor:pointer; font-size:10px;">0Â°</button>
                <button onclick="setUIRotation(90)" style="padding:5px 10px; background:#446; border:none; color:white; border-radius:3px; cursor:pointer; font-size:10px;">90Â°</button>
                <button onclick="setUIRotation(180)" style="padding:5px 10px; background:#446; border:none; color:white; border-radius:3px; cursor:pointer; font-size:10px;">180Â°</button>
                <button onclick="setUIRotation(270)" style="padding:5px 10px; background:#446; border:none; color:white; border-radius:3px; cursor:pointer; font-size:10px;">270Â°</button>
            </div>
        </div>

        <div style="display:flex; gap:8px;">
            <button onclick="confirmUIRotation()" style="flex:2; padding:12px; background:#648; border:none; color:white; border-radius:4px; cursor:pointer; font-size:14px; font-weight:bold;">Confirm</button>
            <button onclick="cancelUIRotation()" style="flex:1; padding:12px; background:#a44; border:none; color:white; border-radius:4px; cursor:pointer; font-size:12px;">Cancel</button>
        </div>
    </div>

    <!-- Farkle Game UI - Minimal overlay, scores render on table -->
    <div id="farkleGameUI" style="display:none;">
        <!-- Hidden score tracking elements (for code compatibility) -->
        <div style="display:none;">
            <span id="farkleTotalScore">0</span>
            <span id="farkleTurnScore">0</span>
            <span id="farkleNPCScore">0</span>
            <span id="farkleMessage"></span>
            <span id="farkleTurnIndicator"></span>
        </div>

        <!-- Controls hint - Bottom center -->
        <div style="position:fixed; bottom:30px; left:50%; transform:translateX(-50%); z-index:150;">
            <div style="text-align:center; background:rgba(0,0,0,0.6); padding:8px 16px; border-radius:6px;">
                <span style="color:#888; font-size:12px;">Press <b style="color:#aa8;">Q</b> for controls &nbsp;|&nbsp; <b style="color:#a66;">ESC</b> exit</span>
            </div>
        </div>
    </div>

    <!-- Farkle Controls Modal - Hidden by default, shown on Q press -->
    <div id="farkleControlsModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:rgba(20,15,10,0.98); padding:30px 40px; border-radius:12px; border:3px solid #b86; z-index:200; text-align:center;">
        <h3 style="color:#ffa; margin:0 0 20px 0; font-size:20px;">Farkle Controls</h3>
        <div style="display:grid; grid-template-columns:auto auto; gap:15px 30px; text-align:left; margin-bottom:25px;">
            <div><span style="background:#684; padding:5px 12px; border-radius:4px; color:white; font-weight:bold;">R</span></div>
            <div style="color:#ca7;">Roll dice</div>
            <div><span style="background:#555; padding:5px 12px; border-radius:4px; color:white; font-weight:bold;">A / D</span></div>
            <div style="color:#ca7;">Select die</div>
            <div><span style="background:#555; padding:5px 12px; border-radius:4px; color:white; font-weight:bold;">Space</span></div>
            <div style="color:#ca7;">Keep selected die</div>
            <div><span style="background:#468; padding:5px 12px; border-radius:4px; color:white; font-weight:bold;">B</span></div>
            <div style="color:#ca7;">Bank points & end turn</div>
            <div><span style="background:#864; padding:5px 12px; border-radius:4px; color:white; font-weight:bold;">P</span></div>
            <div style="color:#ca7;">Pass (keep points, NPC turn)</div>
            <div><span style="background:#a44; padding:5px 12px; border-radius:4px; color:white; font-weight:bold;">ESC</span></div>
            <div style="color:#ca7;">Exit game</div>
        </div>
        <div style="color:#666; font-size:11px; margin-bottom:15px;">First to 10,000 wins!</div>
        <button onclick="toggleFarkleControls()" style="padding:10px 30px; background:#664; border:none; color:white; border-radius:6px; cursor:pointer; font-size:14px;">Close (Q)</button>
    </div>

    <!-- Farkle Prompt -->
    <div id="farklePrompt" style="display:none; position:fixed; bottom:80px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); padding:10px 20px; border-radius:5px; z-index:100;">
        <span style="color:#ffa;">Press E to play Farkle</span>
    </div>

    <!-- Farkle Mode Selection -->
    <div id="farkleModeSelect" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:rgba(20,15,10,0.98); padding:30px 40px; border-radius:12px; border:3px solid #b86; z-index:200; text-align:center;">
        <h3 style="color:#ffa; margin:0 0 20px 0; font-size:22px;">FARKLE</h3>
        <p style="color:#888; margin-bottom:20px; font-size:12px;">First to 10,000 wins!</p>
        <div style="display:flex; flex-direction:column; gap:12px;">
            <button onclick="startFarkleWithMode('npc')" style="padding:15px 40px; background:#684; border:none; color:white; border-radius:8px; cursor:pointer; font-size:16px; font-weight:bold;">vs NPC</button>
            <button onclick="startFarkleWithMode('2player')" style="padding:15px 40px; background:#468; border:none; color:white; border-radius:8px; cursor:pointer; font-size:16px; font-weight:bold;">2 Players (Pass & Play)</button>
        </div>
        <button onclick="closeFarkleModeSelect()" style="margin-top:20px; padding:8px 20px; background:#644; border:none; color:#caa; border-radius:4px; cursor:pointer; font-size:12px;">Cancel</button>
    </div>

    <!-- Tavern Music -->
    <audio id="tavernMusic" loop preload="auto">
        <source src="8-bit-tavern-355302.mp3" type="audio/mpeg">
    </audio>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
        import * as CANNON from 'cannon-es';

        // Settings
        let moveSpeed = 5;
        let lookSensitivity = 2;

        // Spawn point
        let spawnPoint = null;
        let settingSpawn = false;

        // Raycaster and model
        const raycaster = new THREE.Raycaster();
        let loadedModel = null; // Reference to the loaded tavern model
        let undoHistory = []; // Stack of actions for undo

        // Collision system
        let viewMode = 'fp'; // 'fp' = first person, 'tp' = third person
        let testMode = true; // Collision enabled by default
        let playerBodyVisible = true;
        let collisionVisible = true;
        let handsVisible = true;
        let playerBody = null; // The player rectangle mesh
        let collisionBox = null; // The collision box mesh
        let thirdPersonDistance = 5; // Distance behind player in TP view
        let collisionBoxes = []; // Manual collision boxes in the world

        // Player Body dimensions (VISUAL ONLY)
        let playerWidth = 0.5;
        let playerDepth = 0.8;
        let playerHeight = 1.4;

        // Collision Box dimensions (ACTUAL COLLISION)
        let collWidth = 0.6;
        let collDepth = 0.4;
        let collHeight = 3;
        let collOffset = -1; // Y offset from camera

        // Physics
        let velocityY = 0;
        const gravity = -20; // Units per second squared
        const maxFallSpeed = -30;
        const groundCheckDistance = 0.2; // How far below feet to check for ground

        // Player position (camera follows this with offsets)
        let playerPos = new THREE.Vector3(14.369, 5.143, 23.099);

        // First Person Hands
        let fpsHands = null;
        let fpsHandsMixer = null;
        let fpsHandsAnimations = {};
        let currentHandsAnim = 'idle';
        let animSpeed = 1.0;
        let animBlendDuration = 0.2;
        let forceAnim = 'auto';
        let eyeHeight = 1.6; // Camera height above feet (updated when player height changes)
        const maxSlopeAngle = 45; // Maximum walkable slope in degrees
        let isGrounded = false;

        // Update eye height when player height changes
        function updateEyeHeight() {
            // Eye is near the top of the player body (about 90% of height)
            eyeHeight = playerHeight * 0.9;
        }

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        // Physics world for dice
        const physicsWorld = new CANNON.World({
            gravity: new CANNON.Vec3(0, -9.82, 0)
        });
        physicsWorld.broadphase = new CANNON.NaiveBroadphase();
        physicsWorld.solver.iterations = 10;

        // Physics materials
        const diceMaterial = new CANNON.Material('dice');
        const tableMaterial = new CANNON.Material('table');
        const diceTableContact = new CANNON.ContactMaterial(diceMaterial, tableMaterial, {
            friction: 0.3,
            restitution: 0.4 // Bounciness
        });
        physicsWorld.addContactMaterial(diceTableContact);

        // Track dice for physics updates
        let farkleGameActive = false;
        let farkleDice = []; // Array of {mesh, body, value, kept}
        let farklePhysicsBodies = []; // Physics bodies for dice tray

        // Camera - near plane at 0.05 to reduce clipping into objects
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.05, 1000);
        camera.position.set(14.369, 5.143, 23.099);

        // Default spawn rotation
        let yaw = 7.848;
        let pitch = 0.076;

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        document.body.appendChild(renderer.domElement);

        // Mouse look variables
        let isLooking = false;
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');

        // Apply initial rotation
        euler.set(pitch, yaw, 0);
        camera.quaternion.setFromEuler(euler);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Warm point lights (tavern feel)
        const warmLight1 = new THREE.PointLight(0xffaa55, 2, 15);
        warmLight1.position.set(0, 3, 0);
        scene.add(warmLight1);

        const warmLight2 = new THREE.PointLight(0xff8844, 1.5, 10);
        warmLight2.position.set(-3, 2, -2);
        scene.add(warmLight2);

        // Spawn point marker (3D sphere)
        const spawnMarkerGeom = new THREE.SphereGeometry(0.2, 16, 16);
        const spawnMarkerMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7 });
        const spawnMarker3D = new THREE.Mesh(spawnMarkerGeom, spawnMarkerMat);
        spawnMarker3D.visible = false;
        scene.add(spawnMarker3D);

        // Spawn direction arrow
        const arrowHelper = new THREE.ArrowHelper(
            new THREE.Vector3(0, 0, -1),
            new THREE.Vector3(0, 0, 0),
            1,
            0x00ff00
        );
        arrowHelper.visible = false;
        scene.add(arrowHelper);

        // Create player body (rectangle)
        function createPlayerBody() {
            // Remove old body if exists
            if (playerBody) scene.remove(playerBody);
            if (collisionBox) scene.remove(collisionBox);

            // Player body (full height rectangle)
            const bodyGeom = new THREE.BoxGeometry(playerWidth, playerHeight, playerDepth);
            const bodyMat = new THREE.MeshBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.3,
                wireframe: false
            });
            playerBody = new THREE.Mesh(bodyGeom, bodyMat);
            playerBody.visible = playerBodyVisible && viewMode === 'tp';
            scene.add(playerBody);

            // Collision box (uses COLLISION dimensions, not player body)
            const collGeom = new THREE.BoxGeometry(collWidth, collHeight, collDepth);
            const collMat = new THREE.MeshBasicMaterial({
                color: 0xff4444,
                transparent: true,
                opacity: 0.4,
                wireframe: true
            });
            collisionBox = new THREE.Mesh(collGeom, collMat);
            collisionBox.visible = collisionVisible && viewMode === 'tp';
            scene.add(collisionBox);

            updatePlayerBodyPosition();
        }

        function updatePlayerBodyPosition() {
            if (!playerBody || !collisionBox) return;

            // Position collision box based on COLLISION BOX settings
            // Use playerPos (not camera.position) so debug camera doesn't move player
            collisionBox.position.copy(playerPos);
            collisionBox.position.y += collOffset;

            // Player body: anchor at feet (bottom of collision box) and extend UPWARD
            // This way increasing height extends the top, not the bottom
            const feetY = playerPos.y + collOffset - collHeight / 2;
            playerBody.position.set(
                playerPos.x,
                feetY + playerHeight / 2,  // Center of body above feet
                playerPos.z
            );

            // Rotate body to face camera direction (yaw only)
            playerBody.rotation.y = yaw;
            collisionBox.rotation.y = yaw;
        }

        // Update Player Body size (VISUAL ONLY)
        function updatePlayerBodySize() {
            if (!playerBody) return;

            // Update body geometry
            playerBody.geometry.dispose();
            playerBody.geometry = new THREE.BoxGeometry(playerWidth, playerHeight, playerDepth);

            updatePlayerBodyPosition();
        }

        // Update Collision Box size (ACTUAL COLLISION)
        function updateCollisionBoxSize() {
            if (!collisionBox) return;

            // Update collision box geometry with collision dimensions
            collisionBox.geometry.dispose();
            collisionBox.geometry = new THREE.BoxGeometry(collWidth, collHeight, collDepth);

            updatePlayerBodyPosition();
        }

        // Create initial player body
        createPlayerBody();
        updateEyeHeight();

        // Store initial camera position (default spawn)
        let initialCameraPos = new THREE.Vector3(14.369, 5.143, 23.099);
        let initialYaw = 7.848;
        let initialPitch = 0.076;

        // Load the tavern model
        const loader = new GLTFLoader();
        loader.setMeshoptDecoder(MeshoptDecoder);

        loader.load(
            'tavern_assets3d/tavern.glb',
            function(gltf) {
                const model = gltf.scene;

                // Get model bounds
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                // Center model horizontally but keep on ground
                model.position.x = -center.x;
                model.position.z = -center.z;
                model.position.y = -box.min.y; // Put floor at y=0

                // Scale if too big
                const maxDim = Math.max(size.x, size.y, size.z);
                if (maxDim > 100) {
                    const scale = 20 / maxDim;
                    model.scale.setScalar(scale);
                }

                // Enable shadows
                model.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                scene.add(model);
                loadedModel = model; // Store reference for collision

                // Cache collision meshes immediately
                cacheCollisionMeshes();

                // Load first person arms
                loader.load('tavern_assets3d/fp_arms_low_poly.glb', function(handsGltf) {
                    fpsHands = handsGltf.scene;

                    // Scale and position arms relative to camera
                    fpsHands.scale.setScalar(1.5);
                    fpsHands.position.set(0, -0.85, -1.35);
                    fpsHands.rotation.set(60 * Math.PI / 180, Math.PI, 0); // RotX=60Â°, RotY=180Â°

                    // Add hands as child of camera so they move with view
                    camera.add(fpsHands);
                    scene.add(camera); // Camera must be in scene for children to render

                    // Set up animation mixer
                    fpsHandsMixer = new THREE.AnimationMixer(fpsHands);

                    // Store animations by name
                    handsGltf.animations.forEach(clip => {
                        const name = clip.name.toLowerCase();
                        fpsHandsAnimations[name] = fpsHandsMixer.clipAction(clip);
                        console.log('[HANDS] Animation found:', clip.name);
                    });

                    // Start with idle animation
                    if (fpsHandsAnimations['idle']) {
                        fpsHandsAnimations['idle'].play();
                        currentHandsAnim = 'idle';
                    } else {
                        const firstAnim = Object.keys(fpsHandsAnimations)[0];
                        if (firstAnim) {
                            fpsHandsAnimations[firstAnim].play();
                            currentHandsAnim = firstAnim;
                        }
                    }

                    console.log('[HANDS] First person arms loaded!', Object.keys(fpsHandsAnimations));
                });

                // Hide loading (UI starts hidden, press H to show)
                document.getElementById('loading').style.display = 'none';
                document.getElementById('info').style.display = 'none';
                document.getElementById('modeIndicator').style.display = 'none';

                // Auto-start game: request pointer lock and play music
                setTimeout(() => {
                    renderer.domElement.requestPointerLock();
                    // Music will be started by toggleMusic after tavernMusic is set up
                    window.autoStartMusic = true;
                }, 100);

                console.log('Tavern loaded!', 'Size:', size);
            },
            function(progress) {
                if (progress.total > 0) {
                    const percent = Math.round((progress.loaded / progress.total) * 100);
                    document.getElementById('loadBar').style.width = percent + '%';
                    document.getElementById('loadPercent').textContent = percent + '%';
                }
            },
            function(error) {
                console.error('Error loading tavern:', error);
                document.getElementById('loading').innerHTML =
                    '<div style="color:#f66;">Error loading model!</div>' +
                    '<div style="color:#888;font-size:14px;margin-top:10px;">' + error.message + '</div>';
            }
        );

        // Pointer lock for mouse look
        renderer.domElement.addEventListener('click', () => {
            if (settingSpawn) {
                // Set spawn point at current position
                spawnPoint = {
                    position: camera.position.clone(),
                    yaw: yaw,
                    pitch: pitch
                };

                // Update 3D marker
                spawnMarker3D.position.copy(spawnPoint.position);
                spawnMarker3D.visible = true;

                // Update arrow direction
                const dir = new THREE.Vector3(0, 0, -1);
                dir.applyEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
                arrowHelper.position.copy(spawnPoint.position);
                arrowHelper.setDirection(dir);
                arrowHelper.visible = true;

                // Update UI
                const pos = spawnPoint.position;
                document.getElementById('spawnDisplay').textContent =
                    `(${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`;

                // Exit spawn setting mode
                settingSpawn = false;
                document.getElementById('setSpawnBtn').classList.remove('active');
                document.getElementById('setSpawnBtn').textContent = 'Set Spawn Point';
                document.getElementById('spawnMarker').style.display = 'none';
                document.getElementById('modeIndicator').textContent = 'Spawn point set! Click to look around';

                return;
            }

            // Copy mode - click to place in preview phase
            if (copyMode && copyPhase === 'preview') {
                console.log('[COPY] Click detected in preview phase - placing copy');
                placeCopyAtPosition();
                return;
            }

            // Farkle placement mode - click to place table
            if (farklePlaceMode) {
                console.log('[FARKLE] Click detected - placing table');
                confirmFarklePlacement();
                return;
            }

            // Farkle camera setting mode - click to set camera position
            if (farkleCameraMode) {
                console.log('[FARKLE] Setting camera position');
                setFarkleCameraPosition();
                return;
            }

            // Farkle game active - let the dice click handler deal with it
            if (farkleGameActive) {
                return; // Don't request pointer lock during game
            }

            if (!isLooking && !collisionPlaceMode && !copyMode && !farklePlaceMode) {
                renderer.domElement.requestPointerLock();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isLooking = document.pointerLockElement === renderer.domElement;
            document.getElementById('crosshair').style.display = isLooking ? 'block' : 'none';

            if (collisionPlaceMode) {
                if (placementPhase === 'preview') {
                    document.getElementById('modeIndicator').textContent = isLooking
                        ? 'PLACEMENT MODE - Look at surface, click to place'
                        : 'Click canvas to enable look mode';
                    document.getElementById('modeIndicator').style.background = 'rgba(0,100,0,0.8)';
                    document.getElementById('modeIndicator').style.color = '#0f0';
                } else {
                    document.getElementById('modeIndicator').textContent = 'ADJUST MODE - Use sliders, then click SET';
                    document.getElementById('modeIndicator').style.background = 'rgba(100,100,0,0.8)';
                    document.getElementById('modeIndicator').style.color = '#ff0';
                }
            } else if (settingSpawn) {
                document.getElementById('modeIndicator').textContent = 'Move to spawn location, then click to set';
                document.getElementById('spawnMarker').style.display = 'block';
            } else {
                document.getElementById('modeIndicator').textContent = isLooking
                    ? 'Mouse look enabled (ESC to exit)'
                    : 'Click to enable mouse look';
            }
        });

        // Mouse movement for looking
        document.addEventListener('mousemove', (e) => {
            if (!isLooking) return;

            const sensitivity = lookSensitivity * 0.001;
            yaw -= e.movementX * sensitivity;
            pitch -= e.movementY * sensitivity;

            // Clamp pitch to prevent flipping
            pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, pitch));

            euler.set(pitch, yaw, 0);
            camera.quaternion.setFromEuler(euler);
        });

        // Keyboard input
        const keys = {};
        let uiVisible = false; // Start with UI hidden
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === 'Escape') {
                if (farkleGameActive) {
                    exitFarkleGame();
                    return;
                }
                if (farkleUIRotateMode) {
                    cancelUIRotation();
                    return;
                }
                if (farkleCameraMode) {
                    cancelFarkleCamera();
                    return;
                }
                if (copyMode) {
                    if (copyPhase === 'adjust') {
                        cancelCopy();
                    } else {
                        exitCopyMode();
                    }
                    return;
                }
                if (collisionPlaceMode) {
                    exitCollisionPlacement();
                    return;
                }
                if (farklePlaceMode) {
                    exitFarklePlacement();
                    return;
                }
                if (settingSpawn) {
                    settingSpawn = false;
                    document.getElementById('setSpawnBtn').classList.remove('active');
                    document.getElementById('setSpawnBtn').textContent = 'Set Spawn Point';
                    document.getElementById('spawnMarker').style.display = 'none';
                }
                if (isLooking) {
                    document.exitPointerLock();
                }
            }
            // H to toggle UI
            if (e.key.toLowerCase() === 'h') {
                uiVisible = !uiVisible;
                document.getElementById('info').style.display = uiVisible ? 'block' : 'none';
                document.getElementById('modeIndicator').style.display = uiVisible ? 'block' : 'none';
            }
            // E to interact with Farkle table - show mode selection
            if (e.key.toLowerCase() === 'e' && !farkleGameActive) {
                const nearTable = checkNearFarkleTable();
                if (nearTable) {
                    pendingFarkleTableForMode = nearTable;
                    document.getElementById('farkleModeSelect').style.display = 'block';
                    document.getElementById('farklePrompt').style.display = 'none';
                }
            }
            // Farkle game controls: A/D to switch dice, Space to toggle keep, R to roll, Q for help
            if (farkleGameActive) {
                if (e.key.toLowerCase() === 'q') {
                    e.preventDefault();
                    toggleFarkleControls();
                }
                if (e.key.toLowerCase() === 'r') {
                    e.preventDefault();
                    rollFarkleDice();
                }
                if (e.key.toLowerCase() === 'b') {
                    e.preventDefault();
                    bankFarklePoints();
                }
                if (e.key.toLowerCase() === 'p') {
                    e.preventDefault();
                    passFarkleTurn();
                }
                if (farkleRolled && diceSettled) {
                    if (e.key.toLowerCase() === 'a') {
                        e.preventDefault();
                        selectPrevDie();
                    }
                    if (e.key.toLowerCase() === 'd') {
                        e.preventDefault();
                        selectNextDie();
                    }
                    if (e.key === ' ') {
                        e.preventDefault();
                        toggleSelectedDieKept();
                    }
                }
            }
            // TAB to toggle walk/slider mode in collision placement adjust phase
            if (e.key === 'Tab' && collisionPlaceMode && placementPhase === 'adjust') {
                e.preventDefault();
                toggleAdjustWalkMode();
            }
            // C to copy object (when in copy mode select phase)
            if (e.key.toLowerCase() === 'c') {
                console.log('[COPY] C pressed. copyMode:', copyMode, 'copyPhase:', copyPhase);
                if (copyMode && copyPhase === 'select') {
                    console.log('[COPY] Attempting to select object...');
                    const found = selectObjectUnderCrosshair();
                    console.log('[COPY] Object found:', found);
                }
            }
            // Collision placement controls (arrow keys adjust size)
            if (collisionPlaceMode && isLooking) {
                const step = e.shiftKey ? 0.5 : 0.1;
                if (placementPhase === 'preview') {
                    // Adjust initial size in preview mode
                    if (e.key === 'ArrowLeft') {
                        initWidth = Math.max(0.2, initWidth - step);
                        updateInitSliders();
                        updatePreviewSize();
                    }
                    if (e.key === 'ArrowRight') {
                        initWidth = Math.min(10, initWidth + step);
                        updateInitSliders();
                        updatePreviewSize();
                    }
                    if (e.key === 'ArrowUp') {
                        initHeight = Math.min(10, initHeight + step);
                        updateInitSliders();
                        updatePreviewSize();
                    }
                    if (e.key === 'ArrowDown') {
                        initHeight = Math.max(0.2, initHeight - step);
                        updateInitSliders();
                        updatePreviewSize();
                    }
                } else if (placementPhase === 'adjust') {
                    // Adjust size in adjust mode
                    if (e.key === 'ArrowLeft') {
                        adjustWidth = Math.max(0.2, adjustWidth - step);
                        updateAdjustSliders();
                        updateAdjustPreview();
                    }
                    if (e.key === 'ArrowRight') {
                        adjustWidth = Math.min(10, adjustWidth + step);
                        updateAdjustSliders();
                        updateAdjustPreview();
                    }
                    if (e.key === 'ArrowUp') {
                        adjustHeight = Math.min(10, adjustHeight + step);
                        updateAdjustSliders();
                        updateAdjustPreview();
                    }
                    if (e.key === 'ArrowDown') {
                        adjustHeight = Math.max(0.2, adjustHeight - step);
                        updateAdjustSliders();
                        updateAdjustPreview();
                    }
                    // Enter to confirm placement
                    if (e.key === 'Enter') {
                        confirmPlacement();
                    }
                }
            }
        });
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // Slider controls
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            moveSpeed = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = moveSpeed;
        });

        document.getElementById('sensSlider').addEventListener('input', (e) => {
            lookSensitivity = parseFloat(e.target.value);
            document.getElementById('sensVal').textContent = lookSensitivity;
        });

        // Toggle spawn setting mode
        window.toggleSetSpawn = function() {
            settingSpawn = !settingSpawn;
            const btn = document.getElementById('setSpawnBtn');

            if (settingSpawn) {
                btn.classList.add('active');
                btn.textContent = 'Click in 3D to Set Spawn';
                document.getElementById('spawnMarker').style.display = 'block';
                document.getElementById('modeIndicator').textContent = 'Move to spawn location, then click to set (ESC to cancel)';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'Set Spawn Point';
                document.getElementById('spawnMarker').style.display = 'none';
            }
        };

        // Go to spawn point
        window.goToSpawn = function() {
            if (!spawnPoint) {
                alert('No spawn point set!');
                return;
            }
            playerPos.copy(spawnPoint.position);
            camera.position.copy(playerPos);
            yaw = spawnPoint.yaw;
            pitch = spawnPoint.pitch;
            euler.set(pitch, yaw, 0);
            camera.quaternion.setFromEuler(euler);
        };

        // Reset camera
        window.resetCamera = function() {
            playerPos.copy(initialCameraPos);
            camera.position.copy(playerPos);
            yaw = initialYaw;
            pitch = initialPitch;
            euler.set(pitch, yaw, 0);
            camera.quaternion.setFromEuler(euler);
        };

        // Music control
        const tavernMusic = document.getElementById('tavernMusic');
        tavernMusic.volume = 0.3;
        let musicPlaying = false;
        let musicStarted = false; // Track if we've tried to start music

        // Start music on first user interaction
        function tryStartMusic() {
            if (musicStarted) return;
            musicStarted = true;
            tavernMusic.play().then(() => {
                musicPlaying = true;
                document.getElementById('musicBtn').textContent = 'ðŸŽµ Music: ON';
                document.getElementById('musicBtn').style.background = '#4a4';
                console.log('Music started!');
            }).catch(e => console.log('Music autoplay blocked:', e));
        }

        // Listen for first click to start music
        document.addEventListener('click', tryStartMusic, { once: true });

        window.toggleMusic = function() {
            const btn = document.getElementById('musicBtn');
            if (musicPlaying) {
                tavernMusic.pause();
                musicPlaying = false;
                btn.textContent = 'ðŸŽµ Music: OFF';
                btn.style.background = '#555';
            } else {
                tavernMusic.play();
                musicPlaying = true;
                btn.textContent = 'ðŸŽµ Music: ON';
                btn.style.background = '#4a4';
            }
        };

        // Copy spawn data as JSON
        window.copySpawnData = function() {
            if (!spawnPoint) {
                alert('No spawn point set!');
                return;
            }
            const data = {
                position: {
                    x: parseFloat(spawnPoint.position.x.toFixed(3)),
                    y: parseFloat(spawnPoint.position.y.toFixed(3)),
                    z: parseFloat(spawnPoint.position.z.toFixed(3))
                },
                rotation: {
                    yaw: parseFloat(spawnPoint.yaw.toFixed(3)),
                    pitch: parseFloat(spawnPoint.pitch.toFixed(3))
                }
            };
            navigator.clipboard.writeText(JSON.stringify(data, null, 2));
            alert('Spawn data copied to clipboard!');
        };

        window.undoLastAction = function() {
            if (undoHistory.length === 0) return;

            const action = undoHistory.pop();

            if (action.type === 'placeCollision') {
                // Remove placed collision box
                if (action.collisionIndex !== undefined && action.collisionIndex >= 0) {
                    if (bucketCollisionBoxes[action.collisionIndex]) {
                        bucketCollisionBoxes[action.collisionIndex] = null;
                    }
                    removeCollisionVisual(action.collisionIndex);
                }
                console.log(`[UNDO] Removed placed collision, remaining: ${bucketCollisionBoxes.filter(b => b).length}`);
            }
        };

        // Player body slider updates
        document.getElementById('playerWidth').addEventListener('input', (e) => {
            playerWidth = parseFloat(e.target.value);
            document.getElementById('playerWidthVal').textContent = e.target.value;
            updatePlayerBodySize();
        });
        document.getElementById('playerDepth').addEventListener('input', (e) => {
            playerDepth = parseFloat(e.target.value);
            document.getElementById('playerDepthVal').textContent = e.target.value;
            updatePlayerBodySize();
        });
        document.getElementById('playerHeight').addEventListener('input', (e) => {
            playerHeight = parseFloat(e.target.value);
            document.getElementById('playerHeightVal').textContent = e.target.value;
            updatePlayerBodySize();
            updateEyeHeight();
        });
        // Collision Box sliders (ACTUAL COLLISION)
        document.getElementById('collWidthSlider2').addEventListener('input', (e) => {
            collWidth = parseFloat(e.target.value);
            document.getElementById('collWidthVal').textContent = e.target.value;
            updateCollisionBoxSize();
        });
        document.getElementById('collDepthSlider2').addEventListener('input', (e) => {
            collDepth = parseFloat(e.target.value);
            document.getElementById('collDepthVal2').textContent = e.target.value;
            updateCollisionBoxSize();
        });
        document.getElementById('collHeight').addEventListener('input', (e) => {
            collHeight = parseFloat(e.target.value);
            document.getElementById('collHeightVal').textContent = e.target.value;
            updateCollisionBoxSize();
        });
        document.getElementById('collOffset').addEventListener('input', (e) => {
            collOffset = parseFloat(e.target.value);
            document.getElementById('collOffsetVal').textContent = e.target.value;
            updatePlayerBodyPosition(); // Update position since offset changed
        });

        // View mode functions
        window.setViewMode = function(mode) {
            viewMode = mode;
            document.getElementById('viewFP').style.background = mode === 'fp' ? '#4a4' : '#555';
            document.getElementById('viewTP').style.background = mode === 'tp' ? '#4a4' : '#555';
            document.getElementById('currentViewDisplay').textContent = mode === 'fp' ? 'First Person' : 'Third Person';

            // Update visibility based on mode
            if (playerBody) playerBody.visible = playerBodyVisible && mode === 'tp';
            if (collisionBox) collisionBox.visible = collisionVisible && mode === 'tp';
            // Show hands only in first person (if enabled)
            if (fpsHands) fpsHands.visible = handsVisible;
        };

        // Visibility toggles
        window.togglePlayerBody = function() {
            playerBodyVisible = !playerBodyVisible;
            const btn = document.getElementById('toggleBodyBtn');
            btn.textContent = playerBodyVisible ? 'Hide Body' : 'Show Body';
            btn.style.background = playerBodyVisible ? '#555' : '#333';
            if (playerBody) playerBody.visible = playerBodyVisible && viewMode === 'tp';
        };

        window.toggleCollisionVis = function() {
            collisionVisible = !collisionVisible;
            const btn = document.getElementById('toggleCollBtn');
            btn.textContent = collisionVisible ? 'Hide Coll' : 'Show Coll';
            btn.style.background = collisionVisible ? '#555' : '#333';
            if (collisionBox) collisionBox.visible = collisionVisible && viewMode === 'tp';
            // Also toggle manual collision boxes
            collisionBoxes.forEach(box => box.visible = collisionVisible);
        };

        // Collapsible sections
        let helpSectionOpen = false;
        let spawnSectionOpen = false;
        let cameraSectionOpen = false;
        let playerBodySectionOpen = false;
        let collisionSectionOpen = false;

        window.toggleHelpSection = function() {
            helpSectionOpen = !helpSectionOpen;
            document.getElementById('helpContent').style.display = helpSectionOpen ? 'block' : 'none';
            document.getElementById('helpArrow').textContent = helpSectionOpen ? '-' : '+';
        };

        window.toggleSpawnSection = function() {
            spawnSectionOpen = !spawnSectionOpen;
            document.getElementById('spawnContent').style.display = spawnSectionOpen ? 'block' : 'none';
            document.getElementById('spawnArrow').textContent = spawnSectionOpen ? '-' : '+';
        };

        window.toggleCameraSection = function() {
            cameraSectionOpen = !cameraSectionOpen;
            document.getElementById('cameraContent').style.display = cameraSectionOpen ? 'block' : 'none';
            document.getElementById('cameraArrow').textContent = cameraSectionOpen ? '-' : '+';
        };

        window.togglePlayerBodySection = function() {
            playerBodySectionOpen = !playerBodySectionOpen;
            document.getElementById('playerBodyContent').style.display = playerBodySectionOpen ? 'block' : 'none';
            document.getElementById('playerBodyArrow').textContent = playerBodySectionOpen ? '-' : '+';
        };

        window.toggleCollisionSection = function() {
            collisionSectionOpen = !collisionSectionOpen;
            document.getElementById('collisionContent').style.display = collisionSectionOpen ? 'block' : 'none';
            document.getElementById('collisionArrow').textContent = collisionSectionOpen ? '-' : '+';
        };

        // Camera offset sliders (adjust camera position relative to player)
        let camOffsetX = 0, camOffsetY = 0, camOffsetZ = 0;

        document.getElementById('camXSlider').addEventListener('input', function() {
            camOffsetX = parseFloat(this.value);
            document.getElementById('camXVal').textContent = camOffsetX.toFixed(2);
        });
        document.getElementById('camYSlider').addEventListener('input', function() {
            camOffsetY = parseFloat(this.value);
            document.getElementById('camYVal').textContent = camOffsetY.toFixed(2);
        });
        document.getElementById('camZSlider').addEventListener('input', function() {
            camOffsetZ = parseFloat(this.value);
            document.getElementById('camZVal').textContent = camOffsetZ.toFixed(2);
        });

        // Camera marker (white box at camera position)
        let cameraMarker = null;
        let cameraMarkerVisible = false;

        window.toggleCameraMarker = function() {
            cameraMarkerVisible = !cameraMarkerVisible;
            const btn = document.getElementById('toggleCamMarkerBtn');
            btn.textContent = cameraMarkerVisible ? 'Hide Camera Marker' : 'Show Camera Marker';
            btn.style.background = cameraMarkerVisible ? '#4a4' : '#555';

            if (cameraMarkerVisible && !cameraMarker) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
                cameraMarker = new THREE.Mesh(geo, mat);
                scene.add(cameraMarker);
            }
            if (cameraMarker) cameraMarker.visible = cameraMarkerVisible;
        };

        // FPS Hands visibility toggle
        window.toggleHandsVisible = function() {
            handsVisible = !handsVisible;
            const btn = document.getElementById('toggleHandsBtn');
            btn.textContent = handsVisible ? 'Hide Hands' : 'Show Hands';
            btn.style.background = handsVisible ? '#555' : '#333';
            if (fpsHands) fpsHands.visible = handsVisible;
        };

        // Copy camera settings to clipboard
        window.copyCameraSettings = function() {
            const settings = {
                camOffsetX: camOffsetX,
                camOffsetY: camOffsetY,
                camOffsetZ: camOffsetZ
            };
            const text = `Camera Offset: X=${camOffsetX}, Y=${camOffsetY}, Z=${camOffsetZ}`;
            navigator.clipboard.writeText(text);
            alert('Camera settings copied:\n' + text);
        };

        // Copy hands settings to clipboard
        window.copyHandsSettings = function() {
            const x = document.getElementById('handsXSlider').value;
            const y = document.getElementById('handsYSlider').value;
            const z = document.getElementById('handsZSlider').value;
            const scale = document.getElementById('handsScaleSlider').value;
            const rotX = document.getElementById('handsRotXSlider').value;
            const rotY = document.getElementById('handsRotYSlider').value;
            const rotZ = document.getElementById('handsRotZSlider').value;
            const text = `Hands: X=${x}, Y=${y}, Z=${z}, Scale=${scale}, RotX=${rotX}, RotY=${rotY}, RotZ=${rotZ}`;
            navigator.clipboard.writeText(text);
            alert('Hands settings copied:\n' + text);
        };

        // FPS Hands sliders
        document.getElementById('handsXSlider').addEventListener('input', function() {
            document.getElementById('handsXVal').textContent = this.value;
            if (fpsHands) fpsHands.position.x = parseFloat(this.value);
        });
        document.getElementById('handsYSlider').addEventListener('input', function() {
            document.getElementById('handsYVal').textContent = this.value;
            if (fpsHands) fpsHands.position.y = parseFloat(this.value);
        });
        document.getElementById('handsZSlider').addEventListener('input', function() {
            document.getElementById('handsZVal').textContent = this.value;
            if (fpsHands) fpsHands.position.z = parseFloat(this.value);
        });
        document.getElementById('handsScaleSlider').addEventListener('input', function() {
            document.getElementById('handsScaleVal').textContent = this.value;
            if (fpsHands) fpsHands.scale.setScalar(parseFloat(this.value));
        });

        // FPS Hands rotation sliders
        document.getElementById('handsRotXSlider').addEventListener('input', function() {
            document.getElementById('handsRotXVal').textContent = this.value;
            if (fpsHands) fpsHands.rotation.x = parseFloat(this.value) * Math.PI / 180;
        });
        document.getElementById('handsRotYSlider').addEventListener('input', function() {
            document.getElementById('handsRotYVal').textContent = this.value;
            if (fpsHands) fpsHands.rotation.y = parseFloat(this.value) * Math.PI / 180;
        });
        document.getElementById('handsRotZSlider').addEventListener('input', function() {
            document.getElementById('handsRotZVal').textContent = this.value;
            if (fpsHands) fpsHands.rotation.z = parseFloat(this.value) * Math.PI / 180;
        });

        // Animation controls
        document.getElementById('animSpeedSlider').addEventListener('input', function() {
            document.getElementById('animSpeedVal').textContent = this.value;
            animSpeed = parseFloat(this.value);
            // Apply to all animations
            for (const name in fpsHandsAnimations) {
                fpsHandsAnimations[name].timeScale = animSpeed;
            }
        });
        document.getElementById('animBlendSlider').addEventListener('input', function() {
            document.getElementById('animBlendVal').textContent = this.value;
            animBlendDuration = parseFloat(this.value);
        });
        document.getElementById('animIntensitySlider').addEventListener('input', function() {
            document.getElementById('animIntensityVal').textContent = this.value;
            const weight = parseFloat(this.value) / 100;
            // Apply weight to all animations
            for (const name in fpsHandsAnimations) {
                fpsHandsAnimations[name].weight = weight;
            }
        });
        document.getElementById('forceAnimSelect').addEventListener('change', function() {
            forceAnim = this.value;
            // If forcing specific anim, switch to it now
            if (forceAnim !== 'auto' && fpsHandsAnimations[forceAnim]) {
                if (fpsHandsAnimations[currentHandsAnim]) {
                    fpsHandsAnimations[currentHandsAnim].fadeOut(animBlendDuration);
                }
                fpsHandsAnimations[forceAnim].reset().fadeIn(animBlendDuration).play();
                currentHandsAnim = forceAnim;
            }
        });

        // Test mode - enable collision detection
        window.toggleTestMode = function() {
            testMode = !testMode;
            const btn = document.getElementById('testModeBtn');
            if (testMode) {
                btn.style.background = '#4a4';
                btn.textContent = 'Collision: ON';
            } else {
                btn.style.background = '#a44';
                btn.textContent = 'Collision: OFF';
            }
        };

        // Raycast Collision System (enabled by default)
        let useRaycastCollision = true;
        let collisionMeshes = []; // Cached meshes to collide with

        function cacheCollisionMeshes() {
            collisionMeshes = [];
            if (loadedModel) {
                loadedModel.traverse((child) => {
                    if (child.isMesh) {
                        collisionMeshes.push(child);
                    }
                });
                console.log(`[RAYCAST] Cached ${collisionMeshes.length} meshes for collision`);
            }
        }

        // Helper to get world normal from a raycast hit
        function getWorldNormal(hit) {
            if (!hit.face) return null;
            const normal = hit.face.normal.clone();
            // Transform normal to world space
            const normalMatrix = new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld);
            normal.applyMatrix3(normalMatrix).normalize();
            return normal;
        }

        // Check if a surface is walkable based on slope angle
        function isWalkableSurface(hit) {
            const worldNormal = getWorldNormal(hit);
            if (!worldNormal) return false;
            // Calculate angle from vertical (0 = flat floor, 90 = wall)
            const angle = Math.acos(worldNormal.y) * (180 / Math.PI);
            return angle <= maxSlopeAngle;
        }

        // Ground detection - cast ray downward to find ground
        function checkGround(position) {
            if (!loadedModel || collisionMeshes.length === 0) {
                return { grounded: false, groundY: null, normal: null };
            }

            // Calculate feet position based on COLLISION BOX settings (not player body)
            // Collision box bottom is at: camera.y + collOffset - collHeight/2
            const feetY = position.y + collOffset - collHeight / 2;
            const rayOrigin = new THREE.Vector3(position.x, feetY + 0.1, position.z); // Start slightly above feet
            const rayDir = new THREE.Vector3(0, -1, 0);

            raycaster.set(rayOrigin, rayDir);
            raycaster.far = groundCheckDistance + 0.2; // Check a bit below feet

            let bestGroundY = null;
            let bestNormal = null;

            // Check model collision meshes
            const hits = raycaster.intersectObjects(collisionMeshes, false);

            if (hits.length > 0) {
                const hit = hits[0];
                const worldNormal = getWorldNormal(hit);

                // Check if surface is walkable (not too steep)
                if (worldNormal && isWalkableSurface(hit)) {
                    const groundY = hit.point.y;
                    const feetToGround = feetY - groundY;

                    // If we're close enough to the ground, we're grounded
                    if (feetToGround < groundCheckDistance && feetToGround > -0.5) {
                        bestGroundY = groundY;
                        bestNormal = worldNormal;
                    }
                }
            }

            // Also check placed collision boxes (bucketCollisionBoxes) - supports rotated ramps
            for (const entry of bucketCollisionBoxes) {
                if (!entry) continue;

                // Use OBB height at player position (handles rotated ramps)
                const topY = getOBBHeightAt(position.x, position.z, entry);

                if (topY !== null) {
                    const feetToTop = feetY - topY;

                    // If feet are close to or just above the top of the box/ramp
                    if (feetToTop < groundCheckDistance && feetToTop > -0.5) {
                        // Calculate normal for rotated boxes
                        let surfaceNormal;
                        if (entry.rotMatrix) {
                            surfaceNormal = new THREE.Vector3(0, 1, 0);
                            surfaceNormal.applyMatrix4(entry.rotMatrix);
                            surfaceNormal.normalize();
                        } else {
                            surfaceNormal = new THREE.Vector3(0, 1, 0);
                        }

                        // Check if surface is walkable (not too steep)
                        const angle = Math.acos(surfaceNormal.y) * (180 / Math.PI);
                        if (angle <= maxSlopeAngle) {
                            // Use this ground if it's higher than what we found
                            if (bestGroundY === null || topY > bestGroundY) {
                                bestGroundY = topY;
                                bestNormal = surfaceNormal;
                            }
                        }
                    }
                }
            }

            if (bestGroundY !== null) {
                return {
                    grounded: true,
                    groundY: bestGroundY,
                    normal: bestNormal,
                    distance: feetY - bestGroundY
                };
            }

            return { grounded: false, groundY: null, normal: null };
        }

        // Apply physics (gravity, ground snapping)
        function applyPhysics(delta) {
            if (!loadedModel || collisionMeshes.length === 0) return;

            const groundInfo = checkGround(playerPos);

            // Camera height above ground based on COLLISION BOX
            // When feet touch ground, camera is at: groundY + collHeight/2 - collOffset
            const cameraAboveGround = collHeight / 2 - collOffset;

            if (groundInfo.grounded && velocityY <= 0) {
                // On ground and not jumping up
                isGrounded = true;
                velocityY = 0;

                // Snap to ground (camera at correct height above ground based on player settings)
                const targetY = groundInfo.groundY + cameraAboveGround;
                const diff = targetY - playerPos.y;

                // Smooth snap for small differences, instant for large
                if (Math.abs(diff) < 0.5) {
                    playerPos.y += diff * 10 * delta; // Smooth
                } else {
                    playerPos.y = targetY; // Instant
                }
            } else if (groundInfo.grounded && velocityY > 0) {
                // On ground but jumping up - apply upward velocity
                isGrounded = false;
                playerPos.y += velocityY * delta;
                velocityY += gravity * delta;
            } else {
                // In air - apply gravity
                isGrounded = false;
                velocityY += gravity * delta;
                velocityY = Math.max(velocityY, maxFallSpeed); // Clamp fall speed

                const newY = playerPos.y + velocityY * delta;

                // Check if we're about to hit ground
                const predictedGroundInfo = checkGround(new THREE.Vector3(
                    playerPos.x,
                    newY,
                    playerPos.z
                ));

                if (predictedGroundInfo.grounded && velocityY < 0) {
                    // Land on ground
                    playerPos.y = predictedGroundInfo.groundY + cameraAboveGround;
                    velocityY = 0;
                    isGrounded = true;
                } else {
                    // Before moving, check if we'd pass through a collision box top (supports ramps)
                    const currentFeetY = playerPos.y + collOffset - collHeight / 2;
                    const newFeetY = newY + collOffset - collHeight / 2;

                    let landedOnBox = false;
                    for (const entry of bucketCollisionBoxes) {
                        if (!entry) continue;

                        // Use OBB height for rotated boxes/ramps
                        const topY = getOBBHeightAt(playerPos.x, playerPos.z, entry);
                        if (topY === null) continue;

                        // Check if we're passing through the top of the box (falling down)
                        if (velocityY < 0 && currentFeetY >= topY && newFeetY < topY) {
                            // Land on top of this box/ramp
                            playerPos.y = topY + cameraAboveGround;
                            velocityY = 0;
                            isGrounded = true;
                            landedOnBox = true;
                            break;
                        }
                    }

                    if (!landedOnBox) {
                        playerPos.y = newY;
                    }
                }
            }

            // Sync camera to player position with offsets
            camera.position.set(
                playerPos.x + camOffsetX,
                playerPos.y + camOffsetY,
                playerPos.z + camOffsetZ
            );
        }

        function wouldCollideRaycast(currentPos, newPos) {
            if (!loadedModel || collisionMeshes.length === 0) return false;

            const moveDir = new THREE.Vector3().subVectors(newPos, currentPos);
            const moveDistance = moveDir.length();
            if (moveDistance < 0.001) return false;

            // Only check horizontal collisions
            const horizontalDir = new THREE.Vector3(moveDir.x, 0, moveDir.z);
            const horizDist = horizontalDir.length();
            if (horizDist < 0.001) return false; // Pure vertical movement, allow
            horizontalDir.normalize();

            // Check distance - player radius plus small buffer
            const playerRadius = Math.max(playerWidth, playerDepth) / 2 + 0.15;
            const checkDistance = horizDist + playerRadius;

            // Only 2 ray heights - waist and chest (avoid feet which hit floors)
            const rayHeights = [
                -eyeHeight * 0.5,  // Waist level
                -eyeHeight * 0.2,  // Chest level
            ];

            // Check a single ray and return true if blocked
            const checkRay = (origin, direction) => {
                raycaster.set(origin, direction);
                raycaster.far = checkDistance;
                const hits = raycaster.intersectObjects(collisionMeshes, false);
                if (hits.length > 0) {
                    const hit = hits[0];
                    // Get world normal to check if it's a wall (not floor)
                    const worldNormal = getWorldNormal(hit);
                    if (worldNormal) {
                        // Only block if surface is mostly vertical (wall)
                        // Normal Y close to 0 means vertical surface
                        if (Math.abs(worldNormal.y) < 0.7 && hit.distance < checkDistance) {
                            return true;
                        }
                    }
                }
                return false;
            };

            for (const heightOffset of rayHeights) {
                const baseY = currentPos.y + heightOffset;
                const origin = new THREE.Vector3(currentPos.x, baseY, currentPos.z);

                // Just check center ray - simpler and less jittery
                if (checkRay(origin, horizontalDir)) return true;
            }

            return false;
        }

        // Collision detection
        // Check if moving to position would cause collision
        let lastCollisionLog = 0;
        let lastBoxCountLog = 0;
        const COLLISION_SKIN = 0.1; // Extra buffer to prevent phasing

        // Create player bounding box at a position
        function getPlayerBoxAt(position) {
            const box = new THREE.Box3();
            const halfWidth = collWidth / 2 + COLLISION_SKIN;
            const halfDepth = collDepth / 2 + COLLISION_SKIN;
            const collY = position.y + collOffset;

            box.min.set(
                position.x - halfWidth,
                collY - collHeight / 2,
                position.z - halfDepth
            );
            box.max.set(
                position.x + halfWidth,
                collY + collHeight / 2,
                position.z + halfDepth
            );
            return box;
        }

        // OBB (Oriented Bounding Box) collision helpers
        const _tempVec = new THREE.Vector3();
        const _invRotMatrix = new THREE.Matrix4();

        // Transform a point from world space to OBB local space
        function worldToOBBLocal(point, entry) {
            if (!entry.center || !entry.rotMatrix) return point.clone();
            _invRotMatrix.copy(entry.rotMatrix).invert();
            _tempVec.copy(point).sub(entry.center);
            _tempVec.applyMatrix4(_invRotMatrix);
            return _tempVec.clone();
        }

        // Check if point is inside OBB
        function pointInOBB(point, entry) {
            if (!entry.center || !entry.halfExtents || !entry.rotMatrix) {
                // Fallback to AABB
                return entry.box && entry.box.containsPoint(point);
            }
            const local = worldToOBBLocal(point, entry);
            const h = entry.halfExtents;
            return Math.abs(local.x) <= h.x && Math.abs(local.y) <= h.y && Math.abs(local.z) <= h.z;
        }

        // Check if AABB intersects OBB using SAT (Separating Axis Theorem)
        function aabbIntersectsOBB(aabb, entry) {
            if (!entry.center || !entry.halfExtents || !entry.rotMatrix) {
                // Fallback to AABB-AABB
                return entry.box && aabb.intersectsBox(entry.box);
            }

            // Get OBB axes from rotation matrix
            const obbAxes = [
                new THREE.Vector3().setFromMatrixColumn(entry.rotMatrix, 0),
                new THREE.Vector3().setFromMatrixColumn(entry.rotMatrix, 1),
                new THREE.Vector3().setFromMatrixColumn(entry.rotMatrix, 2)
            ];

            // AABB axes (world aligned)
            const aabbAxes = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(0, 1, 0),
                new THREE.Vector3(0, 0, 1)
            ];

            // AABB center and half extents
            const aabbCenter = new THREE.Vector3();
            aabb.getCenter(aabbCenter);
            const aabbHalf = new THREE.Vector3();
            aabb.getSize(aabbHalf).multiplyScalar(0.5);

            // Distance between centers
            const d = new THREE.Vector3().subVectors(entry.center, aabbCenter);

            // Test 15 axes (3 AABB + 3 OBB + 9 cross products)
            const axes = [...aabbAxes, ...obbAxes];

            // Add cross product axes
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const cross = new THREE.Vector3().crossVectors(aabbAxes[i], obbAxes[j]);
                    if (cross.lengthSq() > 0.0001) {
                        axes.push(cross.normalize());
                    }
                }
            }

            for (const axis of axes) {
                // Project AABB onto axis
                const aabbProj = aabbHalf.x * Math.abs(axis.dot(aabbAxes[0])) +
                                 aabbHalf.y * Math.abs(axis.dot(aabbAxes[1])) +
                                 aabbHalf.z * Math.abs(axis.dot(aabbAxes[2]));

                // Project OBB onto axis
                const obbProj = entry.halfExtents.x * Math.abs(axis.dot(obbAxes[0])) +
                                entry.halfExtents.y * Math.abs(axis.dot(obbAxes[1])) +
                                entry.halfExtents.z * Math.abs(axis.dot(obbAxes[2]));

                // Project distance onto axis
                const dist = Math.abs(d.dot(axis));

                // Check for separation
                if (dist > aabbProj + obbProj) {
                    return false; // Separating axis found
                }
            }

            return true; // No separating axis, boxes intersect
        }

        // Get height of OBB surface at a world X/Z position (for ramps)
        function getOBBHeightAt(x, z, entry) {
            if (!entry.center || !entry.halfExtents || !entry.rotMatrix) {
                return entry.box ? entry.box.max.y : null;
            }

            // Transform the X/Z point to OBB local space (at OBB center Y)
            const worldPoint = new THREE.Vector3(x, entry.center.y, z);
            const local = worldToOBBLocal(worldPoint, entry);
            const h = entry.halfExtents;

            // Check if X/Z is within the OBB footprint (in local space)
            if (Math.abs(local.x) > h.x || Math.abs(local.z) > h.z) {
                return null; // Outside the box footprint
            }

            // The top surface of the OBB in local space is at y = h.y
            // We need to find the world Y of this point
            // Local top point at this x/z: (local.x, h.y, local.z)
            const localTop = new THREE.Vector3(local.x, h.y, local.z);
            localTop.applyMatrix4(entry.rotMatrix);
            localTop.add(entry.center);

            return localTop.y;
        }

        function wouldCollide(newPosition, oldPosition = null) {
            // Log box count occasionally
            const now = performance.now();
            if (now - lastBoxCountLog > 5000 && bucketCollisionBoxes.length > 0) {
                console.log(`[COLLISION] Checking against ${bucketCollisionBoxes.length} collision boxes`);
                lastBoxCountLog = now;
            }

            if (bucketCollisionBoxes.length === 0) return false;

            const shouldLog = now - lastCollisionLog > 500;

            // Check at the new position
            const tempBox = getPlayerBoxAt(newPosition);

            // Check against manually placed collision boxes
            for (let i = 0; i < bucketCollisionBoxes.length; i++) {
                const entry = bucketCollisionBoxes[i];
                if (!entry) continue;

                // Check if player is standing on top of this box (ignore it for horizontal collision)
                // Use OBB height at player position for rotated ramps
                const playerBottom = tempBox.min.y;
                const obbHeight = getOBBHeightAt(newPosition.x, newPosition.z, entry);

                if (obbHeight !== null) {
                    const standingOnTop = (playerBottom >= obbHeight - 0.2) && (playerBottom <= obbHeight + 0.35);
                    if (standingOnTop) {
                        // Player is standing on this box/ramp, don't count as horizontal collision
                        continue;
                    }
                }

                // Use OBB collision for rotated boxes
                if (aabbIntersectsOBB(tempBox, entry)) {
                    if (shouldLog) {
                        console.log(`[COLLISION] Blocked by collision box #${i}`, {
                            center: entry.center ? entry.center.clone() : 'N/A',
                            playerBox: { min: tempBox.min.clone(), max: tempBox.max.clone() },
                            playerPos: newPosition.clone()
                        });
                        lastCollisionLog = now;
                    }
                    return true;
                }
            }

            // Swept collision check - test points along the path to prevent tunneling
            if (oldPosition) {
                const distance = newPosition.distanceTo(oldPosition);
                if (distance > 0.1) {
                    const steps = Math.ceil(distance / 0.1); // Check every 0.1 units

                    for (let s = 1; s < steps; s++) {
                        const t = s / steps;
                        const checkPos = new THREE.Vector3().lerpVectors(oldPosition, newPosition, t);
                        const checkBox = getPlayerBoxAt(checkPos);

                        for (let i = 0; i < bucketCollisionBoxes.length; i++) {
                            const entry = bucketCollisionBoxes[i];
                            if (!entry) continue;

                            // Skip if standing on top of this box (use OBB height)
                            const playerBottom = checkBox.min.y;
                            const obbHeight = getOBBHeightAt(checkPos.x, checkPos.z, entry);

                            if (obbHeight !== null) {
                                const standingOnTop = (playerBottom >= obbHeight - 0.2) && (playerBottom <= obbHeight + 0.35);
                                if (standingOnTop) {
                                    continue;
                                }
                            }

                            if (aabbIntersectsOBB(checkBox, entry)) {
                                if (shouldLog) {
                                    console.log(`[COLLISION] Swept collision at step ${s}/${steps} with box #${i}`);
                                    lastCollisionLog = now;
                                }
                                return true;
                            }
                        }
                    }
                }
            }

            return false;
        }

        function checkCollisions() {
            if (!collisionBox) return false;

            const playerBB = new THREE.Box3().setFromObject(collisionBox);
            let collisionCount = 0;

            // Check against manually placed collision boxes
            for (const entry of bucketCollisionBoxes) {
                if (!entry || !entry.box) continue;
                if (playerBB.intersectsBox(entry.box)) {
                    collisionCount++;
                }
            }

            document.getElementById('collisionCount').textContent = collisionCount;
            return collisionCount > 0;
        }
        // Store collision boxes (placed manually)
        const bucketCollisionBoxes = [];
        // Visual wireframes for collision boxes
        const bucketCollisionVisuals = [];
        let bucketCollisionVisualsVisible = false;

        // Toggle collision box visualization
        window.toggleBucketCollisionVis = function() {
            bucketCollisionVisualsVisible = !bucketCollisionVisualsVisible;
            const btn = document.getElementById('toggleBucketCollBtn');
            btn.textContent = bucketCollisionVisualsVisible ? 'Hide Collision Boxes' : 'Show Collision Boxes';
            btn.style.background = bucketCollisionVisualsVisible ? '#4a4' : '#a84';

            // Update visibility of all visual boxes
            bucketCollisionVisuals.forEach(vis => {
                if (vis) vis.visible = bucketCollisionVisualsVisible;
            });
        };

        // Collision Placement Mode - NEW WORKFLOW
        let collisionPlaceMode = false;
        let placementPhase = 'preview'; // 'preview' or 'adjust'
        let collPlacePreview = null; // Preview mesh (follows raycast in preview mode, fixed in adjust mode)
        let collPlaceBasePosition = new THREE.Vector3(); // World position of placed box
        let pendingCollisionBox = null; // The box being adjusted before confirmation
        let adjustWalkMode = true; // true = walk around, false = use sliders
        let savedCameraPos = new THREE.Vector3();
        let savedYaw = 0;
        let savedPitch = 0;

        // Initial size (used when placing)
        let initWidth = 1.0;
        let initHeight = 1.0;
        let initDepth = 1.0;
        let initShape = 'box'; // 'box' or 'cylinder'

        // Adjust values (used after placing)
        let adjustWidth = 1.0;
        let adjustHeight = 1.0;
        let adjustDepth = 1.0;
        let adjustOffsetX = 0;
        let adjustOffsetY = 0;
        let adjustOffsetZ = 0;
        let adjustRotationX = 0; // Rotation in degrees (pitch)
        let adjustRotationY = 0; // Rotation in degrees (yaw)
        let adjustRotationZ = 0; // Rotation in degrees (roll)
        let adjustShape = 'box';

        // Shape presets
        const collShapePresets = {
            box: { w: 1.0, h: 1.0, d: 1.0, shape: 'box' },
            tallBox: { w: 0.5, h: 2.0, d: 0.5, shape: 'box' },
            wideBox: { w: 2.0, h: 0.5, d: 2.0, shape: 'box' },
            wall: { w: 3.0, h: 2.5, d: 0.3, shape: 'box' },
            cylinder: { w: 1.0, h: 2.0, d: 1.0, shape: 'cylinder' }
        };

        // Copy Object Mode
        let copyMode = false;
        let copyPhase = 'select'; // 'select', 'preview', 'adjust'
        let selectedObject = null; // The mesh we're copying
        let copyPreview = null; // The cloned preview
        let copyBasePosition = new THREE.Vector3();
        let copiedObjects = []; // Track all placed copies

        // Copy adjust values
        let copyOffsetX = 0, copyOffsetY = 0, copyOffsetZ = 0;
        let copyRotationY = 0;
        let copyScale = 1;

        // Farkle Table Placement Mode
        let farklePlaceMode = false;
        let farklePreview = null;
        let farkleBasePosition = new THREE.Vector3();
        let farkleTables = []; // Store placed tables
        let farkleRotationY = 0;
        let farkleCameraMode = false; // Setting camera position for table
        let pendingFarkleTable = null; // Table waiting for camera position
        let farkleUIRotateMode = false; // Adjusting UI rotation
        let farkleUIRotation = 0; // UI rotation offset in degrees (0, 90, 180, 270)
        let farkleUIPreview = []; // Preview UI meshes

        // Felt surface adjustable settings
        // Default height: tabletopY (0.95) + tableTopThickness (0.1) + 0.02 = 1.07
        let feltHeightOffset = 1.07; // Default height above table position
        let feltColor = 0x22DD44; // Brighter green for visibility
        let feltEmissive = 0.8; // Higher glow for visibility
        let tableLegHeight = 0.95; // Adjustable leg height

        // Start collision placement mode
        window.startCollisionPlacement = function() {
            collisionPlaceMode = true;
            placementPhase = 'preview';

            const btn = document.getElementById('collPlaceModeBtn');
            const mainUI = document.getElementById('info');
            const placementPanel = document.getElementById('collisionPlacementPanel');

            btn.style.background = '#c44';
            btn.textContent = 'âœ• Exit Placement Mode';
            mainUI.style.display = 'none';
            placementPanel.style.display = 'block';

            // Show preview mode UI
            document.getElementById('previewModeUI').style.display = 'block';
            document.getElementById('adjustModeUI').style.display = 'none';

            // Show collision boxes
            if (!bucketCollisionVisualsVisible) {
                toggleBucketCollisionVis();
            }

            // Create preview that follows raycast
            createPreviewBox();

            document.getElementById('modeIndicator').textContent = 'PLACEMENT MODE - Look at surface, click to place';
            document.getElementById('modeIndicator').style.background = 'rgba(0,100,0,0.8)';
            document.getElementById('modeIndicator').style.color = '#0f0';

            // Request pointer lock
            renderer.domElement.requestPointerLock();

            console.log('[PLACEMENT] Started placement mode');
        };

        // Exit collision placement mode
        window.exitCollisionPlacement = function() {
            collisionPlaceMode = false;
            placementPhase = 'preview';

            const btn = document.getElementById('collPlaceModeBtn');
            const mainUI = document.getElementById('info');
            const placementPanel = document.getElementById('collisionPlacementPanel');

            btn.style.background = '#383';
            btn.textContent = 'â¬› Place Collision Box';
            mainUI.style.display = 'block';
            placementPanel.style.display = 'none';

            removePreviewBox();
            pendingCollisionBox = null;

            document.getElementById('modeIndicator').textContent = 'Click to enable mouse look';
            document.getElementById('modeIndicator').style.background = 'rgba(0,0,0,0.7)';
            document.getElementById('modeIndicator').style.color = '#4af';

            console.log('[PLACEMENT] Exited placement mode');
        };

        // Click to place box (in preview phase)
        function placeBoxAtPosition(position) {
            if (placementPhase !== 'preview') return;

            // Save current camera position for later
            savedCameraPos.copy(camera.position);
            savedYaw = yaw;
            savedPitch = pitch;

            // Save position
            collPlaceBasePosition.copy(position);

            // Copy initial sizes to adjust
            adjustWidth = initWidth;
            adjustHeight = initHeight;
            adjustDepth = initDepth;
            adjustShape = initShape;
            adjustOffsetX = 0;
            adjustOffsetY = 0;
            adjustOffsetZ = 0;
            adjustRotationX = 0;
            adjustRotationY = 0;
            adjustRotationZ = 0;

            console.log('[PLACEMENT] placeBoxAtPosition - init->adjust:', {
                initWidth, initHeight, initDepth, initShape,
                adjustWidth, adjustHeight, adjustDepth,
                basePos: position.clone()
            });

            // Switch to adjust phase (starts in walk mode - can walk around to view yellow box)
            placementPhase = 'adjust';
            adjustWalkMode = true;

            // Keep pointer lock - user can walk around to view the yellow box
            // They can press TAB to toggle slider mode for precise adjustments

            // Update UI
            document.getElementById('previewModeUI').style.display = 'none';
            document.getElementById('adjustModeUI').style.display = 'block';

            // Update adjust sliders
            updateAdjustSliders();

            // Update walk mode button state (we start in walk mode)
            const walkBtn = document.getElementById('walkModeBtn');
            walkBtn.textContent = 'Switch to Sliders (TAB)';
            walkBtn.style.background = '#4a4';

            // Change preview color to yellow (being adjusted)
            if (collPlacePreview) {
                collPlacePreview.material.color.setHex(0xffff00);
                collPlacePreview.material.opacity = 0.5;
            }

            document.getElementById('modeIndicator').textContent = 'WALK MODE - Move around to view, TAB for sliders';
            document.getElementById('modeIndicator').style.background = 'rgba(100,100,0,0.8)';
            document.getElementById('modeIndicator').style.color = '#ff0';

            console.log('[PLACEMENT] Box placed - walk mode (TAB for sliders)');
        }

        // Toggle between walk mode (WASD movement) and slider mode (mouse free)
        window.toggleAdjustWalkMode = function() {
            adjustWalkMode = !adjustWalkMode;
            const walkBtn = document.getElementById('walkModeBtn');

            if (adjustWalkMode) {
                // Enter walk mode - lock pointer for movement
                renderer.domElement.requestPointerLock();
                document.getElementById('modeIndicator').textContent = 'WALK MODE - Move around to view, TAB for sliders';
                document.getElementById('modeIndicator').style.background = 'rgba(100,100,0,0.8)';
                document.getElementById('modeIndicator').style.color = '#ff0';
                walkBtn.textContent = 'Switch to Sliders (TAB)';
                walkBtn.style.background = '#4a4';
                console.log('[PLACEMENT] Walk mode ON - WASD to move');
            } else {
                // Exit walk mode - free mouse for sliders
                document.exitPointerLock();
                document.getElementById('modeIndicator').textContent = 'SLIDER MODE - Adjust with sliders, TAB to walk';
                document.getElementById('modeIndicator').style.background = 'rgba(100,100,0,0.8)';
                document.getElementById('modeIndicator').style.color = '#ff0';
                walkBtn.textContent = 'Switch to Walk Mode (TAB)';
                walkBtn.style.background = '#a84';
                console.log('[PLACEMENT] Slider mode ON - use sliders');
            }
        }

        // Confirm placement (SET button)
        window.confirmPlacement = function() {
            if (placementPhase !== 'adjust') return;

            // Log the values being used
            console.log('[PLACEMENT] Creating box with:', {
                basePos: collPlaceBasePosition.clone(),
                adjustWidth, adjustHeight, adjustDepth,
                adjustOffsetX, adjustOffsetY, adjustOffsetZ,
                adjustRotationX, adjustRotationY, adjustRotationZ, adjustShape
            });

            // Create final collision box
            // Position: base position + offsets, with center at half height above base
            const finalPos = new THREE.Vector3(
                collPlaceBasePosition.x + adjustOffsetX,
                collPlaceBasePosition.y + adjustOffsetY + adjustHeight / 2,
                collPlaceBasePosition.z + adjustOffsetZ
            );

            // For rotated boxes, we need to create an oriented bounding box
            // For now, store rotation and use axis-aligned box (approximate)
            const rotRad = adjustRotationY * Math.PI / 180;
            const cosR = Math.abs(Math.cos(rotRad));
            const sinR = Math.abs(Math.sin(rotRad));

            // Rotated bounding dimensions (axis-aligned approximation)
            const rotWidth = adjustWidth * cosR + adjustDepth * sinR;
            const rotDepth = adjustWidth * sinR + adjustDepth * cosR;

            const newBox = new THREE.Box3();
            newBox.min.set(
                finalPos.x - rotWidth / 2,
                finalPos.y - adjustHeight / 2,
                finalPos.z - rotDepth / 2
            );
            newBox.max.set(
                finalPos.x + rotWidth / 2,
                finalPos.y + adjustHeight / 2,
                finalPos.z + rotDepth / 2
            );

            console.log('[PLACEMENT] Box3 created:', {
                min: newBox.min.clone(),
                max: newBox.max.clone(),
                size: newBox.getSize(new THREE.Vector3()),
                rotation: adjustRotationY
            });

            // Add to collision boxes (store shape info for visual)
            // For OBB collision, store center, half-extents, and rotation matrix
            const collisionIndex = bucketCollisionBoxes.length;
            const halfExtents = new THREE.Vector3(adjustWidth / 2, adjustHeight / 2, adjustDepth / 2);

            // Create rotation matrix from Euler angles
            const rotMatrix = new THREE.Matrix4();
            rotMatrix.makeRotationFromEuler(new THREE.Euler(
                adjustRotationX * Math.PI / 180,
                adjustRotationY * Math.PI / 180,
                adjustRotationZ * Math.PI / 180
            ));

            bucketCollisionBoxes.push({
                box: newBox, // Keep for backwards compatibility
                center: finalPos.clone(),
                halfExtents: halfExtents,
                rotMatrix: rotMatrix,
                shape: adjustShape,
                rotationX: adjustRotationX,
                rotationY: adjustRotationY,
                rotationZ: adjustRotationZ,
                originalSize: { w: adjustWidth, h: adjustHeight, d: adjustDepth }
            });

            // Create visual (force visible)
            const visual = createCollisionVisual(newBox, true, adjustShape, adjustRotationX, adjustRotationY, adjustRotationZ, adjustWidth, adjustHeight, adjustDepth, finalPos);
            bucketCollisionVisuals[collisionIndex] = visual;

            // Update counter
            document.getElementById('placedBoxCount').textContent = bucketCollisionBoxes.length;

            console.log('[PLACEMENT] Confirmed box #' + collisionIndex + ', total boxes:', bucketCollisionBoxes.length);

            // Restore camera position
            camera.position.copy(savedCameraPos);
            yaw = savedYaw;
            pitch = savedPitch;
            euler.set(pitch, yaw, 0);
            camera.quaternion.setFromEuler(euler);

            // Go back to preview phase for next box
            placementPhase = 'preview';
            document.getElementById('previewModeUI').style.display = 'block';
            document.getElementById('adjustModeUI').style.display = 'none';

            // Reset preview color
            if (collPlacePreview) {
                collPlacePreview.material.color.setHex(0x00ff00);
                collPlacePreview.material.opacity = 0.5;
            }

            // Request pointer lock to return to FP controls
            renderer.domElement.requestPointerLock();

            document.getElementById('modeIndicator').textContent = 'PLACEMENT MODE - Place next box';
            document.getElementById('modeIndicator').style.background = 'rgba(0,100,0,0.8)';
            document.getElementById('modeIndicator').style.color = '#0f0';
        };

        // Cancel placement (go back to preview)
        window.cancelPlacement = function() {
            if (placementPhase !== 'adjust') return;

            // Restore camera position
            camera.position.copy(savedCameraPos);
            yaw = savedYaw;
            pitch = savedPitch;
            euler.set(pitch, yaw, 0);
            camera.quaternion.setFromEuler(euler);

            placementPhase = 'preview';
            document.getElementById('previewModeUI').style.display = 'block';
            document.getElementById('adjustModeUI').style.display = 'none';

            // Reset preview color and shape
            if (collPlacePreview) {
                collPlacePreview.material.color.setHex(0x00ff00);
                collPlacePreview.material.opacity = 0.5;
            }

            // Request pointer lock to return to FP controls
            renderer.domElement.requestPointerLock();

            document.getElementById('modeIndicator').textContent = 'PLACEMENT MODE - Look at surface, click to place';
            document.getElementById('modeIndicator').style.background = 'rgba(0,100,0,0.8)';
            document.getElementById('modeIndicator').style.color = '#0f0';

            console.log('[PLACEMENT] Cancelled - back to preview');
        };

        // Shape preset
        window.setCollShape = function(shape) {
            const preset = collShapePresets[shape];
            if (preset) {
                initWidth = preset.w;
                initHeight = preset.h;
                initDepth = preset.d;
                initShape = preset.shape || 'box';
                updateInitSliders();
                // Recreate preview with new shape
                if (collPlacePreview) {
                    const pos = collPlacePreview.position.clone();
                    createPreviewBox();
                    collPlacePreview.position.copy(pos);
                }
            }
            document.querySelectorAll('.collShapeBtn').forEach(b => {
                b.style.background = b.dataset.shape === shape ? '#4a4' : '#555';
            });
        };

        function updateInitSliders() {
            document.getElementById('initWidthSlider').value = initWidth;
            document.getElementById('initWidthVal').textContent = initWidth.toFixed(1);
            document.getElementById('initHeightSlider').value = initHeight;
            document.getElementById('initHeightVal').textContent = initHeight.toFixed(1);
            document.getElementById('initDepthSlider').value = initDepth;
            document.getElementById('initDepthVal').textContent = initDepth.toFixed(1);
        }

        function updateAdjustSliders() {
            document.getElementById('adjustWidthSlider').value = adjustWidth;
            document.getElementById('adjustWidthVal').textContent = adjustWidth.toFixed(1);
            document.getElementById('adjustHeightSlider').value = adjustHeight;
            document.getElementById('adjustHeightVal').textContent = adjustHeight.toFixed(1);
            document.getElementById('adjustDepthSlider').value = adjustDepth;
            document.getElementById('adjustDepthVal').textContent = adjustDepth.toFixed(1);
            document.getElementById('adjustOffsetXSlider').value = adjustOffsetX;
            document.getElementById('adjustOffsetXVal').textContent = adjustOffsetX.toFixed(1);
            document.getElementById('adjustOffsetYSlider').value = adjustOffsetY;
            document.getElementById('adjustOffsetYVal').textContent = adjustOffsetY.toFixed(1);
            document.getElementById('adjustOffsetZSlider').value = adjustOffsetZ;
            document.getElementById('adjustOffsetZVal').textContent = adjustOffsetZ.toFixed(1);
            document.getElementById('adjustRotationXSlider').value = adjustRotationX;
            document.getElementById('adjustRotationXVal').textContent = adjustRotationX;
            document.getElementById('adjustRotationYSlider').value = adjustRotationY;
            document.getElementById('adjustRotationYVal').textContent = adjustRotationY;
            document.getElementById('adjustRotationZSlider').value = adjustRotationZ;
            document.getElementById('adjustRotationZVal').textContent = adjustRotationZ;
        }

        // Create the preview box
        function createPreviewBox() {
            removePreviewBox();

            console.log('[PREVIEW] Creating with init size:', initWidth, initHeight, initDepth, 'shape:', initShape);

            let geometry;
            const previewColor = initShape === 'cylinder' ? 0x00ffff : 0x00ff00;
            if (initShape === 'cylinder') {
                geometry = new THREE.CylinderGeometry(initWidth / 2, initWidth / 2, initHeight, 16);
            } else {
                geometry = new THREE.BoxGeometry(initWidth, initHeight, initDepth);
            }
            const material = new THREE.MeshBasicMaterial({
                color: previewColor,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthTest: false
            });
            collPlacePreview = new THREE.Mesh(geometry, material);

            const edges = new THREE.EdgesGeometry(geometry);
            const edgeMaterial = new THREE.LineBasicMaterial({ color: previewColor, linewidth: 2 });
            const edgeLines = new THREE.LineSegments(edges, edgeMaterial);
            collPlacePreview.add(edgeLines);

            collPlacePreview.renderOrder = 999;
            scene.add(collPlacePreview);

            console.log('[PREVIEW] Created preview', initShape);
        }

        // Update preview size (in preview phase)
        function updatePreviewSize() {
            if (!collPlacePreview) return;
            // Recreate with new size
            const pos = collPlacePreview.position.clone();
            createPreviewBox();
            collPlacePreview.position.copy(pos);
        }

        // Update preview for adjust mode
        function updateAdjustPreview() {
            if (!collPlacePreview) return;

            // Recreate geometry based on shape
            collPlacePreview.geometry.dispose();
            if (adjustShape === 'cylinder') {
                collPlacePreview.geometry = new THREE.CylinderGeometry(adjustWidth / 2, adjustWidth / 2, adjustHeight, 16);
                collPlacePreview.material.color.setHex(0xffff00);
            } else {
                collPlacePreview.geometry = new THREE.BoxGeometry(adjustWidth, adjustHeight, adjustDepth);
                collPlacePreview.material.color.setHex(0xffff00);
            }

            // Update edges
            collPlacePreview.children.forEach(c => {
                if (c.type === 'LineSegments') {
                    collPlacePreview.remove(c);
                }
            });
            const edges = new THREE.EdgesGeometry(collPlacePreview.geometry);
            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
            const edgeLines = new THREE.LineSegments(edges, edgeMaterial);
            collPlacePreview.add(edgeLines);

            // Update position
            collPlacePreview.position.set(
                collPlaceBasePosition.x + adjustOffsetX,
                collPlaceBasePosition.y + adjustHeight / 2 + adjustOffsetY,
                collPlaceBasePosition.z + adjustOffsetZ
            );

            // Apply all rotations (in degrees to radians)
            collPlacePreview.rotation.set(
                adjustRotationX * Math.PI / 180,
                adjustRotationY * Math.PI / 180,
                adjustRotationZ * Math.PI / 180
            );
        }

        function removePreviewBox() {
            if (collPlacePreview) {
                scene.remove(collPlacePreview);
                collPlacePreview = null;
            }
        }

        // Update preview position based on phase
        function updatePreviewPosition() {
            if (!collPlacePreview) return;

            if (placementPhase === 'preview') {
                // In preview mode: box sits on surface (raycast hit point)
                // Position box so its bottom is at the hit point
                collPlacePreview.position.set(
                    collPlaceBasePosition.x,
                    collPlaceBasePosition.y + initHeight / 2,
                    collPlaceBasePosition.z
                );
                // Keep fixed rotation (no rotation) during preview - don't follow camera
                collPlacePreview.rotation.set(0, 0, 0);
            } else if (placementPhase === 'adjust') {
                // In adjust mode: use offsets from base position
                collPlacePreview.position.set(
                    collPlaceBasePosition.x + adjustOffsetX,
                    collPlaceBasePosition.y + adjustHeight / 2 + adjustOffsetY,
                    collPlaceBasePosition.z + adjustOffsetZ
                );
            }
        }

        // Initial size slider listeners (preview phase)
        document.getElementById('initWidthSlider').addEventListener('input', (e) => {
            initWidth = parseFloat(e.target.value);
            document.getElementById('initWidthVal').textContent = initWidth.toFixed(1);
            updatePreviewSize();
        });
        document.getElementById('initHeightSlider').addEventListener('input', (e) => {
            initHeight = parseFloat(e.target.value);
            document.getElementById('initHeightVal').textContent = initHeight.toFixed(1);
            updatePreviewSize();
        });
        document.getElementById('initDepthSlider').addEventListener('input', (e) => {
            initDepth = parseFloat(e.target.value);
            document.getElementById('initDepthVal').textContent = initDepth.toFixed(1);
            updatePreviewSize();
        });

        // Adjust slider listeners (adjust phase)
        document.getElementById('adjustWidthSlider').addEventListener('input', (e) => {
            adjustWidth = parseFloat(e.target.value);
            document.getElementById('adjustWidthVal').textContent = adjustWidth.toFixed(1);
            updateAdjustPreview();
        });
        document.getElementById('adjustHeightSlider').addEventListener('input', (e) => {
            adjustHeight = parseFloat(e.target.value);
            document.getElementById('adjustHeightVal').textContent = adjustHeight.toFixed(1);
            updateAdjustPreview();
        });
        document.getElementById('adjustDepthSlider').addEventListener('input', (e) => {
            adjustDepth = parseFloat(e.target.value);
            document.getElementById('adjustDepthVal').textContent = adjustDepth.toFixed(1);
            updateAdjustPreview();
        });
        document.getElementById('adjustOffsetXSlider').addEventListener('input', (e) => {
            adjustOffsetX = parseFloat(e.target.value);
            document.getElementById('adjustOffsetXVal').textContent = adjustOffsetX.toFixed(1);
            updateAdjustPreview();
        });
        document.getElementById('adjustOffsetYSlider').addEventListener('input', (e) => {
            adjustOffsetY = parseFloat(e.target.value);
            document.getElementById('adjustOffsetYVal').textContent = adjustOffsetY.toFixed(1);
            updateAdjustPreview();
        });
        document.getElementById('adjustOffsetZSlider').addEventListener('input', (e) => {
            adjustOffsetZ = parseFloat(e.target.value);
            document.getElementById('adjustOffsetZVal').textContent = adjustOffsetZ.toFixed(1);
            updateAdjustPreview();
        });
        document.getElementById('adjustRotationXSlider').addEventListener('input', (e) => {
            adjustRotationX = parseFloat(e.target.value);
            document.getElementById('adjustRotationXVal').textContent = adjustRotationX;
            updateAdjustPreview();
        });
        document.getElementById('adjustRotationYSlider').addEventListener('input', (e) => {
            adjustRotationY = parseFloat(e.target.value);
            document.getElementById('adjustRotationYVal').textContent = adjustRotationY;
            updateAdjustPreview();
        });
        document.getElementById('adjustRotationZSlider').addEventListener('input', (e) => {
            adjustRotationZ = parseFloat(e.target.value);
            document.getElementById('adjustRotationZVal').textContent = adjustRotationZ;
            updateAdjustPreview();
        });

        // Create a visual wireframe box for a collision
        function createCollisionVisual(box3, forceVisible = false, shape = 'box', rotationX = 0, rotationY = 0, rotationZ = 0, origW = null, origH = null, origD = null, centerPos = null) {
            const size = box3.getSize(new THREE.Vector3());
            const center = centerPos || box3.getCenter(new THREE.Vector3());

            console.log('[VISUAL] Creating wireframe at', center, 'size:', size, 'shape:', shape);

            // Validate size
            if (size.x <= 0 || size.y <= 0 || size.z <= 0) {
                console.error('[VISUAL] Invalid box size!', size);
                return null;
            }

            // Create a group to hold both the solid fill and wireframe
            const group = new THREE.Group();

            let fillGeometry;
            if (shape === 'cylinder') {
                // Cylinder: use width as diameter
                const radius = (origW || size.x) / 2;
                const height = origH || size.y;
                fillGeometry = new THREE.CylinderGeometry(radius, radius, height, 16);
            } else {
                // Box: use original dimensions if available (for rotation)
                const w = origW || size.x;
                const h = origH || size.y;
                const d = origD || size.z;
                fillGeometry = new THREE.BoxGeometry(w, h, d);
            }

            // Semi-transparent solid fill
            const fillMaterial = new THREE.MeshBasicMaterial({
                color: shape === 'cylinder' ? 0x00ffff : 0x00ff00,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const fillMesh = new THREE.Mesh(fillGeometry, fillMaterial);
            group.add(fillMesh);

            // Wireframe edges
            const edges = new THREE.EdgesGeometry(fillGeometry);
            const edgeMaterial = new THREE.LineBasicMaterial({
                color: shape === 'cylinder' ? 0x00ffff : 0x00ff00,
                linewidth: 2
            });
            const wireframe = new THREE.LineSegments(edges, edgeMaterial);
            group.add(wireframe);

            group.position.copy(center);
            // Apply all rotations
            group.rotation.set(
                rotationX * Math.PI / 180,
                rotationY * Math.PI / 180,
                rotationZ * Math.PI / 180
            );
            group.visible = forceVisible || bucketCollisionVisualsVisible;
            scene.add(group);

            // If forceVisible, also update the toggle state
            if (forceVisible && !bucketCollisionVisualsVisible) {
                bucketCollisionVisualsVisible = true;
                document.getElementById('toggleBucketCollBtn').textContent = 'Hide Collision Boxes';
                document.getElementById('toggleBucketCollBtn').style.background = '#4a4';
            }

            return group;
        }

        // Remove a visual collision box
        function removeCollisionVisual(index) {
            if (bucketCollisionVisuals[index]) {
                scene.remove(bucketCollisionVisuals[index]);
                bucketCollisionVisuals[index] = null;
            }
        }

        // Mouse down for collision placement
        renderer.domElement.addEventListener('mousedown', (e) => {
            // Collision placement mode - click to place (only in preview phase)
            if (collisionPlaceMode && e.button === 0 && placementPhase === 'preview') {
                // If not in pointer lock, request it
                if (!isLooking) {
                    renderer.domElement.requestPointerLock();
                    return;
                }
                // Use the current raycast position to place
                if (collPlaceBasePosition.lengthSq() > 0) {
                    placeBoxAtPosition(collPlaceBasePosition.clone());
                } else {
                    console.log('[PLACE] No position - look at a surface first');
                }
                return;
            }
        });

        // ==================== COPY OBJECT MODE ====================

        // Selection sphere for partial mesh copying
        let selectionSphere = null;
        let selectionPoint = new THREE.Vector3();
        let selectionBasePoint = new THREE.Vector3(); // Original hit point
        let selectionRadius = 0.5;
        let selectionShape = 'sphere'; // 'sphere' or 'box'
        let selectionBoxW = 1, selectionBoxH = 1, selectionBoxD = 1; // box dimensions
        let selectionOffsetX = 0, selectionOffsetY = 0, selectionOffsetZ = 0;
        let hitMesh = null;

        // Start copy mode
        window.startCopyMode = function() {
            console.log('[COPY] Starting copy mode');
            copyMode = true;
            copyPhase = 'select';

            // Hide main UI, show copy panel
            document.getElementById('info').style.display = 'none';
            document.getElementById('copyPanel').style.display = 'block';
            document.getElementById('copySelectUI').style.display = 'block';
            document.getElementById('copySelectionUI').style.display = 'none';
            document.getElementById('copyPreviewUI').style.display = 'none';
            document.getElementById('copyAdjustUI').style.display = 'none';

            // Clean up any leftover selection sphere
            if (selectionSphere) {
                scene.remove(selectionSphere);
                selectionSphere = null;
            }

            // Request pointer lock
            renderer.domElement.requestPointerLock();
            console.log('[COPY] Copy mode started. Phase:', copyPhase, '- Press C while looking at object');
        };

        // Find object under crosshair and start copying it
        function selectObjectUnderCrosshair() {
            // Update matrices
            scene.updateMatrixWorld(true);
            camera.updateMatrixWorld(true);

            // Get camera's forward direction
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);

            // Set ray directly
            raycaster.set(camera.position, forward);
            raycaster.far = 100;

            // Raycast against all meshes in the model
            let allMeshes = [];
            if (loadedModel) {
                loadedModel.traverse(obj => { if (obj.isMesh) allMeshes.push(obj); });
            }

            let intersects = raycaster.intersectObjects(allMeshes, false);

            for (const hit of intersects) {
                // Skip things we don't want to copy
                if (hit.object === playerBody) continue;
                if (hit.object === collisionBox) continue;
                if (hit.object.parent === fpsHands) continue;
                if (copyPreview && (hit.object === copyPreview || hit.object.parent === copyPreview)) continue;
                if (selectionSphere && hit.object === selectionSphere) continue;

                // Store hit info
                hitMesh = hit.object;
                selectionBasePoint.copy(hit.point);
                selectionPoint.copy(hit.point);
                selectionRadius = 0.5;
                selectionShape = 'sphere';
                selectionBoxW = 1;
                selectionBoxH = 1;
                selectionBoxD = 1;
                selectionOffsetX = 0;
                selectionOffsetY = 0;
                selectionOffsetZ = 0;

                console.log('[COPY] Hit mesh:', hitMesh.name, 'at point:', selectionPoint);

                // Create selection sphere at hit point
                createSelectionSphere();

                // Switch to selection phase
                copyPhase = 'selection';
                document.getElementById('copySelectUI').style.display = 'none';
                document.getElementById('copySelectionUI').style.display = 'block';
                document.getElementById('selectionRadiusSlider').value = selectionRadius;
                document.getElementById('selectionRadiusVal').textContent = selectionRadius.toFixed(2);
                document.getElementById('selectionShapeSelect').value = 'sphere';
                document.getElementById('sphereSizeUI').style.display = 'block';
                document.getElementById('boxSizeUI').style.display = 'none';
                document.getElementById('selectionBoxWSlider').value = 1;
                document.getElementById('selectionBoxHSlider').value = 1;
                document.getElementById('selectionBoxDSlider').value = 1;
                document.getElementById('selectionBoxWVal').textContent = '1.00';
                document.getElementById('selectionBoxHVal').textContent = '1.00';
                document.getElementById('selectionBoxDVal').textContent = '1.00';
                document.getElementById('selectionOffsetXSlider').value = 0;
                document.getElementById('selectionOffsetYSlider').value = 0;
                document.getElementById('selectionOffsetZSlider').value = 0;
                document.getElementById('selectionOffsetXVal').textContent = '0.00';
                document.getElementById('selectionOffsetYVal').textContent = '0.00';
                document.getElementById('selectionOffsetZVal').textContent = '0.00';

                // Keep pointer lock - user can move around to view the selection
                // They'll need to press ESC or click a button to adjust slider
                return true;
            }
            console.log('[COPY] No object found under crosshair');
            return false;
        }

        // Create/update the selection shape visual (sphere or box)
        function createSelectionSphere() {
            if (selectionSphere) {
                scene.remove(selectionSphere);
            }

            let geometry, wireGeo;
            if (selectionShape === 'box') {
                geometry = new THREE.BoxGeometry(selectionBoxW, selectionBoxH, selectionBoxD);
                wireGeo = new THREE.BoxGeometry(selectionBoxW, selectionBoxH, selectionBoxD);
            } else {
                geometry = new THREE.SphereGeometry(selectionRadius, 16, 16);
                wireGeo = new THREE.SphereGeometry(selectionRadius, 16, 16);
            }

            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.3,
                wireframe: false
            });
            selectionSphere = new THREE.Mesh(geometry, material);
            selectionSphere.position.copy(selectionPoint);
            scene.add(selectionSphere);

            // Also add wireframe
            const wireMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
            const wire = new THREE.Mesh(wireGeo, wireMat);
            selectionSphere.add(wire);
        }

        // Update selection sphere size
        function updateSelectionRadius(newRadius) {
            selectionRadius = newRadius;
            if (selectionSphere) {
                scene.remove(selectionSphere);
                createSelectionSphere();
            }
        }

        // Update selection sphere position based on offsets
        function updateSelectionPosition() {
            selectionPoint.set(
                selectionBasePoint.x + selectionOffsetX,
                selectionBasePoint.y + selectionOffsetY,
                selectionBasePoint.z + selectionOffsetZ
            );
            if (selectionSphere) {
                selectionSphere.position.copy(selectionPoint);
            }
        }

        // Extract geometry within the selection sphere
        function extractSelectedGeometry() {
            if (!hitMesh || !hitMesh.geometry) {
                console.error('[COPY] No mesh to extract from');
                return null;
            }

            const geo = hitMesh.geometry;
            const posAttr = geo.attributes.position;
            const indexAttr = geo.index;

            if (!posAttr) {
                console.error('[COPY] Mesh has no position attribute');
                return null;
            }

            // Get world matrix to transform vertices
            hitMesh.updateMatrixWorld(true);
            const worldMatrix = hitMesh.matrixWorld;
            const normalMatrix = new THREE.Matrix3().getNormalMatrix(worldMatrix);

            // Find vertices within sphere and store world positions
            const vertexInSphere = [];
            const worldPositions = []; // Store world-space positions
            const tempVec = new THREE.Vector3();

            for (let i = 0; i < posAttr.count; i++) {
                tempVec.set(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i));
                tempVec.applyMatrix4(worldMatrix);
                worldPositions.push(tempVec.clone());

                // Check if vertex is inside selection shape
                if (selectionShape === 'box') {
                    // Box containment check
                    const halfW = selectionBoxW / 2;
                    const halfH = selectionBoxH / 2;
                    const halfD = selectionBoxD / 2;
                    vertexInSphere[i] = (
                        Math.abs(tempVec.x - selectionPoint.x) <= halfW &&
                        Math.abs(tempVec.y - selectionPoint.y) <= halfH &&
                        Math.abs(tempVec.z - selectionPoint.z) <= halfD
                    );
                } else {
                    // Sphere containment check
                    const dist = tempVec.distanceTo(selectionPoint);
                    vertexInSphere[i] = dist <= selectionRadius;
                }
            }

            // Collect faces where at least one vertex is in sphere
            const selectedIndices = [];
            if (indexAttr) {
                // Indexed geometry
                for (let i = 0; i < indexAttr.count; i += 3) {
                    const a = indexAttr.getX(i);
                    const b = indexAttr.getX(i + 1);
                    const c = indexAttr.getX(i + 2);
                    if (vertexInSphere[a] || vertexInSphere[b] || vertexInSphere[c]) {
                        selectedIndices.push(a, b, c);
                    }
                }
            } else {
                // Non-indexed geometry
                for (let i = 0; i < posAttr.count; i += 3) {
                    if (vertexInSphere[i] || vertexInSphere[i+1] || vertexInSphere[i+2]) {
                        selectedIndices.push(i, i+1, i+2);
                    }
                }
            }

            if (selectedIndices.length === 0) {
                console.log('[COPY] No geometry within selection sphere');
                return null;
            }

            console.log('[COPY] Extracting', selectedIndices.length / 3, 'faces');

            // Create new geometry with only selected faces - in WORLD SPACE
            const newGeo = new THREE.BufferGeometry();

            // Build new arrays using world-space positions
            const newPositions = [];
            const newNormals = [];
            const newUvs = [];
            const hasNormals = geo.attributes.normal;
            const hasUvs = geo.attributes.uv;

            // Map old indices to new
            const indexMap = new Map();
            let newIndex = 0;
            const tempNormal = new THREE.Vector3();

            for (const oldIdx of selectedIndices) {
                if (!indexMap.has(oldIdx)) {
                    indexMap.set(oldIdx, newIndex++);
                    // Use world-space position
                    const wp = worldPositions[oldIdx];
                    newPositions.push(wp.x, wp.y, wp.z);

                    if (hasNormals) {
                        // Transform normal to world space
                        tempNormal.set(
                            hasNormals.getX(oldIdx),
                            hasNormals.getY(oldIdx),
                            hasNormals.getZ(oldIdx)
                        );
                        tempNormal.applyMatrix3(normalMatrix).normalize();
                        newNormals.push(tempNormal.x, tempNormal.y, tempNormal.z);
                    }
                    if (hasUvs) {
                        newUvs.push(
                            hasUvs.getX(oldIdx),
                            hasUvs.getY(oldIdx)
                        );
                    }
                }
            }

            // Build new index array
            const newIndices = selectedIndices.map(oldIdx => indexMap.get(oldIdx));

            newGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
            if (hasNormals) {
                newGeo.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));
            }
            if (hasUvs) {
                newGeo.setAttribute('uv', new THREE.Float32BufferAttribute(newUvs, 2));
            }
            newGeo.setIndex(newIndices);
            newGeo.computeBoundingSphere();

            // Center the geometry around its bounding sphere center
            newGeo.computeBoundingBox();
            const center = new THREE.Vector3();
            newGeo.boundingBox.getCenter(center);
            newGeo.translate(-center.x, -center.y, -center.z);

            // Create mesh with same material
            const material = hitMesh.material.clone();
            const newMesh = new THREE.Mesh(newGeo, material);

            // Position the mesh at the center of the extracted geometry
            newMesh.position.copy(center);

            console.log('[COPY] Created mesh at', center);
            return newMesh;
        }

        // Confirm selection and create preview
        window.confirmSelection = function() {
            selectedObject = extractSelectedGeometry();

            if (!selectedObject) {
                alert('No geometry selected. Try increasing the radius.');
                return;
            }

            // Remove selection sphere
            if (selectionSphere) {
                scene.remove(selectionSphere);
                selectionSphere = null;
            }

            // Create preview
            createCopyPreview();

            // Switch to preview phase
            copyPhase = 'preview';
            document.getElementById('copySelectionUI').style.display = 'none';
            document.getElementById('copyPreviewUI').style.display = 'block';

            // Re-enter pointer lock for placement
            renderer.domElement.requestPointerLock();
        };

        // Cancel selection
        window.cancelSelection = function() {
            if (selectionSphere) {
                scene.remove(selectionSphere);
                selectionSphere = null;
            }
            hitMesh = null;

            copyPhase = 'select';
            document.getElementById('copySelectionUI').style.display = 'none';
            document.getElementById('copySelectUI').style.display = 'block';

            renderer.domElement.requestPointerLock();
        };

        // Create a clone for preview
        function createCopyPreview() {
            if (copyPreview) {
                scene.remove(copyPreview);
            }

            copyPreview = selectedObject.clone();

            // Make slightly transparent to indicate it's a preview
            copyPreview.traverse(function(child) {
                if (child.isMesh && child.material) {
                    child.material = child.material.clone();
                    child.material.transparent = true;
                    child.material.opacity = 0.7;
                }
            });

            scene.add(copyPreview);
        }

        // Update preview position based on raycast
        function updateCopyPreviewPosition() {
            if (!copyPreview) return;

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            let foundHit = false;
            for (const hit of intersects) {
                // Skip preview itself and player
                if (hit.object === copyPreview) continue;
                if (hit.object.parent === copyPreview) continue;
                if (copyPreview.getObjectById && copyPreview.getObjectById(hit.object.id)) continue;
                if (hit.object === playerBody) continue;
                if (hit.object === collisionBox) continue;

                copyBasePosition.copy(hit.point);
                foundHit = true;
                break;
            }

            if (!foundHit) {
                // Place 5 units in front of camera
                const forward = new THREE.Vector3(0, 0, -5);
                forward.applyQuaternion(camera.quaternion);
                copyBasePosition.copy(camera.position).add(forward);
            }

            copyPreview.position.copy(copyBasePosition);
        }

        // Place the preview and enter adjust mode
        function placeCopyAtPosition() {
            copyPhase = 'adjust';

            // Reset adjust values
            copyOffsetX = 0; copyOffsetY = 0; copyOffsetZ = 0;
            copyRotationY = 0;
            copyScale = 1;

            // Update sliders
            document.getElementById('copyOffsetXSlider').value = 0;
            document.getElementById('copyOffsetYSlider').value = 0;
            document.getElementById('copyOffsetZSlider').value = 0;
            document.getElementById('copyRotationYSlider').value = 0;
            document.getElementById('copyScaleSlider').value = 1;
            document.getElementById('copyOffsetXVal').textContent = '0';
            document.getElementById('copyOffsetYVal').textContent = '0';
            document.getElementById('copyOffsetZVal').textContent = '0';
            document.getElementById('copyRotationYVal').textContent = '0';
            document.getElementById('copyScaleVal').textContent = '1.0';

            // Switch UI
            document.getElementById('copyPreviewUI').style.display = 'none';
            document.getElementById('copyAdjustUI').style.display = 'block';

            // Exit pointer lock to use sliders
            document.exitPointerLock();
        }

        // Update preview based on adjust sliders
        function updateCopyAdjustPreview() {
            if (!copyPreview) return;

            copyPreview.position.set(
                copyBasePosition.x + copyOffsetX,
                copyBasePosition.y + copyOffsetY,
                copyBasePosition.z + copyOffsetZ
            );
            copyPreview.rotation.y = copyRotationY * Math.PI / 180;
            copyPreview.scale.setScalar(copyScale);
        }

        // Confirm placement
        window.confirmCopyPlacement = function() {
            if (!selectedObject) return;

            // Create final clone from original
            const finalClone = selectedObject.clone();

            // Apply transforms
            finalClone.position.set(
                copyBasePosition.x + copyOffsetX,
                copyBasePosition.y + copyOffsetY,
                copyBasePosition.z + copyOffsetZ
            );
            finalClone.rotation.y = copyRotationY * Math.PI / 180;
            finalClone.scale.setScalar(copyScale);

            scene.add(finalClone);
            copiedObjects.push(finalClone);
            document.getElementById('copiedCount').textContent = copiedObjects.length;

            console.log('[COPY] Placed clone at', finalClone.position);

            // Remove preview
            if (copyPreview) {
                scene.remove(copyPreview);
                copyPreview = null;
            }

            // Go back to select phase
            copyPhase = 'select';
            selectedObject = null;
            document.getElementById('copyAdjustUI').style.display = 'none';
            document.getElementById('copySelectUI').style.display = 'block';

            // Re-enter pointer lock
            renderer.domElement.requestPointerLock();
        };

        // Cancel current copy
        window.cancelCopy = function() {
            if (copyPreview) {
                scene.remove(copyPreview);
                copyPreview = null;
            }
            selectedObject = null;
            copyPhase = 'select';
            document.getElementById('copyAdjustUI').style.display = 'none';
            document.getElementById('copyPreviewUI').style.display = 'none';
            document.getElementById('copySelectUI').style.display = 'block';
            renderer.domElement.requestPointerLock();
        };

        // Exit copy mode
        window.exitCopyMode = function() {
            copyMode = false;
            if (copyPreview) {
                scene.remove(copyPreview);
                copyPreview = null;
            }
            if (selectionSphere) {
                scene.remove(selectionSphere);
                selectionSphere = null;
            }
            selectedObject = null;
            hitMesh = null;
            copyPhase = 'select';

            document.getElementById('copyPanel').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.exitPointerLock();
        };

        // ============================================
        // FARKLE TABLE PLACEMENT
        // ============================================

        // Create dice box/tray mesh (2x size: 2m x 1.4m)
        function createDiceBoxMesh(isPreview = false) {
            const group = new THREE.Group();

            // === MATERIALS ===
            // Rich dark oak wood for the main structure
            const darkOakMat = new THREE.MeshStandardMaterial({
                color: 0x3d2817,
                roughness: 0.7,
                metalness: 0.05,
                transparent: isPreview,
                opacity: isPreview ? 0.7 : 1
            });

            // Lighter polished wood for the tabletop surface
            const polishedWoodMat = new THREE.MeshStandardMaterial({
                color: 0x6b4423,
                roughness: 0.4,
                metalness: 0.1,
                transparent: isPreview,
                opacity: isPreview ? 0.7 : 1
            });

            // Bright green felt for the dice tray interior (uses global adjustable color)
            // Derive emissive color from main felt color (darker version)
            const feltEmissiveColor = new THREE.Color(feltColor).multiplyScalar(0.3);
            const feltMat = new THREE.MeshStandardMaterial({
                color: feltColor,
                roughness: 0.85,
                metalness: 0,
                emissive: feltEmissiveColor,
                emissiveIntensity: feltEmissive,
                transparent: isPreview,
                opacity: isPreview ? 0.7 : 1
            });

            // Gold metal for accents (brighter, more golden)
            const brassMat = new THREE.MeshStandardMaterial({
                color: 0xd4a017,
                roughness: 0.25,
                metalness: 0.9,
                emissive: 0x3d2800,
                emissiveIntensity: 0.2,
                transparent: isPreview,
                opacity: isPreview ? 0.7 : 1
            });

            // Worn/aged wood for decorative elements
            const agedWoodMat = new THREE.MeshStandardMaterial({
                color: 0x4a3728,
                roughness: 0.85,
                metalness: 0,
                transparent: isPreview,
                opacity: isPreview ? 0.7 : 1
            });

            // === TABLE DIMENSIONS (1.5x size, adjustable height) ===
            const tableWidth = 3.3;
            const tableDepth = 2.4;
            const tableTopThickness = 0.1;
            const legHeight = tableLegHeight; // Use adjustable leg height from slider
            const trayWidth = 3.0;
            const trayDepth = 2.1;
            const trayDepthInset = 0.06;
            const railHeight = 0.18;
            const railWidth = 0.12;

            // === TABLE LEGS (Turned/carved style) ===
            function createOrnateleg(x, z) {
                const legGroup = new THREE.Group();

                // Main leg post
                const legGeo = new THREE.CylinderGeometry(0.06, 0.08, legHeight * 0.7, 12);
                const leg = new THREE.Mesh(legGeo, darkOakMat);
                leg.position.y = legHeight * 0.35;
                legGroup.add(leg);

                // Decorative bulb (turned wood detail)
                const bulbGeo = new THREE.SphereGeometry(0.09, 12, 8);
                const bulb = new THREE.Mesh(bulbGeo, agedWoodMat);
                bulb.position.y = legHeight * 0.55;
                bulb.scale.y = 0.7;
                legGroup.add(bulb);

                // Upper neck
                const neckGeo = new THREE.CylinderGeometry(0.05, 0.06, legHeight * 0.15, 10);
                const neck = new THREE.Mesh(neckGeo, darkOakMat);
                neck.position.y = legHeight * 0.78;
                legGroup.add(neck);

                // Top cap connecting to table
                const capGeo = new THREE.CylinderGeometry(0.08, 0.05, 0.04, 10);
                const cap = new THREE.Mesh(capGeo, polishedWoodMat);
                cap.position.y = legHeight * 0.88;
                legGroup.add(cap);

                // Foot (wider base)
                const footGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.05, 10);
                const foot = new THREE.Mesh(footGeo, agedWoodMat);
                foot.position.y = 0.025;
                legGroup.add(foot);

                // Brass foot ring
                const ringGeo = new THREE.TorusGeometry(0.085, 0.012, 8, 16);
                const ring = new THREE.Mesh(ringGeo, brassMat);
                ring.rotation.x = Math.PI / 2;
                ring.position.y = 0.06;
                legGroup.add(ring);

                legGroup.position.set(x, 0, z);
                return legGroup;
            }

            // Add four ornate legs
            const legInsetX = tableWidth / 2 - 0.15;
            const legInsetZ = tableDepth / 2 - 0.15;
            group.add(createOrnateleg(-legInsetX, -legInsetZ));
            group.add(createOrnateleg(legInsetX, -legInsetZ));
            group.add(createOrnateleg(-legInsetX, legInsetZ));
            group.add(createOrnateleg(legInsetX, legInsetZ));

            // === TABLETOP FRAME (thick beveled edge) ===
            const tabletopY = legHeight;

            // Main tabletop slab
            const topGeo = new THREE.BoxGeometry(tableWidth, tableTopThickness, tableDepth);
            const tabletop = new THREE.Mesh(topGeo, polishedWoodMat);
            tabletop.position.y = tabletopY + tableTopThickness / 2;
            group.add(tabletop);

            // Beveled edge trim (decorative molding around the edge)
            const edgeHeight = 0.03;
            const edgeWidth = 0.04;

            // Front edge molding
            const frontEdge = new THREE.Mesh(
                new THREE.BoxGeometry(tableWidth + 0.02, edgeHeight, edgeWidth),
                agedWoodMat
            );
            frontEdge.position.set(0, tabletopY - edgeHeight / 2, tableDepth / 2 + edgeWidth / 2);
            group.add(frontEdge);

            // Back edge molding
            const backEdge = frontEdge.clone();
            backEdge.position.z = -tableDepth / 2 - edgeWidth / 2;
            group.add(backEdge);

            // Left edge molding
            const leftEdge = new THREE.Mesh(
                new THREE.BoxGeometry(edgeWidth, edgeHeight, tableDepth + 0.02),
                agedWoodMat
            );
            leftEdge.position.set(-tableWidth / 2 - edgeWidth / 2, tabletopY - edgeHeight / 2, 0);
            group.add(leftEdge);

            // Right edge molding
            const rightEdge = leftEdge.clone();
            rightEdge.position.x = tableWidth / 2 + edgeWidth / 2;
            group.add(rightEdge);

            // === DICE TRAY (felt surface on top of tabletop) ===
            // Felt playing surface - positioned ON TOP of the tabletop so it's visible
            const feltGeo = new THREE.BoxGeometry(trayWidth, 0.02, trayDepth);
            const felt = new THREE.Mesh(feltGeo, feltMat);
            // Position felt clearly on top of the tabletop (tabletopY + tableTopThickness = top surface)
            felt.position.y = tabletopY + tableTopThickness + 0.011;
            group.add(felt);

            // Store reference to felt for debugging
            group.feltMesh = felt;

            // Felt border/lip (darker edge around felt)
            const feltBorderMat = new THREE.MeshStandardMaterial({
                color: 0x1a4020,
                roughness: 0.95,
                metalness: 0,
                transparent: isPreview,
                opacity: isPreview ? 0.7 : 1
            });
            const feltBorderWidth = 0.03;

            // Front felt border
            const frontFeltBorder = new THREE.Mesh(
                new THREE.BoxGeometry(trayWidth, 0.025, feltBorderWidth),
                feltBorderMat
            );
            frontFeltBorder.position.set(0, tabletopY + tableTopThickness + 0.012, trayDepth / 2 - feltBorderWidth / 2);
            group.add(frontFeltBorder);

            // Back felt border
            const backFeltBorder = frontFeltBorder.clone();
            backFeltBorder.position.z = -trayDepth / 2 + feltBorderWidth / 2;
            group.add(backFeltBorder);

            // Left felt border
            const leftFeltBorder = new THREE.Mesh(
                new THREE.BoxGeometry(feltBorderWidth, 0.025, trayDepth - feltBorderWidth * 2),
                feltBorderMat
            );
            leftFeltBorder.position.set(-trayWidth / 2 + feltBorderWidth / 2, tabletopY + tableTopThickness + 0.012, 0);
            group.add(leftFeltBorder);

            // Right felt border
            const rightFeltBorder = leftFeltBorder.clone();
            rightFeltBorder.position.x = trayWidth / 2 - feltBorderWidth / 2;
            group.add(rightFeltBorder);

            // Rail base Y position
            const railY = tabletopY + tableTopThickness + railHeight / 2 - trayDepthInset;
            const cornerSize = railWidth + 0.02; // Slightly larger corner posts

            // Front rail (shorter, between corners)
            const frontRail = new THREE.Mesh(
                new THREE.BoxGeometry(trayWidth - 0.02, railHeight, railWidth),
                darkOakMat
            );
            frontRail.position.set(0, railY, trayDepth / 2 + railWidth / 2);
            group.add(frontRail);

            // Back rail
            const backRail = frontRail.clone();
            backRail.position.z = -trayDepth / 2 - railWidth / 2;
            group.add(backRail);

            // Left rail (shorter, between corners)
            const leftRail = new THREE.Mesh(
                new THREE.BoxGeometry(railWidth, railHeight, trayDepth - 0.02),
                darkOakMat
            );
            leftRail.position.set(-trayWidth / 2 - railWidth / 2, railY, 0);
            group.add(leftRail);

            // Right rail
            const rightRail = leftRail.clone();
            rightRail.position.x = trayWidth / 2 + railWidth / 2;
            group.add(rightRail);

            // === CORNER POSTS (cover rail joints cleanly) ===
            function createCornerPost(x, z) {
                const postGroup = new THREE.Group();

                // Main corner block
                const post = new THREE.Mesh(
                    new THREE.BoxGeometry(cornerSize, railHeight + 0.02, cornerSize),
                    agedWoodMat
                );
                post.position.y = railY;
                postGroup.add(post);

                // Decorative cap on top
                const cap = new THREE.Mesh(
                    new THREE.BoxGeometry(cornerSize + 0.02, 0.02, cornerSize + 0.02),
                    polishedWoodMat
                );
                cap.position.y = railY + railHeight / 2 + 0.01;
                postGroup.add(cap);

                // Brass corner accent (chamfered look)
                const accent = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 0.025, 8),
                    brassMat
                );
                accent.position.y = railY + railHeight / 2 + 0.025;
                postGroup.add(accent);

                // Inner corner detail (towards felt)
                const innerX = x > 0 ? -0.03 : 0.03;
                const innerZ = z > 0 ? -0.03 : 0.03;
                const innerAccent = new THREE.Mesh(
                    new THREE.BoxGeometry(0.02, railHeight * 0.6, 0.02),
                    brassMat
                );
                innerAccent.position.set(innerX, railY, innerZ);
                postGroup.add(innerAccent);

                postGroup.position.set(x, 0, z);
                return postGroup;
            }

            // Add corner posts at all four corners
            const cornerX = trayWidth / 2 + railWidth / 2;
            const cornerZ = trayDepth / 2 + railWidth / 2;
            group.add(createCornerPost(-cornerX, -cornerZ));
            group.add(createCornerPost(cornerX, -cornerZ));
            group.add(createCornerPost(-cornerX, cornerZ));
            group.add(createCornerPost(cornerX, cornerZ));

            // === INNER EDGE TRIM (where rails meet felt) ===
            const trimHeight = 0.015;
            const trimWidth = 0.02;

            // Front inner trim
            const frontTrim = new THREE.Mesh(
                new THREE.BoxGeometry(trayWidth, trimHeight, trimWidth),
                brassMat
            );
            frontTrim.position.set(0, railY - railHeight / 2 + trimHeight / 2, trayDepth / 2 - trimWidth / 2);
            group.add(frontTrim);

            // Back inner trim
            const backTrim = frontTrim.clone();
            backTrim.position.z = -trayDepth / 2 + trimWidth / 2;
            group.add(backTrim);

            // Left inner trim
            const leftTrim = new THREE.Mesh(
                new THREE.BoxGeometry(trimWidth, trimHeight, trayDepth),
                brassMat
            );
            leftTrim.position.set(-trayWidth / 2 + trimWidth / 2, railY - railHeight / 2 + trimHeight / 2, 0);
            group.add(leftTrim);

            // Right inner trim
            const rightTrim = leftTrim.clone();
            rightTrim.position.x = trayWidth / 2 - trimWidth / 2;
            group.add(rightTrim);

            // === SOLID WOOD SIDE PANELS (full apron around table) ===
            const panelHeight = 0.15; // Taller, more substantial
            const panelThickness = 0.04;
            const panelY = tabletopY - panelHeight / 2;

            // Front panel - solid wood
            const frontPanel = new THREE.Mesh(
                new THREE.BoxGeometry(tableWidth - 0.25, panelHeight, panelThickness),
                polishedWoodMat
            );
            frontPanel.position.set(0, panelY, tableDepth / 2 - 0.06);
            group.add(frontPanel);

            // Back panel
            const backPanel = frontPanel.clone();
            backPanel.position.z = -tableDepth / 2 + 0.06;
            group.add(backPanel);

            // Left panel
            const leftPanel = new THREE.Mesh(
                new THREE.BoxGeometry(panelThickness, panelHeight, tableDepth - 0.25),
                polishedWoodMat
            );
            leftPanel.position.set(-tableWidth / 2 + 0.06, panelY, 0);
            group.add(leftPanel);

            // Right panel
            const rightPanel = leftPanel.clone();
            rightPanel.position.x = tableWidth / 2 - 0.06;
            group.add(rightPanel);

            // === GOLD TRIM STRIPS on panels ===
            const trimStripHeight = 0.02;

            // Top gold trim on front/back
            const frontTopTrim = new THREE.Mesh(
                new THREE.BoxGeometry(tableWidth - 0.2, trimStripHeight, 0.015),
                brassMat
            );
            frontTopTrim.position.set(0, panelY + panelHeight / 2 - trimStripHeight / 2, tableDepth / 2 - 0.04);
            group.add(frontTopTrim);

            const backTopTrim = frontTopTrim.clone();
            backTopTrim.position.z = -tableDepth / 2 + 0.04;
            group.add(backTopTrim);

            // Bottom gold trim on front/back
            const frontBottomTrim = frontTopTrim.clone();
            frontBottomTrim.position.y = panelY - panelHeight / 2 + trimStripHeight / 2;
            group.add(frontBottomTrim);

            const backBottomTrim = frontBottomTrim.clone();
            backBottomTrim.position.z = -tableDepth / 2 + 0.04;
            group.add(backBottomTrim);

            // Top gold trim on sides
            const leftTopTrim = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, trimStripHeight, tableDepth - 0.2),
                brassMat
            );
            leftTopTrim.position.set(-tableWidth / 2 + 0.04, panelY + panelHeight / 2 - trimStripHeight / 2, 0);
            group.add(leftTopTrim);

            const rightTopTrim = leftTopTrim.clone();
            rightTopTrim.position.x = tableWidth / 2 - 0.04;
            group.add(rightTopTrim);

            // Bottom gold trim on sides
            const leftBottomTrim = leftTopTrim.clone();
            leftBottomTrim.position.y = panelY - panelHeight / 2 + trimStripHeight / 2;
            group.add(leftBottomTrim);

            const rightBottomTrim = leftBottomTrim.clone();
            rightBottomTrim.position.x = tableWidth / 2 - 0.04;
            group.add(rightBottomTrim);

            // === DECORATIVE GOLD MEDALLIONS on panels ===
            function createMedallion(x, y, z, rotY) {
                const medalGroup = new THREE.Group();

                // Outer ring
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(0.04, 0.008, 8, 16),
                    brassMat
                );
                ring.rotation.x = Math.PI / 2;
                ring.rotation.z = rotY;
                medalGroup.add(ring);

                // Center disc
                const disc = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.025, 0.025, 0.01, 12),
                    brassMat
                );
                disc.rotation.x = Math.PI / 2;
                disc.rotation.z = rotY;
                medalGroup.add(disc);

                medalGroup.position.set(x, y, z);
                medalGroup.rotation.y = rotY;
                return medalGroup;
            }

            // Medallions on front panel
            group.add(createMedallion(-0.4, panelY, tableDepth / 2 - 0.03, 0));
            group.add(createMedallion(0, panelY, tableDepth / 2 - 0.03, 0));
            group.add(createMedallion(0.4, panelY, tableDepth / 2 - 0.03, 0));

            // Medallions on back panel
            group.add(createMedallion(-0.4, panelY, -tableDepth / 2 + 0.03, Math.PI));
            group.add(createMedallion(0, panelY, -tableDepth / 2 + 0.03, Math.PI));
            group.add(createMedallion(0.4, panelY, -tableDepth / 2 + 0.03, Math.PI));

            // Medallions on side panels
            group.add(createMedallion(-tableWidth / 2 + 0.03, panelY, -0.3, Math.PI / 2));
            group.add(createMedallion(-tableWidth / 2 + 0.03, panelY, 0.3, Math.PI / 2));
            group.add(createMedallion(tableWidth / 2 - 0.03, panelY, -0.3, -Math.PI / 2));
            group.add(createMedallion(tableWidth / 2 - 0.03, panelY, 0.3, -Math.PI / 2));

            // === CROSS BRACES UNDER TABLE ===
            const braceY = legHeight * 0.3;
            const braceThickness = 0.04;

            const sideBrace1 = new THREE.Mesh(
                new THREE.BoxGeometry(braceThickness, braceThickness, tableDepth - 0.4),
                agedWoodMat
            );
            sideBrace1.position.set(-tableWidth / 2 + 0.2, braceY, 0);
            group.add(sideBrace1);

            const sideBrace2 = sideBrace1.clone();
            sideBrace2.position.x = tableWidth / 2 - 0.2;
            group.add(sideBrace2);

            const crossBrace = new THREE.Mesh(
                new THREE.BoxGeometry(tableWidth - 0.4, braceThickness, braceThickness),
                agedWoodMat
            );
            crossBrace.position.set(0, braceY, 0);
            group.add(crossBrace);

            // === CORNER ACCENT PIECES (where panels meet) ===
            function createCornerAccent(x, z) {
                const accent = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, panelHeight + 0.02, 0.06),
                    darkOakMat
                );
                accent.position.set(x, panelY, z);
                return accent;
            }

            // Corner accents at all four corners
            group.add(createCornerAccent(-tableWidth / 2 + 0.05, tableDepth / 2 - 0.05));
            group.add(createCornerAccent(tableWidth / 2 - 0.05, tableDepth / 2 - 0.05));
            group.add(createCornerAccent(-tableWidth / 2 + 0.05, -tableDepth / 2 + 0.05));
            group.add(createCornerAccent(tableWidth / 2 - 0.05, -tableDepth / 2 + 0.05));

            // Add wireframe edges if preview
            if (isPreview) {
                const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(tableWidth, 0.3, tableDepth));
                const edgeMat = new THREE.LineBasicMaterial({ color: 0xffaa55 });
                const edgeLines = new THREE.LineSegments(edges, edgeMat);
                edgeLines.position.y = tabletopY + 0.1;
                group.add(edgeLines);
            }

            // Store the felt surface height for physics calculations
            // Use the adjustable feltHeightOffset from the slider
            // The calculated value would be: tabletopY + tableTopThickness - trayDepthInset + 0.02 â‰ˆ 1.01
            group.feltSurfaceY = feltHeightOffset;

            console.log('[FARKLE] Created table with feltSurfaceY:', group.feltSurfaceY);

            // No offset - table feet are at y=0, everything builds up from there
            return group;
        }

        // Start Farkle table placement mode
        window.startFarklePlacement = function() {
            farklePlaceMode = true;
            farkleRotationY = 0;

            // Create preview
            farklePreview = createDiceBoxMesh(true);
            scene.add(farklePreview);

            // Hide main UI, show Farkle panel
            document.getElementById('info').style.display = 'none';
            document.getElementById('farklePanel').style.display = 'block';

            // Request pointer lock
            renderer.domElement.requestPointerLock();

            // Update mode indicator
            document.getElementById('modeIndicator').textContent = 'FARKLE PLACEMENT - WASD move, Q/E fly up/down, Click to place';
            document.getElementById('modeIndicator').style.background = 'rgba(100,60,20,0.8)';
            document.getElementById('modeIndicator').style.color = '#db8';

            console.log('[FARKLE] Entered placement mode');
        };

        // Update Farkle preview position
        function updateFarklePreviewPosition() {
            if (!farklePreview) return;

            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            for (const hit of intersects) {
                // Skip preview, player, etc.
                if (hit.object === farklePreview || hit.object.parent === farklePreview) continue;
                if (hit.object === playerBody) continue;
                if (hit.object === collisionBox) continue;

                farkleBasePosition.copy(hit.point);
                farklePreview.position.copy(farkleBasePosition);
                farklePreview.rotation.y = farkleRotationY * Math.PI / 180;
                return;
            }

            // If no hit, place in front of camera
            const forward = new THREE.Vector3(0, 0, -3);
            forward.applyQuaternion(camera.quaternion);
            farkleBasePosition.copy(camera.position).add(forward);
            farklePreview.position.copy(farkleBasePosition);
            farklePreview.rotation.y = farkleRotationY * Math.PI / 180;
        }

        // Confirm Farkle table placement - enters camera setting mode
        window.confirmFarklePlacement = function() {
            if (!farklePreview) return;

            // Create final mesh (not preview)
            const finalMesh = createDiceBoxMesh(false);
            finalMesh.position.copy(farkleBasePosition);
            finalMesh.rotation.y = farkleRotationY * Math.PI / 180;
            scene.add(finalMesh);

            // Store as pending table (needs camera position)
            pendingFarkleTable = {
                mesh: finalMesh,
                position: farkleBasePosition.clone(),
                rotation: farkleRotationY,
                cameraPos: null,
                cameraRot: null
            };

            // Remove preview
            scene.remove(farklePreview);
            farklePreview = null;

            // Enter camera setting mode
            farklePlaceMode = false;
            farkleCameraMode = true;

            // Update UI
            document.getElementById('farklePanel').style.display = 'none';
            document.getElementById('farkleCameraPanel').style.display = 'block';
            document.getElementById('modeIndicator').textContent = 'FARKLE CAMERA - WASD move, Q/E height, click to set';
            document.getElementById('modeIndicator').style.color = '#8cf';

            // Keep pointer lock for camera control
            renderer.domElement.requestPointerLock();

            console.log('[FARKLE] Table placed, now set camera position');
        };

        // Set camera position for Farkle table - then enter UI rotation mode
        window.setFarkleCameraPosition = function() {
            if (!pendingFarkleTable) return;

            // Save current camera position/rotation for this table
            pendingFarkleTable.cameraPos = camera.position.clone();
            pendingFarkleTable.cameraRot = camera.rotation.clone();

            // Store config values that were used when creating this table
            pendingFarkleTable.config = {
                legHeight: tableLegHeight,
                feltHeight: feltHeightOffset,
                feltColor: feltColor,
                feltEmissive: feltEmissive
            };

            // Exit camera mode, enter UI rotation mode
            farkleCameraMode = false;
            farkleUIRotateMode = true;
            farkleUIRotation = 0;

            // Show UI rotation panel
            document.getElementById('farkleCameraPanel').style.display = 'none';
            document.getElementById('farkleUIRotatePanel').style.display = 'block';
            document.getElementById('uiRotationSlider').value = 0;
            document.getElementById('uiRotationVal').textContent = '0';
            document.getElementById('modeIndicator').textContent = 'Adjust UI orientation - use slider or buttons';
            document.getElementById('modeIndicator').style.color = '#a8f';

            // Create preview UI on table
            createUIPreview();

            console.log('[FARKLE] Camera set, now adjust UI rotation');
        };

        // Create preview UI on the table
        function createUIPreview() {
            clearUIPreview();

            if (!pendingFarkleTable) return;

            const table = pendingFarkleTable;
            const tablePos = table.position;
            const tableRotY = table.rotation * Math.PI / 180;
            const uiRotY = farkleUIRotation * Math.PI / 180;
            const totalRotY = tableRotY + uiRotY;
            const feltY = table.mesh.feltSurfaceY || 1.0;
            const uiY = tablePos.y + feltY + 0.01;

            // Player score - P1
            const p1Mesh = createScoreDisplay('P1', 0, '#44ff88');
            const p1Offset = new THREE.Vector3(-0.9, 0, 0.7);
            p1Offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), totalRotY);
            p1Mesh.position.set(tablePos.x + p1Offset.x, uiY, tablePos.z + p1Offset.z);
            p1Mesh.rotation.x = -Math.PI / 2;
            p1Mesh.rotation.z = -totalRotY;
            scene.add(p1Mesh);
            farkleUIPreview.push(p1Mesh);

            // P2/NPC score
            const p2Mesh = createScoreDisplay('P2', 0, '#ff6666');
            const p2Offset = new THREE.Vector3(0.9, 0, 0.7);
            p2Offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), totalRotY);
            p2Mesh.position.set(tablePos.x + p2Offset.x, uiY, tablePos.z + p2Offset.z);
            p2Mesh.rotation.x = -Math.PI / 2;
            p2Mesh.rotation.z = -totalRotY;
            scene.add(p2Mesh);
            farkleUIPreview.push(p2Mesh);

            // Turn score
            const turnMesh = createScoreDisplay('TURN', 0, '#ffcc44');
            turnMesh.scale.set(0.8, 0.8, 0.8);
            const turnOffset = new THREE.Vector3(0, 0, 0.85);
            turnOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), totalRotY);
            turnMesh.position.set(tablePos.x + turnOffset.x, uiY, tablePos.z + turnOffset.z);
            turnMesh.rotation.x = -Math.PI / 2;
            turnMesh.rotation.z = -totalRotY;
            scene.add(turnMesh);
            farkleUIPreview.push(turnMesh);

            // Message
            const msgMesh = createMessageDisplay('Press R to roll', 1.2, 0.15);
            const msgOffset = new THREE.Vector3(0, 0, -0.75);
            msgOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), totalRotY);
            msgMesh.position.set(tablePos.x + msgOffset.x, uiY, tablePos.z + msgOffset.z);
            msgMesh.rotation.x = -Math.PI / 2;
            msgMesh.rotation.z = -totalRotY;
            scene.add(msgMesh);
            farkleUIPreview.push(msgMesh);

            console.log('[FARKLE] UI preview created with rotation:', farkleUIRotation);
        }

        // Clear UI preview meshes
        function clearUIPreview() {
            for (const mesh of farkleUIPreview) {
                scene.remove(mesh);
            }
            farkleUIPreview = [];
        }

        // Set UI rotation from buttons or slider
        window.setUIRotation = function(degrees) {
            farkleUIRotation = degrees;
            document.getElementById('uiRotationSlider').value = degrees;
            document.getElementById('uiRotationVal').textContent = degrees;
            createUIPreview();
        };

        // Confirm UI rotation and finalize table
        window.confirmUIRotation = function() {
            if (!pendingFarkleTable) return;

            // Save UI rotation to table
            pendingFarkleTable.uiRotation = farkleUIRotation;

            // Add to tables array
            farkleTables.push(pendingFarkleTable);
            const tableIndex = farkleTables.length;

            // Generate and copy table info
            copyFarkleTableInfo(pendingFarkleTable, tableIndex);

            // Clear preview
            clearUIPreview();
            pendingFarkleTable = null;

            // Update counter
            document.getElementById('farkleTableCount').textContent = farkleTables.length;

            // Exit UI rotation mode
            farkleUIRotateMode = false;

            // Show main UI
            document.getElementById('farkleUIRotatePanel').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('modeIndicator').textContent = 'Click to enable mouse look';
            document.getElementById('modeIndicator').style.color = '#4af';
            document.exitPointerLock();

            console.log('[FARKLE] Table #' + tableIndex + ' placed with UI rotation:', farkleUIRotation);
        };

        // Cancel UI rotation (removes the pending table)
        window.cancelUIRotation = function() {
            clearUIPreview();

            if (pendingFarkleTable) {
                scene.remove(pendingFarkleTable.mesh);
                pendingFarkleTable = null;
            }

            farkleUIRotateMode = false;

            document.getElementById('farkleUIRotatePanel').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('modeIndicator').textContent = 'Click to enable mouse look';
            document.getElementById('modeIndicator').style.color = '#4af';
            document.exitPointerLock();

            console.log('[FARKLE] UI rotation cancelled');
        };

        // Copy Farkle table info to clipboard
        function copyFarkleTableInfo(table, index) {
            const pos = table.position;
            const camPos = table.cameraPos;
            const camRot = table.cameraRot;
            const feltY = table.mesh.feltSurfaceY || 1.0;
            const config = table.config || {};

            const tableData = {
                // Table placement
                position: { x: pos.x, y: pos.y, z: pos.z },
                rotation: table.rotation,
                // Camera view when playing
                cameraPos: { x: camPos.x, y: camPos.y, z: camPos.z },
                cameraRot: { x: camRot.x, y: camRot.y, z: camRot.z },
                // Table config
                feltSurfaceY: feltY,
                legHeight: config.legHeight || 0.95,
                feltColor: '0x' + (config.feltColor || 0x22DD44).toString(16).padStart(6, '0'),
                feltEmissive: config.feltEmissive || 0.8
            };

            const uiRot = table.uiRotation || 0;

            // Format as JavaScript code for easy copy-paste
            const jsCode = `// Farkle Table #${index}
{
    position: new THREE.Vector3(${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)}),
    rotation: ${table.rotation},
    uiRotation: ${uiRot},
    cameraPos: new THREE.Vector3(${camPos.x.toFixed(3)}, ${camPos.y.toFixed(3)}, ${camPos.z.toFixed(3)}),
    cameraRot: new THREE.Euler(${camRot.x.toFixed(4)}, ${camRot.y.toFixed(4)}, ${camRot.z.toFixed(4)}),
    feltSurfaceY: ${feltY.toFixed(3)},
    config: {
        legHeight: ${(config.legHeight || 0.95).toFixed(2)},
        feltColor: 0x${(config.feltColor || 0x22DD44).toString(16).padStart(6, '0')},
        feltEmissive: ${(config.feltEmissive || 0.8).toFixed(1)}
    }
}`;

            // Copy to clipboard
            navigator.clipboard.writeText(jsCode).then(() => {
                console.log('[FARKLE] Table info copied to clipboard');
            }).catch(err => {
                console.error('[FARKLE] Failed to copy:', err);
            });

            // Show panel with the data
            document.getElementById('tableInfoOutput').value = jsCode;
            document.getElementById('copyTablePanel').style.display = 'block';
        }

        // Close copy table panel
        window.closeCopyTablePanel = function() {
            document.getElementById('copyTablePanel').style.display = 'none';
        };

        // Copy all Farkle tables info
        window.copyAllFarkleTables = function() {
            if (farkleTables.length === 0) {
                alert('No Farkle tables placed yet!');
                return;
            }

            let allTablesCode = '// Farkle Tables Data - Add to game initialization\nconst savedFarkleTables = [\n';

            for (let i = 0; i < farkleTables.length; i++) {
                const table = farkleTables[i];
                const pos = table.position;
                const camPos = table.cameraPos;
                const camRot = table.cameraRot;
                const feltY = table.mesh.feltSurfaceY || 1.0;
                const config = table.config || {};
                const uiRot = table.uiRotation || 0;

                allTablesCode += `    { // Table #${i + 1}
        position: new THREE.Vector3(${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)}),
        rotation: ${table.rotation},
        uiRotation: ${uiRot},
        cameraPos: new THREE.Vector3(${camPos.x.toFixed(3)}, ${camPos.y.toFixed(3)}, ${camPos.z.toFixed(3)}),
        cameraRot: new THREE.Euler(${camRot.x.toFixed(4)}, ${camRot.y.toFixed(4)}, ${camRot.z.toFixed(4)}),
        feltSurfaceY: ${feltY.toFixed(3)},
        config: {
            legHeight: ${(config.legHeight || 0.95).toFixed(2)},
            feltColor: 0x${(config.feltColor || 0x22DD44).toString(16).padStart(6, '0')},
            feltEmissive: ${(config.feltEmissive || 0.8).toFixed(1)}
        }
    }${i < farkleTables.length - 1 ? ',' : ''}\n`;
            }

            allTablesCode += '];';

            // Copy to clipboard
            navigator.clipboard.writeText(allTablesCode).then(() => {
                console.log('[FARKLE] All tables info copied to clipboard');
            }).catch(err => {
                console.error('[FARKLE] Failed to copy:', err);
            });

            // Show panel with the data
            document.getElementById('tableInfoOutput').value = allTablesCode;
            document.getElementById('copyTablePanel').style.display = 'block';
        };

        // Cancel camera setting (removes the pending table)
        window.cancelFarkleCamera = function() {
            if (pendingFarkleTable) {
                scene.remove(pendingFarkleTable.mesh);
                pendingFarkleTable = null;
            }

            farkleCameraMode = false;

            document.getElementById('farkleCameraPanel').style.display = 'none';
            document.getElementById('info').style.display = 'block';
            document.getElementById('modeIndicator').textContent = 'Click to enable mouse look';
            document.getElementById('modeIndicator').style.color = '#4af';
            document.exitPointerLock();

            console.log('[FARKLE] Camera setting cancelled');
        };

        // Exit Farkle placement mode
        window.exitFarklePlacement = function() {
            farklePlaceMode = false;

            // Remove preview
            if (farklePreview) {
                scene.remove(farklePreview);
                farklePreview = null;
            }

            // Show main UI, hide panel
            document.getElementById('farklePanel').style.display = 'none';
            document.getElementById('info').style.display = 'block';

            // Reset mode indicator
            document.getElementById('modeIndicator').textContent = 'Click to enable mouse look';
            document.getElementById('modeIndicator').style.background = 'rgba(0,0,0,0.7)';
            document.getElementById('modeIndicator').style.color = '#4af';

            document.exitPointerLock();

            console.log('[FARKLE] Exited placement mode');
        };

        // Farkle rotation slider
        document.getElementById('farkleRotationSlider').addEventListener('input', (e) => {
            farkleRotationY = parseFloat(e.target.value);
            document.getElementById('farkleRotationVal').textContent = farkleRotationY;
        });

        // Leg height slider
        document.getElementById('legHeightSlider').addEventListener('input', (e) => {
            tableLegHeight = parseFloat(e.target.value);
            document.getElementById('legHeightVal').textContent = tableLegHeight.toFixed(2);
            // Auto-update felt height to match table top
            feltHeightOffset = tableLegHeight + 0.12; // legHeight + tableTopThickness + felt offset
            document.getElementById('feltHeightSlider').value = feltHeightOffset;
            document.getElementById('feltHeightVal').textContent = feltHeightOffset.toFixed(2);
            // Update preview table if it exists
            if (farklePreview) {
                scene.remove(farklePreview);
                farklePreview = createDiceBoxMesh(true);
                farklePreview.position.copy(farkleBasePosition);
                farklePreview.rotation.y = farkleRotationY * Math.PI / 180;
                scene.add(farklePreview);
            }
        });

        // Felt height slider
        document.getElementById('feltHeightSlider').addEventListener('input', (e) => {
            feltHeightOffset = parseFloat(e.target.value);
            document.getElementById('feltHeightVal').textContent = feltHeightOffset.toFixed(2);
            // Update preview table if it exists
            if (farklePreview) {
                scene.remove(farklePreview);
                farklePreview = createDiceBoxMesh(true);
                farklePreview.position.copy(farkleBasePosition);
                farklePreview.rotation.y = farkleRotationY * Math.PI / 180;
                scene.add(farklePreview);
            }
        });

        // Felt color picker
        document.getElementById('feltColorPicker').addEventListener('input', (e) => {
            const hexColor = e.target.value;
            document.getElementById('feltColorVal').textContent = hexColor;
            feltColor = parseInt(hexColor.replace('#', ''), 16);
            // Update preview table if it exists
            if (farklePreview) {
                scene.remove(farklePreview);
                farklePreview = createDiceBoxMesh(true);
                farklePreview.position.copy(farkleBasePosition);
                farklePreview.rotation.y = farkleRotationY * Math.PI / 180;
                scene.add(farklePreview);
            }
        });

        // Felt emissive slider
        document.getElementById('feltEmissiveSlider').addEventListener('input', (e) => {
            feltEmissive = parseFloat(e.target.value);
            document.getElementById('feltEmissiveVal').textContent = feltEmissive.toFixed(1);
            // Update preview table if it exists
            if (farklePreview) {
                scene.remove(farklePreview);
                farklePreview = createDiceBoxMesh(true);
                farklePreview.position.copy(farkleBasePosition);
                farklePreview.rotation.y = farkleRotationY * Math.PI / 180;
                scene.add(farklePreview);
            }
        });

        // UI rotation slider
        document.getElementById('uiRotationSlider').addEventListener('input', (e) => {
            farkleUIRotation = parseInt(e.target.value);
            document.getElementById('uiRotationVal').textContent = farkleUIRotation;
            // Update preview UI
            if (farkleUIRotateMode) {
                createUIPreview();
            }
        });

        // ============================================
        // FARKLE DICE GAME
        // ============================================

        let activeFarkleTable = null; // Currently active table for playing
        // Note: savedCameraPos already declared earlier, reusing it
        let savedCameraRotFarkle = new THREE.Euler();

        // Create a canvas texture for die face with pips
        function createDieFaceTexture(value) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // White background
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, 128, 128);

            // Black pips
            ctx.fillStyle = '#111';
            const pipRadius = 10;

            const pipPositions = {
                1: [[64, 64]],
                2: [[32, 32], [96, 96]],
                3: [[32, 32], [64, 64], [96, 96]],
                4: [[32, 32], [96, 32], [32, 96], [96, 96]],
                5: [[32, 32], [96, 32], [64, 64], [32, 96], [96, 96]],
                6: [[32, 32], [96, 32], [32, 64], [96, 64], [32, 96], [96, 96]]
            };

            for (const [x, y] of pipPositions[value]) {
                ctx.beginPath();
                ctx.arc(x, y, pipRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // Create die mesh with proper face textures
        function createDieMesh(size = 0.05) {
            // Die faces order for BoxGeometry: +X, -X, +Y, -Y, +Z, -Z
            // Standard die: opposite faces sum to 7
            // We map: +X=1, -X=6, +Y=2, -Y=5, +Z=3, -Z=4
            const materials = [
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(1) }), // +X: 1
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(6) }), // -X: 6
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(2) }), // +Y: 2
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(5) }), // -Y: 5
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(3) }), // +Z: 3
                new THREE.MeshStandardMaterial({ map: createDieFaceTexture(4) })  // -Z: 4
            ];

            const geometry = new THREE.BoxGeometry(size, size, size);
            const mesh = new THREE.Mesh(geometry, materials);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        // Create die physics body
        function createDieBody(size = 0.05) {
            const halfSize = size / 2;
            const body = new CANNON.Body({
                mass: 0.1,
                shape: new CANNON.Box(new CANNON.Vec3(halfSize, halfSize, halfSize)),
                material: diceMaterial
            });
            body.linearDamping = 0.3;
            body.angularDamping = 0.3;
            return body;
        }

        // Create a complete die (mesh + physics)
        function createDie(position, size = 0.05) {
            const mesh = createDieMesh(size);
            mesh.position.copy(position);
            scene.add(mesh);

            const body = createDieBody(size);
            body.position.set(position.x, position.y, position.z);
            physicsWorld.addBody(body);

            return { mesh, body, value: 0, kept: false };
        }

        // Setup physics bodies for dice tray (floor + walls) - 2x size
        function setupDiceTrayPhysics(table) {
            const pos = table.position;
            const rotY = table.rotation * Math.PI / 180;
            // Get the felt surface height from the table mesh
            const feltY = table.mesh.feltSurfaceY || 1.0;

            console.log('[FARKLE] Setting up physics at pos:', pos, 'feltY:', feltY);

            // Clear old physics bodies
            for (const body of farklePhysicsBodies) {
                physicsWorld.removeBody(body);
            }
            farklePhysicsBodies = [];

            // Tray floor - 3m x 2.1m (half extents: 1.5, 0.05, 1.05)
            // Position at feltY above table base position
            const floorBody = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(1.5, 0.05, 1.05)),
                material: tableMaterial
            });
            floorBody.position.set(pos.x, pos.y + feltY, pos.z);
            floorBody.quaternion.setFromEuler(0, rotY, 0);
            physicsWorld.addBody(floorBody);
            farklePhysicsBodies.push(floorBody);

            console.log('[FARKLE] Physics floor at Y:', pos.y + feltY);

            // Walls (4 sides)
            const wallHeight = 0.35;
            const wallThickness = 0.08;

            // Front wall
            const frontWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(1.5, wallHeight / 2, wallThickness)),
                material: tableMaterial
            });
            const frontOffset = new THREE.Vector3(0, wallHeight / 2, 1.05 - wallThickness);
            frontOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);
            frontWall.position.set(pos.x + frontOffset.x, pos.y + feltY + frontOffset.y, pos.z + frontOffset.z);
            frontWall.quaternion.setFromEuler(0, rotY, 0);
            physicsWorld.addBody(frontWall);
            farklePhysicsBodies.push(frontWall);

            // Back wall
            const backWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(1.5, wallHeight / 2, wallThickness)),
                material: tableMaterial
            });
            const backOffset = new THREE.Vector3(0, wallHeight / 2, -1.05 + wallThickness);
            backOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);
            backWall.position.set(pos.x + backOffset.x, pos.y + feltY + backOffset.y, pos.z + backOffset.z);
            backWall.quaternion.setFromEuler(0, rotY, 0);
            physicsWorld.addBody(backWall);
            farklePhysicsBodies.push(backWall);

            // Left wall
            const leftWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(wallThickness, wallHeight / 2, 1.05)),
                material: tableMaterial
            });
            const leftOffset = new THREE.Vector3(-1.5 + wallThickness, wallHeight / 2, 0);
            leftOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);
            leftWall.position.set(pos.x + leftOffset.x, pos.y + feltY + leftOffset.y, pos.z + leftOffset.z);
            leftWall.quaternion.setFromEuler(0, rotY, 0);
            physicsWorld.addBody(leftWall);
            farklePhysicsBodies.push(leftWall);

            // Right wall
            const rightWall = new CANNON.Body({
                mass: 0,
                shape: new CANNON.Box(new CANNON.Vec3(wallThickness, wallHeight / 2, 1.05)),
                material: tableMaterial
            });
            const rightOffset = new THREE.Vector3(1.5 - wallThickness, wallHeight / 2, 0);
            rightOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);
            rightWall.position.set(pos.x + rightOffset.x, pos.y + feltY + rightOffset.y, pos.z + rightOffset.z);
            rightWall.quaternion.setFromEuler(0, rotY, 0);
            physicsWorld.addBody(rightWall);
            farklePhysicsBodies.push(rightWall);
        }

        // ============================================
        // 3D IN-WORLD FARKLE UI (on table surface)
        // ============================================

        let farkle3DUI = []; // Store 3D UI meshes for cleanup

        // Create a canvas texture for score display
        function createScoreTexture(label, score, color, bgColor = 'rgba(20,15,10,0.9)') {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, 256, 128);

            // Border
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.strokeRect(4, 4, 248, 120);

            // Label
            ctx.fillStyle = '#888';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(label, 128, 40);

            // Score
            ctx.fillStyle = color;
            ctx.font = 'bold 56px monospace';
            ctx.fillText(score.toString(), 128, 100);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return { canvas, ctx, texture };
        }

        // Create a score display mesh for the table
        function createScoreDisplay(label, score, color, width = 0.5, height = 0.25) {
            const texData = createScoreTexture(label, score, color);

            const material = new THREE.MeshBasicMaterial({
                map: texData.texture,
                transparent: true,
                side: THREE.DoubleSide
            });

            const geometry = new THREE.PlaneGeometry(width, height);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData = { label, color, texData };

            return mesh;
        }

        // Update a score display
        function updateScoreDisplay(mesh, newScore) {
            if (!mesh || !mesh.userData.texData) return;

            const { canvas, ctx, texture } = mesh.userData.texData;
            const { label, color } = mesh.userData;

            // Clear and redraw
            ctx.fillStyle = 'rgba(20,15,10,0.9)';
            ctx.fillRect(0, 0, 256, 128);

            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.strokeRect(4, 4, 248, 120);

            ctx.fillStyle = '#888';
            ctx.font = 'bold 24px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(label, 128, 40);

            ctx.fillStyle = color;
            ctx.font = 'bold 56px monospace';
            ctx.fillText(newScore.toString(), 128, 100);

            texture.needsUpdate = true;
        }

        // Create message display texture
        function createMessageTexture(text, color = '#ffaa77') {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Clear and fill background
            ctx.clearRect(0, 0, 512, 64);
            ctx.fillStyle = 'rgba(10,8,5,0.92)';
            ctx.fillRect(0, 0, 512, 64);

            // Text
            ctx.fillStyle = color;
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 32);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return { canvas, ctx, texture };
        }

        // Create message display mesh
        function createMessageDisplay(text, width = 1.0, height = 0.12) {
            const texData = createMessageTexture(text);

            const material = new THREE.MeshBasicMaterial({
                map: texData.texture,
                transparent: true,
                side: THREE.DoubleSide
            });

            const geometry = new THREE.PlaneGeometry(width, height);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.userData = { texData };

            return mesh;
        }

        // Update message display
        function updateMessageDisplay(mesh, text, color = '#ffaa77') {
            if (!mesh || !mesh.userData.texData) return;

            const { canvas, ctx, texture } = mesh.userData.texData;

            // Clear canvas completely before drawing new text
            ctx.clearRect(0, 0, 512, 64);
            ctx.fillStyle = 'rgba(10,8,5,0.92)';
            ctx.fillRect(0, 0, 512, 64);

            ctx.fillStyle = color;
            ctx.font = 'bold 28px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 32);

            texture.needsUpdate = true;
        }

        // 3D UI mesh references
        let playerScoreMesh = null;
        let npcScoreMesh = null;
        let turnScoreMesh = null;
        let messageMesh = null;
        let turnIndicatorMesh = null;

        // Setup 3D UI on table
        function setup3DFarkleUI(table) {
            const tablePos = table.position;
            const tableRotY = table.rotation * Math.PI / 180;
            const uiRotY = (table.uiRotation || 0) * Math.PI / 180;
            const totalRotY = tableRotY + uiRotY; // Combined rotation for UI
            const feltY = table.mesh.feltSurfaceY || 1.0;

            // Height just above felt surface
            const uiY = tablePos.y + feltY + 0.01;

            // Player score - front left of table (near player)
            const playerLabel = farkleGameMode === '2player' ? 'P1' : 'YOU';
            playerScoreMesh = createScoreDisplay(playerLabel, 0, '#44ff88');
            const playerOffset = new THREE.Vector3(-0.9, 0, 0.7);
            playerOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), totalRotY);
            playerScoreMesh.position.set(tablePos.x + playerOffset.x, uiY, tablePos.z + playerOffset.z);
            playerScoreMesh.rotation.x = -Math.PI / 2;
            playerScoreMesh.rotation.z = -totalRotY;
            scene.add(playerScoreMesh);
            farkle3DUI.push(playerScoreMesh);

            // NPC/P2 score - front right of table
            const opponentLabel = farkleGameMode === '2player' ? 'P2' : 'NPC';
            npcScoreMesh = createScoreDisplay(opponentLabel, 0, '#ff6666');
            const npcOffset = new THREE.Vector3(0.9, 0, 0.7);
            npcOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), totalRotY);
            npcScoreMesh.position.set(tablePos.x + npcOffset.x, uiY, tablePos.z + npcOffset.z);
            npcScoreMesh.rotation.x = -Math.PI / 2;
            npcScoreMesh.rotation.z = -totalRotY;
            scene.add(npcScoreMesh);
            farkle3DUI.push(npcScoreMesh);

            // Turn score - center near player
            turnScoreMesh = createScoreDisplay('TURN', 0, '#ffcc44');
            turnScoreMesh.scale.set(0.8, 0.8, 0.8);
            const turnOffset = new THREE.Vector3(0, 0, 0.85);
            turnOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), totalRotY);
            turnScoreMesh.position.set(tablePos.x + turnOffset.x, uiY, tablePos.z + turnOffset.z);
            turnScoreMesh.rotation.x = -Math.PI / 2;
            turnScoreMesh.rotation.z = -totalRotY;
            scene.add(turnScoreMesh);
            farkle3DUI.push(turnScoreMesh);

            // Message display - back of table (far from player)
            messageMesh = createMessageDisplay('Press R to roll', 1.2, 0.15);
            const msgOffset = new THREE.Vector3(0, 0, -0.75);
            msgOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), totalRotY);
            messageMesh.position.set(tablePos.x + msgOffset.x, uiY, tablePos.z + msgOffset.z);
            messageMesh.rotation.x = -Math.PI / 2;
            messageMesh.rotation.z = -totalRotY;
            scene.add(messageMesh);
            farkle3DUI.push(messageMesh);

            // Turn indicator - back corner
            turnIndicatorMesh = createMessageDisplay('Your turn', 0.6, 0.1);
            const indicatorOffset = new THREE.Vector3(0, 0, -0.55);
            indicatorOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), totalRotY);
            turnIndicatorMesh.position.set(tablePos.x + indicatorOffset.x, uiY + 0.005, tablePos.z + indicatorOffset.z);
            turnIndicatorMesh.rotation.x = -Math.PI / 2;
            turnIndicatorMesh.rotation.z = -totalRotY;
            scene.add(turnIndicatorMesh);
            farkle3DUI.push(turnIndicatorMesh);

            console.log('[FARKLE] 3D UI created on table');
        }

        // Remove 3D UI
        function cleanup3DFarkleUI() {
            for (const mesh of farkle3DUI) {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) {
                    if (mesh.material.map) mesh.material.map.dispose();
                    mesh.material.dispose();
                }
            }
            farkle3DUI = [];
            playerScoreMesh = null;
            npcScoreMesh = null;
            turnScoreMesh = null;
            messageMesh = null;
            turnIndicatorMesh = null;
            console.log('[FARKLE] 3D UI cleaned up');
        }

        // Update 3D scores (call this instead of DOM updates)
        function update3DScores() {
            if (playerScoreMesh) updateScoreDisplay(playerScoreMesh, farkleTotalScore);
            if (npcScoreMesh) updateScoreDisplay(npcScoreMesh, farkleNPCScore);
            if (turnScoreMesh) updateScoreDisplay(turnScoreMesh, farkleTurnScore);
        }

        // Update 3D message
        function update3DMessage(text, color = '#ffaa77') {
            if (messageMesh) updateMessageDisplay(messageMesh, text, color);
        }

        // Update 3D turn indicator
        function update3DTurnIndicator(text, color = '#ffaa77') {
            if (turnIndicatorMesh) updateMessageDisplay(turnIndicatorMesh, text, color);
        }

        // Mode selection functions
        window.startFarkleWithMode = function(mode) {
            farkleGameMode = mode;
            document.getElementById('farkleModeSelect').style.display = 'none';
            if (pendingFarkleTableForMode) {
                startFarkleGame(pendingFarkleTableForMode);
                pendingFarkleTableForMode = null;
            }
        };

        window.closeFarkleModeSelect = function() {
            document.getElementById('farkleModeSelect').style.display = 'none';
            pendingFarkleTableForMode = null;
        };

        // Start playing Farkle at a table
        window.startFarkleGame = function(table) {
            if (farkleGameActive) return;

            activeFarkleTable = table;
            farkleGameActive = true;

            // Hide player hands during Farkle game
            if (fpsHands) fpsHands.visible = false;

            // Save camera state
            savedCameraPos.copy(camera.position);
            savedCameraRotFarkle.copy(camera.rotation);

            // Setup physics for this table
            setupDiceTrayPhysics(table);

            // Table position for dice spawning
            const tablePos = table.position;

            // Move camera to the saved position for this table
            if (table.cameraPos && table.cameraRot) {
                camera.position.copy(table.cameraPos);
                camera.rotation.copy(table.cameraRot);
            } else {
                // Fallback: calculate position (for old tables without saved camera)
                const rotY = table.rotation * Math.PI / 180;
                const seatOffset = new THREE.Vector3(0, 0.4, 0.6);
                seatOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);
                camera.position.set(tablePos.x + seatOffset.x, tablePos.y + seatOffset.y, tablePos.z + seatOffset.z);
                camera.lookAt(tablePos.x, tablePos.y + 0.05, tablePos.z);
            }

            // Keep pointer lock for looking around
            renderer.domElement.requestPointerLock();
            document.getElementById('farkleGameUI').style.display = 'block';
            document.getElementById('info').style.display = 'none';
            document.getElementById('modeIndicator').style.display = 'none';

            // Setup 3D UI on the table surface
            setup3DFarkleUI(table);

            // Create 6 dice above the tray - use feltSurfaceY for correct height
            const feltY = table.mesh.feltSurfaceY || 1.0;
            farkleDice = [];
            const dieSize = 0.12; // Good size dice
            for (let i = 0; i < 6; i++) {
                const offsetX = (i % 3 - 1) * 0.45;  // Spread for table
                const offsetZ = (Math.floor(i / 3) - 0.5) * 0.45;
                const diePos = new THREE.Vector3(
                    tablePos.x + offsetX,
                    tablePos.y + feltY + 0.3, // Above the felt surface
                    tablePos.z + offsetZ
                );
                const die = createDie(diePos, dieSize);
                farkleDice.push(die);
            }

            console.log('[FARKLE] Created', farkleDice.length, 'dice at feltY:', feltY, 'spawn Y:', tablePos.y + feltY + 0.3);

            console.log('[FARKLE] Game started at table', table);
        };

        // Check if current player can act (handles both 1P vs NPC and 2P modes)
        function canCurrentPlayerAct() {
            if (!farkleGameActive || !activeFarkleTable) return false;
            if (npcTurnInProgress) return false; // NPC is playing
            // In 2-player mode, either player can act when it's their turn
            // In NPC mode, only P1 can act
            return isPlayerTurn || farkleGameMode === '2player';
        }

        // Roll the dice
        window.rollFarkleDice = function() {
            if (!canCurrentPlayerAct()) return;

            // If already rolled, check for valid roll conditions
            if (farkleRolled) {
                const keptCount = farkleDice.filter(d => d.kept).length;
                if (keptCount === 0) {
                    document.getElementById('farkleMessage').textContent = 'Keep at least one die before rolling again!';
                    return;
                }

                // HOT DICE: If all 6 dice are kept, reset them all for a fresh roll
                if (keptCount === 6) {
                    console.log('[FARKLE] HOT DICE! All 6 dice scored - rolling all again');
                    document.getElementById('farkleMessage').textContent = 'HOT DICE! Rolling all 6 again!';
                    update3DMessage('HOT DICE!', '#ffff00');
                    for (const die of farkleDice) {
                        die.kept = false;
                    }
                    updateDiceHighlights();
                }
            }

            const tablePos = activeFarkleTable.position;
            const rotY = activeFarkleTable.rotation * Math.PI / 180;
            const feltY = activeFarkleTable.mesh.feltSurfaceY || 1.0;

            let diceToRoll = 0;
            for (const die of farkleDice) {
                if (die.kept) continue; // Don't roll kept dice
                diceToRoll++;

                // Random offset within tray bounds
                const offsetX = (Math.random() - 0.5) * 1.0;
                const offsetZ = (Math.random() - 0.5) * 0.7;

                // Apply table rotation to offset
                const rotatedOffset = new THREE.Vector3(offsetX, 0, offsetZ);
                rotatedOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotY);

                // Reset position above tray - use feltY for correct height
                die.body.position.set(
                    tablePos.x + rotatedOffset.x,
                    tablePos.y + feltY + 0.35 + Math.random() * 0.15,
                    tablePos.z + rotatedOffset.z
                );

                // Apply random velocity and spin
                die.body.velocity.set(
                    (Math.random() - 0.5) * 2,
                    -3 - Math.random() * 2,
                    (Math.random() - 0.5) * 2
                );
                die.body.angularVelocity.set(
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20,
                    (Math.random() - 0.5) * 20
                );

                // Wake up the body
                die.body.wakeUp();
            }

            farkleRolled = true;
            diceSettled = false;
            rollStartTime = performance.now();
            lastSettleCheck = 0;
            document.getElementById('farkleMessage').textContent = 'Rolling...';
            update3DMessage('Rolling...', '#ffcc44');

            console.log('[FARKLE] Rolling', diceToRoll, 'dice');
        };

        let diceSettled = false;
        let farkleControlsVisible = false;

        // Toggle Farkle controls modal (Q key)
        window.toggleFarkleControls = function() {
            const modal = document.getElementById('farkleControlsModal');
            farkleControlsVisible = !farkleControlsVisible;
            modal.style.display = farkleControlsVisible ? 'block' : 'none';
        };

        // Exit Farkle game
        window.exitFarkleGame = function() {
            if (!farkleGameActive) return;

            // Remove dice
            for (const die of farkleDice) {
                scene.remove(die.mesh);
                physicsWorld.removeBody(die.body);
            }
            farkleDice = [];

            // Remove tray physics
            for (const body of farklePhysicsBodies) {
                physicsWorld.removeBody(body);
            }
            farklePhysicsBodies = [];

            // Remove 3D UI from table
            cleanup3DFarkleUI();

            // Restore camera
            camera.position.copy(savedCameraPos);
            camera.rotation.copy(savedCameraRotFarkle);

            // Show player hands again (if they were enabled)
            if (fpsHands && handsVisible) fpsHands.visible = true;

            farkleGameActive = false;
            activeFarkleTable = null;

            // Reset scores and game state
            farkleTurnScore = 0;
            farkleTotalScore = 0;
            farkleNPCScore = 0;
            farkleRolled = false;
            diceSettled = false;
            isPlayerTurn = true;
            npcTurnInProgress = false;
            document.getElementById('farkleTurnScore').textContent = '0';
            document.getElementById('farkleTotalScore').textContent = '0';
            document.getElementById('farkleNPCScore').textContent = '0';
            document.getElementById('farkleMessage').textContent = 'Press R to roll dice';
            document.getElementById('farkleMessage').style.color = '#ca7';
            document.getElementById('farkleTurnIndicator').textContent = 'Your turn';
            document.getElementById('farkleTurnIndicator').style.color = '#ffa';
            enableGameButtons();

            // Hide game UI and controls modal, show main UI only if uiVisible
            document.getElementById('farkleGameUI').style.display = 'none';
            document.getElementById('farkleControlsModal').style.display = 'none';
            farkleControlsVisible = false;
            document.getElementById('info').style.display = uiVisible ? 'block' : 'none';
            document.getElementById('modeIndicator').textContent = 'Click to enable mouse look';
            document.getElementById('modeIndicator').style.color = '#4af';
            document.getElementById('modeIndicator').style.display = uiVisible ? 'block' : 'none';

            console.log('[FARKLE] Game exited');
        };

        // Check if player is near a Farkle table
        function checkNearFarkleTable() {
            if (farkleGameActive || farklePlaceMode) return null;

            for (const table of farkleTables) {
                const dist = camera.position.distanceTo(table.position);
                if (dist < 5) { // Within 5 meters
                    return table;
                }
            }
            return null;
        }

        // Detect which face of a die is pointing up
        function getDieFaceValue(die) {
            // Get the die's up vector in world space
            const up = new THREE.Vector3(0, 1, 0);
            const dieUp = new THREE.Vector3();

            // Check each face axis to find which is most aligned with world up
            const axes = [
                { vec: new THREE.Vector3(1, 0, 0), value: 1 },  // +X = 1
                { vec: new THREE.Vector3(-1, 0, 0), value: 6 }, // -X = 6
                { vec: new THREE.Vector3(0, 1, 0), value: 2 },  // +Y = 2
                { vec: new THREE.Vector3(0, -1, 0), value: 5 }, // -Y = 5
                { vec: new THREE.Vector3(0, 0, 1), value: 3 },  // +Z = 3
                { vec: new THREE.Vector3(0, 0, -1), value: 4 }  // -Z = 4
            ];

            let bestDot = -2;
            let bestValue = 1;

            for (const axis of axes) {
                dieUp.copy(axis.vec).applyQuaternion(die.mesh.quaternion);
                const dot = dieUp.dot(up);
                if (dot > bestDot) {
                    bestDot = dot;
                    bestValue = axis.value;
                }
            }

            return bestValue;
        }

        // Check if all dice have stopped moving
        let rollStartTime = 0;
        let lastSettleCheck = 0;

        function diceHaveSettled() {
            const now = performance.now();

            // Log every 500ms while rolling
            if (now - lastSettleCheck > 500) {
                lastSettleCheck = now;
                const rollTime = ((now - rollStartTime) / 1000).toFixed(1);
                let maxVel = 0, maxAngVel = 0;
                for (const die of farkleDice) {
                    if (die.kept) continue;
                    const vel = die.body.velocity.length();
                    const angVel = die.body.angularVelocity.length();
                    if (vel > maxVel) maxVel = vel;
                    if (angVel > maxAngVel) maxAngVel = angVel;
                }
                console.log(`[FARKLE] Rolling ${rollTime}s - maxVel: ${maxVel.toFixed(3)}, maxAngVel: ${maxAngVel.toFixed(3)}`);

                // Force settle after 10 seconds
                if (now - rollStartTime > 10000) {
                    console.log('[FARKLE] Force settling after 10s timeout');
                    for (const die of farkleDice) {
                        die.body.velocity.set(0, 0, 0);
                        die.body.angularVelocity.set(0, 0, 0);
                        die.body.sleep();
                    }
                    return true;
                }
            }

            for (const die of farkleDice) {
                if (die.kept) continue;
                const vel = die.body.velocity.length();
                const angVel = die.body.angularVelocity.length();
                if (vel > 0.05 || angVel > 0.1) return false;
            }
            return true;
        }

        // Read all dice values once settled
        function readDiceValues() {
            for (const die of farkleDice) {
                die.value = getDieFaceValue(die);
            }
        }

        // Farkle scoring variables
        let farkleTurnScore = 0;
        let farkleTotalScore = 0;
        let farkleNPCScore = 0; // Also used for Player 2 score in 2-player mode
        let farkleRolled = false; // Has player rolled this turn?
        let selectedDieIndex = 0; // Currently highlighted die
        let isPlayerTurn = true; // Whose turn is it? (true = P1, false = P2/NPC)
        let npcTurnInProgress = false; // Is NPC currently taking their turn?
        let farkleGameMode = 'npc'; // 'npc' or '2player'
        let pendingFarkleTableForMode = null; // Table waiting for mode selection

        // Calculate score for current dice selection
        function calculateFarkleScore(diceValues) {
            // Count each value
            const counts = [0, 0, 0, 0, 0, 0, 0]; // indices 1-6
            for (const v of diceValues) {
                counts[v]++;
            }

            let score = 0;

            // Check for straight (1-2-3-4-5-6)
            if (counts[1] === 1 && counts[2] === 1 && counts[3] === 1 &&
                counts[4] === 1 && counts[5] === 1 && counts[6] === 1) {
                return 1500;
            }

            // Check for three pairs
            let pairs = 0;
            for (let i = 1; i <= 6; i++) {
                if (counts[i] === 2) pairs++;
            }
            if (pairs === 3) return 1500;

            // Score three/four/five/six of a kind
            for (let i = 1; i <= 6; i++) {
                if (counts[i] >= 3) {
                    let base = (i === 1) ? 1000 : i * 100;
                    if (counts[i] === 4) base *= 2;
                    if (counts[i] === 5) base *= 3;
                    if (counts[i] === 6) base *= 4;
                    score += base;
                    counts[i] -= Math.min(counts[i], 3); // Remove scored dice
                    if (counts[i] > 0) counts[i] = 0; // Clear remaining for this value
                }
            }

            // Score remaining 1s and 5s
            score += counts[1] * 100;
            score += counts[5] * 50;

            return score;
        }

        // Update turn score display based on kept dice
        function updateTurnScoreDisplay() {
            const keptValues = farkleDice.filter(d => d.kept).map(d => d.value);
            const potential = calculateFarkleScore(keptValues);
            document.getElementById('farkleTurnScore').textContent = potential;
            farkleTurnScore = potential;
        }

        // Update visual highlight on all dice
        // Update 2D dice display with pip values and highlights
        function update2DDiceUI() {
            const diceElements = document.querySelectorAll('.dice2d');

            // Pip positions for each value (as percentage)
            const pipLayouts = {
                1: [[50, 50]],
                2: [[25, 25], [75, 75]],
                3: [[25, 25], [50, 50], [75, 75]],
                4: [[25, 25], [75, 25], [25, 75], [75, 75]],
                5: [[25, 25], [75, 25], [50, 50], [25, 75], [75, 75]],
                6: [[25, 25], [75, 25], [25, 50], [75, 50], [25, 75], [75, 75]]
            };

            for (let i = 0; i < 6; i++) {
                const el = diceElements[i];
                if (!el) continue;

                // Clear previous pips
                el.innerHTML = '';

                // Get die info
                const die = farkleDice[i];
                const value = die ? die.value : 0;
                const isKept = die ? die.kept : false;
                const isSelected = (i === selectedDieIndex && farkleRolled && diceSettled);

                // Set border based on selection/kept status
                if (isKept) {
                    el.style.borderColor = '#ffaa00'; // Gold border for kept
                    el.style.boxShadow = '0 0 10px #ffaa00';
                } else if (isSelected) {
                    el.style.borderColor = '#00ffff'; // Cyan border for selected
                    el.style.boxShadow = '0 0 10px #00ffff';
                } else {
                    el.style.borderColor = '#444';
                    el.style.boxShadow = 'none';
                }

                // Draw pips if we have a value
                if (value >= 1 && value <= 6) {
                    const pips = pipLayouts[value];
                    for (const [x, y] of pips) {
                        const pip = document.createElement('div');
                        pip.style.cssText = `
                            position: absolute;
                            width: 10px;
                            height: 10px;
                            background: #222;
                            border-radius: 50%;
                            left: calc(${x}% - 5px);
                            top: calc(${y}% - 5px);
                        `;
                        el.appendChild(pip);
                    }
                }
            }
        }

        function updateDiceHighlights() {
            console.log('[FARKLE] Updating highlights, selectedDieIndex:', selectedDieIndex);
            for (let i = 0; i < farkleDice.length; i++) {
                const die = farkleDice[i];
                const isSelected = (i === selectedDieIndex);

                for (const mat of die.mesh.material) {
                    if (die.kept) {
                        // Kept dice glow bright yellow/gold
                        mat.emissive = new THREE.Color(0xffaa00);
                        mat.emissiveIntensity = 0.5;
                    } else if (isSelected) {
                        // Selected die glows bright cyan
                        mat.emissive = new THREE.Color(0x00ffff);
                        mat.emissiveIntensity = 0.5;
                    } else {
                        // Unselected dice no glow
                        mat.emissive = new THREE.Color(0x000000);
                        mat.emissiveIntensity = 0;
                    }
                }
            }
            // Update 2D display as well
            update2DDiceUI();
        }

        // Select next/previous die with A/D keys - skip kept dice
        function selectNextDie() {
            if (!farkleRolled || farkleDice.length === 0) return;
            // Find next un-kept die
            let attempts = 0;
            do {
                selectedDieIndex = (selectedDieIndex + 1) % farkleDice.length;
                attempts++;
            } while (farkleDice[selectedDieIndex].kept && attempts < farkleDice.length);
            updateDiceHighlights();
            updateSelectionMessage();
        }

        function selectPrevDie() {
            if (!farkleRolled || farkleDice.length === 0) return;
            // Find previous un-kept die
            let attempts = 0;
            do {
                selectedDieIndex = (selectedDieIndex - 1 + farkleDice.length) % farkleDice.length;
                attempts++;
            } while (farkleDice[selectedDieIndex].kept && attempts < farkleDice.length);
            updateDiceHighlights();
            updateSelectionMessage();
        }

        // Check if a die can be kept (contributes to scoring)
        // Key rule: scoring combinations must be achieved in a SINGLE throw
        function canKeepDie(die) {
            // 1s and 5s can always be kept (score individually)
            if (die.value === 1 || die.value === 5) return true;

            const unkeptDice = farkleDice.filter(d => !d.kept);
            const unkeptValues = unkeptDice.map(d => d.value);

            // Check for straight (1-2-3-4-5-6) in current roll
            if (unkeptValues.length === 6) {
                const sorted = [...unkeptValues].sort();
                if (sorted.join('') === '123456') return true;
            }

            // Check for three pairs in current roll
            if (unkeptValues.length === 6) {
                const counts = [0, 0, 0, 0, 0, 0, 0];
                for (const v of unkeptValues) counts[v]++;
                let pairs = 0;
                for (let i = 1; i <= 6; i++) {
                    if (counts[i] === 2) pairs++;
                }
                if (pairs === 3) return true;
            }

            // For 2, 3, 4, 6 - must have 3+ of same value in current roll
            const sameValueInRoll = unkeptValues.filter(v => v === die.value).length;
            return sameValueInRoll >= 3;
        }

        // Toggle keep on currently selected die
        function toggleSelectedDieKept() {
            if (!farkleRolled || farkleDice.length === 0) return;
            const die = farkleDice[selectedDieIndex];

            // If trying to keep, validate it's a scoring die
            if (!die.kept && !canKeepDie(die)) {
                document.getElementById('farkleMessage').textContent = 'That die doesn\'t score! Only 1s, 5s, or sets of 3+';
                update3DMessage('Not a scoring die!', '#ff6666');
                return;
            }

            die.kept = !die.kept;
            updateDiceHighlights();
            readDiceValues();
            updateTurnScoreDisplay();
            updateSelectionMessage();
        }

        // Update message - simplified since we have 2D dice UI now
        function updateSelectionMessage() {
            if (!farkleRolled || farkleDice.length === 0) return;
            const keptCount = farkleDice.filter(d => d.kept).length;
            if (keptCount > 0) {
                document.getElementById('farkleMessage').textContent = `${keptCount} dice kept - R to roll again, B to bank`;
                update3DMessage(keptCount + ' kept - R roll, B bank', '#ffcc44');
            } else {
                document.getElementById('farkleMessage').textContent = 'Select dice to keep (Space), then roll again (R)';
                update3DMessage('Keep dice (Space)', '#ffaa77');
            }
        }

        // Toggle die kept status (legacy click method)
        function toggleDieKept(die) {
            if (!farkleRolled) return; // Can't keep dice before rolling

            // If trying to keep, validate it's a scoring die
            if (!die.kept && !canKeepDie(die)) {
                document.getElementById('farkleMessage').textContent = 'That die doesn\'t score! Only 1s, 5s, or sets of 3+';
                update3DMessage('Not a scoring die!', '#ff6666');
                return;
            }

            die.kept = !die.kept;
            updateDiceHighlights();

            // Update score display
            readDiceValues();
            updateTurnScoreDisplay();
        }

        // Bank current points
        window.bankFarklePoints = function() {
            if (!farkleGameActive || !farkleRolled) return;
            if (!canCurrentPlayerAct()) return;

            // Must have at least one kept die
            const keptCount = farkleDice.filter(d => d.kept).length;
            if (keptCount === 0) {
                document.getElementById('farkleMessage').textContent = 'Keep at least one scoring die!';
                update3DMessage('Keep at least one die!', '#ff6666');
                return;
            }

            // Determine which player is banking
            const isP1 = isPlayerTurn;
            const playerLabel = farkleGameMode === '2player' ? (isP1 ? 'P1' : 'P2') : 'YOU';

            // Add turn score to appropriate player
            if (isP1) {
                farkleTotalScore += farkleTurnScore;
                document.getElementById('farkleTotalScore').textContent = farkleTotalScore;
            } else {
                // Player 2 in 2-player mode
                farkleNPCScore += farkleTurnScore;
                document.getElementById('farkleNPCScore').textContent = farkleNPCScore;
            }
            document.getElementById('farkleMessage').textContent = playerLabel + ' banked ' + farkleTurnScore + ' points!';
            update3DScores();
            update3DMessage(playerLabel + ' banked ' + farkleTurnScore + '!', isP1 ? '#44ff88' : '#ff6666');

            // Reset turn state
            resetPlayerTurn();

            // Check for win
            const scoreToCheck = isP1 ? farkleTotalScore : farkleNPCScore;
            if (scoreToCheck >= 10000) {
                const winLabel = farkleGameMode === '2player' ? (isP1 ? 'P1' : 'P2') : 'YOU';
                document.getElementById('farkleMessage').textContent = winLabel + ' WINS! Final Score: ' + scoreToCheck;
                document.getElementById('farkleTurnIndicator').textContent = 'GAME OVER';
                document.getElementById('farkleTurnIndicator').style.color = '#4f8';
                update3DMessage(winLabel + ' WINS!', isP1 ? '#44ff88' : '#ff6666');
                update3DTurnIndicator('GAME OVER', '#44ff88');
                disableGameButtons();
                return;
            }

            // Switch turns
            if (isP1) {
                // P1 just banked, start NPC/P2 turn
                setTimeout(() => startNPCTurn(), 1500);
            } else {
                // P2 just banked in 2-player mode, switch back to P1
                setTimeout(() => startP1Turn(), 1500);
            }
        };

        // Pass turn without banking (keep current points, end turn)
        window.passFarkleTurn = function() {
            if (!farkleGameActive) return;
            if (!canCurrentPlayerAct()) return;

            // Determine which player is passing
            const isP1 = isPlayerTurn;
            const playerLabel = farkleGameMode === '2player' ? (isP1 ? 'P1' : 'P2') : 'YOU';

            // Bank any points accumulated this turn to appropriate player
            if (farkleTurnScore > 0) {
                if (isP1) {
                    farkleTotalScore += farkleTurnScore;
                    document.getElementById('farkleTotalScore').textContent = farkleTotalScore;
                } else {
                    farkleNPCScore += farkleTurnScore;
                    document.getElementById('farkleNPCScore').textContent = farkleNPCScore;
                }
                document.getElementById('farkleMessage').textContent = playerLabel + ' passed with ' + farkleTurnScore + ' points';
                update3DScores();
                update3DMessage(playerLabel + ' passed +' + farkleTurnScore, '#ffcc44');
            } else {
                document.getElementById('farkleMessage').textContent = playerLabel + ' passed turn';
                update3DMessage(playerLabel + ' passed', '#888888');
            }

            // Reset turn state
            resetPlayerTurn();

            // Check for win
            const scoreToCheck = isP1 ? farkleTotalScore : farkleNPCScore;
            if (scoreToCheck >= 10000) {
                const winLabel = farkleGameMode === '2player' ? (isP1 ? 'P1' : 'P2') : 'YOU';
                document.getElementById('farkleMessage').textContent = winLabel + ' WINS! Final Score: ' + scoreToCheck;
                document.getElementById('farkleTurnIndicator').textContent = 'GAME OVER';
                document.getElementById('farkleTurnIndicator').style.color = '#4f8';
                update3DMessage(winLabel + ' WINS!', isP1 ? '#44ff88' : '#ff6666');
                update3DTurnIndicator('GAME OVER', '#44ff88');
                disableGameButtons();
                return;
            }

            // Switch turns
            if (isP1) {
                setTimeout(() => startNPCTurn(), 1500);
            } else {
                setTimeout(() => startP1Turn(), 1500);
            }
        };

        // Reset player turn state
        function resetPlayerTurn() {
            farkleTurnScore = 0;
            farkleRolled = false;
            document.getElementById('farkleTurnScore').textContent = '0';

            // Reset all dice
            for (const die of farkleDice) {
                die.kept = false;
                for (const mat of die.mesh.material) {
                    mat.emissive = new THREE.Color(0x000000);
                }
            }
            update2DDiceUI();
        }

        // Disable game buttons (no-op since we removed buttons for cleaner UI)
        function disableGameButtons() {
            // Buttons removed for immersive UI - controls are keyboard only now
        }

        // Enable game buttons (no-op since we removed buttons for cleaner UI)
        function enableGameButtons() {
            // Buttons removed for immersive UI - controls are keyboard only now
        }

        // Start NPC/P2 turn
        function startNPCTurn() {
            if (!farkleGameActive) return;

            isPlayerTurn = false;

            if (farkleGameMode === '2player') {
                // 2-Player mode: just switch to P2, let them play
                npcTurnInProgress = false; // P2 is a human, not NPC
                document.getElementById('farkleTurnIndicator').textContent = "P2's turn";
                document.getElementById('farkleTurnIndicator').style.color = '#f88';
                update3DTurnIndicator("P2's turn", '#ff6666');
                update3DMessage('P2: Press R to roll', '#ff8866');
                // Reset dice for P2's turn
                farkleRolled = false;
                farkleTurnScore = 0;
                for (const die of farkleDice) {
                    die.kept = false;
                    for (const mat of die.mesh.material) {
                        mat.emissive = new THREE.Color(0x000000);
                    }
                }
                update2DDiceUI();
                update3DScores();
            } else {
                // NPC mode: AI plays automatically
                npcTurnInProgress = true;
                document.getElementById('farkleTurnIndicator').textContent = "NPC's turn...";
                document.getElementById('farkleTurnIndicator').style.color = '#f88';
                update3DTurnIndicator("NPC's turn", '#ff6666');
                update3DMessage('NPC thinking...', '#ff8866');
                disableGameButtons();
                simulateNPCTurn();
            }
        }

        // Start P1 turn (called after P2 finishes in 2-player mode)
        function startP1Turn() {
            if (!farkleGameActive) return;

            isPlayerTurn = true;
            npcTurnInProgress = false;

            const turnLabel = farkleGameMode === '2player' ? "P1's turn" : "Your turn";
            document.getElementById('farkleTurnIndicator').textContent = turnLabel;
            document.getElementById('farkleTurnIndicator').style.color = '#4f8';
            update3DTurnIndicator(turnLabel, '#44ff88');
            update3DMessage('P1: Press R to roll', '#88ff88');

            // Reset dice for P1's turn
            farkleRolled = false;
            farkleTurnScore = 0;
            document.getElementById('farkleTurnScore').textContent = '0';
            for (const die of farkleDice) {
                die.kept = false;
                for (const mat of die.mesh.material) {
                    mat.emissive = new THREE.Color(0x000000);
                }
            }
            update2DDiceUI();
            update3DScores();
        }

        // Simulate NPC turn with AI logic
        function simulateNPCTurn() {
            let npcTurnPoints = 0;
            let rollsLeft = 6; // Start with 6 dice
            let continueRolling = true;

            function npcRoll() {
                if (!farkleGameActive || !npcTurnInProgress) return;

                // Simulate rolling dice
                const diceValues = [];
                for (let i = 0; i < rollsLeft; i++) {
                    diceValues.push(Math.floor(Math.random() * 6) + 1);
                }

                // Calculate score from this roll
                const rollScore = calculateFarkleScore(diceValues);

                if (rollScore === 0) {
                    // NPC Farkled! Lost all turn points
                    document.getElementById('farkleMessage').textContent = 'NPC Farkled! Lost ' + npcTurnPoints + ' points';
                    update3DMessage('NPC FARKLED!', '#ff4444');
                    npcTurnPoints = 0;
                    endNPCTurn(npcTurnPoints);
                    return;
                }

                // Add roll score to turn total
                npcTurnPoints += rollScore;

                // Count how many dice scored
                const scoringDice = countScoringDice(diceValues);
                rollsLeft -= scoringDice;

                // Hot dice - if all dice scored, reset to 6
                if (rollsLeft === 0) {
                    rollsLeft = 6;
                }

                // NPC decision: bank or continue?
                // Simple AI: bank if turn score > 300 and less than 3 dice left, or if total would win
                const wouldWin = (farkleNPCScore + npcTurnPoints) >= 10000;
                const shouldBank = wouldWin || (npcTurnPoints >= 300 && rollsLeft <= 2) || (npcTurnPoints >= 500);

                document.getElementById('farkleMessage').textContent =
                    'NPC rolled: ' + diceValues.join(', ') + ' (+' + rollScore + ')';
                document.getElementById('farkleTurnScore').textContent = npcTurnPoints;
                farkleTurnScore = npcTurnPoints;
                update3DScores();
                update3DMessage('NPC +' + rollScore, '#ff8866');

                if (shouldBank) {
                    setTimeout(() => endNPCTurn(npcTurnPoints), 1500);
                } else {
                    // Continue rolling
                    setTimeout(npcRoll, 1500);
                }
            }

            // Start first roll after delay
            setTimeout(npcRoll, 1000);
        }

        // Count how many dice contributed to scoring
        function countScoringDice(diceValues) {
            const counts = [0, 0, 0, 0, 0, 0, 0];
            for (const v of diceValues) counts[v]++;

            let scoring = 0;

            // Check for straight
            if (counts[1] === 1 && counts[2] === 1 && counts[3] === 1 &&
                counts[4] === 1 && counts[5] === 1 && counts[6] === 1) {
                return 6;
            }

            // Check three pairs
            let pairs = 0;
            for (let i = 1; i <= 6; i++) {
                if (counts[i] === 2) pairs++;
            }
            if (pairs === 3) return 6;

            // Count sets and singles
            for (let i = 1; i <= 6; i++) {
                if (counts[i] >= 3) {
                    scoring += counts[i]; // All dice in the set
                } else if (i === 1 || i === 5) {
                    scoring += counts[i]; // 1s and 5s score individually
                }
            }

            return Math.max(1, scoring); // At least 1 die scores if we got points
        }

        // End NPC turn
        function endNPCTurn(points) {
            if (!farkleGameActive) return;

            farkleNPCScore += points;
            document.getElementById('farkleNPCScore').textContent = farkleNPCScore;
            update3DScores();

            if (points > 0) {
                document.getElementById('farkleMessage').textContent = 'NPC banked ' + points + ' points!';
                update3DMessage('NPC banked ' + points, '#ff6666');
            }

            // Check for NPC win
            if (farkleNPCScore >= 10000) {
                document.getElementById('farkleMessage').textContent = 'NPC WINS! Score: ' + farkleNPCScore;
                document.getElementById('farkleTurnIndicator').textContent = 'GAME OVER';
                document.getElementById('farkleTurnIndicator').style.color = '#f88';
                update3DMessage('NPC WINS!', '#ff4444');
                update3DTurnIndicator('GAME OVER', '#ff4444');
                npcTurnInProgress = false;
                return;
            }

            // Switch back to player turn
            npcTurnInProgress = false;
            isPlayerTurn = true;
            farkleTurnScore = 0;
            document.getElementById('farkleTurnIndicator').textContent = 'Your turn';
            document.getElementById('farkleTurnIndicator').style.color = '#ffa';
            document.getElementById('farkleTurnScore').textContent = '0';
            update3DTurnIndicator('Your turn', '#44ff88');
            update3DScores();
            enableGameButtons();

            setTimeout(() => {
                document.getElementById('farkleMessage').textContent = 'Press R to roll dice';
                update3DMessage('Press R to roll', '#ffaa77');
            }, 1000);
        }

        // Handle click on dice during Farkle game
        function handleFarkleClick(event) {
            if (!farkleGameActive || !isPlayerTurn) return;

            console.log('[FARKLE] Click detected, checking dice...');

            // Use center of screen (crosshair) for raycasting since pointer is locked
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            // Check intersection with dice
            const diceMeshes = farkleDice.map(d => d.mesh);
            const intersects = raycaster.intersectObjects(diceMeshes, true);

            console.log('[FARKLE] Intersects:', intersects.length, 'dice count:', farkleDice.length);

            if (intersects.length > 0) {
                const hitMesh = intersects[0].object;
                const die = farkleDice.find(d => d.mesh === hitMesh);
                console.log('[FARKLE] Hit die:', die, 'farkleRolled:', farkleRolled);
                if (die) {
                    toggleDieKept(die);
                }
            }
        }

        // Add click listener for dice
        renderer.domElement.addEventListener('click', handleFarkleClick);

        // Check dice settled state in animate loop
        let diceSettleCheckTimer = 0;

        // Selection shape selector
        document.getElementById('selectionShapeSelect').addEventListener('change', function() {
            selectionShape = this.value;
            if (selectionShape === 'box') {
                document.getElementById('sphereSizeUI').style.display = 'none';
                document.getElementById('boxSizeUI').style.display = 'block';
            } else {
                document.getElementById('sphereSizeUI').style.display = 'block';
                document.getElementById('boxSizeUI').style.display = 'none';
            }
            // Recreate the selection shape
            if (selectionSphere) {
                scene.remove(selectionSphere);
                createSelectionSphere();
            }
        });

        // Selection radius slider
        document.getElementById('selectionRadiusSlider').addEventListener('input', function() {
            const newRadius = parseFloat(this.value);
            document.getElementById('selectionRadiusVal').textContent = newRadius.toFixed(2);
            updateSelectionRadius(newRadius);
        });

        // Box size sliders
        document.getElementById('selectionBoxWSlider').addEventListener('input', function() {
            selectionBoxW = parseFloat(this.value);
            document.getElementById('selectionBoxWVal').textContent = selectionBoxW.toFixed(2);
            if (selectionSphere) { scene.remove(selectionSphere); createSelectionSphere(); }
        });
        document.getElementById('selectionBoxHSlider').addEventListener('input', function() {
            selectionBoxH = parseFloat(this.value);
            document.getElementById('selectionBoxHVal').textContent = selectionBoxH.toFixed(2);
            if (selectionSphere) { scene.remove(selectionSphere); createSelectionSphere(); }
        });
        document.getElementById('selectionBoxDSlider').addEventListener('input', function() {
            selectionBoxD = parseFloat(this.value);
            document.getElementById('selectionBoxDVal').textContent = selectionBoxD.toFixed(2);
            if (selectionSphere) { scene.remove(selectionSphere); createSelectionSphere(); }
        });

        // Selection position offset sliders
        document.getElementById('selectionOffsetXSlider').addEventListener('input', function() {
            selectionOffsetX = parseFloat(this.value);
            document.getElementById('selectionOffsetXVal').textContent = selectionOffsetX.toFixed(2);
            updateSelectionPosition();
        });
        document.getElementById('selectionOffsetYSlider').addEventListener('input', function() {
            selectionOffsetY = parseFloat(this.value);
            document.getElementById('selectionOffsetYVal').textContent = selectionOffsetY.toFixed(2);
            updateSelectionPosition();
        });
        document.getElementById('selectionOffsetZSlider').addEventListener('input', function() {
            selectionOffsetZ = parseFloat(this.value);
            document.getElementById('selectionOffsetZVal').textContent = selectionOffsetZ.toFixed(2);
            updateSelectionPosition();
        });

        // Copy adjust sliders
        document.getElementById('copyOffsetXSlider').addEventListener('input', function() {
            copyOffsetX = parseFloat(this.value);
            document.getElementById('copyOffsetXVal').textContent = copyOffsetX.toFixed(1);
            updateCopyAdjustPreview();
        });
        document.getElementById('copyOffsetYSlider').addEventListener('input', function() {
            copyOffsetY = parseFloat(this.value);
            document.getElementById('copyOffsetYVal').textContent = copyOffsetY.toFixed(1);
            updateCopyAdjustPreview();
        });
        document.getElementById('copyOffsetZSlider').addEventListener('input', function() {
            copyOffsetZ = parseFloat(this.value);
            document.getElementById('copyOffsetZVal').textContent = copyOffsetZ.toFixed(1);
            updateCopyAdjustPreview();
        });
        document.getElementById('copyRotationYSlider').addEventListener('input', function() {
            copyRotationY = parseFloat(this.value);
            document.getElementById('copyRotationYVal').textContent = copyRotationY;
            updateCopyAdjustPreview();
        });
        document.getElementById('copyScaleSlider').addEventListener('input', function() {
            copyScale = parseFloat(this.value);
            document.getElementById('copyScaleVal').textContent = copyScale.toFixed(1);
            updateCopyAdjustPreview();
        });

        // Animation loop
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            const now = performance.now();
            const delta = (now - lastTime) / 1000;
            lastTime = now;

            // Update dice physics
            if (farkleGameActive && farkleDice.length > 0) {
                physicsWorld.step(1/60, delta, 3);
                // Sync dice meshes to physics bodies
                for (const die of farkleDice) {
                    if (die.body && die.mesh) {
                        die.mesh.position.copy(die.body.position);
                        die.mesh.quaternion.copy(die.body.quaternion);
                    }
                }

                // Check if dice have settled
                if (farkleRolled && !diceSettled && diceHaveSettled()) {
                    diceSettled = true;
                    readDiceValues();

                    // Check for Farkle (no scoring dice)
                    const allValues = farkleDice.filter(d => !d.kept).map(d => d.value);
                    const potentialScore = calculateFarkleScore(allValues);

                    if (potentialScore === 0) {
                        // Determine which player farkled
                        const isP1 = isPlayerTurn;
                        const playerLabel = farkleGameMode === '2player' ? (isP1 ? 'P1' : 'P2') : 'YOU';
                        document.getElementById('farkleMessage').textContent = playerLabel + ' FARKLE! Turn lost!';
                        document.getElementById('farkleMessage').style.color = '#f44';
                        update3DMessage(playerLabel + ' FARKLE!', '#ff4444');
                        // Reset after short delay and switch turns
                        setTimeout(() => {
                            farkleTurnScore = 0;
                            farkleRolled = false;
                            selectedDieIndex = 0;
                            document.getElementById('farkleTurnScore').textContent = '0';
                            update3DScores();
                            for (const die of farkleDice) {
                                die.kept = false;
                            }
                            updateDiceHighlights();
                            // Switch to other player's turn
                            if (isP1) {
                                setTimeout(() => startNPCTurn(), 500);
                            } else {
                                // P2 farkled in 2-player mode, switch back to P1
                                setTimeout(() => startP1Turn(), 500);
                            }
                        }, 2000);
                    } else {
                        // Select first un-kept die and highlight
                        selectedDieIndex = farkleDice.findIndex(d => !d.kept);
                        if (selectedDieIndex === -1) selectedDieIndex = 0;
                        updateDiceHighlights();
                        updateSelectionMessage();
                    }
                }
            }

            // Skip normal movement and physics when in adjust phase AND not in walk mode
            const inAdjustPhase = collisionPlaceMode && placementPhase === 'adjust';
            const canMove = (!inAdjustPhase || adjustWalkMode) && !farkleGameActive;
            const flyMode = farkleCameraMode || farklePlaceMode; // Free fly in placement modes
            const skipCollision = flyMode; // No collision when flying

            if (canMove) {
                // Apply physics (gravity + ground detection) - skip in fly mode
                if (!flyMode) {
                    applyPhysics(delta);
                }

                // Movement
                const speed = moveSpeed * delta * (keys['shift'] ? 2.5 : 1);
                const direction = new THREE.Vector3();

                if (keys['w']) direction.z -= 1;
                if (keys['s']) direction.z += 1;
                if (keys['a']) direction.x -= 1;
                if (keys['d']) direction.x += 1;

                // Q/E for flying up/down in fly modes (placement or camera setting)
                if (flyMode) {
                    if (keys['q']) {
                        camera.position.y -= speed * 0.8;
                        playerPos.y = camera.position.y - camOffsetY;
                    }
                    if (keys['e']) {
                        camera.position.y += speed * 0.8;
                        playerPos.y = camera.position.y - camOffsetY;
                    }
                }

                if (direction.length() > 0) {
                    direction.normalize();
                    direction.applyQuaternion(camera.quaternion);

                    // In fly mode, allow full 3D movement; otherwise keep horizontal
                    if (!flyMode) {
                        direction.y = 0;
                        direction.normalize();
                    }

                    // Try to move, but check collision first (pass old position for swept check)
                    const oldPos = playerPos.clone();
                    const newPos = playerPos.clone().addScaledVector(direction, speed);
                    // Skip collision check in fly mode or if testMode is off
                    if (skipCollision || !testMode || !wouldCollide(newPos, oldPos)) {
                        playerPos.copy(newPos);
                        // Camera follows player with offsets
                        camera.position.set(
                            playerPos.x + camOffsetX,
                            playerPos.y + camOffsetY,
                            playerPos.z + camOffsetZ
                        );
                    }
                }

                // Jump (Space) - can jump anytime (not in fly mode)
                if (keys[' '] && !flyMode) {
                    velocityY = 8; // Jump velocity
                    isGrounded = false;
                    keys[' '] = false; // Prevent continuous jumping while held
                }

                // Update hands animation based on movement
                if (fpsHandsMixer) {
                    // Only auto-switch if not forcing a specific animation
                    if (forceAnim === 'auto') {
                        const isMoving = keys['w'] || keys['s'] || keys['a'] || keys['d'];
                        const isRunning = keys['shift'] && isMoving;

                        let targetAnim = 'idle';
                        if (isRunning) targetAnim = 'run';
                        else if (isMoving) targetAnim = 'walk';

                        // Switch animation if needed
                        if (targetAnim !== currentHandsAnim && fpsHandsAnimations[targetAnim]) {
                            if (fpsHandsAnimations[currentHandsAnim]) {
                                fpsHandsAnimations[currentHandsAnim].fadeOut(animBlendDuration);
                            }
                            fpsHandsAnimations[targetAnim].reset().fadeIn(animBlendDuration).play();
                            currentHandsAnim = targetAnim;
                        }
                    }

                    fpsHandsMixer.update(delta);
                }
            }

            // Update collision placement preview position
            if (collisionPlaceMode) {
                // Make sure preview exists
                if (!collPlacePreview) {
                    createPreviewBox();
                }

                // Only update preview position via raycast in preview phase
                // In adjust phase, position is controlled by sliders
                if (placementPhase === 'preview') {
                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObjects(scene.children, true);

                    let foundHit = false;
                    for (const hit of intersects) {
                        // Skip the preview box and its children
                        if (hit.object === collPlacePreview) continue;
                        if (hit.object.parent === collPlacePreview) continue;
                        if (hit.object === playerBody) continue;
                        if (hit.object === collisionBox) continue;
                        if (bucketCollisionVisuals.includes(hit.object)) continue;

                        // Store base position and update preview
                        collPlaceBasePosition.copy(hit.point);
                        updatePreviewPosition();
                        foundHit = true;
                        break;
                    }

                    // If no hit, place preview in front of camera
                    if (!foundHit && collPlacePreview) {
                        const forward = new THREE.Vector3(0, 0, -5);
                        forward.applyQuaternion(camera.quaternion);
                        collPlaceBasePosition.copy(camera.position).add(forward);
                        updatePreviewPosition();
                    }
                }
                // In adjust phase: walk mode or slider mode - camera follows player (handled in movement code above)
            }

            // Update copy mode preview position
            if (copyMode && copyPhase === 'preview') {
                updateCopyPreviewPosition();
            }

            // Update Farkle table preview position
            if (farklePlaceMode && farklePreview) {
                updateFarklePreviewPosition();
            }

            // Show/hide Farkle prompt when near table
            if (!farkleGameActive && !farklePlaceMode) {
                const nearTable = checkNearFarkleTable();
                document.getElementById('farklePrompt').style.display = nearTable ? 'block' : 'none';
            } else {
                document.getElementById('farklePrompt').style.display = 'none';
            }

            // Update player body position
            updatePlayerBodyPosition();

            // Update camera marker position
            if (cameraMarker && cameraMarkerVisible) {
                cameraMarker.position.copy(camera.position);
            }

            // Check collisions in test mode
            if (testMode) {
                checkCollisions();
            }

            // Handle third-person camera
            let renderCamera = camera;
            if (viewMode === 'tp') {
                // Create a temporary camera position behind the player
                const behindOffset = new THREE.Vector3(0, 1, thirdPersonDistance);
                behindOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                const tpCamPos = camera.position.clone().add(behindOffset);
                tpCamPos.y += 1; // Slightly above

                // Create a temporary camera for third-person view
                const tpCamera = camera.clone();
                tpCamera.position.copy(tpCamPos);
                tpCamera.lookAt(camera.position);
                renderCamera = tpCamera;
            }

            // Update position display
            const pos = camera.position;
            document.getElementById('posDisplay').textContent =
                `${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}`;
            document.getElementById('heightDisplay').textContent = pos.y.toFixed(2);

            document.getElementById('lookDisplay').textContent =
                `${(yaw * 180 / Math.PI).toFixed(1)}Â°, ${(pitch * 180 / Math.PI).toFixed(1)}Â°`;
            const groundedEl = document.getElementById('groundedDisplay');
            if (isGrounded) {
                groundedEl.textContent = 'GROUNDED';
                groundedEl.style.color = '#4f8';
            } else {
                groundedEl.textContent = 'FALLING';
                groundedEl.style.color = '#f44';
            }

            renderer.render(scene, renderCamera);
        }

        // ============================================
        // SAVED FARKLE TABLES - Auto-load on startup
        // ============================================
        const savedFarkleTables = [
            { // Table #1 - Upper floor purple table
                position: new THREE.Vector3(6.282, 1.723, 17.696),
                rotation: 90,
                uiRotation: 0,
                cameraPos: new THREE.Vector3(5.927, 4.591, 17.700),
                cameraRot: new THREE.Euler(-1.5568, -0.1875, -1.4959),
                feltSurfaceY: 1.070,
                config: {
                    legHeight: 0.95,
                    feltColor: 0x551653,
                    feltEmissive: 0.8
                }
            }
        ];

        // Load saved Farkle tables
        function loadSavedFarkleTables() {
            for (const tableData of savedFarkleTables) {
                // Apply config before creating mesh
                tableLegHeight = tableData.config.legHeight;
                feltHeightOffset = tableData.feltSurfaceY;
                feltColor = tableData.config.feltColor;
                feltEmissive = tableData.config.feltEmissive;

                // Create the table mesh
                const tableMesh = createDiceBoxMesh(false);
                tableMesh.position.copy(tableData.position);
                tableMesh.rotation.y = tableData.rotation * Math.PI / 180;
                scene.add(tableMesh);

                // Create the table object
                const table = {
                    mesh: tableMesh,
                    position: tableData.position.clone(),
                    rotation: tableData.rotation,
                    uiRotation: tableData.uiRotation || 0,
                    cameraPos: tableData.cameraPos.clone(),
                    cameraRot: tableData.cameraRot.clone(),
                    config: { ...tableData.config }
                };

                farkleTables.push(table);
                console.log('[FARKLE] Loaded saved table at', tableData.position);
            }

            // Update counter
            document.getElementById('farkleTableCount').textContent = farkleTables.length;

            // Reset config to defaults
            tableLegHeight = 0.95;
            feltHeightOffset = 1.07;
            feltColor = 0x22DD44;
            feltEmissive = 0.8;
        }

        // Load saved tables on startup
        loadSavedFarkleTables();

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
