<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>World Builder</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: white;
            font-family: 'Segoe UI', sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        /* Phase screens */
        .phase { display: none; height: 100vh; }
        .phase.active { display: flex; }

        /* LOAD PHASE */
        #loadPhase {
            justify-content: center;
            align-items: center;
        }

        .load-box {
            text-align: center;
            padding: 40px;
            border: 2px dashed #555;
            border-radius: 15px;
            background: #2a2a4e;
        }

        .load-box h1 { color: #4af; margin-bottom: 10px; }
        .load-box p { color: #888; margin-bottom: 20px; }

        /* COLLISION PHASE */
        #collisionPhase {
            flex-direction: column;
        }

        .collision-header {
            background: #2a2a4e;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #4af;
        }

        .collision-header h2 { color: #4af; }

        .collision-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .collision-sidebar {
            width: 280px;
            background: #2a2a4e;
            padding: 15px;
            overflow-y: auto;
        }

        .collision-main {
            flex: 1;
            overflow: auto;
            padding: 20px;
            background: #111;
        }

        #collisionTilesetCanvas {
            cursor: crosshair;
            image-rendering: pixelated;
            border: 2px solid #555;
        }

        .tool-buttons {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .tool-buttons button.active {
            background: #4af;
            color: #000;
        }

        /* BUILD PHASE */
        #buildPhase {
            flex-direction: row;
        }

        .panel {
            background: #2a2a4e;
            padding: 15px;
            overflow-y: auto;
        }

        .left-panel { width: 320px; }

        .map-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .toolbar {
            padding: 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            background: #2a2a4e;
            flex-wrap: wrap;
        }

        .map-viewport {
            flex: 1;
            overflow: auto;
            background: #111;
            padding: 40px;
            position: relative;
        }

        #mapCanvas {
            border: 2px solid #555;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        #mapCanvas.grabbing {
            cursor: grab;
        }

        #mapCanvas.grabbing:active {
            cursor: grabbing;
        }

        /* Expand buttons */
        .expand-btn {
            position: absolute;
            background: #4a7c59;
            color: white;
            border: none;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.6;
            z-index: 10;
            padding: 0;
        }

        .expand-btn:hover {
            opacity: 1;
            background: #5a9c69;
        }

        .expand-top {
            top: 10px;
            width: 60px;
            height: 25px;
        }

        .expand-bottom {
            width: 60px;
            height: 25px;
        }

        .expand-left {
            left: 10px;
            width: 25px;
            height: 60px;
        }

        .expand-right {
            width: 25px;
            height: 60px;
        }

        /* Common */
        button {
            background: #4a7c59;
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        button:hover { background: #5a9c69; }
        button.danger { background: #a55; }
        button.primary { background: #4af; color: #000; }

        h2 { color: #4af; font-size: 14px; margin: 15px 0 8px; }
        h3 { color: #8af; font-size: 12px; margin: 10px 0 5px; }

        input[type="file"] { display: none; }

        select, input[type="text"] {
            padding: 6px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }

        .info {
            color: #888;
            font-size: 11px;
            padding: 10px;
            background: #1a1a3e;
            border-radius: 5px;
            margin: 10px 0;
        }

        .tileset-container {
            background: #111;
            padding: 5px;
            border-radius: 5px;
            overflow: auto;
            max-height: 300px;
        }

        #paintTilesetCanvas {
            cursor: crosshair;
            image-rendering: pixelated;
            border: 1px solid #444;
        }

        .selected-preview {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            margin: 10px 0;
        }

        .selected-preview canvas {
            border: 2px solid #0f0;
            image-rendering: pixelated;
        }

        .mode-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .mode-tabs button { flex: 1; }
        .mode-tabs button.active { background: #4af; color: #000; }

        .prop-item {
            background: #333;
            padding: 8px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 11px;
        }

        .prop-item .name { color: #4af; font-weight: bold; }

        .state-picker {
            position: fixed;
            background: #2a2a4e;
            border: 2px solid #4af;
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            display: none;
        }

        .state-picker.visible { display: block; }

        .state-option {
            padding: 8px 12px;
            margin: 3px 0;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
        }

        .state-option:hover { background: #444; }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .zoom-controls button { padding: 4px 10px; }
        .zoom-controls span { color: #888; font-size: 12px; min-width: 30px; text-align: center; }

        .toolbar span { color: #888; font-size: 11px; }

        /* Animated Prop Editor Modal */
        .anim-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
        }
        .anim-modal.visible { display: flex; }

        .anim-modal-content {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .anim-sidebar {
            width: 280px;
            background: #2a2a4e;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #4af;
        }

        .anim-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #1a1a2e;
            overflow: hidden;
            min-width: 0;
        }

        .anim-header {
            padding: 15px 20px;
            background: #2a2a4e;
            border-bottom: 2px solid #4af;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .anim-header h2 { color: #4af; margin: 0; }

        .anim-canvas-area {
            flex: 1;
            overflow: auto;
            padding: 20px;
            display: block;
            min-height: 0;
        }

        .anim-canvas-area canvas {
            border: 2px solid #555;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        .anim-frames-bar {
            background: #2a2a4e;
            padding: 15px 20px;
            border-top: 2px solid #4af;
        }

        .anim-frames-list {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            min-height: 50px;
            background: #111;
            padding: 10px;
            border-radius: 5px;
        }

        .anim-frame-thumb {
            border: 2px solid #4af;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .anim-frame-thumb:hover { border-color: #fff; }

        .anim-frame-thumb .frame-num {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0,0,0,0.8);
            color: #4af;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 2px;
        }

        /* NPC System Styles */
        .npc-item {
            background: #333;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            cursor: pointer;
            border: 2px solid transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .npc-item:hover { background: #444; }
        .npc-item.selected { border-color: #4af; background: #3a3a5e; }
        .npc-item .npc-preview {
            width: 32px;
            height: 32px;
            background: #222;
            border-radius: 4px;
            image-rendering: pixelated;
        }
        .npc-item .npc-info { flex: 1; }
        .npc-item .npc-name { color: #4af; font-weight: bold; font-size: 12px; }
        .npc-item .npc-type { color: #888; font-size: 10px; }
        .npc-item .npc-actions { display: flex; gap: 5px; }
        .npc-item .npc-actions button { padding: 3px 8px; font-size: 10px; }

        .npc-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
        }
        .npc-modal.visible { display: flex; justify-content: center; align-items: center; }

        .npc-modal-content {
            background: #2a2a4e;
            border: 2px solid #4af;
            border-radius: 10px;
            padding: 25px;
            width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .npc-modal h2 { color: #4af; margin-bottom: 20px; }
        .npc-modal label { display: block; color: #aaa; font-size: 12px; margin: 10px 0 5px; }
        .npc-modal input[type="text"], .npc-modal textarea, .npc-modal select {
            width: 100%;
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }
        .npc-modal textarea { min-height: 80px; resize: vertical; }

        .npc-sprite-preview {
            background: #111;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
        }
        .npc-sprite-preview canvas {
            image-rendering: pixelated;
            border: 1px solid #444;
        }

        .npc-modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .placed-npc-item {
            background: #2a2a3e;
            padding: 6px 10px;
            border-radius: 4px;
            margin: 3px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .placed-npc-item button { padding: 2px 8px; font-size: 10px; background: #a55; }

        /* Hamburger menu and resize handle */
        .mode-tabs-header {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #2a2a3e;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .hamburger-btn {
            background: #444;
            border: none;
            color: #fff;
            font-size: 20px;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
        }
        .hamburger-btn:hover { background: #555; }
        #currentModeLabel {
            font-weight: bold;
            font-size: 14px;
        }
        .mode-tabs.collapsed {
            display: none;
        }
        .resize-handle {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: #333;
            cursor: ew-resize;
            z-index: 100;
        }
        .resize-handle:hover, .resize-handle.active {
            background: #4af;
        }
        .left-panel {
            position: relative;
            min-width: 200px;
            max-width: 500px;
        }

        /* Mobile/Touch friendly styles */
        @media (max-width: 1024px), (pointer: coarse) {
            .toolbar button, .tool-buttons button, .zoom-controls button {
                min-height: 44px;
                min-width: 44px;
                font-size: 14px;
                padding: 8px 12px;
            }
            .sidebar { width: 280px; }
            .mode-buttons button { padding: 10px 15px; font-size: 13px; }
            #mapCanvas { touch-action: none; }
            #paintTilesetCanvas { touch-action: none; }
            .mode-tabs-header { display: flex; }
            .mode-tabs { display: none; }
            .mode-tabs.expanded { display: flex; }
        }
    </style>
</head>
<body>
    <!-- PHASE 1: LOAD -->
    <div id="loadPhase" class="phase active">
        <div class="load-box">
            <h1>World Builder</h1>
            <p>Load a tileset to begin</p>
            <input type="file" id="fileInput" accept="image/*" onchange="loadTileset(event)">
            <button onclick="document.getElementById('fileInput').click()" style="padding:15px 30px; font-size:14px;">Load Tileset</button>
            <br><br>
            <button onclick="console.log('Button clicked'); loadProject();" style="background:#555;">Load Saved Project</button>
            <button onclick="document.getElementById('projectFileInputWelcome').click()" style="background:#2a7;">Load From File</button>
            <input type="file" id="projectFileInputWelcome" accept=".json" style="display:none;" onchange="uploadProject(event)">
        </div>
    </div>

    <!-- PHASE 2: COLLISION SETUP -->
    <div id="collisionPhase" class="phase">
        <div class="collision-header">
            <div>
                <h2>Step 1: Define Collision</h2>
                <span style="color:#888; font-size:12px;">Paint collision on tiles with brush</span>
            </div>
            <div>
                <label style="color:#aaa; margin-right:10px;">Tile Size:</label>
                <select id="gridSize" onchange="rebuildCollisionView()">
                    <option value="16" selected>16x16</option>
                    <option value="32">32x32</option>
                </select>
                <button onclick="finishCollisionSetup()" class="primary" style="margin-left:20px; padding:10px 25px;">
                    Done - Start Building ‚Üí
                </button>
            </div>
        </div>
        <div class="collision-body">
            <div class="collision-sidebar">
                <div class="info">
                    <strong>Simple Tile Collision:</strong><br>
                    Left-click: Add collision<br>
                    Right-click: Remove collision<br>
                    Drag to paint multiple tiles
                </div>

                <h3>Tool</h3>
                <div class="tool-buttons">
                    <button id="collisionToolPaint" class="active" onclick="setCollisionTool('paint')">Add Collision</button>
                    <button id="collisionToolErase" onclick="setCollisionTool('erase')">Remove</button>
                    <button id="collisionToolSplit" onclick="setCollisionTool('split')" style="background:#0aa;">Depth Split</button>
                </div>

                <div id="splitControls" style="display:none; margin:10px 0; padding:10px; background:#1a3a3e; border-radius:5px;">
                    <div style="font-size:11px; color:#0ff; margin-bottom:5px;">Draw split line on tiles (drag to draw)</div>
                    <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
                        <label style="font-size:11px; display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="checkbox" id="flatLineToggle" checked onchange="toggleFlatLineMode()">
                            <span>Flat Line</span>
                        </label>
                        <span style="font-size:11px;">Y:</span>
                        <input type="number" id="splitYInput" value="8" min="0" max="16" style="width:50px; padding:3px;">
                        <button onclick="setSplitLineY()" style="padding:3px 8px; font-size:10px; background:#0aa;">Set Y</button>
                        <button onclick="clearSelectedSplit()" style="padding:3px 8px; font-size:10px; background:#a55;">Clear</button>
                    </div>
                    <div style="font-size:10px; color:#888; margin-top:5px;">C = Canopy (top) | T = Trunk (bottom, Y-sorted with player)</div>
                </div>

                <h3>Brush Size (pixels)</h3>
                <div class="tool-buttons">
                    <button id="brush2" onclick="setBrushSize(2)">2</button>
                    <button id="brush4" class="active" onclick="setBrushSize(4)">4</button>
                    <button id="brush8" onclick="setBrushSize(8)">8</button>
                    <button id="brush16" onclick="setBrushSize(16)">16</button>
                </div>

                <h3>Zoom (Q/E or +/-)</h3>
                <div class="tool-buttons">
                    <button onclick="setCollisionZoom(2)">2x</button>
                    <button onclick="setCollisionZoom(4)">4x</button>
                    <button id="collisionZoom8" class="active" onclick="setCollisionZoom(6)">6x</button>
                    <button onclick="setCollisionZoom(8)">8x</button>
                </div>
                <div style="font-size:10px; color:#666; margin-top:5px;">Middle-click drag or Shift+drag to pan</div>

                <h3>Quick Actions</h3>
                <div class="tool-buttons">
                    <button onclick="selectAllCollision()">All Solid</button>
                    <button onclick="clearAllCollision()" class="danger">Clear All</button>
                </div>

                <h3 style="margin-top:20px;">Stats</h3>
                <div id="collisionStats" style="background:#111; padding:10px; border-radius:5px; font-size:12px; color:#888;">
                    0 tiles with collision
                </div>
            </div>

            <div class="collision-main">
                <canvas id="collisionTilesetCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- PHASE 3: BUILD -->
    <div id="buildPhase" class="phase">
        <div class="panel left-panel" id="leftPanel">
            <div class="mode-tabs-header">
                <button id="menuToggle" class="hamburger-btn" onclick="toggleModeMenu()">‚ò∞</button>
                <span id="currentModeLabel">Tiles</span>
            </div>
            <div class="mode-tabs" id="modeTabs">
                <button id="tileMode" class="active" onclick="setMode('tile')">Tiles</button>
                <button id="npcMode" onclick="setMode('npc')">NPCs</button>
                <button id="animPropMode" onclick="setMode('animProp')">Animated</button>
                <button id="soundMode" onclick="setMode('sound')">Sounds</button>
                <button id="lightingMode" onclick="setMode('lighting')">Lights</button>
            </div>
            <div class="resize-handle" id="sidebarResize"></div>

            <!-- TILE MODE -->
            <div id="tileModeContent">
                <h3>Selected Tile</h3>
                <div class="selected-preview" id="selectedPreview" style="display:none;">
                    <canvas id="selectedTile" width="48" height="48"></canvas>
                    <div>
                        <div id="selectedInfo">No tile</div>
                        <div id="selectedCollisionInfo" style="color:#888; font-size:10px;">No collision</div>
                    </div>
                </div>

                <h3>Transform</h3>
                <div class="tool-buttons" style="margin-bottom:8px;">
                    <button id="rot0" class="active" onclick="setRotation(0)">0¬∞</button>
                    <button id="rot90" onclick="setRotation(90)">90¬∞</button>
                    <button id="rot180" onclick="setRotation(180)">180¬∞</button>
                    <button id="rot270" onclick="setRotation(270)">270¬∞</button>
                </div>
                <div class="tool-buttons">
                    <button id="flipBtn" onclick="toggleFlipH()" style="flex:1;">Flip H (I)</button>
                    <button id="eraseBtn" onclick="toggleEraseMode()" style="flex:1; background:#a55;">Erase (E)</button>
                </div>

                <h3>Tileset</h3>
                <div style="display:flex; gap:5px; margin-bottom:5px; align-items:center;">
                    <select id="tilesetSelect" onchange="switchTileset()" style="flex:1;"></select>
                    <input type="file" id="addTilesetInput" accept="image/*" onchange="addTileset(event)" style="display:none;">
                    <button onclick="document.getElementById('addTilesetInput').click()" style="padding:5px 10px;" title="Add tileset">+</button>
                    <button onclick="deleteTileset()" style="padding:5px 10px; background:#a55;" title="Delete tileset">√ó</button>
                </div>
                <div class="tileset-container">
                    <canvas id="paintTilesetCanvas"></canvas>
                </div>

                <div style="margin-top:10px;">
                    <button id="copyFromMapBtn" onclick="startCopyFromMap()" style="background:#666;">Copy from Map</button>
                    <span id="copyModeInfo" style="display:none; font-size:11px; color:#4af; margin-left:8px;">Click & drag on map to select area</span>
                </div>

                <button onclick="goBackToCollision()" style="margin-top:15px; background:#555;">Edit Tile Collisions</button>

                <h3 style="margin-top:15px;">Layers</h3>
                <div id="layerList"></div>
                <button onclick="addLayer()" style="margin-top:5px;">+ Add Layer</button>

                <h3 style="margin-top:15px;">Player Sprite</h3>
                <div style="display:flex; gap:8px; align-items:center;">
                    <canvas id="playerSpritePreview" width="48" height="48" style="border:1px solid #555; border-radius:4px; background:#222; image-rendering:pixelated;"></canvas>
                    <div style="flex:1;">
                        <input type="file" id="playerSpriteInput" accept="image/*" onchange="loadPlayerSprite(event)" style="display:none;">
                        <button onclick="document.getElementById('playerSpriteInput').click()" style="width:100%; margin-bottom:5px;">Upload Sprite</button>
                        <div id="playerSpriteInfo" style="font-size:10px; color:#888;">Default sprite</div>
                    </div>
                </div>
            </div>

            <!-- NPC MODE -->
            <div id="npcModeContent" style="display:none;">
                <h3>NPCs</h3>

                <div id="npcListContainer">
                    <div id="npcList" style="margin-bottom:10px;"></div>
                    <button onclick="openNpcEditor()" style="width:100%;">+ Create NPC</button>
                </div>

                <p style="font-size:10px; color:#666; margin-top:10px;">Select NPC from list, then click map to place.</p>

                <h3 style="margin-top:15px;">Placed NPCs</h3>
                <div id="placedNpcList" style="max-height:120px; overflow-y:auto; font-size:11px; color:#888;">
                    No NPCs placed
                </div>

                <!-- Path Editor Panel (shown when NPC selected) -->
                <div id="npcPathPanel" style="display:none; margin-top:15px; padding:10px; background:#1a1a2e; border-radius:5px;">
                    <h3 style="margin-top:0;">Path for: <span id="npcPathName">NPC</span></h3>

                    <div style="margin-bottom:10px;">
                        <button id="npcDrawPathBtn" onclick="toggleNpcPathDrawing()" style="width:100%; background:#4a4;">Draw Path</button>
                        <p id="npcPathInfo" style="font-size:10px; color:#666; margin-top:5px;">Click tiles to add waypoints</p>
                    </div>

                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px;">Trigger:</label>
                        <select id="npcTriggerType" onchange="updateNpcTrigger()" style="width:100%; margin-top:3px;">
                            <option value="loop">Loop (always walking)</option>
                            <option value="interact">On Interact (attack)</option>
                            <option value="timeDay">Time: Day only</option>
                            <option value="timeNight">Time: Night only</option>
                        </select>
                    </div>

                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px;">Walk Speed:</label>
                        <input type="range" id="npcWalkSpeed" min="1" max="10" value="3" onchange="updateNpcSpeed()" style="width:100%;">
                        <span id="npcSpeedValue" style="font-size:10px; color:#888;">3</span>
                    </div>

                    <div style="display:flex; gap:5px; margin-bottom:8px;">
                        <button id="npcPreviewPathBtn" onclick="toggleNpcPathPreview()" style="flex:1; background:#47a;">‚ñ∂ Preview</button>
                        <button onclick="clearNpcPath()" style="flex:1; background:#a55;">Clear Path</button>
                    </div>
                    <button onclick="deleteSelectedPlacedNpc()" style="width:100%; background:#a33;">Delete NPC</button>

                    <div id="npcWaypointList" style="margin-top:10px; font-size:10px; color:#888; max-height:80px; overflow-y:auto;">
                        No waypoints
                    </div>
                </div>
            </div>

            <!-- ANIMATED PROPS MODE -->
            <div id="animPropModeContent" style="display:none;">
                <h3>Animated Props</h3>

                <!-- Animated Prop List -->
                <div id="animPropListContainer">
                    <div id="animPropList" style="margin-bottom:10px;"></div>
                    <button onclick="openAnimPropEditor()" style="width:100%;">+ Create Animated Prop</button>
                </div>

                <p style="font-size:10px; color:#666; margin-top:10px;">Select prop from list, then click map to place. Right-click to remove.</p>

                <h3 style="margin-top:15px;">Layers</h3>
                <div id="animPropLayerList"></div>
                <button onclick="addLayer()" style="margin-top:5px;">+ Add Layer</button>
            </div>

            <!-- SOUND MODE -->
            <div id="soundModeContent" style="display:none;">
                <h3>Sounds</h3>

                <!-- Sound Library -->
                <div style="margin-bottom:15px;">
                    <div style="display:flex; gap:5px; align-items:center; margin-bottom:8px;">
                        <select id="soundSelect" onchange="switchSound()" style="flex:1;"></select>
                        <input type="file" id="soundInput" accept="audio/*" onchange="loadSound(event)" style="display:none;">
                        <button onclick="document.getElementById('soundInput').click()" style="padding:5px 10px;" title="Add Sound">+</button>
                    </div>
                    <div id="soundControls" style="display:none;">
                        <div style="display:flex; gap:5px; margin-bottom:8px;">
                            <button onclick="previewSound()" style="flex:1;">‚ñ∂ Preview</button>
                            <button onclick="stopPreview()" style="flex:1;">‚ñ† Stop</button>
                        </div>
                        <div id="currentSoundInfo" style="font-size:10px; color:#888;"></div>
                    </div>
                    <div id="noSoundMessage" style="color:#888; font-size:11px; padding:10px; text-align:center;">
                        Click + to add sounds
                    </div>
                </div>

                <!-- Attach Mode -->
                <h4 style="margin:15px 0 8px 0; color:#4af;">Attach To:</h4>
                <div style="display:flex; gap:5px; margin-bottom:10px;">
                    <button id="soundAttachTile" class="active" onclick="setSoundAttachMode('tile')" style="flex:1;">Tile Position</button>
                    <button id="soundAttachPlayer" onclick="setSoundAttachMode('player')" style="flex:1;">Player Action</button>
                </div>

                <!-- Tile Mode Options -->
                <div id="tileSoundOptions">
                    <!-- Selection indicator -->
                    <div id="soundEditMode" style="background:#2a4a3a; padding:8px; border-radius:4px; margin-bottom:10px; display:none;">
                        <span style="color:#4f8;">Editing: <span id="editingSoundKey"></span></span>
                        <button onclick="deselectTileSound()" style="float:right; padding:2px 8px; font-size:10px;">Cancel</button>
                    </div>

                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Radius: <span id="soundRadiusVal">3</span> tiles
                        </label>
                        <input type="range" id="soundRadius" min="1" max="50" value="3" oninput="document.getElementById('soundRadiusVal').textContent=this.value" style="width:100%;">
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="soundLoop" checked> Loop continuously
                        </label>
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Volume: <span id="soundVolumeVal">50</span>%
                        </label>
                        <input type="range" id="soundVolume" min="0" max="100" value="50" oninput="document.getElementById('soundVolumeVal').textContent=this.value" style="width:100%;">
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Fade Distance: <span id="soundFadeVal">50</span>%
                        </label>
                        <input type="range" id="soundFade" min="0" max="100" value="50" oninput="document.getElementById('soundFadeVal').textContent=this.value" style="width:100%;">
                        <p style="font-size:9px; color:#555; margin-top:2px;">How much of radius is fade zone (0=abrupt, 100=full fade)</p>
                    </div>

                    <!-- Action buttons -->
                    <div style="display:flex; gap:5px; margin:10px 0;">
                        <button id="soundSaveBtn" onclick="saveSelectedSound()" style="flex:1; padding:8px; background:#4a7c59;">Save Changes</button>
                        <button onclick="deselectTileSound()" style="flex:1; padding:8px; background:#555;">New Sound</button>
                    </div>
                    <p style="font-size:10px; color:#666;">Click map to place new or select existing. Right-click to remove.</p>

                    <h4 style="margin:15px 0 8px 0; color:#4af;">Placed Sounds:</h4>
                    <div id="placedSoundsList" style="max-height:150px; overflow-y:auto; font-size:11px;"></div>
                </div>

                <!-- Player Mode Options -->
                <div id="playerSoundOptions" style="display:none;">
                    <div style="margin-bottom:10px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">Action:</label>
                        <select id="playerActionSelect" onchange="updatePlayerSoundUI()" style="width:100%;">
                            <option value="walk">Walk</option>
                            <option value="attack">Attack</option>
                        </select>
                    </div>
                    <div id="walkSoundSettings">
                        <div style="margin-bottom:8px;">
                            <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                                Step Interval: <span id="walkIntervalVal">200</span>ms
                            </label>
                            <input type="range" id="walkInterval" min="100" max="400" value="200" oninput="document.getElementById('walkIntervalVal').textContent=this.value" style="width:100%;">
                        </div>
                        <div style="margin-bottom:8px;">
                            <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                                Pitch Variation: <span id="walkPitchVal">10</span>%
                            </label>
                            <input type="range" id="walkPitch" min="0" max="30" value="10" oninput="document.getElementById('walkPitchVal').textContent=this.value" style="width:100%;">
                        </div>
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Volume: <span id="playerSoundVolumeVal">50</span>%
                        </label>
                        <input type="range" id="playerSoundVolume" min="0" max="100" value="50" oninput="document.getElementById('playerSoundVolumeVal').textContent=this.value" style="width:100%;">
                    </div>
                    <button onclick="assignPlayerSound()" style="width:100%; margin-top:5px;">Assign Selected Sound</button>

                    <h4 style="margin:15px 0 8px 0; color:#4af;">Current Assignments:</h4>
                    <div id="playerSoundAssignments" style="font-size:11px; color:#aaa;">
                        <div>Walk: <span id="walkSoundName">None</span></div>
                        <div>Attack: <span id="attackSoundName">None</span></div>
                    </div>
                </div>
            </div>

            <!-- LIGHTING MODE -->
            <div id="lightingModeContent" style="display:none;">
                <h3>Lighting</h3>

                <!-- Preview Toggle -->
                <button id="lightingPreviewBtn" onclick="toggleLightingPreview()" style="width:100%; padding:10px; margin-bottom:15px; background:#2a5a8a; font-weight:bold;">
                    üëÅÔ∏è Preview Lighting: OFF
                </button>

                <!-- Global Settings -->
                <div style="margin-bottom:15px; padding:10px; background:#1a2a1a; border-radius:4px;">
                    <h4 style="margin:0 0 10px 0; color:#4af;">Global Settings</h4>
                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="ambientEnabled" onchange="updateLightingSettings()"> Enable Ambient Lighting
                        </label>
                    </div>
                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="blobShadows" checked onchange="updateLightingSettings()"> Blob Shadows (under sprites)
                        </label>
                    </div>
                </div>

                <!-- Time of Day -->
                <div style="margin-bottom:15px; padding:10px; background:#1a1a2a; border-radius:4px;">
                    <h4 style="margin:0 0 10px 0; color:#4af;">Time of Day</h4>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:5px;">
                        <button id="todDawn" onclick="setTimeOfDay('dawn')" style="padding:8px; background:#4a3520;">üåÖ Dawn</button>
                        <button id="todDay" onclick="setTimeOfDay('day')" class="active" style="padding:8px; background:#2a4a2a;">‚òÄÔ∏è Day</button>
                        <button id="todDusk" onclick="setTimeOfDay('dusk')" style="padding:8px; background:#4a2520;">üåá Dusk</button>
                        <button id="todNight" onclick="setTimeOfDay('night')" style="padding:8px; background:#1a1a3a;">üåô Night</button>
                    </div>
                    <p style="font-size:9px; color:#555; margin-top:8px; text-align:center;">Affects ambient overlay color and darkness</p>
                </div>

                <!-- Player Light -->
                <div style="margin-bottom:15px; padding:10px; background:#2a2a1a; border-radius:4px;">
                    <h4 style="margin:0 0 10px 0; color:#4af;">Player Torch</h4>
                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="playerLight" onchange="updateLightingSettings()"> Player carries light
                        </label>
                    </div>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Light Radius: <span id="playerLightRadiusVal">4</span> tiles
                        </label>
                        <input type="range" id="playerLightRadius" min="1" max="10" value="4" oninput="document.getElementById('playerLightRadiusVal').textContent=this.value; updateLightingSettings();" style="width:100%;">
                    </div>
                </div>

                <!-- Point Lights -->
                <div style="margin-bottom:15px; padding:10px; background:#2a1a2a; border-radius:4px;">
                    <h4 style="margin:0 0 10px 0; color:#4af;">Point Lights</h4>
                    <div style="margin-bottom:8px;">
                        <label style="display:block; font-size:11px; color:#aaa; margin-bottom:3px;">
                            Light Radius: <span id="pointLightRadiusVal">3</span> tiles
                        </label>
                        <input type="range" id="pointLightRadius" min="1" max="10" value="3" oninput="document.getElementById('pointLightRadiusVal').textContent=this.value" style="width:100%;">
                    </div>
                    <div style="margin-bottom:10px;">
                        <label style="font-size:11px; color:#aaa;">
                            <input type="checkbox" id="pointLightFlicker"> Flicker effect
                        </label>
                    </div>
                    <p style="font-size:10px; color:#666;">Click map to place lights. Right-click to remove.</p>

                    <h4 style="margin:15px 0 8px 0; color:#4af;">Placed Lights:</h4>
                    <div id="placedLightsList" style="max-height:150px; overflow-y:auto; font-size:11px;"></div>
                </div>
            </div>
        </div>

        <div class="map-panel">
            <div class="toolbar">
                <button onclick="undo()" id="undoBtn" title="Undo (Ctrl+Z)" style="background:#555;">‚Ü∂ Undo</button>
                <button onclick="redo()" id="redoBtn" title="Redo (Ctrl+Y)" style="background:#555;">‚Ü∑ Redo</button>
                <button onclick="clearMap()">Clear</button>
                <button onclick="saveProject()">Quick Save</button>
                <button onclick="downloadProject()" style="background:#2a7;">Download File</button>
                <button onclick="document.getElementById('projectFileInput').click()" style="background:#555;">Load File</button>
                <input type="file" id="projectFileInput" accept=".json" style="display:none;" onchange="uploadProject(event)">
                <button onclick="exportConfig()">Export</button>
                <button onclick="testMap()" style="background:#e74c3c;">Test Map</button>
                <button id="grabToolBtn" onclick="toggleGrabTool()" style="background:#555;">‚úã Grab</button>
                <div class="zoom-controls">
                    <button onclick="zoomOut()">-</button>
                    <span id="zoomLevel">2x</span>
                    <button onclick="zoomIn()">+</button>
                </div>
                <div class="zoom-controls">
                    <button id="undoBtn" onclick="undo()" title="Undo">‚Ü©</button>
                    <button id="redoBtn" onclick="redo()" title="Redo">‚Ü™</button>
                </div>
                <span id="toolHint">Paint | R:rotate | I:flip | E:erase</span>
            </div>
            <div class="map-viewport" id="mapViewport">
                <!-- Expand buttons -->
                <button class="expand-btn expand-top" onclick="expandMap('top')" title="Expand up">+</button>
                <button class="expand-btn expand-bottom" onclick="expandMap('bottom')" title="Expand down">+</button>
                <button class="expand-btn expand-left" onclick="expandMap('left')" title="Expand left">+</button>
                <button class="expand-btn expand-right" onclick="expandMap('right')" title="Expand right">+</button>
                <canvas id="mapCanvas"></canvas>
            </div>
        </div>
    </div>

    <!-- State picker popup -->
    <div class="state-picker" id="statePicker">
        <h3 style="margin-bottom:10px;">Select State</h3>
        <div id="stateOptions"></div>
    </div>

    <!-- NPC Editor Modal -->
    <div class="anim-modal" id="npcModal">
        <div class="anim-modal-content">
            <!-- Sidebar -->
            <div class="anim-sidebar">
                <h2 style="margin-top:0;">NPC</h2>

                <!-- Step 1: Load Sprite Sheet -->
                <div style="margin-bottom:15px;">
                    <h3>1. Sprite Sheet</h3>
                    <input type="file" id="npcFileInput" accept="image/*" onchange="npcLoadSheet(event)" style="display:none;">
                    <button onclick="document.getElementById('npcFileInput').click()" style="width:100%;">Load Image</button>
                    <div id="npcFileName" style="font-size:11px; color:#4af; margin-top:5px;"></div>
                </div>

                <!-- Step 2: Frame Size -->
                <div id="npcFrameSection" style="margin-bottom:15px; display:none;">
                    <h3>2. Frame Size</h3>
                    <div style="display:flex; gap:5px; flex-wrap:wrap; margin-bottom:8px;">
                        <button onclick="npcSetFrameSize(16,16)" style="padding:4px 8px; font-size:11px;">16x16</button>
                        <button onclick="npcSetFrameSize(16,32)" style="padding:4px 8px; font-size:11px;">16x32</button>
                        <button onclick="npcSetFrameSize(32,32)" style="padding:4px 8px; font-size:11px;">32x32</button>
                        <button onclick="npcSetFrameSize(32,64)" style="padding:4px 8px; font-size:11px;">32x64</button>
                        <button onclick="npcSetFrameSize(48,48)" style="padding:4px 8px; font-size:11px;">48x48</button>
                        <button onclick="npcResetGrid()" style="padding:4px 8px; font-size:11px; background:#a55;">Reset</button>
                    </div>
                    <div style="font-size:11px; color:#888;" id="npcGridInfo"></div>
                </div>

                <!-- Step 3: Animation Selection -->
                <div id="npcAnimSection" style="margin-bottom:15px; display:none;">
                    <h3>3. Select Animation</h3>
                    <div style="display:flex; flex-direction:column; gap:5px;">
                        <button id="npcAnimDown" onclick="npcSelectAnim('walkDown')" class="active" style="padding:6px; font-size:11px;">Walk Down</button>
                        <button id="npcAnimUp" onclick="npcSelectAnim('walkUp')" style="padding:6px; font-size:11px;">Walk Up</button>
                        <button id="npcAnimLeft" onclick="npcSelectAnim('walkLeft')" style="padding:6px; font-size:11px;">Walk Left</button>
                        <button id="npcAnimRight" onclick="npcSelectAnim('walkRight')" style="padding:6px; font-size:11px;">Walk Right</button>
                        <button id="npcAnimIdle" onclick="npcSelectAnim('idle')" style="padding:6px; font-size:11px;">Idle</button>
                    </div>
                    <p style="font-size:10px; color:#666; margin-top:8px;">Select animation type, then click frames on sprite sheet</p>
                </div>

                <!-- Step 4: Name -->
                <div id="npcNameSection" style="margin-bottom:15px; display:none;">
                    <h3>4. Name</h3>
                    <input type="text" id="npcNameInput" placeholder="e.g. villager, guard" style="width:100%;">
                </div>

                <!-- Actions -->
                <div style="margin-top:auto;">
                    <button onclick="npcSave()" style="width:100%; background:#4af; color:#000; margin-bottom:10px;">Save NPC</button>
                    <button onclick="npcCancel()" style="width:100%; background:#a55;">Cancel</button>
                </div>
            </div>

            <!-- Main Area -->
            <div class="anim-main">
                <div class="anim-header">
                    <h2>Sprite Sheet</h2>
                    <span style="color:#888; font-size:12px;">Click frames to add to current animation</span>
                </div>

                <div class="anim-canvas-area">
                    <canvas id="npcEditorCanvas"></canvas>
                </div>

                <!-- Bottom Bar: Animation Frames -->
                <div class="anim-frames-bar">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span><strong id="npcCurrentAnimName" style="color:#4af;">Walk Down</strong>: <span id="npcFrameCount">0</span> frames</span>
                        <div style="display:flex; align-items:center; gap:15px;">
                            <!-- Live Preview (larger) -->
                            <div style="display:flex; align-items:center; gap:10px;">
                                <canvas id="npcLivePreview" width="96" height="96" style="border:2px solid #4af; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                                <div style="font-size:11px;">
                                    <div style="display:flex; align-items:center; gap:5px;">
                                        <span style="color:#888;">Speed:</span>
                                        <input type="range" id="npcSpeedSlider" min="1" max="24" value="8" style="width:80px;" oninput="npcUpdateSpeed()">
                                        <span id="npcSpeedLabel" style="color:#4af; min-width:35px;">8 fps</span>
                                    </div>
                                </div>
                            </div>
                            <button onclick="npcClearCurrentAnim()" style="background:#a55; padding:5px 10px; font-size:11px;">Clear</button>
                        </div>
                    </div>
                    <div class="anim-frames-list" id="npcFramesList"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Animated Prop Editor Modal -->
    <div class="anim-modal" id="animPropModal">
        <div class="anim-modal-content">
            <!-- Sidebar -->
            <div class="anim-sidebar">
                <h2 style="margin-top:0;">Animated Prop</h2>

                <!-- Step 1: Load Sprite Sheet -->
                <div style="margin-bottom:20px;">
                    <h3>1. Sprite Sheet</h3>
                    <input type="file" id="animPropFileInput" accept="image/*" onchange="animPropLoadSheet(event)">
                    <button onclick="document.getElementById('animPropFileInput').click()" style="width:100%;">Load Image</button>
                    <div id="animPropFileName" style="font-size:11px; color:#4af; margin-top:5px;"></div>
                </div>

                <!-- Step 2: Frame Size -->
                <div id="animPropFrameSection" style="margin-bottom:20px; display:none;">
                    <h3>2. Frame Size</h3>
                    <div style="display:flex; gap:10px; margin-bottom:10px;">
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Width:</label>
                            <input type="number" id="animPropFrameW" value="16" min="8" max="256" onchange="animPropUpdateGrid()" style="width:100%;">
                        </div>
                        <div style="flex:1;">
                            <label style="font-size:11px; color:#888;">Height:</label>
                            <input type="number" id="animPropFrameH" value="16" min="8" max="256" onchange="animPropUpdateGrid()" style="width:100%;">
                        </div>
                    </div>
                    <div style="font-size:11px; color:#888;" id="animPropGridInfo"></div>
                </div>

                <!-- Step 3: Animation Type -->
                <div id="animPropTypeSection" style="margin-bottom:20px; display:none;">
                    <h3>3. Animation Type</h3>
                    <select id="animPropType" style="width:100%;" onchange="animPropTypeChanged()">
                        <option value="loop">Loop (continuous)</option>
                        <option value="interactive">Interactive (on trigger)</option>
                    </select>
                    <p style="font-size:10px; color:#666; margin-top:5px;">Adjust speed with slider in preview below</p>
                </div>

                <!-- Step 4: Collision & Depth -->
                <div id="animPropCollisionSection" style="margin-bottom:20px; display:none;">
                    <h3>4. Collision & Depth</h3>
                    <div style="display:flex; gap:5px; flex-wrap:wrap; margin-bottom:10px;">
                        <button id="animPropToolNone" class="active" onclick="setAnimPropTool('none')" style="padding:5px 8px; font-size:11px;">Select</button>
                        <button id="animPropToolCollision" onclick="setAnimPropTool('collision')" style="padding:5px 8px; font-size:11px; background:#a55;">Collision</button>
                        <button id="animPropToolErase" onclick="setAnimPropTool('erase')" style="padding:5px 8px; font-size:11px;">Erase</button>
                        <button id="animPropToolSplit" onclick="setAnimPropTool('split')" style="padding:5px 8px; font-size:11px; background:#0aa;">Split</button>
                    </div>

                    <!-- Brush Size for Collision -->
                    <div id="animPropBrushSection" style="display:none; margin-bottom:10px;">
                        <span style="font-size:10px; color:#aaa;">Brush:</span>
                        <button id="animPropBrush1" onclick="setAnimPropBrush(1)" style="padding:3px 6px; font-size:10px;">1</button>
                        <button id="animPropBrush2" onclick="setAnimPropBrush(2)" style="padding:3px 6px; font-size:10px;">2</button>
                        <button id="animPropBrush4" class="active" onclick="setAnimPropBrush(4)" style="padding:3px 6px; font-size:10px;">4</button>
                        <button id="animPropBrush8" onclick="setAnimPropBrush(8)" style="padding:3px 6px; font-size:10px;">8</button>
                    </div>

                    <!-- Split Controls -->
                    <div id="animPropSplitControls" style="display:none; margin-bottom:10px; padding:8px; background:#1a3a3e; border-radius:5px;">
                        <div style="font-size:10px; color:#0ff; margin-bottom:5px;">Draw split line on tiles (drag to draw)</div>
                        <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                            <label style="font-size:10px; display:flex; align-items:center; gap:4px; cursor:pointer;">
                                <input type="checkbox" id="animPropFlatLine" checked>
                                <span>Flat Line</span>
                            </label>
                            <span style="font-size:10px;">Y:</span>
                            <input type="number" id="animPropSplitY" value="8" min="0" max="16" style="width:40px; padding:2px; font-size:10px;">
                            <button onclick="setAnimPropSplitY()" style="padding:2px 6px; font-size:9px; background:#0aa;">Set Y</button>
                            <button onclick="clearAnimPropSplit()" style="padding:2px 6px; font-size:9px; background:#a55;">Clear</button>
                        </div>
                        <div style="font-size:9px; color:#888; margin-top:4px;">C = Canopy (top) | T = Trunk (Y-sorted)</div>
                    </div>

                    <p style="font-size:10px; color:#666;">Paint on any frame. Collision/split data applies to all frames.</p>
                </div>

                <!-- Step 5: Name -->
                <div id="animPropNameSection" style="margin-bottom:20px; display:none;">
                    <h3>5. Name</h3>
                    <input type="text" id="animPropNameInput" placeholder="e.g. torch, chest, door" style="width:100%;">
                </div>

                <!-- Actions -->
                <div style="margin-top:auto;">
                    <button onclick="animPropSave()" style="width:100%; background:#4af; color:#000; margin-bottom:10px;">Save Prop</button>
                    <button onclick="animPropCancel()" style="width:100%; background:#a55;">Cancel</button>
                </div>
            </div>

            <!-- Main Area -->
            <div class="anim-main">
                <div class="anim-header">
                    <h2>Sprite Sheet</h2>
                    <span style="color:#888; font-size:12px;">Click or drag to select frames (multi-tile supported)</span>
                </div>

                <div class="anim-canvas-area">
                    <canvas id="animPropEditorCanvas"></canvas>
                </div>

                <!-- Bottom Bar: Animation Frames -->
                <div class="anim-frames-bar">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                        <span>Animation Frames: <strong id="animPropFrameCount" style="color:#4af;">0</strong></span>
                        <div style="display:flex; align-items:center; gap:15px;">
                            <!-- Live Preview -->
                            <div style="display:flex; align-items:center; gap:8px;">
                                <canvas id="animPropLivePreview" width="48" height="48" style="border:2px solid #4af; border-radius:4px; background:#111; image-rendering:pixelated;"></canvas>
                                <div style="font-size:11px;">
                                    <div style="display:flex; align-items:center; gap:5px;">
                                        <span style="color:#888;">Speed:</span>
                                        <input type="range" id="animPropSpeedSlider" min="1" max="24" value="8" style="width:80px;" oninput="animPropUpdateSpeed()">
                                        <span id="animPropSpeedLabel" style="color:#4af; min-width:35px;">8 fps</span>
                                    </div>
                                </div>
                            </div>
                            <button onclick="animPropClearFrames()" style="background:#a55; padding:5px 10px; font-size:11px;">Clear</button>
                        </div>
                    </div>
                    <div class="anim-frames-list" id="animPropFramesList"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== GLOBALS =====
        let currentPhase = 'load'; // 'load', 'collision', 'build'
        let gridSize = 16;
        let zoom = 2;
        let mapCols = 40;
        let mapRows = 30;

        let tilesetImg = null;
        let tilesets = []; // Array of { name, img, data } for multiple tilesets
        let currentTilesetIndex = 0;
        let tileCollisions = {}; // "tilesetIndex:x,y" -> [{x,y}, ...]
        let selectedTileData = null;
        let selectionStart = null; // For multi-tile selection
        let selectedTiles = []; // Array of {x, y} for multi-tile selection
        let hoverMapPos = null; // Current hover position on map for preview
        let tileRotation = 0; // 0, 90, 180, 270 degrees
        let tileFlippedH = false; // Flip tile horizontally
        let eraseMode = false; // Erase tiles instead of painting

        // Layers
        let layers = []; // Array of layer data, each layer is a 2D array like map
        let currentLayer = 0;
        let layerVisibility = []; // Which layers are visible
        let layerNames = []; // Custom names for layers

        // Player layer (for visualization - uneditable, undeletable)
        let playerLayerIndex = 1; // Which layer position the player appears at
        let playerPreviewPos = { x: 5, y: 5 }; // Position on map for player preview
        let playerPreviewVisible = true;
        let draggingPlayer = false; // For dragging player preview

        // Brush settings
        let brushPainting = false;
        let brushErasing = false;
        let collisionZoom = 6;
        let collisionTool = 'paint'; // 'paint' or 'erase'
        let brushSize = 4; // Brush size in pixels

        // Pixel collision masks per tile
        let collisionMasks = {}; // "x,y" -> 2D array of booleans

        // Depth split lines for Y-sorting (trunk vs canopy)
        let tileSplitLines = {}; // "tilesetIndex:x,y" -> array of Y values per column (freeform line)
        let selectedSplitTile = null; // {x, y, tilesetIndex} - currently selected tile for splitting
        let draggingSplitLine = false; // true when dragging the split line
        let flatLineMode = true; // when true, split lines are always horizontal

        // Panning
        let collisionPanX = 0;
        let collisionPanY = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;

        let mode = 'tile';
        let currentMap = 'main'; // Current map name (for multi-map support)

        // Player sprite (embedded as base64)
        let playerSpriteData = null; // Base64 data URL of player sprite
        let playerSpriteImg = null; // Image object for preview

        // Copy from map mode
        let copyMode = false;
        let copyStart = null;
        let copyEnd = null;
        let copiedTiles = null; // 2D array of copied tile data

        // Multiple props system - array of prop images like tilesets
        let props = []; // Array of { name, img, data, collisionMasks }
        let currentPropIndex = -1;
        let propImage = null; // Current prop image (shortcut)
        let propImageData = null; // Current prop data (shortcut)
        let propSelection = null; // {x, y, width, height}
        let propCollisionMasks = {}; // Current prop's collision masks
        let propTool = 'select'; // 'select', 'collision', 'erase'
        let propBrushSize = 4;
        let propPainting = false;

        // Animated Props System
        let animatedProps = []; // Array of animated prop definitions { name, spriteData, frameWidth, frameHeight, frames: [{x,y,w,h},...], type: 'loop'|'interactive', fps }
        let currentAnimPropIndex = -1;
        let animPropSpriteSheet = null; // Current sprite sheet Image
        let animPropSpriteData = null; // Current sprite data URL
        let animPropFrames = []; // Frames being edited
        let animPropPreviewPlaying = false;
        let animPropPreviewFrame = 0;
        let animPropPreviewInterval = null;
        let placedAnimProps = []; // Animated props placed on map: { propIndex, x, y, layer } (grid coords like tiles)
        // Drag selection for multi-tile frames
        let animPropDragStart = null; // {gridX, gridY}
        let animPropDragEnd = null; // {gridX, gridY}
        let animPropIsDragging = false;
        // Animation state for placed props in editor
        let placedAnimPropFrames = {}; // key: "x,y,layer" -> { frame: 0, timer: 0 }
        let editorAnimInterval = null;

        // NPC System
        let npcs = []; // Array of NPC definitions { name, spriteData, frameWidth, frameHeight, animations: {...}, fps }
        let currentNpcIndex = -1;
        let placedNpcs = []; // NPCs placed on map: { npcIndex, x, y, path: [{x,y},...], trigger, speed }
        let selectedPlacedNpcIndex = -1; // Currently selected placed NPC for editing
        let npcPathDrawing = false; // Currently drawing a path
        let npcEditorImage = null;

        // NPC Path Preview
        let npcPathPreviewActive = false;
        let npcPreviewAnimId = null;
        let npcPreviewState = null; // { x, y, waypointIndex, direction, frame, frameTimer }
        let npcEditorData = null;
        let npcEditorFrameW = 16;
        let npcEditorFrameH = 16;
        let npcEditorEditingIndex = -1;
        let npcFrames = []; // Frames being edited
        let npcPreviewPlaying = false;
        let npcPreviewFrame = 0;
        let npcPreviewInterval = null;

        // Sound System
        let sounds = []; // Array of { name, data, duration, type: 'ambient'|'action' }
        let currentSoundIndex = -1;
        let soundAttachMode = 'tile'; // 'tile' or 'player'
        let tileSounds = {}; // "x,y" -> { soundIndex, radius, loop, volume, fadePercent }
        let playerSounds = {
            walk: { soundIndex: -1, interval: 200, volume: 0.5, pitchVariation: 0.1 },
            attack: { soundIndex: -1, volume: 0.7 }
        };
        let previewAudio = null; // For sound preview playback
        let selectedTileSoundKey = null; // Currently selected tile sound for editing

        // Lighting System (Classic 2D - no WebGL)
        let lightingSettings = {
            blobShadows: true,
            ambientEnabled: false,
            timeOfDay: 'day',  // 'dawn', 'day', 'dusk', 'night'
            playerLight: false,
            playerLightRadius: 4
        };
        const TIME_PRESETS = {
            dawn:  { r: 0, g: 0, b: 20, a: 0.45 },   // Light darkness
            day:   { r: 0, g: 0, b: 0, a: 0 },        // No overlay
            dusk:  { r: 0, g: 0, b: 20, a: 0.55 },   // Medium darkness
            night: { r: 0, g: 0, b: 20, a: 0.95 }    // Full darkness (100%)
        };
        let pointLights = {};  // "mapName:x,y" -> { radius, flicker }

        // Door System - numbered door pairs that teleport to each other
        let doors = {}; // "mapName:x,y" -> { doorNumber: 1, 2, 3... }
        let currentDoorNumber = 1; // Currently selected door number to place

        let map = [];

        // Canvas refs
        const collisionTilesetCanvas = document.getElementById('collisionTilesetCanvas');
        const collisionTilesetCtx = collisionTilesetCanvas.getContext('2d');
        const paintTilesetCanvas = document.getElementById('paintTilesetCanvas');
        const paintTilesetCtx = paintTilesetCanvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        const propTilesetCanvas = document.getElementById('propTilesetCanvas');
        const propTilesetCtx = propTilesetCanvas ? propTilesetCanvas.getContext('2d') : null;

        // ===== PROP TOOLS =====
        function setPropTool(tool) {
            propTool = tool;
            document.getElementById('propToolSelect').classList.remove('active');
            document.getElementById('propToolCollision').classList.remove('active');
            document.getElementById('propToolErase').classList.remove('active');
            document.getElementById('propTool' + tool.charAt(0).toUpperCase() + tool.slice(1)).classList.add('active');

            // Show/hide brush controls
            document.getElementById('propBrushControls').style.display =
                (tool === 'collision' || tool === 'erase') ? 'block' : 'none';

            // Update cursor
            if (propTilesetCanvas) propTilesetCanvas.style.cursor = (tool === 'select') ? 'crosshair' : 'cell';

            drawPropTileset();
        }

        function setPropBrushSize(size) {
            propBrushSize = size;
            document.querySelectorAll('[id^="propBrush"]').forEach(b => b.classList.remove('active'));
            document.getElementById('propBrush' + size).classList.add('active');
        }

        // ===== PHASE MANAGEMENT =====
        function setPhase(phase) {
            currentPhase = phase;
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('active'));
            document.getElementById(phase + 'Phase').classList.add('active');

            // Start/stop editor animation loop based on phase
            if (phase === 'build') {
                startEditorAnimLoop();
            } else {
                stopEditorAnimLoop();
            }
        }

        // Animation loop for animated props in the editor
        function startEditorAnimLoop() {
            if (editorAnimInterval) return;
            editorAnimInterval = setInterval(() => {
                let needsRender = false;

                // Scan all layers for animTile cells
                for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {
                    const layer = layers[layerIdx];
                    if (!layer) continue;

                    for (let y = 0; y < layer.length; y++) {
                        if (!layer[y]) continue;
                        for (let x = 0; x < layer[y].length; x++) {
                            const cell = layer[y][x];
                            if (!cell || cell.type !== 'animTile') continue;

                            const prop = animatedProps[cell.propIndex];
                            if (!prop || !prop.frames || prop.frames.length <= 1) continue;
                            if (prop.type !== 'loop') continue;

                            const key = x + ',' + y + ',' + layerIdx;
                            if (!placedAnimPropFrames[key]) {
                                placedAnimPropFrames[key] = { frame: 0, timer: 0 };
                            }
                            placedAnimPropFrames[key].timer++;

                            const fps = prop.fps || 8;
                            const frameDelay = Math.round(60 / fps);

                            if (placedAnimPropFrames[key].timer >= frameDelay) {
                                placedAnimPropFrames[key].timer = 0;
                                placedAnimPropFrames[key].frame++;
                                needsRender = true;
                            }
                        }
                    }
                }

                if (needsRender) renderMap();
            }, 1000 / 60); // 60fps update
        }

        function stopEditorAnimLoop() {
            if (editorAnimInterval) {
                clearInterval(editorAnimInterval);
                editorAnimInterval = null;
            }
        }

        // ===== LOAD PHASE =====
        function loadTileset(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Add as first tileset
                    tilesets = [{ name: file.name, img: img, data: e.target.result }];
                    currentTilesetIndex = 0;
                    tilesetImg = img;
                    updateTilesetDropdown();
                    setPhase('collision');
                    rebuildCollisionView();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function addTileset(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    tilesets.push({ name: file.name, img: img, data: e.target.result });
                    currentTilesetIndex = tilesets.length - 1;
                    tilesetImg = img;
                    updateTilesetDropdown();
                    drawPaintTileset();
                    drawPropTileset();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = ''; // Reset input so same file can be selected again
        }

        function switchTileset() {
            const select = document.getElementById('tilesetSelect');
            currentTilesetIndex = parseInt(select.value);
            tilesetImg = tilesets[currentTilesetIndex].img;
            selectedTileData = null; // Clear selection
            selectedTiles = [];
            drawPaintTileset();
            drawPropTileset();
            renderMap();
        }

        function updateTilesetDropdown() {
            const select = document.getElementById('tilesetSelect');
            if (!select) return;
            select.innerHTML = '';
            tilesets.forEach((ts, i) => {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = ts.name;
                if (i === currentTilesetIndex) opt.selected = true;
                select.appendChild(opt);
            });
        }

        function deleteTileset() {
            if (tilesets.length === 0) {
                alert('No tileset to delete');
                return;
            }
            if (tilesets.length === 1) {
                alert('Cannot delete the only tileset. Add another one first.');
                return;
            }

            const tileset = tilesets[currentTilesetIndex];
            if (!confirm('Delete tileset "' + tileset.name + '"?\n\nTiles from this tileset on the map will become empty.')) return;

            // Remove tiles from map that use this tileset
            layers.forEach(layer => {
                for (let y = 0; y < layer.length; y++) {
                    for (let x = 0; x < layer[y].length; x++) {
                        const tile = layer[y][x];
                        if (tile && tile.tilesetIndex === currentTilesetIndex) {
                            layer[y][x] = null;
                        } else if (tile && tile.tilesetIndex > currentTilesetIndex) {
                            // Adjust indices for tilesets after the deleted one
                            tile.tilesetIndex--;
                        }
                    }
                }
            });

            // Remove collision data for this tileset
            const keysToDelete = [];
            for (const key in tileCollisions) {
                const [tsIdx] = key.split(':');
                if (parseInt(tsIdx) === currentTilesetIndex) {
                    keysToDelete.push(key);
                }
            }
            keysToDelete.forEach(key => delete tileCollisions[key]);

            // Update collision keys for tilesets after deleted one
            const updatedCollisions = {};
            for (const key in tileCollisions) {
                const [tsIdx, coords] = key.split(':');
                const idx = parseInt(tsIdx);
                if (idx > currentTilesetIndex) {
                    updatedCollisions[(idx - 1) + ':' + coords] = tileCollisions[key];
                } else {
                    updatedCollisions[key] = tileCollisions[key];
                }
            }
            tileCollisions = updatedCollisions;

            // Remove the tileset
            tilesets.splice(currentTilesetIndex, 1);

            // Update current index
            if (currentTilesetIndex >= tilesets.length) {
                currentTilesetIndex = tilesets.length - 1;
            }
            tilesetImg = tilesets[currentTilesetIndex].img;

            // Update UI
            updateTilesetDropdown();
            selectedTileData = null;
            selectedTiles = [];
            drawPaintTileset();
            renderMap();
        }

        // ===== PLAYER SPRITE =====
        function loadPlayerSprite(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                playerSpriteData = e.target.result;
                playerSpriteImg = new Image();
                playerSpriteImg.onload = () => {
                    // Update preview
                    const preview = document.getElementById('playerSpritePreview');
                    const ctx = preview.getContext('2d');
                    ctx.clearRect(0, 0, 48, 48);
                    ctx.imageSmoothingEnabled = false;
                    // Draw first frame (assuming 64x64 frames, top-left)
                    ctx.drawImage(playerSpriteImg, 0, 0, 64, 64, 0, 0, 48, 48);
                    document.getElementById('playerSpriteInfo').textContent =
                        file.name + ' (' + playerSpriteImg.naturalWidth + 'x' + playerSpriteImg.naturalHeight + ')';
                };
                playerSpriteImg.src = playerSpriteData;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function updatePlayerSpritePreview() {
            const preview = document.getElementById('playerSpritePreview');
            if (!preview) return;
            const ctx = preview.getContext('2d');
            ctx.clearRect(0, 0, 48, 48);

            if (playerSpriteImg && playerSpriteImg.complete) {
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(playerSpriteImg, 0, 0, 64, 64, 0, 0, 48, 48);
            }
        }

        // ===== COLLISION PHASE =====
        function rebuildCollisionView() {
            gridSize = parseInt(document.getElementById('gridSize').value);
            drawCollisionTileset();
            updateCollisionStats();
        }

        function drawCollisionTileset() {
            if (!tilesetImg) return;

            collisionTilesetCanvas.width = tilesetImg.naturalWidth * collisionZoom;
            collisionTilesetCanvas.height = tilesetImg.naturalHeight * collisionZoom;

            collisionTilesetCtx.imageSmoothingEnabled = false;
            collisionTilesetCtx.drawImage(tilesetImg, 0, 0, collisionTilesetCanvas.width, collisionTilesetCanvas.height);

            // Grid
            collisionTilesetCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            const cols = Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = Math.floor(tilesetImg.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(x * gridSize * collisionZoom, 0);
                collisionTilesetCtx.lineTo(x * gridSize * collisionZoom, collisionTilesetCanvas.height);
                collisionTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(0, y * gridSize * collisionZoom);
                collisionTilesetCtx.lineTo(collisionTilesetCanvas.width, y * gridSize * collisionZoom);
                collisionTilesetCtx.stroke();
            }

            // Draw pixel collision masks (only for current tileset)
            collisionTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            const keyPrefix = currentTilesetIndex + ':';
            for (let key in collisionMasks) {
                // Only show collisions for current tileset
                if (!key.startsWith(keyPrefix)) continue;

                const mask = collisionMasks[key];
                if (!mask) continue;

                // Parse key format: "tilesetIndex:x,y"
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                for (let py = 0; py < gridSize; py++) {
                    for (let px = 0; px < gridSize; px++) {
                        if (mask[py] && mask[py][px]) {
                            collisionTilesetCtx.fillRect(
                                (tx + px) * collisionZoom,
                                (ty + py) * collisionZoom,
                                collisionZoom,
                                collisionZoom
                            );
                        }
                    }
                }
            }

            // Draw depth split lines (cyan freeform lines)
            collisionTilesetCtx.strokeStyle = '#0ff';
            collisionTilesetCtx.lineWidth = 2;
            for (let key in tileSplitLines) {
                if (!key.startsWith(keyPrefix)) continue;

                const splitYArray = tileSplitLines[key];
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                // Draw freeform line connecting all column Y values
                collisionTilesetCtx.beginPath();
                for (let col = 0; col < gridSize; col++) {
                    const splitY = Array.isArray(splitYArray) ? splitYArray[col] : splitYArray;
                    const lineX = (tx + col + 0.5) * collisionZoom;
                    const lineY = (ty + splitY) * collisionZoom;
                    if (col === 0) {
                        collisionTilesetCtx.moveTo(lineX, lineY);
                    } else {
                        collisionTilesetCtx.lineTo(lineX, lineY);
                    }
                }
                collisionTilesetCtx.stroke();

                // Fill canopy region with semi-transparent cyan
                collisionTilesetCtx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                collisionTilesetCtx.beginPath();
                collisionTilesetCtx.moveTo(tx * collisionZoom, ty * collisionZoom);
                for (let col = 0; col < gridSize; col++) {
                    const splitY = Array.isArray(splitYArray) ? splitYArray[col] : splitYArray;
                    const lineX = (tx + col + 0.5) * collisionZoom;
                    const lineY = (ty + splitY) * collisionZoom;
                    collisionTilesetCtx.lineTo(lineX, lineY);
                }
                collisionTilesetCtx.lineTo((tx + gridSize) * collisionZoom, ty * collisionZoom);
                collisionTilesetCtx.closePath();
                collisionTilesetCtx.fill();

                // Draw "C" for canopy and "T" for trunk
                const avgSplitY = Array.isArray(splitYArray)
                    ? splitYArray.reduce((a, b) => a + b, 0) / splitYArray.length
                    : splitYArray;
                collisionTilesetCtx.fillStyle = '#0ff';
                collisionTilesetCtx.font = (collisionZoom * 2) + 'px sans-serif';
                collisionTilesetCtx.textAlign = 'center';
                collisionTilesetCtx.fillText('C', tx * collisionZoom + gridSize * collisionZoom / 2, (ty + avgSplitY / 2) * collisionZoom);
                collisionTilesetCtx.fillText('T', tx * collisionZoom + gridSize * collisionZoom / 2, (ty + avgSplitY + (gridSize - avgSplitY) / 2) * collisionZoom);
            }

            // Highlight selected split tile
            if (selectedSplitTile && collisionTool === 'split') {
                collisionTilesetCtx.strokeStyle = '#ff0';
                collisionTilesetCtx.lineWidth = 3;
                collisionTilesetCtx.strokeRect(
                    selectedSplitTile.x * collisionZoom,
                    selectedSplitTile.y * collisionZoom,
                    gridSize * collisionZoom,
                    gridSize * collisionZoom
                );
            }
        }

        function setCollisionZoom(z) {
            collisionZoom = z;
            document.querySelectorAll('[id^="collisionZoom"]').forEach(b => b.classList.remove('active'));
            const btn = document.querySelector(`[onclick="setCollisionZoom(${z})"]`);
            if (btn) btn.classList.add('active');
            drawCollisionTileset();
        }

        function setCollisionTool(tool) {
            collisionTool = tool;
            document.getElementById('collisionToolPaint').classList.toggle('active', tool === 'paint');
            document.getElementById('collisionToolErase').classList.toggle('active', tool === 'erase');
            document.getElementById('collisionToolSplit').classList.toggle('active', tool === 'split');

            // Show/hide split controls
            document.getElementById('splitControls').style.display = tool === 'split' ? 'block' : 'none';

            // Update cursor based on tool
            if (tool === 'split') {
                collisionTilesetCanvas.style.cursor = 'pointer';
            } else if (tool === 'erase') {
                collisionTilesetCanvas.style.cursor = 'not-allowed';
            } else {
                collisionTilesetCanvas.style.cursor = 'crosshair';
            }

            // Clear split selection when switching away
            if (tool !== 'split') {
                selectedSplitTile = null;
            }

            drawCollisionTileset();
        }

        function setBrushSize(size) {
            brushSize = size;
            document.querySelectorAll('[id^="brush"]').forEach(b => b.classList.remove('active'));
            document.getElementById('brush' + size).classList.add('active');
        }

        function updateCollisionStats() {
            // Only count collisions for current tileset
            const keyPrefix = currentTilesetIndex + ':';
            const count = Object.keys(tileCollisions).filter(k => k.startsWith(keyPrefix) && tileCollisions[k]).length;
            document.getElementById('collisionStats').textContent = count + ' tiles with collision (tileset ' + currentTilesetIndex + ')';
        }

        function selectAllCollision() {
            if (!tilesetImg) return;
            const cols = Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = Math.floor(tilesetImg.naturalHeight / gridSize);

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const tileX = col * gridSize;
                    const tileY = row * gridSize;
                    // Include tileset index in key
                    const key = currentTilesetIndex + ':' + tileX + ',' + tileY;
                    tileCollisions[key] = true;
                }
            }

            drawCollisionTileset();
            updateCollisionStats();
        }

        function clearAllCollision() {
            if (!confirm('Clear all collision for current tileset?')) return;
            // Only clear collisions for current tileset
            const keyPrefix = currentTilesetIndex + ':';
            for (let key in tileCollisions) {
                if (key.startsWith(keyPrefix)) {
                    delete tileCollisions[key];
                }
            }
            for (let key in collisionMasks) {
                if (key.startsWith(keyPrefix)) {
                    delete collisionMasks[key];
                }
            }
            drawCollisionTileset();
            updateCollisionStats();
        }

        // Collision canvas mouse events - pixel brush painting + pan
        collisionTilesetCanvas.addEventListener('mousedown', (e) => {
            e.preventDefault();

            // Middle mouse or shift+left = pan
            if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                isPanning = true;
                panStartX = e.clientX + collisionPanX;
                panStartY = e.clientY + collisionPanY;
                collisionTilesetCanvas.style.cursor = 'grabbing';
                return;
            }

            // Handle split tool mode
            if (collisionTool === 'split' && e.button === 0) {
                handleSplitClick(e);
                return;
            }

            if (e.button === 0) {
                brushPainting = true;
                paintCollisionAt(e, collisionTool === 'paint');
            } else if (e.button === 2) {
                brushErasing = true;
                paintCollisionAt(e, false);
            }
        });

        collisionTilesetCanvas.addEventListener('mousemove', (e) => {
            if (isPanning) {
                collisionPanX = panStartX - e.clientX;
                collisionPanY = panStartY - e.clientY;
                updateCollisionScroll();
                return;
            }

            // Handle dragging split line
            if (draggingSplitLine && selectedSplitTile) {
                handleSplitDrag(e);
                return;
            }

            if (brushPainting) paintCollisionAt(e, collisionTool === 'paint');
            if (brushErasing) paintCollisionAt(e, false);
        });

        collisionTilesetCanvas.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                collisionTilesetCanvas.style.cursor = collisionTool === 'split' ? 'pointer' : 'crosshair';
            }
            draggingSplitLine = false;
            brushPainting = false;
            brushErasing = false;
        });

        collisionTilesetCanvas.addEventListener('mouseleave', () => {
            if (isPanning) {
                isPanning = false;
                collisionTilesetCanvas.style.cursor = 'crosshair';
            }
            brushPainting = false;
            brushErasing = false;
        });

        collisionTilesetCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Paint collision pixels with brush
        function paintCollisionAt(e, addCollision) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            // Find which tile this pixel is in
            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;
            // Include tileset index in key so each tileset has separate collisions
            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;

            // Get or create mask for this tile
            if (!collisionMasks[key]) {
                collisionMasks[key] = [];
                for (let y = 0; y < gridSize; y++) {
                    collisionMasks[key][y] = new Array(gridSize).fill(false);
                }
            }
            const mask = collisionMasks[key];

            // Paint pixels with brush
            const half = Math.floor(brushSize / 2);
            const localX = px - tileX;
            const localY = py - tileY;

            for (let dy = -half; dy < half; dy++) {
                for (let dx = -half; dx < half; dx++) {
                    const mx = localX + dx;
                    const my = localY + dy;
                    if (mx >= 0 && mx < gridSize && my >= 0 && my < gridSize) {
                        mask[my][mx] = addCollision;
                    }
                }
            }

            // Update tileCollisions (true if any pixel is set)
            let hasCollision = false;
            for (let y = 0; y < gridSize && !hasCollision; y++) {
                for (let x = 0; x < gridSize && !hasCollision; x++) {
                    if (mask[y][x]) hasCollision = true;
                }
            }
            if (hasCollision) {
                tileCollisions[key] = true;
            } else {
                delete tileCollisions[key];
                delete collisionMasks[key];
            }

            drawCollisionTileset();
            updateCollisionStats();
        }

        // ===== DEPTH SPLIT FUNCTIONS =====
        // tileSplitLines stores an array of Y values per column for freeform lines
        // Format: "tilesetIndex:x,y" -> [y0, y1, y2, ..., y15] (one Y per column)

        function toggleFlatLineMode() {
            flatLineMode = document.getElementById('flatLineToggle').checked;
        }

        function handleSplitClick(e) {
            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            if (!tilesetImg || px < 0 || py < 0 || px >= tilesetImg.naturalWidth || py >= tilesetImg.naturalHeight) return;

            // Find which tile was clicked
            const tileX = Math.floor(px / gridSize) * gridSize;
            const tileY = Math.floor(py / gridSize) * gridSize;

            // Select this tile for splitting
            selectedSplitTile = { x: tileX, y: tileY, tilesetIndex: currentTilesetIndex };
            draggingSplitLine = true;

            const key = currentTilesetIndex + ':' + tileX + ',' + tileY;

            // Calculate local Y position within the tile
            const localY = py - tileY;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            // Initialize or set split line
            if (flatLineMode) {
                // Flat line mode: set entire line to clicked Y
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                // Update the Y input to show current value
                document.getElementById('splitYInput').value = clampedY;
            } else {
                // Freeform mode: initialize if doesn't exist, then set clicked column
                if (!tileSplitLines[key]) {
                    const defaultY = parseInt(document.getElementById('splitYInput').value) || Math.floor(gridSize / 2);
                    tileSplitLines[key] = new Array(gridSize).fill(defaultY);
                }
                const localX = px - tileX;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            // Update UI
            document.getElementById('splitYInput').max = gridSize;

            drawCollisionTileset();
        }

        function handleSplitDrag(e) {
            if (!selectedSplitTile || !draggingSplitLine) return;

            const rect = collisionTilesetCanvas.getBoundingClientRect();
            const px = Math.floor((e.clientX - rect.left) / collisionZoom);
            const py = Math.floor((e.clientY - rect.top) / collisionZoom);

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            if (!tileSplitLines[key]) return;

            // Calculate local position within the tile
            const localY = py - selectedSplitTile.y;
            const clampedY = Math.max(0, Math.min(gridSize, localY));

            if (flatLineMode) {
                // Flat line mode: set entire line to current Y
                tileSplitLines[key] = new Array(gridSize).fill(clampedY);
                document.getElementById('splitYInput').value = clampedY;
            } else {
                // Freeform mode: set only this column
                const localX = px - selectedSplitTile.x;
                const clampedX = Math.max(0, Math.min(gridSize - 1, localX));
                tileSplitLines[key][clampedX] = clampedY;
            }

            drawCollisionTileset();
        }

        function setSplitLineY() {
            // Set a flat horizontal line at the specified Y
            if (!selectedSplitTile) {
                alert('Click a tile first to select it');
                return;
            }

            const splitY = parseInt(document.getElementById('splitYInput').value) || Math.floor(gridSize / 2);
            const clampedY = Math.max(0, Math.min(gridSize, splitY));

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            tileSplitLines[key] = new Array(gridSize).fill(clampedY);

            drawCollisionTileset();
        }

        function clearSelectedSplit() {
            if (!selectedSplitTile) return;

            const key = currentTilesetIndex + ':' + selectedSplitTile.x + ',' + selectedSplitTile.y;
            delete tileSplitLines[key];
            selectedSplitTile = null;

            drawCollisionTileset();
        }

        // Keyboard controls for build phase
        document.addEventListener('keydown', (e) => {
            if (currentPhase === 'build') {
                if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    rotateNext();
                }
                if (e.key === 'i' || e.key === 'I') {
                    e.preventDefault();
                    toggleFlipH();
                }
                if (e.key === 'e' || e.key === 'E') {
                    e.preventDefault();
                    toggleEraseMode();
                }
            }
        });

        // Keyboard controls for collision painter
        document.addEventListener('keydown', (e) => {
            if (currentPhase !== 'collision') return;

            // Zoom with Q/E or +/-
            if (e.key === 'e' || e.key === 'E' || e.key === '=' || e.key === '+') {
                e.preventDefault();
                if (collisionZoom < 12) setCollisionZoom(collisionZoom + 1);
                return;
            }
            if (e.key === 'q' || e.key === 'Q' || e.key === '-' || e.key === '_') {
                e.preventDefault();
                if (collisionZoom > 1) setCollisionZoom(collisionZoom - 1);
                return;
            }

            // Arrow keys to pan
            const panSpeed = 50;
            let moved = false;

            if (e.key === 'ArrowLeft') { collisionPanX -= panSpeed; moved = true; }
            if (e.key === 'ArrowRight') { collisionPanX += panSpeed; moved = true; }
            if (e.key === 'ArrowUp') { collisionPanY -= panSpeed; moved = true; }
            if (e.key === 'ArrowDown') { collisionPanY += panSpeed; moved = true; }

            if (moved) {
                e.preventDefault();
                updateCollisionScroll();
            }
        });

        function updateCollisionScroll() {
            const container = document.querySelector('.collision-main');
            // Clamp pan values
            const maxX = Math.max(0, collisionTilesetCanvas.width - container.clientWidth);
            const maxY = Math.max(0, collisionTilesetCanvas.height - container.clientHeight);
            collisionPanX = Math.max(0, Math.min(maxX, collisionPanX));
            collisionPanY = Math.max(0, Math.min(maxY, collisionPanY));

            container.scrollLeft = collisionPanX;
            container.scrollTop = collisionPanY;
        }

        let mapInitialized = false;

        function finishCollisionSetup() {
            // Only initialize map if it hasn't been created yet
            if (!mapInitialized) {
                initMap();
                mapInitialized = true;
            }
            setPhase('build');
            drawPaintTileset();
            renderMap();
            updateAnimPropListDisplay();
        }

        function goBackToCollision() {
            setPhase('collision');
            rebuildCollisionView();
        }

        // ===== BUILD PHASE =====
        function initMap() {
            // Initialize with one layer
            layers = [createEmptyLayer()];
            layerVisibility = [true];
            layerNames = [''];
            currentLayer = 0;
            map = layers[0]; // map points to current layer for compatibility
            renderLayerList();
        }

        function createEmptyLayer() {
            const layer = [];
            for (let y = 0; y < mapRows; y++) {
                layer[y] = [];
                for (let x = 0; x < mapCols; x++) {
                    layer[y][x] = null;
                }
            }
            return layer;
        }

        function addLayer() {
            layers.push(createEmptyLayer());
            layerVisibility.push(true);
            layerNames.push('');
            currentLayer = layers.length - 1;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function selectLayer(index) {
            currentLayer = index;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function toggleLayerVisibility(index) {
            layerVisibility[index] = !layerVisibility[index];
            renderLayerList();
            renderMap();
        }

        function deleteLayer(index) {
            if (layers.length <= 1) return alert('Need at least one layer');
            const layerLabel = layerNames[index] ? `"${layerNames[index]}"` : `Layer ${index}`;
            if (!confirm('Delete ' + layerLabel + '?')) return;
            layers.splice(index, 1);
            layerVisibility.splice(index, 1);
            layerNames.splice(index, 1);
            if (currentLayer >= layers.length) currentLayer = layers.length - 1;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function moveLayerUp(index) {
            if (index <= 0) return;
            [layers[index], layers[index-1]] = [layers[index-1], layers[index]];
            [layerVisibility[index], layerVisibility[index-1]] = [layerVisibility[index-1], layerVisibility[index]];
            [layerNames[index], layerNames[index-1]] = [layerNames[index-1], layerNames[index]];
            if (currentLayer === index) currentLayer--;
            else if (currentLayer === index - 1) currentLayer++;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function moveLayerDown(index) {
            if (index >= layers.length - 1) return;
            [layers[index], layers[index+1]] = [layers[index+1], layers[index]];
            [layerVisibility[index], layerVisibility[index+1]] = [layerVisibility[index+1], layerVisibility[index]];
            [layerNames[index], layerNames[index+1]] = [layerNames[index+1], layerNames[index]];
            if (currentLayer === index) currentLayer++;
            else if (currentLayer === index + 1) currentLayer--;
            map = layers[currentLayer];
            renderLayerList();
            renderMap();
        }

        function renderLayerList() {
            // Render to both layer lists (tileset mode and animProp mode)
            const lists = [
                document.getElementById('layerList'),
                document.getElementById('animPropLayerList')
            ];

            for (const list of lists) {
                if (!list) continue;
                list.innerHTML = '';

                // Insert player layer row at the right position
                // Player layer is rendered BETWEEN layers[playerLayerIndex-1] and layers[playerLayerIndex]
                // So we need to show it after displaying layer playerLayerIndex-1

                for (let i = 0; i < layers.length; i++) {
                    // If this is where the player layer should appear, show it first
                    if (i === playerLayerIndex) {
                        list.appendChild(createPlayerLayerRow());
                    }

                    const div = document.createElement('div');
                    div.style.cssText = 'display:flex; align-items:center; gap:5px; padding:5px; margin:3px 0; background:' + (i === currentLayer ? '#4af' : '#333') + '; border-radius:4px; font-size:11px;';

                    const layerLabel = layerNames[i] ? `Layer ${i} (${layerNames[i]})` : `Layer ${i}`;

                    div.innerHTML = `
                        <input type="checkbox" ${layerVisibility[i] ? 'checked' : ''} onclick="toggleLayerVisibility(${i})" title="Visibility">
                        <span style="flex:1; cursor:pointer; color:${i === currentLayer ? '#000' : '#fff'};" onclick="selectLayer(${i})">${layerLabel}</span>
                        <button onclick="renameLayer(${i})" style="padding:2px 5px; font-size:10px;" title="Rename">‚úé</button>
                        <button onclick="moveLayerUp(${i})" style="padding:2px 5px; font-size:10px;">‚Üë</button>
                        <button onclick="moveLayerDown(${i})" style="padding:2px 5px; font-size:10px;">‚Üì</button>
                        <button onclick="deleteLayer(${i})" style="padding:2px 5px; font-size:10px; background:#a55;">X</button>
                    `;
                    list.appendChild(div);
                }

                // If player layer is at the end (beyond all layers)
                if (playerLayerIndex >= layers.length) {
                    list.appendChild(createPlayerLayerRow());
                }
            }
        }

        function createPlayerLayerRow() {
            const div = document.createElement('div');
            div.style.cssText = 'display:flex; align-items:center; gap:5px; padding:5px; margin:3px 0; background:#f0a; border-radius:4px; font-size:11px;';

            div.innerHTML = `
                <input type="checkbox" ${playerPreviewVisible ? 'checked' : ''} onclick="togglePlayerPreview()" title="Visibility">
                <span style="flex:1; color:#000;">üßç PLAYER</span>
                <span style="color:#000; font-size:9px; opacity:0.7;">locked</span>
                <button onclick="movePlayerLayerUp()" style="padding:2px 5px; font-size:10px;">‚Üë</button>
                <button onclick="movePlayerLayerDown()" style="padding:2px 5px; font-size:10px;">‚Üì</button>
            `;
            return div;
        }

        function togglePlayerPreview() {
            playerPreviewVisible = !playerPreviewVisible;
            renderLayerList();
            renderMap();
        }

        function movePlayerLayerUp() {
            if (playerLayerIndex > 0) {
                playerLayerIndex--;
                renderLayerList();
                renderMap();
            }
        }

        function movePlayerLayerDown() {
            if (playerLayerIndex < layers.length) {
                playerLayerIndex++;
                renderLayerList();
                renderMap();
            }
        }

        function renameLayer(index) {
            const currentName = layerNames[index] || '';
            const newName = prompt('Enter nickname for Layer ' + index + ':', currentName);
            if (newName !== null) {
                layerNames[index] = newName.trim();
                renderLayerList();
            }
        }

        function setMode(m) {
            mode = m;
            document.getElementById('tileMode').classList.toggle('active', m === 'tile');
            document.getElementById('npcMode').classList.toggle('active', m === 'npc');
            document.getElementById('animPropMode').classList.toggle('active', m === 'animProp');
            document.getElementById('soundMode').classList.toggle('active', m === 'sound');
            document.getElementById('lightingMode').classList.toggle('active', m === 'lighting');
            document.getElementById('tileModeContent').style.display = m === 'tile' ? 'block' : 'none';
            document.getElementById('npcModeContent').style.display = m === 'npc' ? 'block' : 'none';
            document.getElementById('animPropModeContent').style.display = m === 'animProp' ? 'block' : 'none';
            document.getElementById('soundModeContent').style.display = m === 'sound' ? 'block' : 'none';
            document.getElementById('lightingModeContent').style.display = m === 'lighting' ? 'block' : 'none';

            // Update mode label for mobile
            const labels = { tile: 'Tiles', npc: 'NPCs', animProp: 'Animated', sound: 'Sounds', lighting: 'Lights' };
            document.getElementById('currentModeLabel').textContent = labels[m] || m;

            // Collapse menu on mobile after selection
            document.getElementById('modeTabs').classList.remove('expanded');

            // Update lists when switching modes
            if (m === 'npc') updateNpcList();

            // Redraw map to show appropriate overlays
            renderMap();
        }

        function toggleModeMenu() {
            document.getElementById('modeTabs').classList.toggle('expanded');
        }

        // Sidebar resize functionality
        (function() {
            const panel = document.getElementById('leftPanel');
            const handle = document.getElementById('sidebarResize');
            if (!panel || !handle) return;

            let isResizing = false;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                handle.classList.add('active');
                document.body.style.cursor = 'ew-resize';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const newWidth = e.clientX;
                if (newWidth >= 200 && newWidth <= 500) {
                    panel.style.width = newWidth + 'px';
                }
            });

            document.addEventListener('mouseup', () => {
                isResizing = false;
                handle.classList.remove('active');
                document.body.style.cursor = '';
            });

            // Touch support for resize
            handle.addEventListener('touchstart', (e) => {
                isResizing = true;
                handle.classList.add('active');
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!isResizing) return;
                const touch = e.touches[0];
                const newWidth = touch.clientX;
                if (newWidth >= 200 && newWidth <= 500) {
                    panel.style.width = newWidth + 'px';
                }
            }, { passive: false });

            document.addEventListener('touchend', () => {
                isResizing = false;
                handle.classList.remove('active');
            });
        })();

        // ===== SOUND MANAGEMENT =====
        function loadSound(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const audio = new Audio(e.target.result);
                audio.addEventListener('loadedmetadata', function() {
                    sounds.push({
                        name: file.name,
                        data: e.target.result,
                        duration: audio.duration || 0,
                        type: 'ambient'
                    });
                    updateSoundDropdown();
                    currentSoundIndex = sounds.length - 1;
                    const selectEl = document.getElementById('soundSelect');
                    const controlsEl = document.getElementById('soundControls');
                    if (selectEl) selectEl.value = currentSoundIndex;
                    if (controlsEl) controlsEl.style.display = 'block';
                });
                audio.addEventListener('error', function() {
                    console.error('Failed to load audio metadata');
                    // Still add the sound even if metadata fails
                    sounds.push({
                        name: file.name,
                        data: e.target.result,
                        duration: 0,
                        type: 'ambient'
                    });
                    updateSoundDropdown();
                    currentSoundIndex = sounds.length - 1;
                    const selectEl = document.getElementById('soundSelect');
                    const controlsEl = document.getElementById('soundControls');
                    if (selectEl) selectEl.value = currentSoundIndex;
                    if (controlsEl) controlsEl.style.display = 'block';
                });
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function switchSound() {
            const selectEl = document.getElementById('soundSelect');
            const controlsEl = document.getElementById('soundControls');
            currentSoundIndex = selectEl ? parseInt(selectEl.value) : -1;
            if (controlsEl) controlsEl.style.display = currentSoundIndex >= 0 ? 'block' : 'none';
            stopPreview();
        }

        function updateSoundDropdown() {
            const select = document.getElementById('soundSelect');
            if (!select) return;
            select.innerHTML = '<option value="-1">-- Select Sound --</option>';
            sounds.forEach((sound, idx) => {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = sound.name;
                select.appendChild(opt);
            });
        }

        function previewSound() {
            if (currentSoundIndex < 0 || !sounds[currentSoundIndex]) return;
            stopPreview();
            previewAudio = new Audio(sounds[currentSoundIndex].data);
            const volumeEl = document.getElementById('soundVolume');
            previewAudio.volume = volumeEl ? volumeEl.value / 100 : 0.5;
            previewAudio.play();
        }

        function stopPreview() {
            if (previewAudio) {
                previewAudio.pause();
                previewAudio.currentTime = 0;
                previewAudio = null;
            }
        }

        function setSoundAttachMode(attachMode) {
            soundAttachMode = attachMode;
            const tileBtn = document.getElementById('soundAttachTile');
            const playerBtn = document.getElementById('soundAttachPlayer');
            const tileOpts = document.getElementById('tileSoundOptions');
            const playerOpts = document.getElementById('playerSoundOptions');
            if (tileBtn) tileBtn.classList.toggle('active', attachMode === 'tile');
            if (playerBtn) playerBtn.classList.toggle('active', attachMode === 'player');
            if (tileOpts) tileOpts.style.display = attachMode === 'tile' ? 'block' : 'none';
            if (playerOpts) playerOpts.style.display = attachMode === 'player' ? 'block' : 'none';
            renderMap();
        }

        function assignPlayerSound() {
            if (currentSoundIndex < 0) {
                alert('Select a sound first');
                return;
            }
            const actionEl = document.getElementById('playerActionSelect');
            const volumeEl = document.getElementById('playerSoundVolume');
            const intervalEl = document.getElementById('walkInterval');
            const pitchEl = document.getElementById('walkPitch');

            const action = actionEl ? actionEl.value : 'walk';
            playerSounds[action].soundIndex = currentSoundIndex;
            playerSounds[action].volume = volumeEl ? volumeEl.value / 100 : 0.5;
            if (action === 'walk') {
                playerSounds.walk.interval = intervalEl ? parseInt(intervalEl.value) : 200;
                playerSounds.walk.pitchVariation = pitchEl ? parseInt(pitchEl.value) / 100 : 0.1;
            }
            updatePlayerSoundAssignments();
        }

        function updatePlayerSoundAssignments() {
            const container = document.getElementById('playerSoundAssignments');
            if (!container) return;
            let html = '';
            if (playerSounds.walk.soundIndex >= 0) {
                html += `<div>Walk: ${sounds[playerSounds.walk.soundIndex]?.name || 'Unknown'}</div>`;
            }
            if (playerSounds.attack.soundIndex >= 0) {
                html += `<div>Attack: ${sounds[playerSounds.attack.soundIndex]?.name || 'Unknown'}</div>`;
            }
            container.innerHTML = html || '<div style="color:#888;">None assigned</div>';
        }

        function updatePlayerSoundUI() {
            const actionSelect = document.getElementById('playerActionSelect');
            const walkSettings = document.getElementById('walkSoundSettings');
            if (!actionSelect || !walkSettings) return;
            const action = actionSelect.value;
            walkSettings.style.display = action === 'walk' ? 'block' : 'none';
        }

        function placeTileSound(gridX, gridY) {
            if (currentSoundIndex < 0) {
                alert('Select a sound first');
                return;
            }
            const radiusEl = document.getElementById('soundRadius');
            const loopEl = document.getElementById('soundLoop');
            const volumeEl = document.getElementById('soundVolume');
            const fadeEl = document.getElementById('soundFade');
            const key = `${gridX},${gridY}`;
            tileSounds[key] = {
                soundIndex: currentSoundIndex,
                radius: radiusEl ? parseInt(radiusEl.value) : 3,
                loop: loopEl ? loopEl.checked : true,
                volume: volumeEl ? volumeEl.value / 100 : 0.5,
                fadePercent: fadeEl ? parseInt(fadeEl.value) / 100 : 0.5
            };
            console.log('Placed tile sound:', key, tileSounds[key]);
            console.log('Total tile sounds:', Object.keys(tileSounds).length);
            updatePlacedSoundsList();
            renderMap();
        }

        function removeTileSound(key) {
            delete tileSounds[key];
            updatePlacedSoundsList();
            renderMap();
        }

        function updatePlacedSoundsList() {
            const container = document.getElementById('placedSoundsList');
            if (!container) return;
            const keys = Object.keys(tileSounds);
            if (keys.length === 0) {
                container.innerHTML = '<div style="color:#888;">No sounds placed</div>';
                return;
            }
            container.innerHTML = keys.map(key => {
                const ts = tileSounds[key];
                const soundName = sounds[ts.soundIndex]?.name || 'Unknown';
                const isSelected = key === selectedTileSoundKey;
                return `<div style="display:flex; justify-content:space-between; align-items:center; padding:4px; margin:2px 0; background:${isSelected ? '#4a7c59' : '#333'}; border-radius:3px; cursor:pointer;" onclick="selectTileSound('${key}')">
                    <span style="flex:1;">üìç ${key}: ${soundName}</span>
                    <button onclick="event.stopPropagation(); removeTileSound('${key}')" style="padding:2px 6px;">√ó</button>
                </div>`;
            }).join('');
        }

        function selectTileSound(key) {
            if (!tileSounds[key]) return;
            selectedTileSoundKey = key;
            const ts = tileSounds[key];

            // Populate UI with current values
            const radiusEl = document.getElementById('soundRadius');
            const loopEl = document.getElementById('soundLoop');
            const volumeEl = document.getElementById('soundVolume');
            const fadeEl = document.getElementById('soundFade');
            const selectEl = document.getElementById('soundSelect');

            if (radiusEl) {
                radiusEl.value = ts.radius || 3;
                document.getElementById('soundRadiusVal').textContent = ts.radius || 3;
            }
            if (loopEl) loopEl.checked = ts.loop !== false;
            if (volumeEl) {
                volumeEl.value = (ts.volume || 0.5) * 100;
                document.getElementById('soundVolumeVal').textContent = Math.round((ts.volume || 0.5) * 100);
            }
            if (fadeEl) {
                fadeEl.value = (ts.fadePercent !== undefined ? ts.fadePercent : 0.5) * 100;
                document.getElementById('soundFadeVal').textContent = Math.round((ts.fadePercent !== undefined ? ts.fadePercent : 0.5) * 100);
            }
            if (selectEl) selectEl.value = ts.soundIndex;
            currentSoundIndex = ts.soundIndex;

            // Show edit mode indicator
            document.getElementById('soundEditMode').style.display = 'block';
            document.getElementById('editingSoundKey').textContent = key;

            updatePlacedSoundsList();
            renderMap();
        }

        function deselectTileSound() {
            selectedTileSoundKey = null;
            document.getElementById('soundEditMode').style.display = 'none';
            updatePlacedSoundsList();
            renderMap();
        }

        function saveSelectedSound() {
            if (!selectedTileSoundKey || !tileSounds[selectedTileSoundKey]) {
                alert('No sound selected to save');
                return;
            }
            if (currentSoundIndex < 0) {
                alert('Select a sound first');
                return;
            }

            const radiusEl = document.getElementById('soundRadius');
            const loopEl = document.getElementById('soundLoop');
            const volumeEl = document.getElementById('soundVolume');
            const fadeEl = document.getElementById('soundFade');

            tileSounds[selectedTileSoundKey] = {
                soundIndex: currentSoundIndex,
                radius: radiusEl ? parseInt(radiusEl.value) : 3,
                loop: loopEl ? loopEl.checked : true,
                volume: volumeEl ? volumeEl.value / 100 : 0.5,
                fadePercent: fadeEl ? parseInt(fadeEl.value) / 100 : 0.5
            };

            console.log('Updated tile sound:', selectedTileSoundKey, tileSounds[selectedTileSoundKey]);
            updatePlacedSoundsList();
            renderMap();
        }

        // ===== LIGHTING MANAGEMENT =====
        let lightingPreviewEnabled = false;

        function toggleLightingPreview() {
            lightingPreviewEnabled = !lightingPreviewEnabled;
            const btn = document.getElementById('lightingPreviewBtn');
            if (btn) {
                btn.textContent = lightingPreviewEnabled ? 'üëÅÔ∏è Preview Lighting: ON' : 'üëÅÔ∏è Preview Lighting: OFF';
                btn.style.background = lightingPreviewEnabled ? '#5a8a2a' : '#2a5a8a';
            }
            renderMap();
        }

        function updateLightingSettings() {
            lightingSettings.ambientEnabled = document.getElementById('ambientEnabled').checked;
            lightingSettings.blobShadows = document.getElementById('blobShadows').checked;
            lightingSettings.playerLight = document.getElementById('playerLight').checked;
            lightingSettings.playerLightRadius = parseInt(document.getElementById('playerLightRadius').value);
            renderMap();
        }

        function setTimeOfDay(time) {
            lightingSettings.timeOfDay = time;
            // Update button states
            ['dawn', 'day', 'dusk', 'night'].forEach(t => {
                const btn = document.getElementById('tod' + t.charAt(0).toUpperCase() + t.slice(1));
                if (btn) btn.classList.toggle('active', t === time);
            });
            renderMap();
        }

        function placeLightAt(x, y) {
            const key = currentMap + ':' + x + ',' + y;
            const radius = parseInt(document.getElementById('pointLightRadius').value) || 3;
            const flicker = document.getElementById('pointLightFlicker').checked;
            pointLights[key] = { radius, flicker };
            console.log('Placed light:', key, pointLights[key]);
            updatePlacedLightsList();
            renderMap();
        }

        function removeLightAt(x, y) {
            const key = currentMap + ':' + x + ',' + y;
            if (pointLights[key]) {
                delete pointLights[key];
                updatePlacedLightsList();
                renderMap();
            }
        }

        function removeNearestLight(x, y) {
            // Find nearest light within 1.5 tiles
            let nearestKey = null;
            let nearestDist = 1.5;
            Object.keys(pointLights).forEach(key => {
                if (!key.startsWith(currentMap + ':')) return;
                const coords = key.split(':')[1].split(',');
                const lx = parseFloat(coords[0]);
                const ly = parseFloat(coords[1]);
                const dist = Math.sqrt((x - lx) ** 2 + (y - ly) ** 2);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestKey = key;
                }
            });
            if (nearestKey) {
                delete pointLights[nearestKey];
                updatePlacedLightsList();
                renderMap();
            }
        }

        function updatePlacedLightsList() {
            const container = document.getElementById('placedLightsList');
            if (!container) return;
            const keys = Object.keys(pointLights).filter(k => k.startsWith(currentMap + ':'));
            if (keys.length === 0) {
                container.innerHTML = '<div style="color:#888;">No lights placed</div>';
                return;
            }
            container.innerHTML = keys.map(key => {
                const light = pointLights[key];
                const coords = key.split(':')[1];
                return `<div style="display:flex; justify-content:space-between; align-items:center; padding:4px; margin:2px 0; background:#333; border-radius:3px;">
                    <span style="flex:1;">üí° ${coords} (r=${light.radius}${light.flicker ? ', flicker' : ''})</span>
                    <button onclick="delete pointLights['${key}']; updatePlacedLightsList(); renderMap();" style="padding:2px 6px;">√ó</button>
                </div>`;
            }).join('');
        }

        function setRotation(deg) {
            tileRotation = deg;
            document.querySelectorAll('[id^="rot"]').forEach(b => b.classList.remove('active'));
            document.getElementById('rot' + deg).classList.add('active');
            updateSelectedPreview();
            renderMap(); // Update preview
        }

        function rotateNext() {
            const rotations = [0, 90, 180, 270];
            const idx = rotations.indexOf(tileRotation);
            setRotation(rotations[(idx + 1) % 4]);
        }

        function toggleFlipH() {
            tileFlippedH = !tileFlippedH;
            updateFlipButton();
            updateSelectedTilePreview();
            renderMap();
        }

        function updateFlipButton() {
            const btn = document.getElementById('flipBtn');
            if (btn) {
                btn.style.background = tileFlippedH ? '#4a4' : '';
                btn.textContent = tileFlippedH ? 'Flip H ‚úì' : 'Flip H (I)';
            }
        }

        function toggleEraseMode() {
            eraseMode = !eraseMode;
            updateEraseButton();
        }

        function updateEraseButton() {
            const btn = document.getElementById('eraseBtn');
            if (btn) {
                btn.style.background = eraseMode ? '#f55' : '#a55';
                btn.textContent = eraseMode ? 'Erase ‚úì' : 'Erase (E)';
            }
        }

        // Draw a tile with rotation and optional horizontal flip
        function drawRotatedTile(ctx, img, srcX, srcY, srcSize, destX, destY, destSize, rotation, flipped) {
            ctx.save();
            ctx.translate(destX + destSize / 2, destY + destSize / 2);

            if (rotation !== 0) {
                ctx.rotate(rotation * Math.PI / 180);
            }
            if (flipped) {
                ctx.scale(-1, 1); // Flip horizontally
            }

            ctx.drawImage(img, srcX, srcY, srcSize, srcSize, -destSize / 2, -destSize / 2, destSize, destSize);
            ctx.restore();
        }

        // Draw player preview placeholder on map
        function drawPlayerPreview(tileSize) {
            mapCtx.globalAlpha = 1;

            const playerWidth = 28;
            const playerHeight = 64;
            const px = playerPreviewPos.x * tileSize;
            const py = playerPreviewPos.y * tileSize;

            // Draw player silhouette (simple humanoid shape)
            const scale = zoom;

            // Body
            mapCtx.fillStyle = '#f0a';
            mapCtx.fillRect(px + 6 * scale, py + 16 * scale, 16 * scale, 32 * scale);

            // Head
            mapCtx.beginPath();
            mapCtx.arc(px + 14 * scale, py + 10 * scale, 8 * scale, 0, Math.PI * 2);
            mapCtx.fill();

            // Legs
            mapCtx.fillRect(px + 6 * scale, py + 48 * scale, 6 * scale, 14 * scale);
            mapCtx.fillRect(px + 16 * scale, py + 48 * scale, 6 * scale, 14 * scale);

            // Arms
            mapCtx.fillRect(px + 0 * scale, py + 20 * scale, 6 * scale, 20 * scale);
            mapCtx.fillRect(px + 22 * scale, py + 20 * scale, 6 * scale, 20 * scale);

            // Outline
            mapCtx.strokeStyle = '#fff';
            mapCtx.lineWidth = 2;
            mapCtx.strokeRect(px, py, 28 * scale, 64 * scale);

            // Label
            mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
            mapCtx.font = '10px sans-serif';
            mapCtx.textAlign = 'center';
            const labelWidth = mapCtx.measureText('PLAYER').width + 6;
            mapCtx.fillRect(px + 14 * scale - labelWidth / 2, py - 16, labelWidth, 14);
            mapCtx.fillStyle = '#f0a';
            mapCtx.fillText('PLAYER', px + 14 * scale, py - 5);

            // Drag handle indicator
            if (mode === 'tile') {
                mapCtx.strokeStyle = '#fff';
                mapCtx.setLineDash([3, 3]);
                mapCtx.strokeRect(px - 2, py - 2, 28 * scale + 4, 64 * scale + 4);
                mapCtx.setLineDash([]);
            }
        }

        // Check if a click is within the player preview bounds
        function isClickOnPlayer(clickX, clickY, tileSize) {
            const px = playerPreviewPos.x * tileSize;
            const py = playerPreviewPos.y * tileSize;
            const playerWidth = 28 * zoom;
            const playerHeight = 64 * zoom;

            return clickX >= px && clickX <= px + playerWidth &&
                   clickY >= py && clickY <= py + playerHeight;
        }

        function drawPaintTileset() {
            if (!tilesetImg) return;

            const displayZoom = 2;
            paintTilesetCanvas.width = tilesetImg.naturalWidth * displayZoom;
            paintTilesetCanvas.height = tilesetImg.naturalHeight * displayZoom;

            paintTilesetCtx.imageSmoothingEnabled = false;
            paintTilesetCtx.drawImage(tilesetImg, 0, 0, paintTilesetCanvas.width, paintTilesetCanvas.height);

            // Grid
            paintTilesetCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            const cols = Math.floor(tilesetImg.naturalWidth / gridSize);
            const rows = Math.floor(tilesetImg.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(x * gridSize * displayZoom, 0);
                paintTilesetCtx.lineTo(x * gridSize * displayZoom, paintTilesetCanvas.height);
                paintTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(0, y * gridSize * displayZoom);
                paintTilesetCtx.lineTo(paintTilesetCanvas.width, y * gridSize * displayZoom);
                paintTilesetCtx.stroke();
            }

            // Mark collision tiles
            for (let key in tileCollisions) {
                if (tileCollisions[key] && tileCollisions[key].length >= 3) {
                    const [tx, ty] = key.split(',').map(Number);
                    paintTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.25)';
                    paintTilesetCtx.fillRect(tx * displayZoom, ty * displayZoom, gridSize * displayZoom, gridSize * displayZoom);
                }
            }

            // Mark tiles with depth split lines (cyan indicator)
            const keyPrefix = currentTilesetIndex + ':';
            for (let key in tileSplitLines) {
                if (!key.startsWith(keyPrefix)) continue;

                const splitY = tileSplitLines[key];
                const coordPart = key.substring(keyPrefix.length);
                const parts = coordPart.split(',');
                const tx = parseInt(parts[0]);
                const ty = parseInt(parts[1]);

                // Draw cyan horizontal line
                paintTilesetCtx.strokeStyle = '#0ff';
                paintTilesetCtx.lineWidth = 2;
                const lineY = (ty + splitY) * displayZoom;
                paintTilesetCtx.beginPath();
                paintTilesetCtx.moveTo(tx * displayZoom, lineY);
                paintTilesetCtx.lineTo((tx + gridSize) * displayZoom, lineY);
                paintTilesetCtx.stroke();

                // Draw small cyan dot in corner to indicate split tile
                paintTilesetCtx.fillStyle = '#0ff';
                paintTilesetCtx.beginPath();
                paintTilesetCtx.arc(tx * displayZoom + 6, ty * displayZoom + 6, 4, 0, Math.PI * 2);
                paintTilesetCtx.fill();
            }

            // Highlight selected tiles
            if (selectedTileData) {
                paintTilesetCtx.strokeStyle = '#0f0';
                paintTilesetCtx.lineWidth = 3;
                const w = (selectedTileData.width || 1) * gridSize * displayZoom;
                const h = (selectedTileData.height || 1) * gridSize * displayZoom;
                paintTilesetCtx.strokeRect(
                    selectedTileData.x * displayZoom,
                    selectedTileData.y * displayZoom,
                    w,
                    h
                );
                paintTilesetCtx.lineWidth = 1;
            }
        }

        // Multi-tile selection on tileset
        let tilesetSelecting = false;

        paintTilesetCanvas.addEventListener('mousedown', (e) => {
            if (mode !== 'tile') return;
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            selectionStart = { x, y };
            tilesetSelecting = true;
        });

        paintTilesetCanvas.addEventListener('mousemove', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            updateTileSelection(e);
        });

        paintTilesetCanvas.addEventListener('mouseup', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            updateTileSelection(e);
            tilesetSelecting = false;
        });

        // Touch support for tileset selection
        paintTilesetCanvas.addEventListener('touchstart', (e) => {
            if (mode !== 'tile') return;
            e.preventDefault();
            const touch = e.touches[0];
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((touch.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((touch.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            selectionStart = { x, y };
            tilesetSelecting = true;
        }, { passive: false });

        paintTilesetCanvas.addEventListener('touchmove', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            e.preventDefault();
            updateTileSelectionTouch(e.touches[0]);
        }, { passive: false });

        paintTilesetCanvas.addEventListener('touchend', (e) => {
            if (!tilesetSelecting || mode !== 'tile') return;
            tilesetSelecting = false;
        });

        function updateTileSelectionTouch(touch) {
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((touch.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((touch.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            const minX = Math.min(selectionStart.x, x);
            const minY = Math.min(selectionStart.y, y);
            const maxX = Math.max(selectionStart.x, x);
            const maxY = Math.max(selectionStart.y, y);

            selectedTiles = [];
            for (let ty = minY; ty <= maxY; ty += gridSize) {
                for (let tx = minX; tx <= maxX; tx += gridSize) {
                    selectedTiles.push({ x: tx, y: ty });
                }
            }

            const selWidth = (maxX - minX) / gridSize + 1;
            const selHeight = (maxY - minY) / gridSize + 1;

            document.getElementById('selectedPreview').style.display = 'flex';
            document.getElementById('selectedInfo').textContent = `${selWidth}x${selHeight} tiles`;
            document.getElementById('selectedCollisionInfo').textContent = '';

            selectedTileData = { x: minX, y: minY, width: selWidth, height: selHeight };

            updateSelectedPreview();
            drawPaintTileset();
        }

        function updateTileSelection(e) {
            const rect = paintTilesetCanvas.getBoundingClientRect();
            const displayZoom = 2;
            const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
            const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

            // Calculate selection rectangle
            const minX = Math.min(selectionStart.x, x);
            const minY = Math.min(selectionStart.y, y);
            const maxX = Math.max(selectionStart.x, x);
            const maxY = Math.max(selectionStart.y, y);

            // Build array of selected tiles
            selectedTiles = [];
            for (let ty = minY; ty <= maxY; ty += gridSize) {
                for (let tx = minX; tx <= maxX; tx += gridSize) {
                    selectedTiles.push({ x: tx, y: ty });
                }
            }

            // Calculate selection dimensions
            const selWidth = (maxX - minX) / gridSize + 1;
            const selHeight = (maxY - minY) / gridSize + 1;

            document.getElementById('selectedPreview').style.display = 'flex';
            document.getElementById('selectedInfo').textContent = `${selWidth}x${selHeight} tiles`;
            document.getElementById('selectedCollisionInfo').textContent = '';

            // Store selection bounds for painting
            selectedTileData = { x: minX, y: minY, width: selWidth, height: selHeight };

            updateSelectedPreview();
            drawPaintTileset();
        }

        function updateSelectedPreview() {
            if (!selectedTileData || !tilesetImg) return;

            const selWidth = selectedTileData.width || 1;
            const selHeight = selectedTileData.height || 1;

            const preview = document.getElementById('selectedTile');
            const previewSize = Math.max(48, selWidth * 16, selHeight * 16);
            preview.width = previewSize;
            preview.height = previewSize;
            const ctx = preview.getContext('2d');
            ctx.imageSmoothingEnabled = false;
            ctx.clearRect(0, 0, previewSize, previewSize);

            // Draw selected tiles to preview with rotation and flip
            const scale = Math.min(previewSize / (selWidth * gridSize), previewSize / (selHeight * gridSize));
            for (const tile of selectedTiles) {
                // Calculate tile position relative to selection
                const tileCol = (tile.x - selectedTileData.x) / gridSize;
                const tileRow = (tile.y - selectedTileData.y) / gridSize;
                // Mirror X position when flipped
                const drawCol = tileFlippedH ? (selWidth - 1 - tileCol) : tileCol;
                const drawX = drawCol * gridSize * scale;
                const drawY = tileRow * gridSize * scale;
                drawRotatedTile(ctx, tilesetImg, tile.x, tile.y, gridSize, drawX, drawY, gridSize * scale, tileRotation, tileFlippedH);
            }
        }

        function updateSelectedTilePreview() {
            updateSelectedPreview();
        }

        // ===== UNDO/REDO SYSTEM =====
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO = 50;
        let currentStrokeChanges = []; // Track changes during a single stroke

        function saveForUndo(x, y, oldValue) {
            currentStrokeChanges.push({ x, y, layer: currentLayer, oldValue: oldValue ? { ...oldValue } : null });
        }

        function commitStroke() {
            if (currentStrokeChanges.length > 0) {
                // Also save new values for redo
                const changes = currentStrokeChanges.map(c => ({
                    ...c,
                    newValue: layers[c.layer][c.y][c.x] ? { ...layers[c.layer][c.y][c.x] } : null
                }));
                undoStack.push(changes);
                if (undoStack.length > MAX_UNDO) undoStack.shift();
                redoStack = []; // Clear redo stack on new action
                currentStrokeChanges = [];
                updateUndoRedoButtons();
            }
        }

        function undo() {
            if (undoStack.length === 0) return;
            const changes = undoStack.pop();

            // Apply old values
            changes.forEach(c => {
                if (c.y >= 0 && c.y < layers[c.layer].length && c.x >= 0 && c.x < layers[c.layer][c.y].length) {
                    layers[c.layer][c.y][c.x] = c.oldValue ? { ...c.oldValue } : null;
                }
            });

            redoStack.push(changes);
            map = layers[currentLayer];
            renderMap();
            updateUndoRedoButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;
            const changes = redoStack.pop();

            // Apply new values
            changes.forEach(c => {
                if (c.y >= 0 && c.y < layers[c.layer].length && c.x >= 0 && c.x < layers[c.layer][c.y].length) {
                    layers[c.layer][c.y][c.x] = c.newValue ? { ...c.newValue } : null;
                }
            });

            undoStack.push(changes);
            map = layers[currentLayer];
            renderMap();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            undoBtn.style.opacity = undoStack.length > 0 ? '1' : '0.5';
            redoBtn.style.opacity = redoStack.length > 0 ? '1' : '0.5';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                } else if (e.key === 'y' || (e.key === 'z' && e.shiftKey)) {
                    e.preventDefault();
                    redo();
                }
            }
        });

        // Map painting
        let painting = false;
        let erasing = false;

        mapCanvas.addEventListener('mousedown', (e) => {
            // Skip painting when grab tool is active
            if (grabToolActive) return;

            e.preventDefault();
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((e.clientX - rect.left) / tileSize);
            const y = Math.floor((e.clientY - rect.top) / tileSize);

            // Check if clicking on player preview (to drag it)
            if (playerPreviewVisible && isClickOnPlayer(e.clientX - rect.left, e.clientY - rect.top, tileSize)) {
                draggingPlayer = true;
                mapCanvas.style.cursor = 'move';
                return;
            }

            if (copyMode) {
                // Start copy selection
                copyStart = { x, y };
                copyEnd = { x, y };
                renderMap();
                return;
            }

            // Animated prop mode - click to place, right-click to remove (no dragging)
            if (mode === 'animProp') {
                if (e.button === 0 && currentAnimPropIndex >= 0) {
                    placeAnimPropAt(x, y);
                } else if (e.button === 2) {
                    removeAnimPropAt(x, y);
                }
                return;
            }

            // Sound mode - click to place/select tile sound, right-click to remove
            if (mode === 'sound' && soundAttachMode === 'tile') {
                const key = `${x},${y}`;
                if (e.button === 0) {
                    // If clicking on existing sound, select it for editing
                    if (tileSounds[key]) {
                        selectTileSound(key);
                    } else if (selectedTileSoundKey) {
                        // If a sound is selected and clicking empty tile, deselect
                        deselectTileSound();
                    } else {
                        // Place new sound
                        placeTileSound(x, y);
                    }
                } else if (e.button === 2) {
                    if (selectedTileSoundKey === key) {
                        deselectTileSound();
                    }
                    removeTileSound(key);
                }
                return;
            }

            // Lighting mode - click to place point lights (free placement), right-click to remove
            if (mode === 'lighting') {
                // Use float coordinates for free placement (not grid-snapped)
                const freeX = (e.clientX - rect.left) / tileSize;
                const freeY = (e.clientY - rect.top) / tileSize;
                if (e.button === 0) {
                    placeLightAt(freeX.toFixed(2), freeY.toFixed(2));
                } else if (e.button === 2) {
                    // Find and remove nearest light within 1 tile
                    removeNearestLight(freeX, freeY);
                }
                return;
            }

            // NPC mode - place, select, or draw path
            if (mode === 'npc') {
                if (npcPathDrawing && selectedPlacedNpcIndex >= 0) {
                    // Drawing path - add waypoint
                    if (e.button === 0) {
                        addNpcWaypoint(x, y);
                    } else if (e.button === 2) {
                        // Right-click removes last waypoint
                        removeLastNpcWaypoint();
                    }
                } else if (e.button === 0) {
                    // Check if clicking on existing placed NPC
                    const clickedNpcIdx = findPlacedNpcAt(x, y);
                    if (clickedNpcIdx >= 0) {
                        selectPlacedNpc(clickedNpcIdx);
                    } else if (currentNpcIndex >= 0) {
                        // Place new NPC
                        placeNpcAt(x, y);
                    }
                } else if (e.button === 2) {
                    // Right-click to remove placed NPC
                    removeNpcAt(x, y);
                }
                return;
            }

            if (e.button === 0) {
                if (eraseMode) {
                    erasing = true;
                } else {
                    painting = true;
                }
                paintAt(x, y);
            }
            if (e.button === 2) {
                erasing = true;
                paintAt(x, y);
            }
        });

        mapCanvas.addEventListener('mousemove', (e) => {
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((e.clientX - rect.left) / tileSize);
            const y = Math.floor((e.clientY - rect.top) / tileSize);

            // Handle dragging player preview
            if (draggingPlayer) {
                playerPreviewPos.x = x;
                playerPreviewPos.y = y;
                renderMap();
                return;
            }

            if (copyMode && copyStart) {
                // Update copy selection
                copyEnd = { x, y };
                renderMap();
                return;
            }

            // Update hover position for preview
            if (hoverMapPos?.x !== x || hoverMapPos?.y !== y) {
                hoverMapPos = { x, y };
                renderMap();
            }

            if (painting || erasing) {
                paintAt(x, y);
            }
        });

        mapCanvas.addEventListener('mouseleave', () => {
            hoverMapPos = null;
            renderMap();
        });

        window.addEventListener('mouseup', (e) => {
            // Stop dragging player
            if (draggingPlayer) {
                draggingPlayer = false;
                mapCanvas.style.cursor = grabToolActive ? 'grab' : 'crosshair';
            }
            if (copyMode && copyStart && copyEnd) {
                // Finish copy selection
                finishCopyFromMap();
            }
            if (painting || erasing) {
                commitStroke(); // Save undo state after stroke is complete
            }
            painting = false;
            erasing = false;
        });
        mapCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Touch support for mobile
        mapCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((touch.clientX - rect.left) / tileSize);
            const y = Math.floor((touch.clientY - rect.top) / tileSize);

            if (eraseMode) {
                erasing = true;
            } else {
                painting = true;
            }
            hoverMapPos = { x, y };
            paintAt(x, y);
            renderMap();
        }, { passive: false });

        mapCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = mapCanvas.getBoundingClientRect();
            const tileSize = gridSize * zoom;
            const x = Math.floor((touch.clientX - rect.left) / tileSize);
            const y = Math.floor((touch.clientY - rect.top) / tileSize);

            if (hoverMapPos?.x !== x || hoverMapPos?.y !== y) {
                hoverMapPos = { x, y };
                renderMap();
            }

            if (painting || erasing) {
                paintAt(x, y);
            }
        }, { passive: false });

        mapCanvas.addEventListener('touchend', (e) => {
            if (painting || erasing) {
                commitStroke();
            }
            painting = false;
            erasing = false;
            hoverMapPos = null;
            renderMap();
        });

        // Animated prop placement helpers - stores directly in layer like tiles
        // Supports multi-tile props based on frame size
        // Properly rotates the entire object shape, not just individual tiles
        function placeAnimPropAt(x, y) {
            if (x < 0 || y < 0 || x >= mapCols || y >= mapRows) return;
            if (!layers[currentLayer]) return;
            if (currentAnimPropIndex < 0 || !animatedProps[currentAnimPropIndex]) return;

            const prop = animatedProps[currentAnimPropIndex];
            const frames = prop.frames || [];
            if (frames.length === 0) return;

            // Calculate how many tiles this prop spans based on first frame size
            const frame = frames[0];
            const origW = Math.ceil(frame.w / gridSize);
            const origH = Math.ceil(frame.h / gridSize);

            // Determine placed dimensions based on rotation (90/270 swap W and H)
            const rot = tileRotation;
            const placedW = (rot === 90 || rot === 270) ? origH : origW;
            const placedH = (rot === 90 || rot === 270) ? origW : origH;

            // Place tiles with proper rotation mapping
            for (let ty = 0; ty < origH; ty++) {
                for (let tx = 0; tx < origW; tx++) {
                    // Calculate rotated position on map
                    let placedTx, placedTy;
                    if (rot === 0) {
                        placedTx = tx;
                        placedTy = ty;
                    } else if (rot === 90) {
                        // 90¬∞ CW: (tx, ty) -> (origH - 1 - ty, tx)
                        placedTx = origH - 1 - ty;
                        placedTy = tx;
                    } else if (rot === 180) {
                        // 180¬∞: (tx, ty) -> (origW - 1 - tx, origH - 1 - ty)
                        placedTx = origW - 1 - tx;
                        placedTy = origH - 1 - ty;
                    } else { // 270
                        // 270¬∞ CW: (tx, ty) -> (ty, origW - 1 - tx)
                        placedTx = ty;
                        placedTy = origW - 1 - tx;
                    }

                    const px = x + placedTx;
                    const py = y + placedTy;
                    if (px < 0 || py < 0 || px >= mapCols || py >= mapRows) continue;

                    if (!layers[currentLayer][py]) layers[currentLayer][py] = [];

                    // Store original source offset (for sprite lookup) and rotation
                    layers[currentLayer][py][px] = {
                        type: 'animTile',
                        propIndex: currentAnimPropIndex,
                        offsetX: tx,  // Original source tile X (for sprite lookup)
                        offsetY: ty,  // Original source tile Y (for sprite lookup)
                        tilesW: origW,  // Original prop size
                        tilesH: origH,
                        placedW: placedW,  // Placed size (after rotation)
                        placedH: placedH,
                        rotation: rot
                    };
                }
            }
            renderMap();
        }

        function removeAnimPropAt(x, y) {
            if (x < 0 || y < 0 || x >= mapCols || y >= mapRows) return;
            if (!layers[currentLayer] || !layers[currentLayer][y]) return;

            const cell = layers[currentLayer][y][x];
            if (cell && cell.type === 'animTile') {
                // Remove all tiles of this multi-tile prop
                const rot = cell.rotation || 0;
                const origW = cell.tilesW || 1;
                const origH = cell.tilesH || 1;
                const offsetX = cell.offsetX || 0;
                const offsetY = cell.offsetY || 0;

                // Calculate placed offset based on rotation (reverse of placement)
                let placedOffX, placedOffY;
                if (rot === 0) {
                    placedOffX = offsetX;
                    placedOffY = offsetY;
                } else if (rot === 90) {
                    placedOffX = origH - 1 - offsetY;
                    placedOffY = offsetX;
                } else if (rot === 180) {
                    placedOffX = origW - 1 - offsetX;
                    placedOffY = origH - 1 - offsetY;
                } else { // 270
                    placedOffX = offsetY;
                    placedOffY = origW - 1 - offsetX;
                }

                // Find origin (top-left of placed object)
                const originX = x - placedOffX;
                const originY = y - placedOffY;

                // Get placed dimensions
                const placedW = (rot === 90 || rot === 270) ? origH : origW;
                const placedH = (rot === 90 || rot === 270) ? origW : origH;

                // Remove all tiles in the placed rectangle
                for (let py = 0; py < placedH; py++) {
                    for (let px = 0; px < placedW; px++) {
                        const mapX = originX + px;
                        const mapY = originY + py;
                        if (mapX < 0 || mapY < 0 || mapX >= mapCols || mapY >= mapRows) continue;
                        if (layers[currentLayer][mapY]) {
                            layers[currentLayer][mapY][mapX] = null;
                        }
                    }
                }
            }
            renderMap();
        }

        // Copy from map functions
        function startCopyFromMap() {
            copyMode = true;
            copyStart = null;
            copyEnd = null;
            copiedTiles = null;
            document.getElementById('copyFromMapBtn').classList.add('active');
            document.getElementById('copyFromMapBtn').textContent = 'Selecting...';
            document.getElementById('copyModeInfo').style.display = 'inline';
            mapCanvas.style.cursor = 'copy';
        }

        function finishCopyFromMap() {
            if (!copyStart || !copyEnd) {
                cancelCopyMode();
                return;
            }

            const minX = Math.min(copyStart.x, copyEnd.x);
            const maxX = Math.max(copyStart.x, copyEnd.x);
            const minY = Math.min(copyStart.y, copyEnd.y);
            const maxY = Math.max(copyStart.y, copyEnd.y);

            const width = maxX - minX + 1;
            const height = maxY - minY + 1;

            // Copy tiles from current layer
            copiedTiles = [];
            for (let dy = 0; dy < height; dy++) {
                copiedTiles[dy] = [];
                for (let dx = 0; dx < width; dx++) {
                    const mx = minX + dx;
                    const my = minY + dy;
                    if (my >= 0 && my < mapRows && mx >= 0 && mx < mapCols) {
                        copiedTiles[dy][dx] = map[my][mx] ? { ...map[my][mx] } : null;
                    } else {
                        copiedTiles[dy][dx] = null;
                    }
                }
            }

            // Set as selected tile data for painting
            selectedTileData = {
                isCopied: true,
                width: width,
                height: height
            };

            // Reset flip when copying from map (copied tiles have their own transforms)
            tileFlippedH = false;
            updateFlipButton();

            // Update preview
            updateCopiedPreview();

            // Exit copy mode
            copyMode = false;
            copyStart = null;
            copyEnd = null;
            document.getElementById('copyFromMapBtn').classList.remove('active');
            document.getElementById('copyFromMapBtn').textContent = 'Copy from Map';
            document.getElementById('copyModeInfo').style.display = 'none';
            mapCanvas.style.cursor = 'crosshair';
            renderMap();
        }

        function cancelCopyMode() {
            copyMode = false;
            copyStart = null;
            copyEnd = null;
            document.getElementById('copyFromMapBtn').classList.remove('active');
            document.getElementById('copyFromMapBtn').textContent = 'Copy from Map';
            document.getElementById('copyModeInfo').style.display = 'none';
            mapCanvas.style.cursor = 'crosshair';
            renderMap();
        }

        function updateCopiedPreview() {
            if (!copiedTiles || copiedTiles.length === 0) return;

            const previewCanvas = document.getElementById('selectedTile');
            const previewCtx = previewCanvas.getContext('2d');
            const previewSize = 48;

            // Calculate tile size to fit preview
            const width = copiedTiles[0].length;
            const height = copiedTiles.length;
            const tilePreviewSize = Math.min(previewSize / width, previewSize / height, 16);

            previewCanvas.width = previewSize;
            previewCanvas.height = previewSize;

            previewCtx.fillStyle = '#333';
            previewCtx.fillRect(0, 0, previewSize, previewSize);
            previewCtx.imageSmoothingEnabled = false;

            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    const cell = copiedTiles[dy][dx];
                    if (cell) {
                        const px = dx * tilePreviewSize;
                        const py = dy * tilePreviewSize;

                        if (cell.type === 'tile') {
                            const cellTileset = tilesets[cell.tilesetIndex || 0]?.img || tilesetImg;
                            if (cellTileset) {
                                previewCtx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tilePreviewSize, tilePreviewSize);
                            }
                        } else if (cell.type === 'prop' && propImage) {
                            previewCtx.drawImage(propImage, cell.x, cell.y, gridSize, gridSize, px, py, tilePreviewSize, tilePreviewSize);
                        }
                    }
                }
            }

            document.getElementById('selectedPreview').style.display = 'flex';
            document.getElementById('selectedInfo').textContent = width + 'x' + height + ' copied';
            document.getElementById('selectedCollisionInfo').textContent = 'From map';
        }

        function paintAt(x, y) {
            if (!selectedTileData) {
                if (erasing && x >= 0 && x < mapCols && y >= 0 && y < mapRows) {
                    saveForUndo(x, y, map[y][x]); // Save for undo
                    map[y][x] = null;
                    renderMap();
                }
                return;
            }

            const selW = selectedTileData.width || 1;
            const selH = selectedTileData.height || 1;

            if (erasing) {
                // Erase area matching selection size
                for (let dy = 0; dy < selH; dy++) {
                    for (let dx = 0; dx < selW; dx++) {
                        const mx = x + dx;
                        const my = y + dy;
                        if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                            saveForUndo(mx, my, map[my][mx]); // Save for undo
                            map[my][mx] = null;
                        }
                    }
                }
            } else if (painting) {
                // Check if painting with copied tiles
                if (selectedTileData.isCopied && copiedTiles) {
                    // Paint copied tiles
                    for (let dy = 0; dy < selH; dy++) {
                        for (let dx = 0; dx < selW; dx++) {
                            const mx = x + dx;
                            const my = y + dy;

                            // Auto-expand map if painting at or beyond edge
                            if (my >= mapRows - 2) expandMapRows();
                            if (mx >= mapCols - 2) expandMapCols();

                            if (mx >= 0 && my >= 0 && mx < mapCols && my < mapRows) {
                                const srcCell = copiedTiles[dy] && copiedTiles[dy][dx];
                                if (srcCell) {
                                    saveForUndo(mx, my, map[my][mx]); // Save for undo
                                    map[my][mx] = { ...srcCell };
                                }
                            }
                        }
                    }
                } else {
                    // Paint from tileset selection
                    for (let dy = 0; dy < selH; dy++) {
                        for (let dx = 0; dx < selW; dx++) {
                            const mx = x + dx;
                            const my = y + dy;

                            // Auto-expand map if painting at or beyond edge
                            if (my >= mapRows - 2) expandMapRows();
                            if (mx >= mapCols - 2) expandMapCols();

                            if (mx >= 0 && my >= 0 && mx < mapCols && my < mapRows) {
                                // When flipped, mirror the source tile positions horizontally
                                const srcDx = tileFlippedH ? (selW - 1 - dx) : dx;
                                const tileX = selectedTileData.x + srcDx * gridSize;
                                const tileY = selectedTileData.y + dy * gridSize;

                                saveForUndo(mx, my, map[my][mx]); // Save for undo

                                if (selectedTileData.isProp) {
                                    // Paint as prop with propIndex (collision is painted separately in prop panel)
                                    map[my][mx] = { type: 'prop', x: tileX, y: tileY, propIndex: currentPropIndex };
                                } else {
                                    // Paint as tile with rotation and flip
                                    map[my][mx] = { type: 'tile', x: tileX, y: tileY, rotation: tileRotation, flipped: tileFlippedH, tilesetIndex: currentTilesetIndex };
                                }
                            }
                        }
                    }
                }
            }
            renderMap();
        }

        function renderMap() {
            const tileSize = gridSize * zoom;
            mapCanvas.width = mapCols * tileSize;
            mapCanvas.height = mapRows * tileSize;

            // Background
            mapCtx.fillStyle = '#1a1a1a';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    if ((x + y) % 2 === 0) {
                        mapCtx.fillStyle = '#222';
                        mapCtx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }

            // Grid
            mapCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            for (let x = 0; x <= mapCols; x++) {
                mapCtx.beginPath();
                mapCtx.moveTo(x * tileSize, 0);
                mapCtx.lineTo(x * tileSize, mapCanvas.height);
                mapCtx.stroke();
            }
            for (let y = 0; y <= mapRows; y++) {
                mapCtx.beginPath();
                mapCtx.moveTo(0, y * tileSize);
                mapCtx.lineTo(mapCanvas.width, y * tileSize);
                mapCtx.stroke();
            }

            // Draw all visible layers (bottom to top)
            if (tilesetImg) {
                mapCtx.imageSmoothingEnabled = false;

                for (let layerIdx = 0; layerIdx < layers.length; layerIdx++) {
                    // Draw player preview at the right layer position
                    if (layerIdx === playerLayerIndex && playerPreviewVisible) {
                        drawPlayerPreview(tileSize);
                    }

                    if (!layerVisibility[layerIdx]) continue;

                    const layerData = layers[layerIdx];
                    // Dim non-current layers slightly
                    mapCtx.globalAlpha = (layerIdx === currentLayer) ? 1 : 0.7;

                    for (let y = 0; y < mapRows; y++) {
                        for (let x = 0; x < mapCols; x++) {
                            const cell = layerData[y] && layerData[y][x];
                            if (!cell) continue;

                            const px = x * tileSize;
                            const py = y * tileSize;

                            if (cell.type === 'tile') {
                                // Use the correct tileset for this tile
                                const cellTileset = tilesets[cell.tilesetIndex || 0]?.img || tilesetImg;
                                drawRotatedTile(mapCtx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize, cell.rotation || 0, cell.flipped || false);

                                // Show collision only on current layer
                                if (layerIdx === currentLayer) {
                                    // Include tileset index in collision key lookup
                                    const tilesetIdx = cell.tilesetIndex || 0;
                                    const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                                    const collision = tileCollisions[key];
                                    if (collision && collision.length >= 3) {
                                        const scale = tileSize / gridSize;
                                        mapCtx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                                        mapCtx.beginPath();
                                        mapCtx.moveTo(px + collision[0].x * scale, py + collision[0].y * scale);
                                        for (let i = 1; i < collision.length; i++) {
                                            mapCtx.lineTo(px + collision[i].x * scale, py + collision[i].y * scale);
                                        }
                                        mapCtx.closePath();
                                        mapCtx.fill();
                                    }
                                }
                            } else if (cell.type === 'prop') {
                                // Draw prop from the correct prop image
                                const propIdx = cell.propIndex || 0;
                                const propImg = props[propIdx]?.img;
                                if (propImg) {
                                    mapCtx.drawImage(propImg, cell.x, cell.y, gridSize, gridSize, px, py, tileSize, tileSize);
                                }
                            } else if (cell.type === 'animTile') {
                                // Animated tile - cycles through frames (supports multi-tile)
                                const prop = animatedProps[cell.propIndex];
                                if (prop && prop._spriteImg && prop.frames && prop.frames.length > 0) {
                                    // Use origin tile's position for animation sync
                                    const originX = x - (cell.offsetX || 0);
                                    const originY = y - (cell.offsetY || 0);
                                    const key = originX + ',' + originY + ',' + layerIdx;
                                    const animState = placedAnimPropFrames[key] || { frame: 0 };
                                    const frameIdx = animState.frame % prop.frames.length;
                                    const frame = prop.frames[frameIdx];

                                    // Draw only this tile's portion of the frame
                                    const offsetX = cell.offsetX || 0;
                                    const offsetY = cell.offsetY || 0;
                                    const srcX = frame.x + offsetX * gridSize;
                                    const srcY = frame.y + offsetY * gridSize;

                                    mapCtx.imageSmoothingEnabled = false;
                                    // Draw with rotation support
                                    const rot = cell.rotation || 0;
                                    if (rot === 0) {
                                        mapCtx.drawImage(prop._spriteImg, srcX, srcY, gridSize, gridSize, px, py, tileSize, tileSize);
                                    } else {
                                        mapCtx.save();
                                        mapCtx.translate(px + tileSize / 2, py + tileSize / 2);
                                        mapCtx.rotate(rot * Math.PI / 180);
                                        mapCtx.drawImage(prop._spriteImg, srcX, srcY, gridSize, gridSize, -tileSize / 2, -tileSize / 2, tileSize, tileSize);
                                        mapCtx.restore();
                                    }

                                    // Show label in animProp mode (only on origin tile)
                                    if (mode === 'animProp' && offsetX === 0 && offsetY === 0) {
                                        mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
                                        mapCtx.font = '10px sans-serif';
                                        mapCtx.textAlign = 'center';
                                        const nameWidth = mapCtx.measureText(prop.name).width + 4;
                                        mapCtx.fillRect(px + tileSize / 2 - nameWidth / 2, py - 14, nameWidth, 14);
                                        mapCtx.fillStyle = '#fff';
                                        mapCtx.fillText(prop.name, px + tileSize / 2, py - 3);
                                    }
                                }
                            }
                        }
                    }
                }

                // Draw player preview at end if it's beyond all layers
                if (playerLayerIndex >= layers.length && playerPreviewVisible) {
                    drawPlayerPreview(tileSize);
                }

                mapCtx.globalAlpha = 1;
            }

            // Draw copy selection rectangle if in copy mode
            if (copyMode && copyStart && copyEnd) {
                const minX = Math.min(copyStart.x, copyEnd.x);
                const maxX = Math.max(copyStart.x, copyEnd.x);
                const minY = Math.min(copyStart.y, copyEnd.y);
                const maxY = Math.max(copyStart.y, copyEnd.y);

                mapCtx.fillStyle = 'rgba(74, 175, 255, 0.3)';
                mapCtx.fillRect(minX * tileSize, minY * tileSize, (maxX - minX + 1) * tileSize, (maxY - minY + 1) * tileSize);

                mapCtx.strokeStyle = '#4af';
                mapCtx.lineWidth = 3;
                mapCtx.setLineDash([5, 5]);
                mapCtx.strokeRect(minX * tileSize, minY * tileSize, (maxX - minX + 1) * tileSize, (maxY - minY + 1) * tileSize);
                mapCtx.setLineDash([]);
            }

            // Draw transparent preview of selected tiles at hover position
            // Skip when in animProp mode (animProp has its own preview)
            if (hoverMapPos && selectedTileData && !copyMode && mode !== 'animProp') {
                mapCtx.globalAlpha = 0.5;
                const selW = selectedTileData.width || 1;
                const selH = selectedTileData.height || 1;

                // Check if using copied tiles
                if (selectedTileData.isCopied && copiedTiles) {
                    // Draw preview of copied tiles
                    for (let dy = 0; dy < selH; dy++) {
                        for (let dx = 0; dx < selW; dx++) {
                            const mx = hoverMapPos.x + dx;
                            const my = hoverMapPos.y + dy;
                            if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                                const srcCell = copiedTiles[dy] && copiedTiles[dy][dx];
                                if (srcCell) {
                                    const px = mx * tileSize;
                                    const py = my * tileSize;
                                    if (srcCell.type === 'tile') {
                                        const cellTileset = tilesets[srcCell.tilesetIndex || 0]?.img || tilesetImg;
                                        if (cellTileset) {
                                            drawRotatedTile(mapCtx, cellTileset, srcCell.x, srcCell.y, gridSize, px, py, tileSize, srcCell.rotation || 0, srcCell.inverted || false);
                                        }
                                    } else if (srcCell.type === 'prop') {
                                        const propIdx = srcCell.propIndex || 0;
                                        const propImg = props[propIdx]?.img;
                                        if (propImg) {
                                            mapCtx.drawImage(propImg, srcCell.x, srcCell.y, gridSize, gridSize, px, py, tileSize, tileSize);
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Draw preview from tileset/prop selection
                    const sourceImg = selectedTileData.isProp ? propImage : tilesetImg;

                    if (sourceImg) {
                        for (let dy = 0; dy < selH; dy++) {
                            for (let dx = 0; dx < selW; dx++) {
                                const mx = hoverMapPos.x + dx;
                                const my = hoverMapPos.y + dy;
                                if (mx >= 0 && mx < mapCols && my >= 0 && my < mapRows) {
                                    // Mirror source tile position when flipped
                                    const srcDx = tileFlippedH ? (selW - 1 - dx) : dx;
                                    const tileX = selectedTileData.x + srcDx * gridSize;
                                    const tileY = selectedTileData.y + dy * gridSize;
                                    const px = mx * tileSize;
                                    const py = my * tileSize;
                                    if (selectedTileData.isProp) {
                                        mapCtx.drawImage(sourceImg, tileX, tileY, gridSize, gridSize, px, py, tileSize, tileSize);
                                    } else {
                                        drawRotatedTile(mapCtx, sourceImg, tileX, tileY, gridSize, px, py, tileSize, tileRotation, tileFlippedH);
                                    }
                                }
                            }
                        }
                    }
                }

                // Draw outline
                mapCtx.globalAlpha = 1;
                mapCtx.strokeStyle = selectedTileData.isCopied ? '#ff0' : (selectedTileData.isProp ? '#4af' : '#0f0');
                mapCtx.lineWidth = 2;
                mapCtx.strokeRect(
                    hoverMapPos.x * tileSize,
                    hoverMapPos.y * tileSize,
                    selW * tileSize,
                    selH * tileSize
                );
            }

            // Draw animated prop placement preview when hovering in animProp mode
            if (mode === 'animProp' && hoverMapPos && currentAnimPropIndex >= 0 && !copyMode) {
                const prop = animatedProps[currentAnimPropIndex];
                if (prop) {
                    const frames = prop.frames || [];
                    const spriteImg = prop._spriteImg;
                    const drawX = hoverMapPos.x * tileSize;
                    const drawY = hoverMapPos.y * tileSize;

                    mapCtx.globalAlpha = 0.5;
                    if (spriteImg && frames.length > 0) {
                        const frame = frames[0];
                        // Calculate how many tiles this prop spans
                        const origW = Math.ceil(frame.w / gridSize);
                        const origH = Math.ceil(frame.h / gridSize);
                        // Apply rotation to dimensions
                        const rot = tileRotation;
                        const placedW = (rot === 90 || rot === 270) ? origH : origW;
                        const placedH = (rot === 90 || rot === 270) ? origW : origH;
                        const drawW = placedW * tileSize;
                        const drawH = placedH * tileSize;

                        mapCtx.imageSmoothingEnabled = false;
                        // Draw with rotation
                        if (rot === 0) {
                            mapCtx.drawImage(spriteImg, frame.x, frame.y, frame.w, frame.h, drawX, drawY, origW * tileSize, origH * tileSize);
                        } else {
                            mapCtx.save();
                            mapCtx.translate(drawX + drawW / 2, drawY + drawH / 2);
                            mapCtx.rotate(rot * Math.PI / 180);
                            // After rotation, draw centered
                            mapCtx.drawImage(spriteImg, frame.x, frame.y, frame.w, frame.h, -origW * tileSize / 2, -origH * tileSize / 2, origW * tileSize, origH * tileSize);
                            mapCtx.restore();
                        }

                        mapCtx.globalAlpha = 1;
                        // Draw outline around full prop area
                        mapCtx.strokeStyle = '#f0a';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(drawX, drawY, drawW, drawH);
                    } else {
                        // Placeholder preview
                        mapCtx.fillStyle = '#f0a';
                        mapCtx.fillRect(drawX + 2, drawY + 2, tileSize - 4, tileSize - 4);
                        mapCtx.globalAlpha = 1;
                        mapCtx.strokeStyle = '#f0a';
                        mapCtx.lineWidth = 2;
                        mapCtx.strokeRect(drawX, drawY, tileSize, tileSize);
                    }
                }
            }

            // Draw sound markers when in sound mode
            if (mode === 'sound' && tileSounds) {
                Object.keys(tileSounds).forEach(key => {
                    try {
                        const parts = key.split(',');
                        const sx = parseInt(parts[0]) || 0;
                        const sy = parseInt(parts[1]) || 0;
                        const ts = tileSounds[key];
                        if (!ts) return;

                        const px = sx * tileSize + tileSize / 2;
                        const py = sy * tileSize + tileSize / 2;
                        const radius = ts.radius || 3;
                        const isSelected = key === selectedTileSoundKey;

                        // Draw radius circle (highlighted if selected)
                        mapCtx.strokeStyle = isSelected ? 'rgba(0, 255, 100, 0.8)' : 'rgba(255, 165, 0, 0.5)';
                        mapCtx.lineWidth = isSelected ? 3 : 2;
                        mapCtx.setLineDash(isSelected ? [] : [5, 5]);
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, radius * tileSize, 0, Math.PI * 2);
                        mapCtx.stroke();
                        mapCtx.setLineDash([]);

                        // Draw fade zone indicator if selected
                        if (isSelected && ts.fadePercent > 0) {
                            const fadeStartRadius = radius * (1 - ts.fadePercent);
                            mapCtx.strokeStyle = 'rgba(0, 255, 100, 0.4)';
                            mapCtx.lineWidth = 1;
                            mapCtx.setLineDash([3, 3]);
                            mapCtx.beginPath();
                            mapCtx.arc(px, py, fadeStartRadius * tileSize, 0, Math.PI * 2);
                            mapCtx.stroke();
                            mapCtx.setLineDash([]);
                        }

                        // Draw speaker icon (highlighted if selected)
                        mapCtx.fillStyle = isSelected ? '#0f8' : (ts.loop ? '#ffa500' : '#ff6600');
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, tileSize / 4, 0, Math.PI * 2);
                        mapCtx.fill();

                        // Sound wave icon
                        mapCtx.font = `${tileSize / 3}px sans-serif`;
                        mapCtx.textAlign = 'center';
                        mapCtx.textBaseline = 'middle';
                        mapCtx.fillStyle = '#fff';
                        mapCtx.fillText('üîä', px, py);
                    } catch (e) {
                        console.error('Error drawing sound marker:', key, e);
                    }
                });
            }

            // Draw light markers when in lighting mode
            if (mode === 'lighting' && pointLights) {
                Object.keys(pointLights).forEach(key => {
                    try {
                        if (!key.startsWith(currentMap + ':')) return;
                        const coords = key.split(':')[1];
                        const parts = coords.split(',');
                        const lx = parseInt(parts[0]) || 0;
                        const ly = parseInt(parts[1]) || 0;
                        const light = pointLights[key];
                        if (!light) return;

                        const px = lx * tileSize + tileSize / 2;
                        const py = ly * tileSize + tileSize / 2;
                        const radius = light.radius || 3;

                        // Draw light radius circle
                        mapCtx.strokeStyle = 'rgba(255, 220, 100, 0.6)';
                        mapCtx.lineWidth = 2;
                        mapCtx.setLineDash([5, 5]);
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, radius * tileSize, 0, Math.PI * 2);
                        mapCtx.stroke();
                        mapCtx.setLineDash([]);

                        // Draw light glow gradient preview
                        const gradient = mapCtx.createRadialGradient(px, py, 0, px, py, radius * tileSize);
                        gradient.addColorStop(0, 'rgba(255, 220, 100, 0.3)');
                        gradient.addColorStop(0.6, 'rgba(255, 200, 50, 0.1)');
                        gradient.addColorStop(1, 'rgba(255, 200, 50, 0)');
                        mapCtx.fillStyle = gradient;
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, radius * tileSize, 0, Math.PI * 2);
                        mapCtx.fill();

                        // Draw light bulb icon
                        mapCtx.fillStyle = light.flicker ? '#ffd700' : '#ffaa00';
                        mapCtx.beginPath();
                        mapCtx.arc(px, py, tileSize / 4, 0, Math.PI * 2);
                        mapCtx.fill();

                        mapCtx.font = `${tileSize / 3}px sans-serif`;
                        mapCtx.textAlign = 'center';
                        mapCtx.textBaseline = 'middle';
                        mapCtx.fillStyle = '#fff';
                        mapCtx.fillText('üí°', px, py);
                    } catch (e) {
                        console.error('Error drawing light marker:', key, e);
                    }
                });
            }

            // === DRAW PLACED NPCs AND PATHS ===
            if (mode === 'npc' || placedNpcs.length > 0) {
                const currentMapNpcs = placedNpcs.filter(p => p.mapName === currentMap);

                currentMapNpcs.forEach((placed, idx) => {
                    const globalIdx = placedNpcs.indexOf(placed);
                    const npc = npcs[placed.npcIndex];
                    if (!npc) return;

                    const isSelected = globalIdx === selectedPlacedNpcIndex;

                    // Use preview position if preview is active for this NPC
                    const usePreview = npcPathPreviewActive && isSelected && npcPreviewState;
                    const drawX = usePreview ? npcPreviewState.x : placed.x;
                    const drawY = usePreview ? npcPreviewState.y : placed.y;
                    const px = drawX * tileSize;
                    const py = drawY * tileSize;

                    // Draw path if has waypoints
                    if (placed.path && placed.path.length > 0) {
                        mapCtx.strokeStyle = isSelected ? '#4f4' : 'rgba(100, 255, 100, 0.5)';
                        mapCtx.lineWidth = isSelected ? 3 : 2;
                        mapCtx.setLineDash(isSelected ? [] : [5, 5]);

                        // Draw line from NPC to first waypoint
                        mapCtx.beginPath();
                        mapCtx.moveTo(px + tileSize / 2, py + tileSize / 2);

                        // Draw lines through all waypoints
                        placed.path.forEach((wp, i) => {
                            const wpx = wp.x * tileSize + tileSize / 2;
                            const wpy = wp.y * tileSize + tileSize / 2;
                            mapCtx.lineTo(wpx, wpy);
                        });

                        // If loop trigger, connect back to start
                        if (placed.trigger === 'loop') {
                            mapCtx.lineTo(px + tileSize / 2, py + tileSize / 2);
                        }

                        mapCtx.stroke();
                        mapCtx.setLineDash([]);

                        // Draw waypoint markers
                        placed.path.forEach((wp, i) => {
                            const wpx = wp.x * tileSize + tileSize / 2;
                            const wpy = wp.y * tileSize + tileSize / 2;

                            mapCtx.fillStyle = isSelected ? '#4f4' : 'rgba(100, 255, 100, 0.7)';
                            mapCtx.beginPath();
                            mapCtx.arc(wpx, wpy, 6, 0, Math.PI * 2);
                            mapCtx.fill();

                            // Number
                            mapCtx.fillStyle = '#000';
                            mapCtx.font = 'bold 10px sans-serif';
                            mapCtx.textAlign = 'center';
                            mapCtx.textBaseline = 'middle';
                            mapCtx.fillText((i + 1).toString(), wpx, wpy);
                        });
                    }

                    // Draw NPC sprite - use correct animation if previewing
                    const anims = npc.animations || {};
                    let anim;
                    let frameIdx = 0;

                    if (usePreview && npcPreviewState) {
                        // Use directional animation during preview
                        const dirMap = { 'down': 'walkDown', 'up': 'walkUp', 'left': 'walkLeft', 'right': 'walkRight' };
                        anim = anims[dirMap[npcPreviewState.direction]] || anims.walkDown || anims.idle;
                        frameIdx = npcPreviewState.frame % (anim ? anim.length : 1);
                    } else {
                        anim = anims.walkDown || anims.idle || Object.values(anims).find(a => a && a.length > 0);
                    }

                    if (npc.spriteData && anim && anim.length > 0) {
                        const frame = anim[frameIdx] || anim[0];
                        const img = npc._editorImg;

                        if (img && img.complete) {
                            mapCtx.imageSmoothingEnabled = false;
                            // Flip for left direction if no dedicated left animation
                            const flipX = usePreview && npcPreviewState && npcPreviewState.direction === 'left' && !anims.walkLeft?.length;
                            if (flipX) {
                                mapCtx.save();
                                mapCtx.translate(px + tileSize, py);
                                mapCtx.scale(-1, 1);
                                mapCtx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, tileSize, tileSize);
                                mapCtx.restore();
                            } else {
                                mapCtx.drawImage(img, frame.x, frame.y, frame.w, frame.h, px, py, tileSize, tileSize);
                            }
                        } else {
                            // Load image if not cached
                            if (!npc._editorImg) {
                                npc._editorImg = new Image();
                                npc._editorImg.onload = () => renderMap();
                                npc._editorImg.src = npc.spriteData;
                            }
                            // Draw placeholder
                            mapCtx.fillStyle = '#a4f';
                            mapCtx.fillRect(px + 4, py + 4, tileSize - 8, tileSize - 8);
                        }
                    } else {
                        // No sprite - draw placeholder
                        mapCtx.fillStyle = '#a4f';
                        mapCtx.fillRect(px + 4, py + 4, tileSize - 8, tileSize - 8);
                    }

                    // Draw selection highlight
                    if (isSelected) {
                        mapCtx.strokeStyle = '#4f4';
                        mapCtx.lineWidth = 3;
                        mapCtx.strokeRect(px, py, tileSize, tileSize);
                    }

                    // Draw NPC name label
                    if (mode === 'npc') {
                        mapCtx.fillStyle = 'rgba(0,0,0,0.7)';
                        mapCtx.font = '10px sans-serif';
                        mapCtx.textAlign = 'center';
                        const nameWidth = mapCtx.measureText(npc.name).width + 4;
                        mapCtx.fillRect(px + tileSize / 2 - nameWidth / 2, py - 14, nameWidth, 14);
                        mapCtx.fillStyle = isSelected ? '#4f4' : '#fff';
                        mapCtx.fillText(npc.name, px + tileSize / 2, py - 3);
                    }
                });
            }

            // === LIGHTING PREVIEW OVERLAY ===
            if (lightingPreviewEnabled && lightingSettings.ambientEnabled && lightingSettings.timeOfDay !== 'day') {
                const preset = TIME_PRESETS[lightingSettings.timeOfDay];
                if (preset && preset.a > 0) {
                    // Create offscreen canvas for lighting
                    const lightCanvas = document.createElement('canvas');
                    lightCanvas.width = mapCanvas.width;
                    lightCanvas.height = mapCanvas.height;
                    const lightCtx = lightCanvas.getContext('2d');

                    // Fill with ambient darkness
                    lightCtx.fillStyle = 'rgba(' + preset.r + ',' + preset.g + ',' + preset.b + ',' + preset.a + ')';
                    lightCtx.fillRect(0, 0, lightCanvas.width, lightCanvas.height);

                    // Cut out point lights
                    lightCtx.globalCompositeOperation = 'destination-out';
                    Object.keys(pointLights).forEach(key => {
                        if (!key.startsWith(currentMap + ':')) return;
                        const light = pointLights[key];
                        const coords = key.split(':')[1].split(',');
                        const lx = parseFloat(coords[0]);
                        const ly = parseFloat(coords[1]);
                        const px = lx * tileSize + tileSize / 2;
                        const py = ly * tileSize + tileSize / 2;
                        const radius = light.radius * tileSize;

                        const gradient = lightCtx.createRadialGradient(px, py, 0, px, py, radius);
                        gradient.addColorStop(0, 'rgba(255,255,255,1)');
                        gradient.addColorStop(0.6, 'rgba(255,255,255,0.5)');
                        gradient.addColorStop(1, 'rgba(255,255,255,0)');
                        lightCtx.fillStyle = gradient;
                        lightCtx.beginPath();
                        lightCtx.arc(px, py, radius, 0, Math.PI * 2);
                        lightCtx.fill();
                    });

                    // Draw lighting overlay on map
                    mapCtx.drawImage(lightCanvas, 0, 0);
                }
            }

            // Update expand button positions after canvas resize
            positionExpandButtons();
        }

        // Zoom
        function zoomIn() { if (zoom < 4) { zoom++; document.getElementById('zoomLevel').textContent = zoom + 'x'; renderMap(); } }
        function zoomOut() { if (zoom > 1) { zoom--; document.getElementById('zoomLevel').textContent = zoom + 'x'; renderMap(); } }

        // Only zoom with scroll when grab tool is active
        document.getElementById('mapViewport').addEventListener('wheel', (e) => {
            if (grabToolActive) {
                e.preventDefault();
                if (e.deltaY < 0) zoomIn(); else zoomOut();
            }
        });

        function clearMap() { if (confirm('Clear entire map?')) { initMap(); mapInitialized = true; renderMap(); } }

        // ===== GRAB TOOL =====
        let grabToolActive = false;
        let grabbing = false;
        let grabStartX = 0;
        let grabStartY = 0;
        let grabScrollX = 0;
        let grabScrollY = 0;

        function toggleGrabTool() {
            grabToolActive = !grabToolActive;
            const btn = document.getElementById('grabToolBtn');
            const canvas = document.getElementById('mapCanvas');
            const hint = document.getElementById('toolHint');

            if (grabToolActive) {
                btn.style.background = '#4af';
                btn.style.color = '#000';
                canvas.classList.add('grabbing');
                hint.textContent = 'Drag to pan | Scroll to zoom';
            } else {
                btn.style.background = '#555';
                btn.style.color = 'white';
                canvas.classList.remove('grabbing');
                hint.textContent = 'Left: paint | Right: erase';
            }
        }

        // Grab/pan handlers
        const mapViewport = document.getElementById('mapViewport');

        mapCanvas.addEventListener('mousedown', (e) => {
            if (grabToolActive && e.button === 0) {
                grabbing = true;
                grabStartX = e.clientX;
                grabStartY = e.clientY;
                grabScrollX = mapViewport.scrollLeft;
                grabScrollY = mapViewport.scrollTop;
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (grabbing) {
                const dx = e.clientX - grabStartX;
                const dy = e.clientY - grabStartY;
                mapViewport.scrollLeft = grabScrollX - dx;
                mapViewport.scrollTop = grabScrollY - dy;
            }
        });

        document.addEventListener('mouseup', () => {
            grabbing = false;
        });

        // ===== EXPAND MAP =====
        function expandMap(direction) {
            const expandAmount = 5; // Add 5 rows/cols at a time

            if (direction === 'right') {
                mapCols += expandAmount;
                layers.forEach(layer => {
                    for (let y = 0; y < layer.length; y++) {
                        for (let i = 0; i < expandAmount; i++) {
                            layer[y].push(null);
                        }
                    }
                });
            } else if (direction === 'left') {
                mapCols += expandAmount;
                layers.forEach(layer => {
                    for (let y = 0; y < layer.length; y++) {
                        for (let i = 0; i < expandAmount; i++) {
                            layer[y].unshift(null);
                        }
                    }
                });
                // Shift placed animated props
                placedAnimProps.forEach(ap => ap.x += expandAmount);
                // Shift placed props
                placedProps.forEach(prop => prop.x += expandAmount);
            } else if (direction === 'bottom') {
                mapRows += expandAmount;
                layers.forEach(layer => {
                    for (let i = 0; i < expandAmount; i++) {
                        const newRow = [];
                        for (let x = 0; x < mapCols; x++) newRow.push(null);
                        layer.push(newRow);
                    }
                });
            } else if (direction === 'top') {
                mapRows += expandAmount;
                layers.forEach(layer => {
                    for (let i = 0; i < expandAmount; i++) {
                        const newRow = [];
                        for (let x = 0; x < mapCols; x++) newRow.push(null);
                        layer.unshift(newRow);
                    }
                });
                // Shift placed animated props
                placedAnimProps.forEach(ap => ap.y += expandAmount);
                // Shift placed props
                placedProps.forEach(prop => prop.y += expandAmount);
            }

            renderMap();
        }

        // Position expand buttons at map edges
        function positionExpandButtons() {
            const canvas = document.getElementById('mapCanvas');
            const viewport = document.getElementById('mapViewport');
            if (!canvas || !viewport) return;

            const padding = 40; // viewport padding
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;

            const topBtn = document.querySelector('.expand-top');
            const bottomBtn = document.querySelector('.expand-bottom');
            const leftBtn = document.querySelector('.expand-left');
            const rightBtn = document.querySelector('.expand-right');

            if (topBtn) {
                topBtn.style.left = (padding + canvasWidth / 2 - 30) + 'px';
            }
            if (bottomBtn) {
                bottomBtn.style.left = (padding + canvasWidth / 2 - 30) + 'px';
                bottomBtn.style.top = (padding + canvasHeight + 5) + 'px';
            }
            if (leftBtn) {
                leftBtn.style.top = (padding + canvasHeight / 2 - 30) + 'px';
            }
            if (rightBtn) {
                rightBtn.style.left = (padding + canvasWidth + 5) + 'px';
                rightBtn.style.top = (padding + canvasHeight / 2 - 30) + 'px';
            }
        }

        // ===== MULTIPLE PROPS SYSTEM =====
        // Props work just like tilesets - load images, select area, paint on map
        // Each prop has its own collision masks

        function loadPropImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Save current prop's collision masks before switching
                    if (currentPropIndex >= 0 && props[currentPropIndex]) {
                        props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
                    }

                    // Add new prop to array
                    const newProp = {
                        name: file.name,
                        img: img,
                        data: e.target.result,
                        collisionMasks: {}
                    };
                    props.push(newProp);
                    currentPropIndex = props.length - 1;

                    // Set current prop shortcuts
                    propImage = img;
                    propImageData = e.target.result;
                    propCollisionMasks = newProp.collisionMasks;
                    propSelection = null;

                    updatePropDropdown();
                    updatePropUI();
                    drawPropTileset();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        }

        function switchProp() {
            const select = document.getElementById('propSelect');
            const newIndex = parseInt(select.value);

            // Save current prop's collision masks
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Switch to new prop
            currentPropIndex = newIndex;
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                propImage = props[currentPropIndex].img;
                propImageData = props[currentPropIndex].data;
                propCollisionMasks = props[currentPropIndex].collisionMasks || {};
            } else {
                propImage = null;
                propImageData = null;
                propCollisionMasks = {};
            }

            propSelection = null;
            updatePropUI();
            drawPropTileset();
            renderMap();
        }

        function updatePropDropdown() {
            const select = document.getElementById('propSelect');
            if (!select) return;
            select.innerHTML = '';

            if (props.length === 0) {
                const opt = document.createElement('option');
                opt.value = -1;
                opt.textContent = 'No props loaded';
                select.appendChild(opt);
            } else {
                props.forEach((prop, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.textContent = prop.name;
                    if (i === currentPropIndex) opt.selected = true;
                    select.appendChild(opt);
                });
            }
        }

        function updatePropUI() {
            const propControls = document.getElementById('propControls');
            const noPropMessage = document.getElementById('noPropMessage');
            if (!propControls || !noPropMessage) return;
            const hasProps = props.length > 0 && currentPropIndex >= 0;
            propControls.style.display = hasProps ? 'block' : 'none';
            noPropMessage.style.display = hasProps ? 'none' : 'block';
        }

        function drawPropTileset() {
            if (!propTilesetCanvas || !propTilesetCtx) return;
            if (!propImage) {
                propTilesetCanvas.width = 200;
                propTilesetCanvas.height = 50;
                propTilesetCtx.fillStyle = '#333';
                propTilesetCtx.fillRect(0, 0, 200, 50);
                propTilesetCtx.fillStyle = '#888';
                propTilesetCtx.font = '12px sans-serif';
                propTilesetCtx.fillText('Load a prop image...', 20, 30);
                return;
            }

            const displayZoom = 3; // Larger zoom for easier collision painting
            propTilesetCanvas.width = propImage.naturalWidth * displayZoom;
            propTilesetCanvas.height = propImage.naturalHeight * displayZoom;

            propTilesetCtx.imageSmoothingEnabled = false;
            propTilesetCtx.drawImage(propImage, 0, 0, propTilesetCanvas.width, propTilesetCanvas.height);

            // Draw collision overlay (red pixels where collision is set)
            if (propTool === 'collision' || propTool === 'erase') {
                const cols = Math.floor(propImage.naturalWidth / gridSize);
                const rows = Math.floor(propImage.naturalHeight / gridSize);

                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const tileX = col * gridSize;
                        const tileY = row * gridSize;
                        const key = tileX + ',' + tileY;
                        const mask = propCollisionMasks[key];

                        if (mask) {
                            for (let py = 0; py < gridSize; py++) {
                                for (let px = 0; px < gridSize; px++) {
                                    if (mask[py] && mask[py][px]) {
                                        propTilesetCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                                        propTilesetCtx.fillRect(
                                            (tileX + px) * displayZoom,
                                            (tileY + py) * displayZoom,
                                            displayZoom,
                                            displayZoom
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Grid
            propTilesetCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            const cols = Math.floor(propImage.naturalWidth / gridSize);
            const rows = Math.floor(propImage.naturalHeight / gridSize);

            for (let x = 0; x <= cols; x++) {
                propTilesetCtx.beginPath();
                propTilesetCtx.moveTo(x * gridSize * displayZoom, 0);
                propTilesetCtx.lineTo(x * gridSize * displayZoom, propTilesetCanvas.height);
                propTilesetCtx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                propTilesetCtx.beginPath();
                propTilesetCtx.moveTo(0, y * gridSize * displayZoom);
                propTilesetCtx.lineTo(propTilesetCanvas.width, y * gridSize * displayZoom);
                propTilesetCtx.stroke();
            }

            // Highlight selection (only in select mode)
            if (propSelection && propTool === 'select') {
                propTilesetCtx.fillStyle = 'rgba(74, 175, 255, 0.4)';
                propTilesetCtx.strokeStyle = '#4af';
                propTilesetCtx.lineWidth = 2;
                propTilesetCtx.fillRect(
                    propSelection.x * displayZoom,
                    propSelection.y * displayZoom,
                    propSelection.width * displayZoom,
                    propSelection.height * displayZoom
                );
                propTilesetCtx.strokeRect(
                    propSelection.x * displayZoom,
                    propSelection.y * displayZoom,
                    propSelection.width * displayZoom,
                    propSelection.height * displayZoom
                );
            }
        }

        // Prop tileset selection and collision painting
        let propSelectionStart = null;

        function paintPropCollisionAt(canvasX, canvasY, isErasing) {
            const displayZoom = 3;
            const imgX = Math.floor(canvasX / displayZoom);
            const imgY = Math.floor(canvasY / displayZoom);

            // Find which tile this pixel belongs to
            const tileCol = Math.floor(imgX / gridSize);
            const tileRow = Math.floor(imgY / gridSize);
            const tileX = tileCol * gridSize;
            const tileY = tileRow * gridSize;
            const key = tileX + ',' + tileY;

            // Initialize mask if needed
            if (!propCollisionMasks[key]) {
                propCollisionMasks[key] = [];
                for (let y = 0; y < gridSize; y++) {
                    propCollisionMasks[key][y] = new Array(gridSize).fill(false);
                }
            }

            // Paint with brush
            const halfBrush = Math.floor(propBrushSize / 2);
            for (let dy = -halfBrush; dy < halfBrush; dy++) {
                for (let dx = -halfBrush; dx < halfBrush; dx++) {
                    const px = imgX + dx;
                    const py = imgY + dy;

                    // Get the tile for this pixel
                    const ptileCol = Math.floor(px / gridSize);
                    const ptileRow = Math.floor(py / gridSize);
                    const ptileX = ptileCol * gridSize;
                    const ptileY = ptileRow * gridSize;
                    const pkey = ptileX + ',' + ptileY;

                    // Local coords within tile
                    const localX = px - ptileX;
                    const localY = py - ptileY;

                    if (localX >= 0 && localX < gridSize && localY >= 0 && localY < gridSize) {
                        if (!propCollisionMasks[pkey]) {
                            propCollisionMasks[pkey] = [];
                            for (let y = 0; y < gridSize; y++) {
                                propCollisionMasks[pkey][y] = new Array(gridSize).fill(false);
                            }
                        }
                        propCollisionMasks[pkey][localY][localX] = !isErasing;
                    }
                }
            }

            drawPropTileset();
        }

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mousedown', (e) => {
            if (!propImage) return;
            const rect = propTilesetCanvas.getBoundingClientRect();
            const displayZoom = 3;

            if (propTool === 'select') {
                // Tile selection mode
                const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
                const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;
                propSelectionStart = { x, y };
            } else {
                // Collision painting mode
                propPainting = true;
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                paintPropCollisionAt(canvasX, canvasY, propTool === 'erase');
            }
        });

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mousemove', (e) => {
            if (!propImage || !propPainting) return;
            if (propTool === 'collision' || propTool === 'erase') {
                const rect = propTilesetCanvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                paintPropCollisionAt(canvasX, canvasY, propTool === 'erase');
            }
        });

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mouseup', (e) => {
            if (!propImage) return;

            if (propTool === 'select' && propSelectionStart) {
                const rect = propTilesetCanvas.getBoundingClientRect();
                const displayZoom = 3;
                const x = Math.floor((e.clientX - rect.left) / displayZoom / gridSize) * gridSize;
                const y = Math.floor((e.clientY - rect.top) / displayZoom / gridSize) * gridSize;

                const minX = Math.min(propSelectionStart.x, x);
                const minY = Math.min(propSelectionStart.y, y);
                const maxX = Math.max(propSelectionStart.x, x) + gridSize;
                const maxY = Math.max(propSelectionStart.y, y) + gridSize;

                propSelection = {
                    x: minX,
                    y: minY,
                    width: maxX - minX,
                    height: maxY - minY
                };

                // When in prop mode, set this as the selected tile data for painting
                if (mode === 'prop') {
                    selectedTileData = {
                        x: minX,
                        y: minY,
                        width: (maxX - minX) / gridSize,
                        height: (maxY - minY) / gridSize,
                        isProp: true // Flag to indicate this is from prop image
                    };
                }

                propSelectionStart = null;
                drawPropTileset();
            }

            propPainting = false;
        });

        if (propTilesetCanvas) propTilesetCanvas.addEventListener('mouseleave', () => {
            propPainting = false;
        });

        if (propTilesetCanvas) propTilesetCanvas.style.cursor = 'crosshair';

        // Expand map size
        function expandMapRows() {
            mapRows += 10;
            layers.forEach(layer => {
                while (layer.length < mapRows) {
                    layer.push(new Array(mapCols).fill(null));
                }
            });
        }

        function expandMapCols() {
            mapCols += 10;
            layers.forEach(layer => {
                layer.forEach((row, i) => {
                    if (row) {
                        while (row.length < mapCols) row.push(null);
                    }
                });
            });
        }

        // ===== NPC FUNCTIONS =====
        let npcCurrentAnim = 'walkDown'; // Currently selected animation type
        let npcAnimations = {}; // { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [] }

        function openNpcEditor(editIndex = -1) {
            npcStopPreview();
            npcEditorEditingIndex = editIndex;
            npcCurrentAnim = 'walkDown';
            npcAnimations = { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [] };

            if (editIndex >= 0 && npcs[editIndex]) {
                // Editing existing NPC
                const npc = npcs[editIndex];
                npcEditorFrameW = npc.frameWidth || 32;
                npcEditorFrameH = npc.frameHeight || 32;
                npcEditorData = npc.spriteData;
                document.getElementById('npcNameInput').value = npc.name;
                const fps = npc.fps || 8;
                document.getElementById('npcSpeedSlider').value = fps;
                document.getElementById('npcSpeedLabel').textContent = fps + ' fps';

                // Load animations
                if (npc.animations) {
                    npcAnimations = JSON.parse(JSON.stringify(npc.animations));
                }

                if (npc.spriteData) {
                    npcEditorImage = new Image();
                    npcEditorImage.onload = () => {
                        document.getElementById('npcFrameSection').style.display = 'block';
                        document.getElementById('npcAnimSection').style.display = 'block';
                        document.getElementById('npcNameSection').style.display = 'block';
                        npcUpdateGrid();
                        npcDrawCanvas();
                        npcUpdateFramesList();
                        npcStartPreview();
                    };
                    npcEditorImage.src = npc.spriteData;
                    document.getElementById('npcFileName').textContent = 'Sprite loaded';
                }
            } else {
                // New NPC
                npcEditorImage = null;
                npcEditorData = null;
                npcEditorFrameW = 32;
                npcEditorFrameH = 32;
                document.getElementById('npcNameInput').value = '';
                document.getElementById('npcSpeedSlider').value = 8;
                document.getElementById('npcSpeedLabel').textContent = '8 fps';
                document.getElementById('npcFileName').textContent = '';
                document.getElementById('npcFrameSection').style.display = 'none';
                document.getElementById('npcAnimSection').style.display = 'none';
                document.getElementById('npcNameSection').style.display = 'none';
                // Clear canvases
                const previewCtx = document.getElementById('npcLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 96, 96);
                const editorCanvas = document.getElementById('npcEditorCanvas');
                const editorCtx = editorCanvas.getContext('2d');
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                const framesList = document.getElementById('npcFramesList');
                if (framesList) framesList.innerHTML = '';
                const fileInput = document.getElementById('npcFileInput');
                if (fileInput) fileInput.value = '';
            }

            npcSelectAnim('walkDown');
            document.getElementById('npcModal').classList.add('visible');
        }

        function npcLoadSheet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                npcEditorData = e.target.result;
                npcEditorImage = new Image();
                npcEditorImage.onload = () => {
                    document.getElementById('npcFileName').textContent = file.name + ' (' + npcEditorImage.naturalWidth + 'x' + npcEditorImage.naturalHeight + ')';
                    document.getElementById('npcFrameSection').style.display = 'block';
                    document.getElementById('npcAnimSection').style.display = 'block';
                    document.getElementById('npcNameSection').style.display = 'block';
                    npcUpdateGrid();
                    npcDrawCanvas();
                };
                npcEditorImage.src = npcEditorData;
            };
            reader.readAsDataURL(file);
        }

        function npcSetFrameSize(w, h) {
            npcEditorFrameW = w;
            npcEditorFrameH = h;
            npcUpdateGrid();
            npcDrawCanvas();
        }

        function npcResetGrid() {
            npcEditorFrameW = 32;
            npcEditorFrameH = 32;
            npcUpdateGrid();
            npcDrawCanvas();
        }

        function npcUpdateGrid() {
            if (npcEditorImage) {
                const cols = Math.floor(npcEditorImage.naturalWidth / npcEditorFrameW);
                const rows = Math.floor(npcEditorImage.naturalHeight / npcEditorFrameH);
                document.getElementById('npcGridInfo').textContent = cols + ' cols x ' + rows + ' rows (' + npcEditorFrameW + 'x' + npcEditorFrameH + ')';
            }
            npcDrawCanvas();
        }

        function npcSelectAnim(animName) {
            npcCurrentAnim = animName;
            // Update all button states and show frame counts
            npcUpdateAnimButtons();
            // Update display
            const names = { walkDown: 'Walk Down', walkUp: 'Walk Up', walkLeft: 'Walk Left', walkRight: 'Walk Right', idle: 'Idle' };
            document.getElementById('npcCurrentAnimName').textContent = names[animName] || animName;
            npcDrawCanvas();
            npcUpdateFramesList();
            npcStartPreview();
        }

        function npcUpdateAnimButtons() {
            const animMap = {
                'Down': 'walkDown',
                'Up': 'walkUp',
                'Left': 'walkLeft',
                'Right': 'walkRight',
                'Idle': 'idle'
            };
            const labels = {
                'Down': 'Walk Down',
                'Up': 'Walk Up',
                'Left': 'Walk Left',
                'Right': 'Walk Right',
                'Idle': 'Idle'
            };

            for (const [dir, animKey] of Object.entries(animMap)) {
                const btn = document.getElementById('npcAnim' + dir);
                if (btn) {
                    const frames = npcAnimations[animKey] || [];
                    const isActive = npcCurrentAnim === animKey;
                    btn.classList.toggle('active', isActive);

                    // Show frame count and checkmark if has frames
                    if (frames.length > 0) {
                        btn.innerHTML = `‚úì ${labels[dir]} <span style="color:#4f4;">(${frames.length})</span>`;
                        btn.style.background = isActive ? '#2a5a2a' : '#1a3a1a';
                    } else {
                        btn.innerHTML = labels[dir];
                        btn.style.background = isActive ? '#555' : '#333';
                    }
                }
            }
        }

        function npcDrawCanvas() {
            const canvas = document.getElementById('npcEditorCanvas');
            const ctx = canvas.getContext('2d');

            if (!npcEditorImage) {
                canvas.width = 400;
                canvas.height = 300;
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.textAlign = 'center';
                ctx.font = '14px monospace';
                ctx.fillText('Load a sprite sheet to begin', canvas.width / 2, canvas.height / 2);
                return;
            }

            const scale = 3;
            canvas.width = npcEditorImage.naturalWidth * scale;
            canvas.height = npcEditorImage.naturalHeight * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(npcEditorImage, 0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;

            const fw = npcEditorFrameW * scale;
            const fh = npcEditorFrameH * scale;

            for (let x = 0; x <= canvas.width; x += fw) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += fh) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Highlight frames for current animation
            const currentFrames = npcAnimations[npcCurrentAnim] || [];
            currentFrames.forEach((frame, i) => {
                const sx = frame.x * scale;
                const sy = frame.y * scale;
                const sw = frame.w * scale;
                const sh = frame.h * scale;

                ctx.fillStyle = 'rgba(74, 170, 255, 0.3)';
                ctx.fillRect(sx, sy, sw, sh);
                ctx.strokeStyle = '#4af';
                ctx.lineWidth = 2;
                ctx.strokeRect(sx, sy, sw, sh);

                // Frame number
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText((i + 1).toString(), sx + sw / 2, sy + sh / 2 + 5);
            });
        }

        function npcCanvasClick(e) {
            if (!npcEditorImage) return;

            const canvas = document.getElementById('npcEditorCanvas');
            const rect = canvas.getBoundingClientRect();
            const scale = 3;

            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const gridX = Math.floor(clickX / scale / npcEditorFrameW);
            const gridY = Math.floor(clickY / scale / npcEditorFrameH);

            const frameX = gridX * npcEditorFrameW;
            const frameY = gridY * npcEditorFrameH;

            // Initialize animation array if needed
            if (!npcAnimations[npcCurrentAnim]) {
                npcAnimations[npcCurrentAnim] = [];
            }

            const frames = npcAnimations[npcCurrentAnim];

            // Check if already selected - if so, remove it
            const existingIdx = frames.findIndex(f => f.x === frameX && f.y === frameY);
            if (existingIdx >= 0) {
                frames.splice(existingIdx, 1);
            } else {
                // Add new frame
                frames.push({
                    x: frameX,
                    y: frameY,
                    w: npcEditorFrameW,
                    h: npcEditorFrameH
                });
            }

            npcDrawCanvas();
            npcUpdateFramesList();
            npcUpdateAnimButtons();
            npcStartPreview();
        }

        function npcUpdateFramesList() {
            const container = document.getElementById('npcFramesList');
            const countEl = document.getElementById('npcFrameCount');
            const frames = npcAnimations[npcCurrentAnim] || [];

            countEl.textContent = frames.length;

            if (!npcEditorImage || frames.length === 0) {
                container.innerHTML = '<span style="color:#666;">Click frames on sprite sheet to add</span>';
                return;
            }

            container.innerHTML = '';
            frames.forEach((frame, i) => {
                const div = document.createElement('div');
                div.style.cssText = 'display:inline-block; margin:2px; cursor:pointer;';

                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = 40;
                thumbCanvas.height = 40;
                const thumbCtx = thumbCanvas.getContext('2d');
                thumbCtx.imageSmoothingEnabled = false;

                const scale = Math.min(40 / frame.w, 40 / frame.h);
                const dw = frame.w * scale;
                const dh = frame.h * scale;
                const dx = (40 - dw) / 2;
                const dy = (40 - dh) / 2;

                thumbCtx.drawImage(npcEditorImage, frame.x, frame.y, frame.w, frame.h, dx, dy, dw, dh);

                thumbCanvas.style.border = '2px solid #4af';
                thumbCanvas.style.borderRadius = '3px';
                thumbCanvas.title = 'Frame ' + (i + 1) + ' - Click to remove';
                thumbCanvas.onclick = () => {
                    npcAnimations[npcCurrentAnim].splice(i, 1);
                    npcDrawCanvas();
                    npcUpdateFramesList();
                    npcUpdateAnimButtons();
                };

                div.appendChild(thumbCanvas);
                container.appendChild(div);
            });
        }

        function npcUpdateSpeed() {
            const fps = parseInt(document.getElementById('npcSpeedSlider').value);
            document.getElementById('npcSpeedLabel').textContent = fps + ' fps';
            npcStartPreview();
        }

        function npcStartPreview() {
            npcStopPreview();
            const frames = npcAnimations[npcCurrentAnim] || [];
            if (frames.length === 0 || !npcEditorImage) return;

            const fps = parseInt(document.getElementById('npcSpeedSlider').value) || 8;
            npcPreviewFrame = 0;
            npcPreviewPlaying = true;

            npcPreviewInterval = setInterval(() => {
                const canvas = document.getElementById('npcLivePreview');
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, 96, 96);

                if (frames.length > 0) {
                    const frame = frames[npcPreviewFrame % frames.length];
                    const scale = Math.min(96 / frame.w, 96 / frame.h);
                    const dw = frame.w * scale;
                    const dh = frame.h * scale;
                    const dx = (96 - dw) / 2;
                    const dy = (96 - dh) / 2;
                    ctx.drawImage(npcEditorImage, frame.x, frame.y, frame.w, frame.h, dx, dy, dw, dh);
                    npcPreviewFrame = (npcPreviewFrame + 1) % frames.length;
                }
            }, 1000 / fps);
        }

        function npcStopPreview() {
            if (npcPreviewInterval) {
                clearInterval(npcPreviewInterval);
                npcPreviewInterval = null;
            }
            npcPreviewPlaying = false;
        }

        function npcClearCurrentAnim() {
            npcAnimations[npcCurrentAnim] = [];
            npcDrawCanvas();
            npcUpdateFramesList();
            npcStopPreview();
            const ctx = document.getElementById('npcLivePreview').getContext('2d');
            ctx.clearRect(0, 0, 96, 96);
        }

        function npcSave() {
            const name = document.getElementById('npcNameInput').value.trim() || 'NPC ' + (npcs.length + 1);

            // Check if at least one animation has frames
            const hasFrames = Object.values(npcAnimations).some(arr => arr.length > 0);
            if (!hasFrames) {
                alert('Please select at least one frame for any animation');
                return;
            }

            const fps = parseInt(document.getElementById('npcSpeedSlider').value) || 8;

            const npcData = {
                name: name,
                spriteData: npcEditorData,
                frameWidth: npcEditorFrameW,
                frameHeight: npcEditorFrameH,
                animations: JSON.parse(JSON.stringify(npcAnimations)),
                fps: fps
            };

            if (npcEditorEditingIndex >= 0) {
                npcs[npcEditorEditingIndex] = npcData;
            } else {
                npcs.push(npcData);
                currentNpcIndex = npcs.length - 1;
            }

            document.getElementById('npcModal').classList.remove('visible');
            npcStopPreview();
            updateNpcList();
        }

        function npcCancel() {
            document.getElementById('npcModal').classList.remove('visible');
            npcStopPreview();
        }

        function updateNpcList() {
            const container = document.getElementById('npcList');

            if (npcs.length === 0) {
                container.innerHTML = '<div style="color:#888; font-size:12px; padding:10px; text-align:center;">No NPCs created yet</div>';
                return;
            }

            container.innerHTML = '';
            npcs.forEach((npc, i) => {
                const div = document.createElement('div');
                div.style.cssText = 'display:flex; align-items:center; gap:8px; padding:5px; margin-bottom:5px; background:' + (i === currentNpcIndex ? '#2a5a8a' : '#333') + '; border-radius:4px; cursor:pointer;';

                // Thumbnail
                const thumb = document.createElement('canvas');
                thumb.width = 32;
                thumb.height = 32;
                thumb.style.cssText = 'border:1px solid #555; border-radius:3px; image-rendering:pixelated;';

                // Use first frame from walkDown or first available animation
                const anims = npc.animations || {};
                const firstAnim = anims.walkDown || anims.idle || Object.values(anims).find(a => a && a.length > 0);
                if (npc.spriteData && firstAnim && firstAnim.length > 0) {
                    const img = new Image();
                    img.onload = () => {
                        const ctx = thumb.getContext('2d');
                        ctx.imageSmoothingEnabled = false;
                        const frame = firstAnim[0];
                        const scale = Math.min(32 / frame.w, 32 / frame.h);
                        const dw = frame.w * scale;
                        const dh = frame.h * scale;
                        ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, (32-dw)/2, (32-dh)/2, dw, dh);
                    };
                    img.src = npc.spriteData;
                }

                // Name
                const nameSpan = document.createElement('span');
                nameSpan.textContent = npc.name;
                nameSpan.style.cssText = 'flex:1; font-size:12px;';

                // Edit button
                const editBtn = document.createElement('button');
                editBtn.textContent = '‚úé';
                editBtn.style.cssText = 'padding:2px 6px; font-size:11px; background:#666;';
                editBtn.onclick = (e) => { e.stopPropagation(); openNpcEditor(i); };

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = '√ó';
                delBtn.style.cssText = 'padding:2px 6px; font-size:11px; background:#a55;';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Delete NPC "' + npc.name + '"?')) {
                        npcs.splice(i, 1);
                        if (currentNpcIndex >= npcs.length) currentNpcIndex = npcs.length - 1;
                        updateNpcList();
                    }
                };

                div.onclick = () => {
                    currentNpcIndex = i;
                    updateNpcList();
                };

                div.appendChild(thumb);
                div.appendChild(nameSpan);
                div.appendChild(editBtn);
                div.appendChild(delBtn);
                container.appendChild(div);
            });
        }

        // Set up NPC canvas click handler
        document.addEventListener('DOMContentLoaded', () => {
            const npcCanvas = document.getElementById('npcEditorCanvas');
            if (npcCanvas) {
                npcCanvas.addEventListener('click', npcCanvasClick);
            }
        });

        // ===== NPC PLACEMENT & PATH FUNCTIONS =====

        function placeNpcAt(x, y) {
            console.log('placeNpcAt called:', x, y, 'currentNpcIndex:', currentNpcIndex);
            if (currentNpcIndex < 0 || !npcs[currentNpcIndex]) {
                console.log('No NPC selected, cannot place');
                return;
            }

            // Check if there's already an NPC at this position
            const existing = placedNpcs.findIndex(p => p.x === x && p.y === y && p.mapName === currentMap);
            if (existing >= 0) {
                // Select existing instead of placing new
                selectPlacedNpc(existing);
                return;
            }

            const placed = {
                npcIndex: currentNpcIndex,
                mapName: currentMap,
                x: x,
                y: y,
                path: [],
                trigger: 'loop',
                speed: 3
            };

            placedNpcs.push(placed);
            selectedPlacedNpcIndex = placedNpcs.length - 1;

            updatePlacedNpcList();
            showNpcPathPanel();
            renderMap();
        }

        function findPlacedNpcAt(x, y) {
            return placedNpcs.findIndex(p => p.x === x && p.y === y && p.mapName === currentMap);
        }

        function selectPlacedNpc(index) {
            // Stop any running preview when selecting different NPC
            if (npcPathPreviewActive && index !== selectedPlacedNpcIndex) {
                stopNpcPathPreview();
            }

            selectedPlacedNpcIndex = index;
            npcPathDrawing = false;

            const placed = placedNpcs[index];
            if (placed) {
                document.getElementById('npcTriggerType').value = placed.trigger || 'loop';
                document.getElementById('npcWalkSpeed').value = placed.speed || 3;
                document.getElementById('npcSpeedValue').textContent = placed.speed || 3;
            }

            updatePlacedNpcList();
            showNpcPathPanel();
            renderMap();
        }

        function removeNpcAt(x, y) {
            const idx = findPlacedNpcAt(x, y);
            if (idx >= 0) {
                placedNpcs.splice(idx, 1);
                if (selectedPlacedNpcIndex === idx) {
                    selectedPlacedNpcIndex = -1;
                    hideNpcPathPanel();
                } else if (selectedPlacedNpcIndex > idx) {
                    selectedPlacedNpcIndex--;
                }
                updatePlacedNpcList();
                renderMap();
            }
        }

        function deleteSelectedPlacedNpc() {
            if (selectedPlacedNpcIndex >= 0) {
                placedNpcs.splice(selectedPlacedNpcIndex, 1);
                selectedPlacedNpcIndex = -1;
                npcPathDrawing = false;
                hideNpcPathPanel();
                updatePlacedNpcList();
                renderMap();
            }
        }

        function showNpcPathPanel() {
            const panel = document.getElementById('npcPathPanel');
            if (!panel) {
                console.error('npcPathPanel not found!');
                return;
            }
            panel.style.display = 'block';
            console.log('Path panel shown, selectedPlacedNpcIndex:', selectedPlacedNpcIndex);

            if (selectedPlacedNpcIndex >= 0) {
                const placed = placedNpcs[selectedPlacedNpcIndex];
                const npc = npcs[placed.npcIndex];
                document.getElementById('npcPathName').textContent = npc ? npc.name : 'NPC';
                updateNpcWaypointList();
                updatePathDrawButton();
            }
        }

        function hideNpcPathPanel() {
            document.getElementById('npcPathPanel').style.display = 'none';
            npcPathDrawing = false;
            updatePathDrawButton();
        }

        function toggleNpcPathDrawing() {
            npcPathDrawing = !npcPathDrawing;
            updatePathDrawButton();
        }

        function updatePathDrawButton() {
            const btn = document.getElementById('npcDrawPathBtn');
            const info = document.getElementById('npcPathInfo');
            if (npcPathDrawing) {
                btn.textContent = 'Stop Drawing';
                btn.style.background = '#a55';
                info.textContent = 'Click tiles to add waypoints. Right-click to undo.';
                info.style.color = '#4f4';
            } else {
                btn.textContent = 'Draw Path';
                btn.style.background = '#4a4';
                info.textContent = 'Click tiles to add waypoints';
                info.style.color = '#666';
            }
        }

        function addNpcWaypoint(x, y) {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (!placed.path) placed.path = [];

            // Don't add duplicate consecutive waypoints
            const last = placed.path[placed.path.length - 1];
            if (last && last.x === x && last.y === y) return;

            placed.path.push({ x, y });
            updateNpcWaypointList();
            renderMap();
        }

        function removeLastNpcWaypoint() {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (placed.path && placed.path.length > 0) {
                placed.path.pop();
                updateNpcWaypointList();
                renderMap();
            }
        }

        function clearNpcPath() {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            placed.path = [];
            updateNpcWaypointList();
            renderMap();
        }

        function updateNpcTrigger() {
            if (selectedPlacedNpcIndex < 0) return;
            placedNpcs[selectedPlacedNpcIndex].trigger = document.getElementById('npcTriggerType').value;
        }

        function updateNpcSpeed() {
            if (selectedPlacedNpcIndex < 0) return;
            const speed = parseInt(document.getElementById('npcWalkSpeed').value);
            placedNpcs[selectedPlacedNpcIndex].speed = speed;
            document.getElementById('npcSpeedValue').textContent = speed;
        }

        function updateNpcWaypointList() {
            const container = document.getElementById('npcWaypointList');
            if (selectedPlacedNpcIndex < 0) {
                container.innerHTML = 'No NPC selected';
                return;
            }

            const placed = placedNpcs[selectedPlacedNpcIndex];
            const path = placed.path || [];

            if (path.length === 0) {
                container.innerHTML = 'No waypoints - click Draw Path then click map';
                return;
            }

            container.innerHTML = '<strong>Waypoints:</strong> ' + path.map((p, i) => `${i + 1}:(${p.x},${p.y})`).join(' ‚Üí ');
        }

        function updatePlacedNpcList() {
            const container = document.getElementById('placedNpcList');
            const currentMapNpcs = placedNpcs.filter(p => p.mapName === currentMap);

            if (currentMapNpcs.length === 0) {
                container.innerHTML = 'No NPCs placed on this map';
                return;
            }

            container.innerHTML = '';
            currentMapNpcs.forEach((placed, localIdx) => {
                const globalIdx = placedNpcs.indexOf(placed);
                const npc = npcs[placed.npcIndex];
                const div = document.createElement('div');
                div.style.cssText = 'padding:4px; margin-bottom:3px; background:' +
                    (globalIdx === selectedPlacedNpcIndex ? '#2a5a8a' : '#333') +
                    '; border-radius:3px; cursor:pointer;';
                div.innerHTML = `<strong>${npc ? npc.name : 'Unknown'}</strong> at (${placed.x},${placed.y})` +
                    `<br><span style="font-size:9px; color:#888;">${placed.trigger} | ${placed.path?.length || 0} waypoints</span>`;
                div.onclick = () => selectPlacedNpc(globalIdx);
                container.appendChild(div);
            });
        }

        // ===== NPC PATH PREVIEW =====
        function toggleNpcPathPreview() {
            if (npcPathPreviewActive) {
                stopNpcPathPreview();
            } else {
                startNpcPathPreview();
            }
        }

        function startNpcPathPreview() {
            if (selectedPlacedNpcIndex < 0) return;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            if (!placed.path || placed.path.length === 0) {
                alert('No path to preview. Draw a path first.');
                return;
            }

            npcPathPreviewActive = true;
            npcPreviewState = {
                x: placed.x,
                y: placed.y,
                waypointIndex: 0,
                direction: 'down',
                frame: 0,
                frameTimer: 0
            };

            // Update button
            const btn = document.getElementById('npcPreviewPathBtn');
            btn.textContent = '‚èπ Stop';
            btn.style.background = '#a55';

            // Start animation loop
            npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
        }

        function stopNpcPathPreview() {
            npcPathPreviewActive = false;
            if (npcPreviewAnimId) {
                cancelAnimationFrame(npcPreviewAnimId);
                npcPreviewAnimId = null;
            }
            npcPreviewState = null;

            // Update button
            const btn = document.getElementById('npcPreviewPathBtn');
            if (btn) {
                btn.textContent = '‚ñ∂ Preview';
                btn.style.background = '#47a';
            }

            renderMap();
        }

        let lastPreviewTime = 0;
        function npcPathPreviewLoop(timestamp) {
            if (!npcPathPreviewActive || selectedPlacedNpcIndex < 0) {
                stopNpcPathPreview();
                return;
            }

            const deltaTime = timestamp - lastPreviewTime;
            lastPreviewTime = timestamp;

            const placed = placedNpcs[selectedPlacedNpcIndex];
            const path = placed.path || [];
            const speed = (placed.speed || 3) * 0.05; // Slower for editor preview

            if (path.length === 0) {
                stopNpcPathPreview();
                return;
            }

            // Get target waypoint
            const waypoint = path[npcPreviewState.waypointIndex];
            if (!waypoint) {
                // Loop back to start
                npcPreviewState.waypointIndex = 0;
                npcPreviewState.x = placed.x;
                npcPreviewState.y = placed.y;
                npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
                return;
            }

            // Move towards waypoint
            const dx = waypoint.x - npcPreviewState.x;
            const dy = waypoint.y - npcPreviewState.y;
            const dist = Math.hypot(dx, dy);

            if (dist < speed) {
                // Reached waypoint
                npcPreviewState.x = waypoint.x;
                npcPreviewState.y = waypoint.y;
                npcPreviewState.waypointIndex++;

                // Check if done
                if (npcPreviewState.waypointIndex >= path.length) {
                    npcPreviewState.waypointIndex = 0;
                    npcPreviewState.x = placed.x;
                    npcPreviewState.y = placed.y;
                }
            } else {
                // Move
                npcPreviewState.x += (dx / dist) * speed;
                npcPreviewState.y += (dy / dist) * speed;

                // Set direction
                if (Math.abs(dx) > Math.abs(dy)) {
                    npcPreviewState.direction = dx > 0 ? 'right' : 'left';
                } else {
                    npcPreviewState.direction = dy > 0 ? 'down' : 'up';
                }
            }

            // Update animation frame
            npcPreviewState.frameTimer++;
            if (npcPreviewState.frameTimer >= 8) {
                npcPreviewState.frameTimer = 0;
                npcPreviewState.frame = (npcPreviewState.frame + 1) % 4;
            }

            // Render
            renderMap();

            // Continue loop
            npcPreviewAnimId = requestAnimationFrame(npcPathPreviewLoop);
        }

        // ===== ANIMATED PROPS FUNCTIONS =====
        let animPropEditorImage = null;
        let animPropEditorData = null;
        let animPropEditorFrameW = 16;
        let animPropEditorFrameH = 16;
        let animPropEditorEditingIndex = -1;
        let animPropTool = 'none'; // 'none', 'collision', 'erase', 'split'
        let animPropCollisionMask = null; // 2D array for collision pixels
        let animPropSplitLine = null; // Array of Y values per column (like tileSplitLines)
        let animPropPainting = false;

        function openAnimPropEditor(editIndex = -1) {
            // Stop any running preview from previous session
            animPropStopPreview();

            animPropEditorEditingIndex = editIndex;
            animPropFrames = [];

            // Reset collision/split tool state
            animPropTool = 'none';
            setAnimPropTool('none');

            if (editIndex >= 0 && animatedProps[editIndex]) {
                // Editing existing
                const prop = animatedProps[editIndex];
                animPropEditorFrameW = prop.frameWidth || 16;
                animPropEditorFrameH = prop.frameHeight || 16;
                animPropFrames = JSON.parse(JSON.stringify(prop.frames || []));
                animPropEditorData = prop.spriteData;
                document.getElementById('animPropNameInput').value = prop.name;
                document.getElementById('animPropType').value = prop.type || 'loop';
                const fps = prop.fps || 8;
                document.getElementById('animPropSpeedSlider').value = fps;
                document.getElementById('animPropSpeedLabel').textContent = fps + ' fps';

                // Load existing collision/split data
                animPropCollisionMask = prop.collisionMask ? JSON.parse(JSON.stringify(prop.collisionMask)) : null;
                animPropSplitLine = prop.splitLine ? JSON.parse(JSON.stringify(prop.splitLine)) : null;

                if (prop.spriteData) {
                    animPropEditorImage = new Image();
                    animPropEditorImage.onload = () => {
                        document.getElementById('animPropFrameSection').style.display = 'block';
                        document.getElementById('animPropTypeSection').style.display = 'block';
                        document.getElementById('animPropCollisionSection').style.display = 'block';
                        document.getElementById('animPropNameSection').style.display = 'block';
                        animPropDrawCanvas();
                        animPropUpdateFramesList();
                    };
                    animPropEditorImage.src = prop.spriteData;
                    document.getElementById('animPropFileName').textContent = 'Sprite loaded';
                }
            } else {
                // New prop - default frame size to match grid size
                animPropEditorImage = null;
                animPropEditorData = null;
                animPropEditorFrameW = gridSize;
                animPropEditorFrameH = gridSize;
                animPropCollisionMask = null;
                animPropSplitLine = null;
                animPropFrames = []; // Ensure frames list is cleared
                document.getElementById('animPropNameInput').value = '';
                document.getElementById('animPropType').value = 'loop';
                document.getElementById('animPropSpeedSlider').value = 8;
                document.getElementById('animPropSpeedLabel').textContent = '8 fps';
                document.getElementById('animPropFileName').textContent = '';
                document.getElementById('animPropFrameSection').style.display = 'none';
                document.getElementById('animPropTypeSection').style.display = 'none';
                document.getElementById('animPropCollisionSection').style.display = 'none';
                document.getElementById('animPropNameSection').style.display = 'none';
                // Clear live preview
                const previewCtx = document.getElementById('animPropLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 48, 48);
                // Clear editor canvas
                const editorCanvas = document.getElementById('animPropEditorCanvas');
                const editorCtx = editorCanvas.getContext('2d');
                editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
                // Clear frames list display
                const framesList = document.getElementById('animPropFramesList');
                if (framesList) framesList.innerHTML = '';
                // Reset file input
                const fileInput = document.getElementById('animPropFileInput');
                if (fileInput) fileInput.value = '';
            }

            document.getElementById('animPropFrameW').value = animPropEditorFrameW;
            document.getElementById('animPropFrameH').value = animPropEditorFrameH;
            animPropUpdateFramesList();

            document.getElementById('animPropModal').classList.add('visible');
        }

        function animPropLoadSheet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                animPropEditorData = e.target.result;
                animPropEditorImage = new Image();
                animPropEditorImage.onload = () => {
                    document.getElementById('animPropFileName').textContent = file.name + ' (' + animPropEditorImage.naturalWidth + 'x' + animPropEditorImage.naturalHeight + ')';
                    document.getElementById('animPropFrameSection').style.display = 'block';
                    document.getElementById('animPropTypeSection').style.display = 'block';
                    document.getElementById('animPropCollisionSection').style.display = 'block';
                    document.getElementById('animPropNameSection').style.display = 'block';

                    // Reset collision/split for new sheet
                    animPropCollisionMask = null;
                    animPropSplitLine = null;

                    // Auto-suggest frame size
                    const w = animPropEditorImage.naturalWidth;
                    const h = animPropEditorImage.naturalHeight;
                    const sizes = [16, 32, 24, 48, 64];
                    for (const size of sizes) {
                        if (w % size === 0 && h % size === 0) {
                            animPropEditorFrameW = size;
                            animPropEditorFrameH = size;
                            break;
                        }
                    }
                    document.getElementById('animPropFrameW').value = animPropEditorFrameW;
                    document.getElementById('animPropFrameH').value = animPropEditorFrameH;

                    animPropUpdateGrid();
                    animPropDrawCanvas();
                };
                animPropEditorImage.src = animPropEditorData;
            };
            reader.readAsDataURL(file);
        }

        function animPropUpdateGrid() {
            animPropEditorFrameW = parseInt(document.getElementById('animPropFrameW').value) || 16;
            animPropEditorFrameH = parseInt(document.getElementById('animPropFrameH').value) || 16;

            if (animPropEditorImage) {
                const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
                const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);
                document.getElementById('animPropGridInfo').textContent = cols + ' cols x ' + rows + ' rows';
            }

            animPropDrawCanvas();
        }

        function animPropDrawCanvas() {
            const canvas = document.getElementById('animPropEditorCanvas');
            const ctx = canvas.getContext('2d');

            if (!animPropEditorImage) {
                canvas.width = 400;
                canvas.height = 300;
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Load a sprite sheet to begin', 200, 150);
                return;
            }

            const scale = 3;
            canvas.width = animPropEditorImage.naturalWidth * scale;
            canvas.height = animPropEditorImage.naturalHeight * scale;

            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(animPropEditorImage, 0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
            const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);

            for (let x = 0; x <= cols; x++) {
                ctx.beginPath();
                ctx.moveTo(x * animPropEditorFrameW * scale, 0);
                ctx.lineTo(x * animPropEditorFrameW * scale, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= rows; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * animPropEditorFrameH * scale);
                ctx.lineTo(canvas.width, y * animPropEditorFrameH * scale);
                ctx.stroke();
            }

            // Highlight selected frames
            ctx.strokeStyle = '#4af';
            ctx.lineWidth = 3;
            animPropFrames.forEach((frame, i) => {
                ctx.strokeRect(frame.x * scale + 2, frame.y * scale + 2, frame.w * scale - 4, frame.h * scale - 4);
                ctx.fillStyle = '#4af';
                ctx.font = 'bold 14px sans-serif';
                ctx.fillText(i + 1, frame.x * scale + 6, frame.y * scale + 18);
            });

            // Draw current drag selection
            if (animPropIsDragging && animPropDragStart && animPropDragEnd) {
                const startGX = Math.min(animPropDragStart.gridX, animPropDragEnd.gridX);
                const startGY = Math.min(animPropDragStart.gridY, animPropDragEnd.gridY);
                const endGX = Math.max(animPropDragStart.gridX, animPropDragEnd.gridX);
                const endGY = Math.max(animPropDragStart.gridY, animPropDragEnd.gridY);

                const selX = startGX * animPropEditorFrameW * scale;
                const selY = startGY * animPropEditorFrameH * scale;
                const selW = (endGX - startGX + 1) * animPropEditorFrameW * scale;
                const selH = (endGY - startGY + 1) * animPropEditorFrameH * scale;

                ctx.fillStyle = 'rgba(74, 170, 255, 0.3)';
                ctx.fillRect(selX, selY, selW, selH);
                ctx.strokeStyle = '#4af';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(selX, selY, selW, selH);
                ctx.setLineDash([]);
            }

            // Draw collision mask overlay on first frame area
            if (animPropFrames.length > 0 && animPropCollisionMask) {
                const frame = animPropFrames[0];
                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                for (let py = 0; py < animPropCollisionMask.length; py++) {
                    if (!animPropCollisionMask[py]) continue;
                    for (let px = 0; px < animPropCollisionMask[py].length; px++) {
                        if (animPropCollisionMask[py][px]) {
                            ctx.fillRect(
                                (frame.x + px) * scale,
                                (frame.y + py) * scale,
                                scale, scale
                            );
                        }
                    }
                }
            }

            // Draw split line overlay on ALL frames - per tile
            if (animPropFrames.length > 0 && animPropSplitLine && typeof animPropSplitLine === 'object') {
                ctx.strokeStyle = '#0ff';
                ctx.lineWidth = 2;
                ctx.font = 'bold 10px sans-serif';
                ctx.fillStyle = '#0ff';

                // Draw on every frame
                for (const frame of animPropFrames) {
                    const tilesW = Math.ceil(frame.w / gridSize);
                    const tilesH = Math.ceil(frame.h / gridSize);

                    for (let ty = 0; ty < tilesH; ty++) {
                        for (let tx = 0; tx < tilesW; tx++) {
                            const key = tx + ',' + ty;
                            const splitY = animPropSplitLine[key];
                            if (splitY === undefined || splitY === null) continue;

                            const tileStartX = frame.x + tx * gridSize;
                            const tileStartY = frame.y + ty * gridSize;

                            // Draw horizontal line across this tile
                            ctx.beginPath();
                            ctx.moveTo(tileStartX * scale, (tileStartY + splitY) * scale);
                            ctx.lineTo((tileStartX + gridSize) * scale, (tileStartY + splitY) * scale);
                            ctx.stroke();

                            // Draw C/T labels (smaller for per-tile)
                            ctx.fillText('C', tileStartX * scale + 2, (tileStartY + splitY / 2) * scale + 5);
                            ctx.fillText('T', tileStartX * scale + 2, (tileStartY + splitY + (gridSize - splitY) / 2) * scale + 5);
                        }
                    }
                }
            }
        }

        // Animated prop editor brush size
        let animPropBrushSize = 4;
        let animPropFlatLineY = null; // Y position locked when flat line mode + dragging

        // Tool switching for animated prop editor
        function setAnimPropTool(tool) {
            animPropTool = tool;
            ['None', 'Collision', 'Erase', 'Split'].forEach(t => {
                const btn = document.getElementById('animPropTool' + t);
                if (btn) btn.classList.toggle('active', t.toLowerCase() === tool);
            });

            // Show/hide brush section for collision/erase tools
            const brushSection = document.getElementById('animPropBrushSection');
            if (brushSection) {
                brushSection.style.display = (tool === 'collision' || tool === 'erase') ? 'block' : 'none';
            }

            // Show/hide split controls
            const splitControls = document.getElementById('animPropSplitControls');
            if (splitControls) {
                splitControls.style.display = (tool === 'split') ? 'block' : 'none';
            }
        }

        function setAnimPropBrush(size) {
            animPropBrushSize = size;
            [1, 2, 4, 8].forEach(s => {
                const btn = document.getElementById('animPropBrush' + s);
                if (btn) btn.classList.toggle('active', s === size);
            });
        }

        function setAnimPropSplitY() {
            const yVal = parseInt(document.getElementById('animPropSplitY').value) || 8;
            if (animPropFrames.length === 0) return;

            // Initialize split lines object if needed
            if (!animPropSplitLine || typeof animPropSplitLine !== 'object' || Array.isArray(animPropSplitLine)) {
                animPropSplitLine = {};
            }

            // Set same Y for all tiles in the prop
            const frame = animPropFrames[0];
            const tilesW = Math.ceil(frame.w / gridSize);
            const tilesH = Math.ceil(frame.h / gridSize);

            for (let ty = 0; ty < tilesH; ty++) {
                for (let tx = 0; tx < tilesW; tx++) {
                    const key = tx + ',' + ty;
                    animPropSplitLine[key] = Math.max(0, Math.min(gridSize, yVal));
                }
            }
            animPropDrawCanvas();
        }

        function clearAnimPropSplit() {
            animPropSplitLine = null;
            animPropDrawCanvas();
        }

        // Collision/split painting helpers
        function animPropPaintCollision(px, py, erase) {
            if (animPropFrames.length === 0) return;

            // Find which frame was clicked (can be any frame)
            let clickedFrame = null;
            for (const frame of animPropFrames) {
                if (px >= frame.x && px < frame.x + frame.w &&
                    py >= frame.y && py < frame.y + frame.h) {
                    clickedFrame = frame;
                    break;
                }
            }
            if (!clickedFrame) return;

            // Use first frame dimensions for mask size
            const frame0 = animPropFrames[0];

            // Initialize mask if needed
            if (!animPropCollisionMask) {
                animPropCollisionMask = [];
                for (let y = 0; y < frame0.h; y++) {
                    animPropCollisionMask[y] = new Array(frame0.w).fill(false);
                }
            }

            // Calculate position relative to clicked frame
            const localX = px - clickedFrame.x;
            const localY = py - clickedFrame.y;

            if (localX < 0 || localX >= frame0.w || localY < 0 || localY >= frame0.h) return;

            // Paint with brush size
            const halfBrush = Math.floor(animPropBrushSize / 2);
            for (let dy = -halfBrush; dy < animPropBrushSize - halfBrush; dy++) {
                for (let dx = -halfBrush; dx < animPropBrushSize - halfBrush; dx++) {
                    const bx = localX + dx;
                    const by = localY + dy;
                    if (bx >= 0 && bx < frame0.w && by >= 0 && by < frame0.h) {
                        if (!animPropCollisionMask[by]) animPropCollisionMask[by] = [];
                        animPropCollisionMask[by][bx] = !erase;
                    }
                }
            }
        }

        function animPropPaintSplit(px, py, isStart = false) {
            if (animPropFrames.length === 0) return;

            // Find which frame was clicked (can be any frame, not just first)
            let clickedFrame = null;
            for (const frame of animPropFrames) {
                if (px >= frame.x && px < frame.x + frame.w &&
                    py >= frame.y && py < frame.y + frame.h) {
                    clickedFrame = frame;
                    break;
                }
            }
            if (!clickedFrame) return;

            // Calculate which tile within the frame was clicked
            const localX = px - clickedFrame.x;
            const localY = py - clickedFrame.y;

            const tileX = Math.floor(localX / gridSize);
            const tileY = Math.floor(localY / gridSize);

            // Y position within the tile
            const tileLocalY = localY - (tileY * gridSize);
            // Round to nearest pixel, and snap to gridSize if in bottom 2 pixels (allows full tile split)
            let clampedY = Math.round(tileLocalY);
            if (tileLocalY >= gridSize - 2) clampedY = gridSize;
            clampedY = Math.max(0, Math.min(gridSize, clampedY));

            // Check flat line mode
            const flatLineCheckbox = document.getElementById('animPropFlatLine');
            const flatLineMode = flatLineCheckbox && flatLineCheckbox.checked;

            if (flatLineMode) {
                if (isStart) {
                    // Lock Y on first click
                    animPropFlatLineY = clampedY;
                } else if (animPropFlatLineY !== null) {
                    // Use locked Y for subsequent drags
                    clampedY = animPropFlatLineY;
                }
            }

            // Initialize split lines object if needed: key "tileX,tileY" -> splitY
            if (!animPropSplitLine || typeof animPropSplitLine !== 'object' || Array.isArray(animPropSplitLine)) {
                animPropSplitLine = {};
            }

            const key = tileX + ',' + tileY;
            animPropSplitLine[key] = clampedY;
        }

        // Canvas drag handlers for animated prop editor (multi-tile selection)
        document.getElementById('animPropEditorCanvas').addEventListener('mousedown', function(e) {
            if (!animPropEditorImage) return;

            const rect = this.getBoundingClientRect();
            const scale = 3;
            const clickX = (e.clientX - rect.left) / scale;
            const clickY = (e.clientY - rect.top) / scale;

            if (animPropTool === 'collision' || animPropTool === 'erase') {
                animPropPainting = true;
                animPropPaintCollision(Math.floor(clickX), Math.floor(clickY), animPropTool === 'erase');
                animPropDrawCanvas();
            } else if (animPropTool === 'split') {
                animPropPainting = true;
                animPropPaintSplit(Math.floor(clickX), Math.floor(clickY), true); // isStart = true
                animPropDrawCanvas();
            } else {
                // Frame selection mode
                const gridX = Math.floor(clickX / animPropEditorFrameW);
                const gridY = Math.floor(clickY / animPropEditorFrameH);

                animPropDragStart = { gridX, gridY };
                animPropDragEnd = { gridX, gridY };
                animPropIsDragging = true;
                animPropDrawCanvas();
            }
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mousemove', function(e) {
            if (!animPropEditorImage) return;

            const rect = this.getBoundingClientRect();
            const scale = 3;
            const clickX = (e.clientX - rect.left) / scale;
            const clickY = (e.clientY - rect.top) / scale;

            if (animPropPainting) {
                if (animPropTool === 'collision' || animPropTool === 'erase') {
                    animPropPaintCollision(Math.floor(clickX), Math.floor(clickY), animPropTool === 'erase');
                    animPropDrawCanvas();
                } else if (animPropTool === 'split') {
                    animPropPaintSplit(Math.floor(clickX), Math.floor(clickY));
                    animPropDrawCanvas();
                }
            } else if (animPropIsDragging) {
                const cols = Math.floor(animPropEditorImage.naturalWidth / animPropEditorFrameW);
                const rows = Math.floor(animPropEditorImage.naturalHeight / animPropEditorFrameH);

                const gridX = Math.max(0, Math.min(cols - 1, Math.floor(clickX / animPropEditorFrameW)));
                const gridY = Math.max(0, Math.min(rows - 1, Math.floor(clickY / animPropEditorFrameH)));

                animPropDragEnd = { gridX, gridY };
                animPropDrawCanvas();
            }
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mouseup', function(e) {
            if (!animPropEditorImage) return;

            if (animPropPainting) {
                animPropPainting = false;
                animPropFlatLineY = null; // Reset flat line Y lock
                return;
            }

            if (!animPropIsDragging) return;
            animPropIsDragging = false;

            // Calculate selection rectangle
            const startGX = Math.min(animPropDragStart.gridX, animPropDragEnd.gridX);
            const startGY = Math.min(animPropDragStart.gridY, animPropDragEnd.gridY);
            const endGX = Math.max(animPropDragStart.gridX, animPropDragEnd.gridX);
            const endGY = Math.max(animPropDragStart.gridY, animPropDragEnd.gridY);

            const frameX = startGX * animPropEditorFrameW;
            const frameY = startGY * animPropEditorFrameH;
            const frameW = (endGX - startGX + 1) * animPropEditorFrameW;
            const frameH = (endGY - startGY + 1) * animPropEditorFrameH;

            if (frameX >= animPropEditorImage.naturalWidth || frameY >= animPropEditorImage.naturalHeight) return;

            animPropFrames.push({
                x: frameX,
                y: frameY,
                w: frameW,
                h: frameH
            });

            animPropDragStart = null;
            animPropDragEnd = null;
            animPropDrawCanvas();
            animPropUpdateFramesList();
        });

        document.getElementById('animPropEditorCanvas').addEventListener('mouseleave', function(e) {
            animPropPainting = false;
            if (animPropIsDragging) {
                animPropIsDragging = false;
                animPropDragStart = null;
                animPropDragEnd = null;
                animPropDrawCanvas();
            }
        });

        function animPropUpdateFramesList() {
            const container = document.getElementById('animPropFramesList');
            container.innerHTML = '';
            document.getElementById('animPropFrameCount').textContent = animPropFrames.length;

            if (animPropFrames.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px;">Click or drag on sprite sheet to select frames</div>';
                animPropStopPreview();
                // Clear live preview
                const previewCtx = document.getElementById('animPropLivePreview').getContext('2d');
                previewCtx.clearRect(0, 0, 48, 48);
                return;
            }

            animPropFrames.forEach((frame, i) => {
                const thumb = document.createElement('div');
                thumb.className = 'anim-frame-thumb';

                const canvas = document.createElement('canvas');
                canvas.width = 48;
                canvas.height = 48;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;

                const scale = Math.min(48 / frame.w, 48 / frame.h);
                const drawW = frame.w * scale;
                const drawH = frame.h * scale;
                const drawX = (48 - drawW) / 2;
                const drawY = (48 - drawH) / 2;

                ctx.drawImage(animPropEditorImage, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);

                const num = document.createElement('span');
                num.className = 'frame-num';
                num.textContent = i + 1;

                thumb.appendChild(canvas);
                thumb.appendChild(num);
                thumb.onclick = () => {
                    animPropFrames.splice(i, 1);
                    animPropUpdateFramesList();
                    animPropDrawCanvas();
                };
                thumb.title = 'Click to remove';

                container.appendChild(thumb);
            });

            // Auto-start live preview when frames exist
            animPropStartLivePreview();
        }

        function animPropClearFrames() {
            if (!confirm('Clear all frames?')) return;
            animPropFrames = [];
            animPropUpdateFramesList();
            animPropDrawCanvas();
        }

        // Live animation preview - starts automatically when frames are added
        function animPropStartLivePreview() {
            if (animPropPreviewInterval) return; // Already running
            if (animPropFrames.length === 0) return;

            animPropPreviewFrame = 0;
            const fps = parseInt(document.getElementById('animPropSpeedSlider').value) || 8;

            animPropPreviewInterval = setInterval(() => {
                animPropPreviewFrame = (animPropPreviewFrame + 1) % animPropFrames.length;
                animPropDrawLivePreview();

                // Highlight current frame in list
                const thumbs = document.querySelectorAll('.anim-frame-thumb');
                thumbs.forEach((t, i) => {
                    t.style.borderColor = i === animPropPreviewFrame ? '#0f0' : '#4af';
                });
            }, 1000 / fps);
        }

        function animPropStopPreview() {
            if (animPropPreviewInterval) {
                clearInterval(animPropPreviewInterval);
                animPropPreviewInterval = null;
            }
            const thumbs = document.querySelectorAll('.anim-frame-thumb');
            thumbs.forEach(t => t.style.borderColor = '#4af');
        }

        function animPropDrawLivePreview() {
            const canvas = document.getElementById('animPropLivePreview');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 48, 48);

            if (!animPropEditorImage || animPropFrames.length === 0) return;

            const frame = animPropFrames[animPropPreviewFrame];
            if (!frame) return;

            ctx.imageSmoothingEnabled = false;
            // Scale to fit 48x48 preview
            const scale = Math.min(48 / frame.w, 48 / frame.h);
            const drawW = frame.w * scale;
            const drawH = frame.h * scale;
            const drawX = (48 - drawW) / 2;
            const drawY = (48 - drawH) / 2;
            ctx.drawImage(animPropEditorImage, frame.x, frame.y, frame.w, frame.h, drawX, drawY, drawW, drawH);
        }

        function animPropUpdateSpeed() {
            const fps = parseInt(document.getElementById('animPropSpeedSlider').value) || 8;
            document.getElementById('animPropSpeedLabel').textContent = fps + ' fps';
            document.getElementById('animPropSpeed').value = fps; // Sync with hidden input

            // Restart preview with new speed
            if (animPropPreviewInterval) {
                animPropStopPreview();
                animPropStartLivePreview();
            }
        }

        function animPropTypeChanged() {
            // Could show/hide different options based on type
        }

        function animPropSave() {
            const name = document.getElementById('animPropNameInput').value.trim();
            if (!name) {
                alert('Please enter a name for the prop');
                return;
            }

            if (!animPropEditorImage) {
                alert('Please load a sprite sheet first');
                return;
            }

            if (animPropFrames.length === 0) {
                alert('Please add at least one frame');
                return;
            }

            const propData = {
                name: name,
                spriteData: animPropEditorData,
                frameWidth: animPropEditorFrameW,
                frameHeight: animPropEditorFrameH,
                frames: [...animPropFrames],
                type: document.getElementById('animPropType').value,
                fps: parseInt(document.getElementById('animPropSpeedSlider').value) || 8,
                collisionMask: animPropCollisionMask ? JSON.parse(JSON.stringify(animPropCollisionMask)) : null,
                splitLine: animPropSplitLine ? JSON.parse(JSON.stringify(animPropSplitLine)) : null,
                _spriteImg: animPropEditorImage // Store the loaded image
            };

            if (animPropEditorEditingIndex >= 0) {
                animatedProps[animPropEditorEditingIndex] = propData;
            } else {
                animatedProps.push(propData);
                currentAnimPropIndex = animatedProps.length - 1; // Select the new prop
            }

            animPropStopPreview();
            document.getElementById('animPropModal').classList.remove('visible');
            updateAnimPropListDisplay();
            renderMap();
        }

        function animPropCancel() {
            animPropStopPreview();
            document.getElementById('animPropModal').classList.remove('visible');
        }

        function updateAnimPropListDisplay() {
            const container = document.getElementById('animPropList');
            if (!container) return;
            container.innerHTML = '';

            if (animatedProps.length === 0) {
                container.innerHTML = '<div style="color:#666; font-size:11px; padding:10px;">No animated props yet</div>';
                return;
            }

            animatedProps.forEach((prop, i) => {
                const item = document.createElement('div');
                const isSelected = (currentAnimPropIndex === i);
                item.style.cssText = 'display:flex; align-items:center; gap:10px; padding:8px; background:' + (isSelected ? '#4a4a6e' : '#333') + '; border:2px solid ' + (isSelected ? '#4af' : 'transparent') + '; border-radius:5px; margin-bottom:5px; cursor:pointer;';
                item.onclick = () => { currentAnimPropIndex = i; updateAnimPropListDisplay(); };

                // Preview thumbnail
                if (prop.frames && prop.frames.length > 0) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 32;
                    canvas.height = 32;
                    canvas.style.cssText = 'border:1px solid #555; image-rendering:pixelated;';
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = false;

                    const frame = prop.frames[0];
                    if (prop._spriteImg) {
                        ctx.drawImage(prop._spriteImg, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                    } else if (prop.spriteData) {
                        // Fallback: load image if _spriteImg not available
                        const img = new Image();
                        img.onload = () => {
                            prop._spriteImg = img;
                            ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, 32, 32);
                        };
                        img.src = prop.spriteData;
                    }
                    item.appendChild(canvas);
                }

                const info = document.createElement('div');
                info.style.flex = '1';
                info.innerHTML = '<div style="color:#4af; font-weight:bold;">' + prop.name + '</div>' +
                    '<div style="font-size:10px; color:#888;">' + prop.frames.length + ' frames | ' + prop.type + '</div>';
                item.appendChild(info);

                // Edit button
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.style.cssText = 'padding:4px 8px; font-size:10px;';
                editBtn.onclick = (e) => { e.stopPropagation(); openAnimPropEditor(i); };
                item.appendChild(editBtn);

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.textContent = '√ó';
                delBtn.style.cssText = 'padding:4px 8px; font-size:10px; background:#a55;';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Delete "' + prop.name + '"?')) {
                        animatedProps.splice(i, 1);
                        placedAnimProps = placedAnimProps.filter(p => p.propIndex !== i);
                        placedAnimProps.forEach(p => { if (p.propIndex > i) p.propIndex--; });
                        updateAnimPropListDisplay();
                        renderMap();
                    }
                };
                item.appendChild(delBtn);

                container.appendChild(item);
            });
        }

        // ===== SAVE/LOAD =====
        function saveProject() {
            // Count tiles in first layer for debugging
            let tileCount = 0;
            if (layers[0]) {
                for (let y = 0; y < layers[0].length; y++) {
                    if (layers[0][y]) {
                        for (let x = 0; x < layers[0][y].length; x++) {
                            if (layers[0][y][x]) tileCount++;
                        }
                    }
                }
            }
            console.log('Saving project with', layers.length, 'layers,', tileCount, 'tiles in first layer,', tilesets.length, 'tilesets,', props.length, 'props');

            // Save current prop's collision masks before saving
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Save all tilesets
            const tilesetsData = tilesets.map(ts => ({ name: ts.name, data: ts.data }));

            // Save all props
            const propsData = props.map(p => ({
                name: p.name,
                data: p.data,
                collisionMasks: p.collisionMasks || {}
            }));

            // Save all animated props
            const animPropsData = animatedProps.map(prop => ({
                name: prop.name,
                spriteData: prop.spriteData,
                frameWidth: prop.frameWidth,
                frameHeight: prop.frameHeight,
                frames: prop.frames,
                type: prop.type,
                fps: prop.fps,
                collisionMask: prop.collisionMask || null,
                splitLine: prop.splitLine || null
            }));

            // Save sounds
            const soundsData = sounds.map(s => ({
                name: s.name,
                data: s.data,
                duration: s.duration,
                type: s.type
            }));
            console.log('=== SAVING SOUNDS ===');
            console.log('Sounds to save:', sounds.length);
            console.log('Tile sounds to save:', Object.keys(tileSounds).length, tileSounds);
            console.log('Player sounds to save:', playerSounds);

            const data = {
                gridSize, mapCols, mapRows,
                layers, layerVisibility, layerNames, currentLayer,
                tileCollisions, collisionMasks,
                tileSplitLines, // Depth split lines for Y-sorting
                tilesets: tilesetsData,
                currentTilesetIndex,
                // Keep for backwards compatibility
                tilesetData: tilesets[0]?.data,
                // Save multiple props
                props: propsData,
                currentPropIndex,
                // Keep old format for backwards compatibility
                propImageData: props[0]?.data || null,
                propCollisionMasks: props[0]?.collisionMasks || {},
                // Save animated props
                animatedProps: animPropsData,
                currentAnimPropIndex,
                placedAnimProps,
                // Save NPCs
                npcs: npcs.map(npc => ({
                    name: npc.name,
                    spriteData: npc.spriteData,
                    frameWidth: npc.frameWidth,
                    frameHeight: npc.frameHeight,
                    animations: npc.animations,
                    fps: npc.fps
                })),
                currentNpcIndex,
                placedNpcs,
                // Save player layer settings
                playerLayerIndex,
                playerPreviewPos,
                playerPreviewVisible,
                // Save sound data
                sounds: soundsData,
                tileSounds,
                playerSounds,
                // Save lighting data
                lightingSettings,
                pointLights
            };
            console.log('Saving playerPreviewPos:', playerPreviewPos);
            try {
                localStorage.setItem('worldBuilderProject', JSON.stringify(data));
                console.log('Project saved to localStorage');
                alert('Saved! Player spawn: (' + playerPreviewPos.x + ', ' + playerPreviewPos.y + ')');
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.warn('localStorage quota exceeded, project too large');
                    // Store in sessionStorage for test game (temporary)
                    try {
                        sessionStorage.setItem('worldBuilderProject', JSON.stringify(data));
                        alert('Project too large for permanent save! Using temporary storage.\nUse "Download" to save to file.');
                    } catch (e2) {
                        alert('Project too large to save! Use "Download" to save to a file.');
                    }
                } else {
                    throw e;
                }
            }
            return data; // Return for file download
        }

        function downloadProject() {
            // Get save data
            const data = getProjectData();
            const json = JSON.stringify(data, null, 2);

            // Create download
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'world-project-' + new Date().toISOString().slice(0,10) + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function getProjectData() {
            // Save current prop's collision masks before saving
            if (currentPropIndex >= 0 && props[currentPropIndex]) {
                props[currentPropIndex].collisionMasks = { ...propCollisionMasks };
            }

            // Save all tilesets
            const tilesetsData = tilesets.map(ts => ({ name: ts.name, data: ts.data }));

            // Save all props
            const propsData = props.map(p => ({
                name: p.name,
                data: p.data,
                collisionMasks: p.collisionMasks || {}
            }));

            // Save all animated props
            const animPropsData = animatedProps.map(prop => ({
                name: prop.name,
                spriteData: prop.spriteData,
                frameWidth: prop.frameWidth,
                frameHeight: prop.frameHeight,
                frames: prop.frames,
                type: prop.type,
                fps: prop.fps,
                collisionMask: prop.collisionMask || null,
                splitLine: prop.splitLine || null
            }));

            // Save sounds
            const soundsData = sounds.map(s => ({
                name: s.name,
                data: s.data,
                duration: s.duration,
                type: s.type
            }));
            console.log('getProjectData - sounds:', sounds.length, 'tileSounds:', Object.keys(tileSounds).length);

            return {
                gridSize, mapCols, mapRows,
                layers, layerVisibility, layerNames, currentLayer,
                tileCollisions, collisionMasks,
                tileSplitLines, // Depth split lines for Y-sorting
                tilesets: tilesetsData,
                currentTilesetIndex,
                // Keep for backwards compatibility
                tilesetData: tilesets[0]?.data,
                // Save multiple props
                props: propsData,
                currentPropIndex,
                // Keep old format for backwards compatibility
                propImageData: props[0]?.data || null,
                propCollisionMasks: props[0]?.collisionMasks || {},
                // Save animated props
                animatedProps: animPropsData,
                currentAnimPropIndex,
                placedAnimProps,
                // Save NPCs
                npcs: npcs.map(npc => ({
                    name: npc.name,
                    spriteData: npc.spriteData,
                    frameWidth: npc.frameWidth,
                    frameHeight: npc.frameHeight,
                    animations: npc.animations,
                    fps: npc.fps
                })),
                currentNpcIndex,
                placedNpcs,
                // Save player layer settings
                playerLayerIndex,
                playerPreviewPos,
                playerPreviewVisible,
                // Save sound data
                sounds: soundsData,
                tileSounds,
                playerSounds,
                // Save lighting data
                lightingSettings,
                pointLights,
                // Save player sprite
                playerSpriteData
            };
        }

        function uploadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    // Save to storage so Test Map works
                    try {
                        localStorage.setItem('worldBuilderProject', JSON.stringify(data));
                    } catch (storageErr) {
                        // localStorage full, use sessionStorage
                        console.warn('localStorage full, using sessionStorage');
                        try {
                            sessionStorage.setItem('worldBuilderProject', JSON.stringify(data));
                        } catch (e2) {
                            console.warn('sessionStorage also full');
                        }
                    }
                    // Load into editor
                    loadProject(data);
                } catch (err) {
                    alert('Error loading file: ' + err.message);
                }
            };
            reader.readAsText(file);

            // Clear input so same file can be loaded again
            event.target.value = '';
        }

        function loadProject(projectData) {
            // If no data passed, load from localStorage
            let p;
            if (projectData) {
                p = projectData;
            } else {
                const data = localStorage.getItem('worldBuilderProject');
                if (!data) {
                    alert('No saved project found in browser storage. Use "Load File" to load from a downloaded file.');
                    return;
                }
                try {
                    p = JSON.parse(data);
                } catch (err) {
                    alert('Error parsing saved data: ' + err.message);
                    return;
                }
            }

            console.log('Loading project:', p);
            gridSize = p.gridSize || 16;
            mapCols = p.mapCols || 40;
            mapRows = p.mapRows || 30;
            tileCollisions = p.tileCollisions || {};
            collisionMasks = p.collisionMasks || {};
            tileSplitLines = p.tileSplitLines || {}; // Depth split lines for Y-sorting

            // Load multiple props (new format)
            props = [];
            propImage = null;
            propImageData = null;
            propCollisionMasks = {};
            currentPropIndex = -1;

            if (p.props && p.props.length > 0) {
                console.log('Loading', p.props.length, 'props');
                let propsLoaded = 0;
                p.props.forEach((propData, i) => {
                    const img = new Image();
                    img.onload = () => {
                        props[i] = {
                            name: propData.name,
                            img: img,
                            data: propData.data,
                            collisionMasks: propData.collisionMasks || {}
                        };
                        propsLoaded++;
                        if (propsLoaded === p.props.length) {
                            // All props loaded
                            currentPropIndex = p.currentPropIndex >= 0 ? p.currentPropIndex : 0;
                            if (props[currentPropIndex]) {
                                propImage = props[currentPropIndex].img;
                                propImageData = props[currentPropIndex].data;
                                propCollisionMasks = props[currentPropIndex].collisionMasks;
                            }
                            updatePropDropdown();
                            updatePropUI();
                            drawPropTileset();
                            renderMap();
                        }
                    };
                    img.onerror = () => {
                        console.error('Failed to load prop', i);
                        propsLoaded++;
                    };
                    img.src = propData.data;
                });
            } else if (p.propImageData) {
                // Old format - single prop image (backwards compatibility)
                console.log('Loading single prop (old format)');
                const img = new Image();
                img.onload = () => {
                    props = [{
                        name: 'prop',
                        img: img,
                        data: p.propImageData,
                        collisionMasks: p.propCollisionMasks || {}
                    }];
                    currentPropIndex = 0;
                    propImage = img;
                    propImageData = p.propImageData;
                    propCollisionMasks = p.propCollisionMasks || {};
                    updatePropDropdown();
                    updatePropUI();
                    drawPropTileset();
                    renderMap();
                };
                img.onerror = () => console.error('Failed to load prop image');
                img.src = p.propImageData;
            } else {
                console.log('No props in saved project');
                updatePropDropdown();
                updatePropUI();
            }

            // Load animated props
            animatedProps = [];
            animPropSpriteSheet = null;
            animPropSpriteData = null;
            currentAnimPropIndex = -1;
            placedAnimProps = p.placedAnimProps || [];

            if (p.animatedProps && p.animatedProps.length > 0) {
                console.log('Loading', p.animatedProps.length, 'animated props');
                let propsLoaded = 0;
                p.animatedProps.forEach((propData, i) => {
                    animatedProps[i] = {
                        name: propData.name,
                        spriteData: propData.spriteData,
                        frameWidth: propData.frameWidth || 16,
                        frameHeight: propData.frameHeight || 16,
                        frames: propData.frames || [],
                        type: propData.type || 'loop',
                        fps: propData.fps || 8,
                        collisionMask: propData.collisionMask || null,
                        splitLine: propData.splitLine || null
                    };

                    // Load sprite sheet image if present
                    if (propData.spriteData) {
                        const img = new Image();
                        img.onload = () => {
                            animatedProps[i]._spriteImg = img;
                            propsLoaded++;
                            if (propsLoaded === p.animatedProps.length) {
                                currentAnimPropIndex = p.currentAnimPropIndex >= 0 ? p.currentAnimPropIndex : 0;
                                if (animatedProps[currentAnimPropIndex] && animatedProps[currentAnimPropIndex]._spriteImg) {
                                    animPropSpriteSheet = animatedProps[currentAnimPropIndex]._spriteImg;
                                    animPropSpriteData = animatedProps[currentAnimPropIndex].spriteData;
                                }
                                updateAnimPropListDisplay();
                                renderMap();
                            }
                        };
                        img.onerror = () => {
                            console.error('Failed to load animated prop sprite', i);
                            propsLoaded++;
                        };
                        img.src = propData.spriteData;
                    } else {
                        propsLoaded++;
                        if (propsLoaded === p.animatedProps.length) {
                            currentAnimPropIndex = p.currentAnimPropIndex >= 0 ? p.currentAnimPropIndex : 0;
                            updateAnimPropListDisplay();
                            renderMap();
                        }
                    }
                });
            } else {
                console.log('No animated props in saved project');
                updateAnimPropListDisplay();
            }

            // Load NPCs
            npcs = [];
            currentNpcIndex = -1;
            placedNpcs = p.placedNpcs || [];
            selectedPlacedNpcIndex = -1;
            npcPathDrawing = false;

            if (p.npcs && p.npcs.length > 0) {
                console.log('Loading', p.npcs.length, 'NPCs');
                p.npcs.forEach((npcData, i) => {
                    npcs[i] = {
                        name: npcData.name,
                        spriteData: npcData.spriteData,
                        frameWidth: npcData.frameWidth || 32,
                        frameHeight: npcData.frameHeight || 32,
                        animations: npcData.animations || { walkDown: [], walkUp: [], walkLeft: [], walkRight: [], idle: [] },
                        fps: npcData.fps || 8
                    };
                });
                currentNpcIndex = p.currentNpcIndex >= 0 ? p.currentNpcIndex : 0;
                updateNpcList();
                updatePlacedNpcList();
            } else {
                console.log('No NPCs in saved project');
                updateNpcList();
                updatePlacedNpcList();
            }

            // Load layers (backwards compatible with old saves)
            if (p.layers) {
                layers = p.layers;
                layerVisibility = p.layerVisibility || layers.map(() => true);
                layerNames = p.layerNames || layers.map(() => '');
                currentLayer = p.currentLayer || 0;
            } else if (p.map) {
                // Old format - single map
                layers = [p.map];
                layerVisibility = [true];
                layerNames = [''];
                currentLayer = 0;
            } else {
                layers = [createEmptyLayer()];
                layerVisibility = [true];
                layerNames = [''];
                currentLayer = 0;
            }
            map = layers[currentLayer];

            // Load player layer settings
            playerLayerIndex = p.playerLayerIndex !== undefined ? p.playerLayerIndex : 1;
            playerPreviewPos = p.playerPreviewPos || { x: 5, y: 5 };
            playerPreviewVisible = p.playerPreviewVisible !== undefined ? p.playerPreviewVisible : true;

            // Load sounds
            sounds = [];
            tileSounds = p.tileSounds || {};
            playerSounds = p.playerSounds || {
                walk: { soundIndex: -1, interval: 200, volume: 0.5, pitchVariation: 0.1 },
                attack: { soundIndex: -1, volume: 0.7 }
            };

            if (p.sounds && p.sounds.length > 0) {
                console.log('Loading', p.sounds.length, 'sounds');
                p.sounds.forEach((soundData, i) => {
                    sounds[i] = {
                        name: soundData.name,
                        data: soundData.data,
                        duration: soundData.duration || 0,
                        type: soundData.type || 'ambient'
                    };
                });
                updateSoundDropdown();
                updatePlacedSoundsList();
                updatePlayerSoundAssignments();
            } else {
                console.log('No sounds in saved project');
                updateSoundDropdown();
                updatePlacedSoundsList();
                updatePlayerSoundAssignments();
            }

            // Load lighting settings
            if (p.lightingSettings) {
                lightingSettings = {
                    blobShadows: p.lightingSettings.blobShadows !== false,
                    ambientEnabled: p.lightingSettings.ambientEnabled || false,
                    timeOfDay: p.lightingSettings.timeOfDay || 'day',
                    playerLight: p.lightingSettings.playerLight || false,
                    playerLightRadius: p.lightingSettings.playerLightRadius || 4
                };
                // Update UI to match loaded settings
                const ambientEl = document.getElementById('ambientEnabled');
                const blobEl = document.getElementById('blobShadows');
                const playerLightEl = document.getElementById('playerLight');
                const radiusEl = document.getElementById('playerLightRadius');
                if (ambientEl) ambientEl.checked = lightingSettings.ambientEnabled;
                if (blobEl) blobEl.checked = lightingSettings.blobShadows;
                if (playerLightEl) playerLightEl.checked = lightingSettings.playerLight;
                if (radiusEl) {
                    radiusEl.value = lightingSettings.playerLightRadius;
                    document.getElementById('playerLightRadiusVal').textContent = lightingSettings.playerLightRadius;
                }
                setTimeOfDay(lightingSettings.timeOfDay);
            }
            pointLights = p.pointLights || {};
            updatePlacedLightsList();

            // Load player sprite
            playerSpriteData = p.playerSpriteData || null;
            playerSpriteImg = null;
            if (playerSpriteData) {
                playerSpriteImg = new Image();
                playerSpriteImg.onload = () => {
                    updatePlayerSpritePreview();
                    document.getElementById('playerSpriteInfo').textContent = 'Custom sprite loaded';
                };
                playerSpriteImg.src = playerSpriteData;
            } else {
                const preview = document.getElementById('playerSpritePreview');
                if (preview) {
                    const ctx = preview.getContext('2d');
                    ctx.clearRect(0, 0, 48, 48);
                }
                document.getElementById('playerSpriteInfo').textContent = 'Default sprite';
            }

            // Load tilesets (new format with multiple tilesets)
            if (p.tilesets && p.tilesets.length > 0) {
                let loadedCount = 0;
                tilesets = [];
                p.tilesets.forEach((tsData, i) => {
                    const img = new Image();
                    img.onload = () => {
                        tilesets[i] = { name: tsData.name, img: img, data: tsData.data };
                        loadedCount++;
                        if (loadedCount === p.tilesets.length) {
                            // All tilesets loaded
                            currentTilesetIndex = p.currentTilesetIndex || 0;
                            tilesetImg = tilesets[currentTilesetIndex].img;
                            mapInitialized = true; // Mark map as loaded
                            updateTilesetDropdown();
                            setPhase('build');
                            drawPaintTileset();
                            renderLayerList();
                            renderMap();
                            updateAnimPropListDisplay();
                            alert('Project loaded!');
                        }
                    };
                    img.src = tsData.data;
                });
            } else if (p.tilesetData) {
                // Old format - single tileset
                const img = new Image();
                img.onload = () => {
                    tilesets = [{ name: 'tileset', img: img, data: p.tilesetData }];
                    currentTilesetIndex = 0;
                    tilesetImg = img;
                    mapInitialized = true; // Mark map as loaded
                    updateTilesetDropdown();
                    setPhase('build');
                    drawPaintTileset();
                    renderLayerList();
                    renderMap();
                    updateAnimPropListDisplay();
                    alert('Project loaded!');
                };
                img.src = p.tilesetData;
            } else {
                alert('No tileset data found in save');
            }
        }

        function exportConfig() {
            const config = { gridSize, mapSize: { cols: mapCols, rows: mapRows }, tileCollisions, layers };
            navigator.clipboard.writeText(JSON.stringify(config, null, 2)).then(() => alert('Copied!'));
        }

        // ===== TEST MAP =====
        function testMap() {
            // Get current project data directly (don't rely on storage)
            const projectDataForTest = getProjectData();
            const projectDataJSON = JSON.stringify(projectDataForTest);

            // Close existing test window if any, then open fresh (fullscreen)
            const testWindow = window.open('about:blank', 'MapTest', 'width=' + screen.width + ',height=' + screen.height);
            testWindow.document.open();
            testWindow.document.write(`
<!DOCTYPE html>
<html>
<head>
    <title>Map Test</title>
    <style>
        * { margin: 0; padding: 0; }
        body { background: #111; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #debugPanel {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.85);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            min-width: 200px;
            display: none;
        }
        #debugPanel.visible { display: block; }
        #debugPanel h3 { margin: 0 0 10px 0; color: #4af; font-size: 14px; }
        #debugPanel label { display: block; margin: 8px 0 4px 0; color: #aaa; }
        #debugPanel input[type="range"] { width: 100%; }
        #debugPanel .value { color: #4f8; float: right; }
        #debugPanel button {
            margin-top: 10px;
            padding: 5px 10px;
            background: #4a7c59;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }
        #debugPanel button:hover { background: #5a9c69; }
    </style>
</head>
<body>
    <canvas id="game"></canvas>
    <div id="info">Arrows to move | SPACE attack | C collision | S sounds | P debug | ESC close</div>
    <div id="debugPanel">
        <h3>Player Settings</h3>
        <label>Scale: <span class="value" id="scaleVal">1.7</span></label>
        <input type="range" id="scaleSlider" min="0.5" max="4" step="0.1" value="1.7">
        <label>Move Speed: <span class="value" id="speedVal">4</span></label>
        <input type="range" id="speedSlider" min="1" max="15" step="0.5" value="4">
        <label>Anim Speed: <span class="value" id="animVal">10</span></label>
        <input type="range" id="animSlider" min="1" max="20" step="1" value="10">
        <label>Hitbox Width: <span class="value" id="widthVal">28</span></label>
        <input type="range" id="widthSlider" min="10" max="60" step="2" value="28">
        <label>Hitbox Height: <span class="value" id="heightVal">76</span></label>
        <input type="range" id="heightSlider" min="20" max="100" step="2" value="76">
        <h3 style="margin-top:15px;">Camera</h3>
        <label>Zoom: <span class="value" id="zoomVal">0.9</span></label>
        <input type="range" id="zoomSlider" min="0.5" max="3" step="0.1" value="0.9">
        <h3 style="margin-top:15px;">Lighting</h3>
        <label>Darkness: <span class="value" id="darknessVal">0</span>%</label>
        <input type="range" id="darknessSlider" min="0" max="100" step="5" value="0">
        <label style="margin-top:10px;"><input type="checkbox" id="cycleEnabled"> Enable Day/Night Cycle</label>
        <label>Cycle Time: <span class="value" id="dayLengthVal">1</span> min</label>
        <input type="range" id="dayLengthSlider" min="1" max="10" step="0.5" value="1">
        <div id="timeDisplay" style="color:#4f8;margin-top:5px;"></div>
        <button onclick="copySettings()">Copy Settings</button>
    </div>
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        // Fullscreen canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Show loading message
        function showLoading(current, total) {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#4af';
            ctx.font = '24px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('Loading... ' + current + '/' + total, canvas.width / 2, canvas.height / 2);
        }
        showLoading(0, 1);

        // Load project data directly from editor (embedded)
        const projectData = ${projectDataJSON};
        console.log('Loaded project data:', projectData);

        const gridSize = projectData.gridSize || 16;
        const mapRows = projectData.mapRows || 30;
        const mapCols = projectData.mapCols || 40;

        // Load layers
        let layers = [];
        if (projectData.layers && projectData.layers.length > 0) {
            layers = projectData.layers;
            console.log('Loaded layers from projectData.layers');
        } else if (projectData.map && projectData.map.length > 0) {
            layers = [projectData.map];
            console.log('Loaded map from projectData.map (old format)');
        } else {
            console.error('No map data found!');
        }

        const layerVisibility = projectData.layerVisibility || layers.map(() => true);
        const playerLayerIndex = projectData.playerLayerIndex !== undefined ? projectData.playerLayerIndex : 1;

        console.log('Layers:', layers.length, 'MapRows:', mapRows, 'MapCols:', mapCols, 'PlayerLayer:', playerLayerIndex);

        // Debug: Check layer content
        if (layers.length > 0) {
            const firstLayer = layers[0];
            console.log('First layer type:', typeof firstLayer, 'isArray:', Array.isArray(firstLayer));
            if (Array.isArray(firstLayer) && firstLayer.length > 0) {
                console.log('First layer rows:', firstLayer.length);
                // Count non-null cells
                let tileCount = 0;
                for (let y = 0; y < firstLayer.length; y++) {
                    if (firstLayer[y]) {
                        for (let x = 0; x < firstLayer[y].length; x++) {
                            if (firstLayer[y][x]) tileCount++;
                        }
                    }
                }
                console.log('Tiles in first layer:', tileCount);
            }
        }

        const tileCollisions = projectData.tileCollisions || {};
        const collisionMasks = projectData.collisionMasks || {};
        const tileSplitLines = projectData.tileSplitLines || {}; // Depth split for Y-sorting

        console.log('Tiles with collision:', Object.keys(tileCollisions).length);
        console.log('Tiles with depth split:', Object.keys(tileSplitLines).length);

        // Multiple props system
        const propImages = [];
        const propsData = projectData.props || [];
        const propCollisionMasksAll = {}; // propIndex -> collision masks

        // Load tilesets (support multiple)
        const tilesetImages = [];
        const tilesetsData = projectData.tilesets || [{ data: projectData.tilesetData }];

        // Animated props data (needed for counting)
        const animatedPropsData = projectData.animatedProps || [];

        // Track all images that need to load before starting the game
        let imagesToLoad = 0;
        let imagesLoaded = 0;
        let gameStarted = false;

        function checkAllImagesLoaded() {
            showLoading(imagesLoaded, imagesToLoad);
            if (imagesLoaded >= imagesToLoad && !gameStarted) {
                console.log('All images loaded, starting game...');
                gameStarted = true;
                findStartPos();
                gameLoop();
            }
        }

        // Count all images to load
        imagesToLoad += tilesetsData.filter(ts => ts && ts.data).length; // Tilesets with valid data
        imagesToLoad += animatedPropsData.filter(p => p && p.spriteData).length; // Animated props
        imagesToLoad += propsData.filter(p => p && p.data).length; // Regular props with valid data
        if (projectData.propImageData && propsData.length === 0) imagesToLoad += 1; // Legacy single prop
        imagesToLoad += 1; // Player sprite

        console.log('Total images to load:', imagesToLoad);

        // Safety check - if somehow no images to load, start anyway
        if (imagesToLoad === 0) {
            console.warn('No images to load, starting game immediately');
            imagesToLoad = 1;
            imagesLoaded = 1;
            findStartPos();
            gameLoop();
        }

        // Fallback timeout - start game after 5 seconds even if some images failed
        setTimeout(() => {
            if (!gameStarted) {
                console.warn('Timeout reached, starting game with', imagesLoaded, '/', imagesToLoad, 'images loaded');
                gameStarted = true;
                findStartPos();
                gameLoop();
            }
        }, 5000);

        // Load all prop images
        if (propsData.length > 0) {
            propsData.forEach((propData, i) => {
                if (!propData || !propData.data) {
                    console.warn('Prop', i, 'has no data, skipping');
                    return;
                }
                const img = new Image();
                img.onload = () => {
                    console.log('Prop', i, 'loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error('Failed to load prop', i);
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.src = propData.data;
                propImages[i] = img;
                propCollisionMasksAll[i] = propData.collisionMasks || {};
            });
        } else if (projectData.propImageData) {
            // Backwards compatibility - single prop
            const img = new Image();
            img.onload = () => {
                console.log('Prop image loaded (legacy) (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.onerror = () => {
                console.error('Failed to load legacy prop');
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.src = projectData.propImageData;
            propImages[0] = img;
            propCollisionMasksAll[0] = projectData.propCollisionMasks || {};
        }

        tilesetsData.forEach((ts, i) => {
            if (!ts || !ts.data) {
                console.warn('Tileset', i, 'has no data, skipping');
                return;
            }
            const img = new Image();
            img.onload = () => {
                tilesetImages[i] = img;
                imagesLoaded++;
                console.log('Tileset', i, 'loaded (' + imagesLoaded + '/' + imagesToLoad + ')');
                checkAllImagesLoaded();
            };
            img.onerror = () => {
                console.error('Failed to load tileset', i);
                imagesLoaded++;
                checkAllImagesLoaded();
            };
            img.src = ts.data;
        });

        // For backwards compat
        const tilesetImg = { complete: false };

        // Load animated props (stored as animTile cells in layers)
        const animPropImages = [];
        const animPropFrameTimers = {}; // key: "x,y,layer" -> { frame: 0, timer: 0 }

        animatedPropsData.forEach((propData, i) => {
            if (propData && propData.spriteData) {
                const img = new Image();
                img.onload = () => {
                    console.log('AnimProp', i, propData.name, 'loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.onerror = () => {
                    console.error('Failed to load AnimProp', i);
                    imagesLoaded++;
                    checkAllImagesLoaded();
                };
                img.src = propData.spriteData;
                animPropImages[i] = img;
            }
        });

        console.log('Animated props:', animatedPropsData.length);

        // Load player sprite - use embedded sprite if available, otherwise fall back to file
        const playerImg = new Image();
        const basePath = window.opener ? window.opener.location.href.replace(/[^/]*$/, '') : '';
        playerImg.onload = () => {
            console.log('Player sprite loaded (' + (imagesLoaded + 1) + '/' + imagesToLoad + ')');
            imagesLoaded++;
            checkAllImagesLoaded();
        };
        playerImg.onerror = () => {
            console.error('Failed to load player sprite');
            imagesLoaded++;
            checkAllImagesLoaded();
        };
        // Use embedded sprite data if available, otherwise load from file
        if (projectData.playerSpriteData) {
            console.log('Using embedded player sprite');
            playerImg.src = projectData.playerSpriteData;
        } else {
            console.log('Loading player sprite from file:', basePath + 'assets/player_sprite.png');
            playerImg.src = basePath + 'assets/player_sprite.png';
        }

        // Player state (matching game.js)
        const player = {
            x: 100,
            y: 100,
            width: 28,
            height: 76,
            speed: 4,
            direction: 'down',
            frame: 0,
            frameTimer: 0,
            moving: false,
            attacking: false,
            attackTimer: 0
        };

        // === SOUND SYSTEM ===
        const soundsData = projectData.sounds || [];
        const tileSoundsData = projectData.tileSounds || {};
        const playerSoundsData = projectData.playerSounds || {
            walk: { soundIndex: -1, interval: 200, volume: 0.5, pitchVariation: 0.1 },
            attack: { soundIndex: -1, volume: 0.7 }
        };
        console.log('=== SOUND DATA LOADED ===');
        console.log('Sounds array:', soundsData.length, soundsData);
        console.log('Tile sounds:', Object.keys(tileSoundsData).length, tileSoundsData);
        console.log('Player sounds:', playerSoundsData);

        // === LIGHTING SYSTEM ===
        const currentMapName = 'main'; // Default map name for lighting keys
        const lightingSettingsData = projectData.lightingSettings || {
            blobShadows: true,
            ambientEnabled: false,
            timeOfDay: 'day',
            playerLight: false,
            playerLightRadius: 4
        };
        const pointLightsData = projectData.pointLights || {};
        const TIME_PRESETS = {
            dawn:  { r: 0, g: 0, b: 20, a: 0.45 },
            day:   { r: 0, g: 0, b: 0, a: 0 },
            dusk:  { r: 0, g: 0, b: 20, a: 0.55 },
            night: { r: 0, g: 0, b: 20, a: 0.95 }
        };

        // Day/Night cycle system
        let dayCycleEnabled = false;
        let dayLength = 60; // seconds for full cycle (1 min default)
        let cycleTime = 0;  // current position in cycle (0-1)
        let lastCycleUpdate = Date.now();
        let currentLighting = { r: 0, g: 0, b: 0, a: 0 }; // interpolated values
        let manualDarkness = 0; // 0-100, used when cycle is off

        // Shadow settings (fixed values)
        const shadowWidth = 21;
        const shadowHeight = 8;
        const shadowYOffset = 17;

        // === NPC SYSTEM ===
        const npcsData = projectData.npcs || [];
        const placedNpcsData = projectData.placedNpcs || [];
        const npcImages = [];

        // Load NPC sprites
        npcsData.forEach((npc, i) => {
            if (npc && npc.spriteData) {
                const img = new Image();
                img.onload = () => {
                    console.log('NPC sprite loaded:', npc.name);
                };
                img.src = npc.spriteData;
                npcImages[i] = img;
            }
        });

        // NPC runtime state for each placed NPC
        const npcRuntimeState = placedNpcsData.map((placed, i) => ({
            // Position (in pixels)
            x: placed.x * gridSize,
            y: placed.y * gridSize,
            // Path following
            currentWaypoint: 0,
            pathDirection: 1, // 1 = forward, -1 = backward (for non-loop paths)
            // Animation
            direction: 'down',
            frame: 0,
            frameTimer: 0,
            // Movement
            moving: false,
            targetX: placed.x * gridSize,
            targetY: placed.y * gridSize,
            // Trigger state
            triggered: placed.trigger === 'loop', // Loop starts immediately
            waitTimer: 0
        }));

        console.log('NPCs loaded:', npcsData.length, 'Placed:', placedNpcsData.length);

        // Cycle phases: long night with peak darkness held for 50% of each night period
        // Night1: 0-30% (peak 0-15%), EarlyMorn: 30-38%, Dawn: 38-45%, Day: 45-55%,
        // Afternoon: 55-62%, Dusk: 62-70%, Night2: 70-100% (peak 85-100%)
        function updateDayCycle() {
            if (!dayCycleEnabled) return;

            const now = Date.now();
            const delta = (now - lastCycleUpdate) / 1000; // seconds
            lastCycleUpdate = now;

            // Advance cycle
            cycleTime += delta / dayLength;
            if (cycleTime >= 1) cycleTime -= 1;

            // Determine current phase and interpolation
            let fromPreset, toPreset, t, phaseName;

            if (cycleTime < 0.15) {
                // Peak Night 1 (0-15%) - full darkness
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = 0;
                phaseName = 'Night';
            } else if (cycleTime < 0.30) {
                // Late Night (15-30%) - very slowly lightening
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = (cycleTime - 0.15) / 0.15 * 0.1; // barely lighten
                phaseName = 'Late Night';
            } else if (cycleTime < 0.38) {
                // Early Morning (30-38%) - still very dark
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.dawn;
                t = (cycleTime - 0.30) / 0.08 * 0.4;
                phaseName = 'Early Morn';
            } else if (cycleTime < 0.45) {
                // Dawn (38-45%)
                fromPreset = TIME_PRESETS.dawn;
                toPreset = TIME_PRESETS.day;
                t = (cycleTime - 0.38) / 0.07;
                phaseName = 'Dawn';
            } else if (cycleTime < 0.55) {
                // Day (45-55%)
                fromPreset = TIME_PRESETS.day;
                toPreset = TIME_PRESETS.day;
                t = 0;
                phaseName = 'Day';
            } else if (cycleTime < 0.62) {
                // Afternoon (55-62%)
                fromPreset = TIME_PRESETS.day;
                toPreset = TIME_PRESETS.dusk;
                t = (cycleTime - 0.55) / 0.07;
                phaseName = 'Afternoon';
            } else if (cycleTime < 0.70) {
                // Dusk (62-70%)
                fromPreset = TIME_PRESETS.dusk;
                toPreset = TIME_PRESETS.night;
                t = (cycleTime - 0.62) / 0.08;
                phaseName = 'Dusk';
            } else if (cycleTime < 0.85) {
                // Early Night (70-85%) - getting darker
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = 0;
                phaseName = 'Early Night';
            } else {
                // Peak Night 2 (85-100%) - full darkness
                fromPreset = TIME_PRESETS.night;
                toPreset = TIME_PRESETS.night;
                t = 0;
                phaseName = 'Night';
            }

            // Smooth interpolation
            currentLighting.r = Math.round(fromPreset.r + (toPreset.r - fromPreset.r) * t);
            currentLighting.g = Math.round(fromPreset.g + (toPreset.g - fromPreset.g) * t);
            currentLighting.b = Math.round(fromPreset.b + (toPreset.b - fromPreset.b) * t);
            currentLighting.a = fromPreset.a + (toPreset.a - fromPreset.a) * t;

            // Update display
            const timeDisplay = document.getElementById('timeDisplay');
            if (timeDisplay) {
                timeDisplay.textContent = 'Time: ' + phaseName + ' (' + Math.round(cycleTime * 100) + '%)';
            }
        }

        console.log('=== LIGHTING DATA LOADED ===');
        console.log('Lighting settings:', lightingSettingsData);
        console.log('Point lights:', Object.keys(pointLightsData).length);

        // === NPC UPDATE FUNCTION ===
        function updateNPCs() {
            placedNpcsData.forEach((placed, i) => {
                const state = npcRuntimeState[i];
                if (!state) return;

                const npc = npcsData[placed.npcIndex];
                if (!npc) return;

                const path = placed.path || [];
                const speed = (placed.speed || 3) * 0.5; // Convert to pixel speed

                // Check trigger conditions
                if (!state.triggered) {
                    if (placed.trigger === 'interact') {
                        // Triggered by player attack - check if player is attacking nearby
                        if (player.attacking) {
                            const dist = Math.hypot(player.x - state.x, player.y - state.y);
                            if (dist < gridSize * 2) {
                                state.triggered = true;
                            }
                        }
                    } else if (placed.trigger === 'timeDay') {
                        // Only active during day
                        state.triggered = dayCycleEnabled && cycleTime > 0.38 && cycleTime < 0.70;
                    } else if (placed.trigger === 'timeNight') {
                        // Only active during night
                        state.triggered = dayCycleEnabled && (cycleTime < 0.38 || cycleTime > 0.70);
                    }
                }

                // Reset trigger for time-based when condition no longer met
                if (placed.trigger === 'timeDay' && state.triggered) {
                    if (!dayCycleEnabled || cycleTime < 0.38 || cycleTime > 0.70) {
                        state.triggered = false;
                        state.currentWaypoint = 0;
                    }
                }
                if (placed.trigger === 'timeNight' && state.triggered) {
                    if (!dayCycleEnabled || (cycleTime > 0.38 && cycleTime < 0.70)) {
                        state.triggered = false;
                        state.currentWaypoint = 0;
                    }
                }

                // Skip movement if not triggered or no path
                if (!state.triggered || path.length === 0) {
                    state.moving = false;
                    return;
                }

                // Get current waypoint target
                const waypoint = path[state.currentWaypoint];
                if (!waypoint) {
                    // Reset to start
                    state.currentWaypoint = 0;
                    return;
                }

                state.targetX = waypoint.x * gridSize;
                state.targetY = waypoint.y * gridSize;

                // Calculate direction to target
                const dx = state.targetX - state.x;
                const dy = state.targetY - state.y;
                const dist = Math.hypot(dx, dy);

                if (dist < speed) {
                    // Reached waypoint
                    state.x = state.targetX;
                    state.y = state.targetY;
                    state.currentWaypoint++;

                    // Check if path complete
                    if (state.currentWaypoint >= path.length) {
                        if (placed.trigger === 'loop') {
                            // Return to start position, then repeat path
                            state.currentWaypoint = 0;
                            state.x = placed.x * gridSize;
                            state.y = placed.y * gridSize;
                        } else {
                            // One-shot trigger - stop and reset
                            state.triggered = false;
                            state.currentWaypoint = 0;
                            state.x = placed.x * gridSize;
                            state.y = placed.y * gridSize;
                        }
                    }
                    state.moving = false;
                } else {
                    // Move towards waypoint
                    state.moving = true;
                    const moveX = (dx / dist) * speed;
                    const moveY = (dy / dist) * speed;
                    state.x += moveX;
                    state.y += moveY;

                    // Set direction based on movement
                    if (Math.abs(dx) > Math.abs(dy)) {
                        state.direction = dx > 0 ? 'right' : 'left';
                    } else {
                        state.direction = dy > 0 ? 'down' : 'up';
                    }
                }

                // Update animation
                state.frameTimer++;
                const animSpeed = 10;
                if (state.frameTimer >= animSpeed) {
                    state.frameTimer = 0;
                    state.frame = (state.frame + 1) % 4;
                }
            });
        }

        // Offscreen canvas for lighting effects
        let lightCanvas = null;
        let lightCtx = null;

        // Audio context for playback
        let audioContext = null;
        let soundBuffers = {}; // soundIndex -> AudioBuffer

        // Walk sound timing
        let lastWalkSoundTime = 0;

        // Ambient sounds currently playing
        let ambientSounds = {}; // "x,y" -> { source, gainNode, playing }

        // Debug flags
        let showSounds = false;
        let showLayers = false; // L key to toggle layer debug

        // Initialize audio context on first user interaction
        function initAudio() {
            if (audioContext) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            console.log('Audio context initialized');
            console.log('Sounds to load:', soundsData.length);
            console.log('Tile sounds:', Object.keys(tileSoundsData).length);
            console.log('Player sounds:', playerSoundsData);

            // Load all sounds into buffers
            soundsData.forEach((sound, idx) => {
                if (sound && sound.data) {
                    // Decode base64 audio data
                    const base64 = sound.data.split(',')[1];
                    const binary = atob(base64);
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) {
                        bytes[i] = binary.charCodeAt(i);
                    }
                    // Create a copy of the buffer (decodeAudioData detaches the original)
                    const audioBuffer = bytes.buffer.slice(0);
                    audioContext.decodeAudioData(audioBuffer, (buffer) => {
                        soundBuffers[idx] = buffer;
                        console.log('Sound', idx, sound.name, 'loaded successfully');
                    }, (err) => {
                        console.error('Failed to decode sound', idx, err);
                    });
                }
            });
        }

        // Play a sound with optional pitch variation
        function playSound(soundIndex, volume = 1, pitchVariation = 0) {
            if (!audioContext) {
                console.log('playSound: No audio context');
                return;
            }
            if (!soundBuffers[soundIndex]) {
                console.log('playSound: No buffer for sound', soundIndex);
                return;
            }

            const source = audioContext.createBufferSource();
            source.buffer = soundBuffers[soundIndex];

            // Apply pitch variation
            if (pitchVariation > 0) {
                source.playbackRate.value = 1 + (Math.random() - 0.5) * pitchVariation * 2;
            }

            const gainNode = audioContext.createGain();
            gainNode.gain.value = volume;

            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start();

            return { source, gainNode };
        }

        // Update ambient sounds based on player position with smooth fading
        function updateAmbientSounds() {
            if (!audioContext) return;

            const tileSize = gridSize * TILE_SCALE;
            const playerTileX = Math.floor(player.x / tileSize);
            const playerTileY = Math.floor(player.y / tileSize);
            const fadeTime = 0.1; // Smooth transition time in seconds

            Object.keys(tileSoundsData).forEach(key => {
                const [sx, sy] = key.split(',').map(Number);
                const ts = tileSoundsData[key];
                const soundBuffer = soundBuffers[ts.soundIndex];

                if (!soundBuffer) return;

                // Calculate distance from player (in tiles)
                const dx = playerTileX - sx;
                const dy = playerTileY - sy;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Get fade percent (default 50% = half the radius is fade zone)
                const fadePercent = ts.fadePercent !== undefined ? ts.fadePercent : 0.5;

                // Calculate volume based on distance with fade zone
                let targetVolume = 0;
                if (dist <= ts.radius) {
                    // Inside radius - calculate fade
                    const fadeStartDist = ts.radius * (1 - fadePercent); // Where fade begins
                    if (dist <= fadeStartDist) {
                        // Inside inner zone - full volume
                        targetVolume = ts.volume;
                    } else {
                        // In fade zone - linear fade from full to zero
                        const fadeZoneSize = ts.radius - fadeStartDist;
                        const distInFadeZone = dist - fadeStartDist;
                        targetVolume = ts.volume * (1 - distInFadeZone / fadeZoneSize);
                    }
                }

                // Start sound if not playing yet (for looping sounds, keep them running)
                if (!ambientSounds[key]?.playing && ts.loop) {
                    const source = audioContext.createBufferSource();
                    source.buffer = soundBuffer;
                    source.loop = true;

                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = 0; // Start silent

                    source.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    source.start();

                    ambientSounds[key] = { source, gainNode, playing: true };
                }

                // For non-looping sounds, only start when in range
                if (!ambientSounds[key]?.playing && !ts.loop && targetVolume > 0) {
                    const source = audioContext.createBufferSource();
                    source.buffer = soundBuffer;
                    source.loop = false;

                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = targetVolume;

                    source.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    source.start();

                    ambientSounds[key] = { source, gainNode, playing: true };

                    source.onended = () => {
                        if (ambientSounds[key]) {
                            ambientSounds[key].playing = false;
                        }
                    };
                }

                // Smoothly adjust volume for playing sounds
                if (ambientSounds[key]?.playing && ambientSounds[key].gainNode) {
                    const gain = ambientSounds[key].gainNode.gain;
                    // Use linearRampToValueAtTime for smooth transitions
                    gain.cancelScheduledValues(audioContext.currentTime);
                    gain.setValueAtTime(gain.value, audioContext.currentTime);
                    gain.linearRampToValueAtTime(Math.max(0, targetVolume), audioContext.currentTime + fadeTime);
                }
            });
        }

        // === LIGHTING RENDERING (Classic 2D - no WebGL) ===
        function renderLighting() {
            const lighting = lightingSettingsData;

            // Get lighting values - use cycle if enabled, otherwise use darkness slider
            let preset;
            if (dayCycleEnabled) {
                preset = currentLighting;
            } else {
                // Use manual darkness slider (0-100 maps to 0-0.95 alpha)
                const alpha = manualDarkness / 100 * 0.95;
                preset = { r: 0, g: 0, b: 20, a: alpha };
            }

            // Skip if no darkness and no player light
            if (preset.a === 0 && !lighting.playerLight) return;

            // Create/resize offscreen canvas for lighting
            if (!lightCanvas || lightCanvas.width !== canvas.width || lightCanvas.height !== canvas.height) {
                lightCanvas = document.createElement('canvas');
                lightCanvas.width = canvas.width;
                lightCanvas.height = canvas.height;
                lightCtx = lightCanvas.getContext('2d');
            }

            // Clear and fill with ambient darkness
            lightCtx.clearRect(0, 0, lightCanvas.width, lightCanvas.height);
            lightCtx.fillStyle = 'rgba(' + preset.r + ',' + preset.g + ',' + preset.b + ',' + preset.a + ')';
            lightCtx.fillRect(0, 0, lightCanvas.width, lightCanvas.height);

            // Cut out light circles using destination-out compositing
            lightCtx.globalCompositeOperation = 'destination-out';

            const tileSize = gridSize * TILE_SCALE;
            const camX = Math.floor(player.x - canvas.width / (2 * cameraZoom) + player.width / 2);
            const camY = Math.floor(player.y - canvas.height / (2 * cameraZoom) + player.height / 2);

            // Player torch light (always follows player)
            if (lighting.playerLight) {
                const px = (player.x - camX + player.width / 2) * cameraZoom;
                const py = (player.y - camY + player.height / 2) * cameraZoom;
                const radius = lighting.playerLightRadius * tileSize * cameraZoom;

                const gradient = lightCtx.createRadialGradient(px, py, 0, px, py, radius);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.5, 'rgba(255,255,255,0.6)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                lightCtx.fillStyle = gradient;
                lightCtx.beginPath();
                lightCtx.arc(px, py, radius, 0, Math.PI * 2);
                lightCtx.fill();
            }

            // Cut out placed point lights
            const mapPrefix = currentMapName + ':';
            Object.keys(pointLightsData).forEach(key => {
                if (!key.startsWith(mapPrefix)) return;

                const coords = key.split(':')[1];
                const [lx, ly] = coords.split(',').map(Number);
                const light = pointLightsData[key];

                const screenX = ((lx * tileSize + tileSize / 2) - camX) * cameraZoom;
                const screenY = ((ly * tileSize + tileSize / 2) - camY) * cameraZoom;
                let radius = light.radius * tileSize * cameraZoom;

                // Optional flicker effect
                if (light.flicker) {
                    radius *= 0.95 + Math.random() * 0.1;
                }

                const gradient = lightCtx.createRadialGradient(screenX, screenY, 0, screenX, screenY, radius);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.6, 'rgba(255,255,255,0.5)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                lightCtx.fillStyle = gradient;
                lightCtx.beginPath();
                lightCtx.arc(screenX, screenY, radius, 0, Math.PI * 2);
                lightCtx.fill();
            });

            // Reset composite operation and draw darkness over game
            lightCtx.globalCompositeOperation = 'source-over';
            ctx.drawImage(lightCanvas, 0, 0);
        }

        // Initialize audio on first key press
        document.addEventListener('keydown', () => initAudio(), { once: true });

        // Adjustable settings
        let playerScale = 1.7;
        let animSpeed = 10; // Lower = faster animation

        // Tile scale - how big to render tiles (zoom level)
        const TILE_SCALE = 4;

        // Camera zoom (1 = normal, 2 = 2x closer, etc)
        let cameraZoom = 1.0;

        // Debug panel toggle and slider handlers
        document.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') {
                document.getElementById('debugPanel').classList.toggle('visible');
            }
            if (e.key === 's' || e.key === 'S') {
                showSounds = !showSounds;
                console.log('Sound debug:', showSounds ? 'ON' : 'OFF');
            }
            if (e.key === 'l' || e.key === 'L') {
                showLayers = !showLayers;
                console.log('Layer debug:', showLayers ? 'ON' : 'OFF');
            }
        });

        document.getElementById('scaleSlider').addEventListener('input', (e) => {
            playerScale = parseFloat(e.target.value);
            document.getElementById('scaleVal').textContent = playerScale.toFixed(1);
        });

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            player.speed = parseFloat(e.target.value);
            document.getElementById('speedVal').textContent = player.speed.toFixed(1);
        });

        document.getElementById('animSlider').addEventListener('input', (e) => {
            animSpeed = parseInt(e.target.value);
            document.getElementById('animVal').textContent = animSpeed;
        });

        document.getElementById('widthSlider').addEventListener('input', (e) => {
            player.width = parseInt(e.target.value);
            document.getElementById('widthVal').textContent = player.width;
        });

        document.getElementById('heightSlider').addEventListener('input', (e) => {
            player.height = parseInt(e.target.value);
            document.getElementById('heightVal').textContent = player.height;
        });

        document.getElementById('zoomSlider').addEventListener('input', (e) => {
            cameraZoom = parseFloat(e.target.value);
            document.getElementById('zoomVal').textContent = cameraZoom.toFixed(1);
        });

        // Lighting controls
        document.getElementById('darknessSlider').addEventListener('input', (e) => {
            manualDarkness = parseInt(e.target.value);
            document.getElementById('darknessVal').textContent = manualDarkness;
        });

        document.getElementById('cycleEnabled').addEventListener('change', (e) => {
            dayCycleEnabled = e.target.checked;
            lastCycleUpdate = Date.now(); // Reset timer
            if (!dayCycleEnabled) {
                document.getElementById('timeDisplay').textContent = '';
            }
        });

        document.getElementById('dayLengthSlider').addEventListener('input', (e) => {
            const minutes = parseFloat(e.target.value);
            dayLength = minutes * 60; // convert to seconds
            document.getElementById('dayLengthVal').textContent = minutes;
        });

        function copySettings() {
            const settings = \`Player Settings:
  scale: \${playerScale}
  speed: \${player.speed}
  animSpeed: \${animSpeed}
  width: \${player.width}
  height: \${player.height}
  cameraZoom: \${cameraZoom}\`;
            navigator.clipboard.writeText(settings).then(() => {
                alert('Settings copied to clipboard!');
            });
        }

        // Find starting position - use player marker position from editor
        function findStartPos() {
            const tileSize = gridSize * TILE_SCALE;

            console.log('findStartPos called, projectData.playerPreviewPos =', projectData.playerPreviewPos);

            // Use the player preview position saved in project data
            if (projectData.playerPreviewPos && (projectData.playerPreviewPos.x !== undefined)) {
                const pos = projectData.playerPreviewPos;
                player.x = pos.x * tileSize + tileSize / 2;
                player.y = pos.y * tileSize + tileSize / 2;
                console.log('Start position from marker: tile', pos.x, pos.y, '-> pixel', player.x, player.y);
                return;
            }

            console.log('No playerPreviewPos found, using fallback');
            // Fallback: find first tile without collision
            const layer = layers[0];
            if (!layer) {
                console.error('No layers found for starting position');
                return;
            }
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y] && layer[y][x];
                    if (cell && cell.type === 'tile') {
                        const key = cell.x + ',' + cell.y;
                        if (!tileCollisions[key]) {
                            player.x = x * tileSize + tileSize / 2;
                            player.y = y * tileSize + tileSize / 2;
                            console.log('Start position: tile', x, y);
                            return;
                        }
                    }
                }
            }
            // If no safe tile, just start at first tile
            for (let y = 0; y < mapRows; y++) {
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y] && layer[y][x];
                    if (cell) {
                        player.x = x * tileSize + tileSize / 2;
                        player.y = y * tileSize + tileSize / 2;
                        console.log('Start position (fallback): tile', x, y);
                        return;
                    }
                }
            }
        }

        // Camera
        const camera = { x: 0, y: 0 };

        // Debug
        let showCollision = false;

        // Input
        const keys = {};

        document.addEventListener('keydown', e => {
            keys[e.key] = true;

            if (e.key === 'Escape') window.close();
            if (e.key === 'c' || e.key === 'C') showCollision = !showCollision;
            if (e.key === ' ' && !player.attacking) {
                player.attacking = true;
                player.attackTimer = 18;
                // Play attack sound
                if (playerSoundsData.attack && playerSoundsData.attack.soundIndex >= 0) {
                    playSound(playerSoundsData.attack.soundIndex, playerSoundsData.attack.volume || 0.7, 0);
                }
            }
        });
        document.addEventListener('keyup', e => keys[e.key] = false);

        // Pixel-level collision check on ALL layers
        function checkCollision(x, y, w, h) {
            const tileSize = gridSize * TILE_SCALE;
            const pixelScale = tileSize / gridSize;

            // Check corners and edge midpoints
            const points = [
                { x: x, y: y },
                { x: x + w - 1, y: y },
                { x: x, y: y + h - 1 },
                { x: x + w - 1, y: y + h - 1 },
                { x: x + w / 2, y: y },
                { x: x + w / 2, y: y + h - 1 },
                { x: x, y: y + h / 2 },
                { x: x + w - 1, y: y + h / 2 }
            ];

            for (const point of points) {
                const tileX = Math.floor(point.x / tileSize);
                const tileY = Math.floor(point.y / tileSize);

                // Out of bounds = collision
                if (tileX < 0 || tileX >= mapCols || tileY < 0 || tileY >= mapRows) {
                    return true;
                }

                // Check ALL layers for collision
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li];
                    if (!layer) continue;

                    const cell = layer[tileY] && layer[tileY][tileX];
                    if (cell) {
                        // Include tileset index in key for tiles
                        const tilesetIdx = cell.tilesetIndex || 0;
                        const key = cell.type === 'tile'
                            ? tilesetIdx + ':' + cell.x + ',' + cell.y
                            : cell.x + ',' + cell.y;
                        // Use tile collision masks for tiles, prop collision masks for props (by propIndex)
                        let mask = null;
                        let maskOffsetX = 0;
                        let maskOffsetY = 0;

                        if (cell.type === 'prop') {
                            const propIdx = cell.propIndex || 0;
                            const propKey = cell.x + ',' + cell.y;
                            mask = propCollisionMasksAll[propIdx] ? propCollisionMasksAll[propIdx][propKey] : null;
                        } else if (cell.type === 'animTile') {
                            // Animated tile - get collision from prop data
                            const propData = animatedPropsData[cell.propIndex];
                            if (propData && propData.collisionMask) {
                                mask = propData.collisionMask;
                                // For multi-tile props, offset into the mask
                                maskOffsetX = (cell.offsetX || 0) * gridSize;
                                maskOffsetY = (cell.offsetY || 0) * gridSize;
                            }
                        } else {
                            mask = collisionMasks[key];
                        }

                        if (mask) {
                            // Check pixel-level collision (works for both tiles and props)
                            const localX = Math.floor((point.x % tileSize) / pixelScale);
                            const localY = Math.floor((point.y % tileSize) / pixelScale);

                            // Apply offset for multi-tile animated props
                            const maskX = localX + maskOffsetX;
                            const maskY = localY + maskOffsetY;

                            if (maskY >= 0 && maskY < mask.length && mask[maskY]) {
                                if (maskX >= 0 && maskX < mask[maskY].length && mask[maskY][maskX]) {
                                    return true;
                                }
                            }
                        } else if (cell.type === 'tile' && tileCollisions[key]) {
                            // Full tile collision (no mask = solid tile)
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function update() {
            let dx = 0, dy = 0;
            player.moving = false;

            if (!player.attacking) {
                if (keys['ArrowUp']) { dy = -1; player.direction = 'up'; player.moving = true; }
                if (keys['ArrowDown']) { dy = 1; player.direction = 'down'; player.moving = true; }
                if (keys['ArrowLeft']) { dx = -1; player.direction = 'left'; player.moving = true; }
                if (keys['ArrowRight']) { dx = 1; player.direction = 'right'; player.moving = true; }

                // Normalize diagonal movement so it's not faster
                if (dx !== 0 && dy !== 0) {
                    const diag = 0.7071; // 1/sqrt(2)
                    dx *= diag;
                    dy *= diag;
                }

                dx *= player.speed;
                dy *= player.speed;
            }

            // Move with collision - always use small foot hitbox (bottom 1/3 of player)
            // This allows walking behind objects naturally and prevents getting stuck
            const collisionHeight = player.height / 3;
            const collisionY = player.y + player.height * 2/3;

            let movedX = false;
            let movedY = false;

            if (dx !== 0 && !checkCollision(player.x + dx, collisionY, player.width, collisionHeight)) {
                player.x += dx;
                movedX = true;
            }
            if (dy !== 0 && !checkCollision(player.x, collisionY + dy, player.width, collisionHeight)) {
                player.y += dy;
                movedY = true;
            }

            // If player tried to move but was blocked in all directions, force idle
            if (player.moving && !movedX && !movedY) {
                player.moving = false;
            }

            // Animation - uses animSpeed variable (lower = faster)
            player.frameTimer++;
            if (player.frameTimer >= animSpeed) {
                player.frameTimer = 0;
                player.frame = (player.frame + 1) % 4;
            }

            // Update animated tile animations - scan layers for animTile cells
            for (let li = 0; li < layers.length; li++) {
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell || cell.type !== 'animTile') continue;

                        const propData = animatedPropsData[cell.propIndex];
                        if (!propData || !propData.frames || propData.frames.length <= 1) continue;
                        if (propData.type !== 'loop') continue;

                        // Use origin tile position for multi-tile prop sync
                        const originX = x - (cell.offsetX || 0);
                        const originY = y - (cell.offsetY || 0);
                        const key = originX + ',' + originY + ',' + li;

                        // Only process animation once per prop (at origin tile)
                        if (cell.offsetX === 0 && cell.offsetY === 0 || (!cell.offsetX && !cell.offsetY)) {
                            if (!animPropFrameTimers[key]) {
                                animPropFrameTimers[key] = { frame: 0, timer: 0 };
                            }
                            animPropFrameTimers[key].timer++;

                            const fps = propData.fps || 8;
                            const frameDelay = Math.round(60 / fps);

                            if (animPropFrameTimers[key].timer >= frameDelay) {
                                animPropFrameTimers[key].timer = 0;
                                animPropFrameTimers[key].frame = (animPropFrameTimers[key].frame + 1) % propData.frames.length;
                            }
                        }
                    }
                }
            }

            // Attack timer
            if (player.attacking) {
                player.attackTimer--;
                if (player.attackTimer <= 0) {
                    player.attacking = false;
                }
            }

            // Camera follow - adjust for zoom so player stays centered
            camera.x = player.x - (canvas.width / 2) / cameraZoom;
            camera.y = player.y - (canvas.height / 2) / cameraZoom;

            // === UPDATE NPCs ===
            updateNPCs();

            // === SOUND UPDATES ===
            // Play walk sounds when moving
            if (player.moving && playerSoundsData.walk && playerSoundsData.walk.soundIndex >= 0) {
                const now = performance.now();
                const interval = playerSoundsData.walk.interval || 200;
                if (now - lastWalkSoundTime >= interval) {
                    playSound(
                        playerSoundsData.walk.soundIndex,
                        playerSoundsData.walk.volume || 0.5,
                        playerSoundsData.walk.pitchVariation || 0.1
                    );
                    lastWalkSoundTime = now;
                }
            }

            // Update ambient sounds based on proximity
            updateAmbientSounds();
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const tileSize = gridSize * TILE_SCALE;
            ctx.imageSmoothingEnabled = false;

            // Check if all tilesets are ready
            let allTilesetsReady = true;
            for (let i = 0; i < tilesetImages.length; i++) {
                if (!tilesetImages[i] || !tilesetImages[i].complete) {
                    allTilesetsReady = false;
                    break;
                }
            }
            if (!allTilesetsReady) {
                ctx.fillStyle = '#4af';
                ctx.font = '20px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('Loading tilesets...', canvas.width / 2, canvas.height / 2);
                return;
            }

            // Debug: Show message if no layers
            if (layers.length === 0) {
                ctx.fillStyle = '#f00';
                ctx.font = '16px monospace';
                ctx.fillText('ERROR: No layers loaded!', 20, 70);
                return;
            }

            // Apply camera zoom transform
            ctx.save();
            ctx.scale(cameraZoom, cameraZoom);

            // Draw tiles - use Math.round for camera to prevent seams
            const camX = Math.round(camera.x);
            const camY = Math.round(camera.y);

            // === 3-PASS RENDERING FOR Y-SORTING ===

            // PASS 1: Draw ground layer (layer 0) - always behind everything
            let tilesDrawn = drawLayer(0, camX, camY, tileSize);

            // PASS 2: Y-sort player with tiles from layers 1+
            tilesDrawn += drawYSortedEntities(camX, camY, tileSize);

            // PASS 3: Draw canopy overlay (split tile tops)
            drawCanopyOverlay(camX, camY, tileSize);

            // PASS 4: Redraw higher layer content that canopy covered
            redrawHigherLayerContent(camX, camY, tileSize);

            // Draw sound debug visualization
            if (showSounds) {
                Object.keys(tileSoundsData).forEach(key => {
                    const parts = key.split(',');
                    const sx = parseInt(parts[0]) || 0;
                    const sy = parseInt(parts[1]) || 0;
                    const ts = tileSoundsData[key];
                    if (!ts) return;

                    const px = sx * tileSize - camX + tileSize / 2;
                    const py = sy * tileSize - camY + tileSize / 2;
                    const radius = (ts.radius || 3) * tileSize;

                    // Draw radius circle
                    const isPlaying = ambientSounds[key]?.playing;
                    ctx.strokeStyle = isPlaying ? 'rgba(0, 255, 0, 0.6)' : 'rgba(255, 165, 0, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(px, py, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw center marker
                    ctx.fillStyle = isPlaying ? '#0f0' : '#ffa500';
                    ctx.beginPath();
                    ctx.arc(px, py, tileSize / 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Label
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    const soundName = soundsData[ts.soundIndex]?.name || 'Sound ' + ts.soundIndex;
                    ctx.fillText(soundName, px, py - tileSize / 2);
                    ctx.fillText(isPlaying ? 'PLAYING' : 'idle', px, py + tileSize / 2 + 12);
                });
            }

            // Layer debug visualization
            if (showLayers) {
                ctx.font = '10px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                for (let li = 0; li < layers.length; li++) {
                    const layer = layers[li];
                    if (!layer) continue;
                    for (let y = 0; y < mapRows; y++) {
                        if (!layer[y]) continue;
                        for (let x = 0; x < mapCols; x++) {
                            const cell = layer[y][x];
                            if (!cell) continue;
                            const px = x * tileSize - camX + tileSize / 2;
                            const py = y * tileSize - camY + tileSize / 2;
                            // Skip off-screen tiles
                            if (px < -tileSize || px > canvas.width / cameraZoom + tileSize || py < -tileSize || py > canvas.height / cameraZoom + tileSize) continue;
                            // Different color for animTiles
                            if (cell.type === 'animTile') {
                                ctx.fillStyle = 'rgba(255, 0, 255, 0.8)'; // Magenta for animTiles
                                ctx.fillRect(px - 8, py - 6, 16, 12);
                                ctx.fillStyle = '#fff';
                                ctx.fillText('A' + li, px, py);
                            } else if (li > 0) {
                                // Only show layer number for non-ground tiles
                                ctx.fillStyle = 'rgba(0, 100, 255, 0.7)';
                                ctx.fillRect(px - 6, py - 6, 12, 12);
                                ctx.fillStyle = '#fff';
                                ctx.fillText(li, px, py);
                            }
                        }
                    }
                }
            }

            ctx.restore();

            // === LIGHTING OVERLAY (drawn after all game content) ===
            renderLighting();

            // Debug info (drawn after restore so it's not zoomed)
            ctx.fillStyle = '#fff';
            ctx.font = '12px monospace';
            ctx.fillText('Layers: ' + layers.length + ' | Tiles: ' + tilesDrawn + ' | Zoom: ' + cameraZoom.toFixed(1) + 'x', 10, canvas.height - 10);

            // Sound debug info
            if (showSounds) {
                ctx.fillText('Sounds: ' + soundsData.length + ' loaded | Tile sounds: ' + Object.keys(tileSoundsData).length + ' | Audio: ' + (audioContext ? 'ON' : 'OFF'), 10, canvas.height - 25);
            }

            // Layer debug info
            if (showLayers) {
                // Count animTiles per layer
                let animCounts = [];
                for (let li = 0; li < layers.length; li++) {
                    let count = 0;
                    const layer = layers[li];
                    if (layer) {
                        for (let y = 0; y < mapRows; y++) {
                            if (!layer[y]) continue;
                            for (let x = 0; x < mapCols; x++) {
                                if (layer[y][x]?.type === 'animTile') count++;
                            }
                        }
                    }
                    if (count > 0) animCounts.push('L' + li + ':' + count);
                }
                ctx.fillText('Layer Debug ON (L) | AnimTiles: ' + (animCounts.length > 0 ? animCounts.join(', ') : 'none') + ' | Press L to toggle', 10, canvas.height - 25);
            }
        }

        // Helper for drawing tiles with rotation and flip in test game
        function drawTileWithEffects(ctx, img, srcX, srcY, srcSize, destX, destY, destSize, rotation, flipped) {
            ctx.save();
            ctx.translate(destX + destSize / 2, destY + destSize / 2);

            if (rotation !== 0) {
                ctx.rotate(rotation * Math.PI / 180);
            }
            if (flipped) {
                ctx.scale(-1, 1); // Flip horizontally
            }

            ctx.drawImage(img, srcX, srcY, srcSize, srcSize, -destSize / 2, -destSize / 2, destSize, destSize);
            ctx.restore();
        }

        function drawLayer(li, camX, camY, tileSize) {
            if (!layerVisibility[li]) return 0;
            const layer = layers[li];
            if (!layer) return 0;

            let count = 0;
            for (let y = 0; y < mapRows; y++) {
                if (!layer[y]) continue;
                for (let x = 0; x < mapCols; x++) {
                    const cell = layer[y][x];
                    if (!cell) continue;

                    const px = Math.floor(x * tileSize - camX);
                    const py = Math.floor(y * tileSize - camY);

                    // Account for zoom in off-screen check
                    if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                    // Overlap to prevent seams when zoomed
                    const overlap = 1;

                    if (cell.type === 'tile') {
                        count++;
                        // Use correct tileset for this tile
                        const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
                        if (cellTileset) {
                            // Draw with rotation and inversion
                            drawTileWithEffects(ctx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize + overlap, cell.rotation || 0, cell.flipped || false);
                        } else {
                            // Fallback: draw colored rectangle if tileset not loaded
                            ctx.fillStyle = '#4a7c59';
                            ctx.fillRect(px, py, tileSize, tileSize);
                        }

                        // Draw collision overlay if debug enabled (all layers)
                        if (showCollision) {
                            // Include tileset index in collision key
                            const tilesetIdx = cell.tilesetIndex || 0;
                            const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                            const mask = collisionMasks[key];

                            if (mask) {
                                // Draw pixel-level collision
                                const pixelSize = tileSize / gridSize;
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                for (let my = 0; my < gridSize; my++) {
                                    for (let mx = 0; mx < gridSize; mx++) {
                                        if (mask[my] && mask[my][mx]) {
                                            ctx.fillRect(
                                                px + mx * pixelSize,
                                                py + my * pixelSize,
                                                pixelSize,
                                                pixelSize
                                            );
                                        }
                                    }
                                }
                            } else if (tileCollisions[key]) {
                                // Full tile collision
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                ctx.fillRect(px, py, tileSize, tileSize);
                            }
                        }
                    } else if (cell.type === 'prop') {
                        const propIdx = cell.propIndex || 0;
                        const propImg = propImages[propIdx];
                        if (propImg && propImg.complete) {
                            count++;
                            ctx.drawImage(propImg, cell.x, cell.y, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
                        }

                        // Show collision in debug mode
                        if (showCollision) {
                            const key = cell.x + ',' + cell.y;
                            const mask = propCollisionMasksAll[propIdx] ? propCollisionMasksAll[propIdx][key] : null;
                            if (mask) {
                                const pixelSize = tileSize / gridSize;
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                                for (let my = 0; my < gridSize; my++) {
                                    for (let mx = 0; mx < gridSize; mx++) {
                                        if (mask[my] && mask[my][mx]) {
                                            ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                                        }
                                    }
                                }
                            }
                        }
                    } else if (cell.type === 'animTile') {
                        // Animated tile - cycles through frames like a regular tile
                        const propData = animatedPropsData[cell.propIndex];
                        const propImg = animPropImages[cell.propIndex];
                        if (propData && propImg && propImg.complete && propData.frames && propData.frames.length > 0) {
                            // Use origin tile position for synced animation
                            const originX = x - (cell.offsetX || 0);
                            const originY = y - (cell.offsetY || 0);
                            const key = originX + ',' + originY + ',' + li;
                            const timer = animPropFrameTimers[key] || { frame: 0 };
                            const frameIdx = timer.frame % propData.frames.length;
                            const frame = propData.frames[frameIdx];

                            // Draw only this tile's portion of the frame
                            const offsetX = cell.offsetX || 0;
                            const offsetY = cell.offsetY || 0;
                            const srcX = frame.x + offsetX * gridSize;
                            const srcY = frame.y + offsetY * gridSize;

                            count++;
                            // Draw with rotation support
                            const rot = cell.rotation || 0;
                            if (rot === 0) {
                                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
                            } else {
                                ctx.save();
                                ctx.translate(px + tileSize / 2, py + tileSize / 2);
                                ctx.rotate(rot * Math.PI / 180);
                                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, -tileSize / 2, -tileSize / 2, tileSize + overlap, tileSize + overlap);
                                ctx.restore();
                            }
                        }
                    }
                }
            }

            return count;
        }

        // === Y-SORTING FUNCTIONS ===

        // Original Y-sorting: Y position is primary, layer is tiebreaker
        function drawYSortedEntities(camX, camY, tileSize) {
            const entities = [];

            // Add player
            const playerGridY = Math.floor((player.y + player.height) / (gridSize * TILE_SCALE));
            const playerLayer = playerLayerIndex || 1;
            entities.push({
                type: 'player',
                sortY: (playerGridY + 1) * 1000 + playerLayer + 0.5
            });

            // Add NPCs
            placedNpcsData.forEach((placed, i) => {
                const state = npcRuntimeState[i];
                if (!state) return;
                const npc = npcsData[placed.npcIndex];
                if (!npc) return;

                const npcGridY = Math.floor((state.y + gridSize) / (gridSize * TILE_SCALE));
                entities.push({
                    type: 'npc',
                    npcIndex: i,
                    sortY: (npcGridY + 1) * 1000 + playerLayer + 0.4 // Slightly before player at same Y
                });
            });

            // Add tiles from all layers 1+
            for (let li = 1; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        const px = x * tileSize - camX;
                        const py = y * tileSize - camY;

                        // Skip off-screen tiles
                        if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                        // Y is primary, layer is tiebreaker
                        const baseSortY = (y + 1) * 1000 + li;

                        if (cell.type === 'tile') {
                            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
                            const splitData = tileSplitLines[key];
                            const hasSplit = splitData !== undefined && splitData !== null;

                            entities.push({
                                type: hasSplit ? 'trunk' : 'tile',
                                cell, x, y, layer: li,
                                sortY: baseSortY
                            });
                        } else if (cell.type === 'animTile') {
                            const propData = animatedPropsData[cell.propIndex];
                            const hasSplit = propData && propData.splitLine !== null && propData.splitLine !== undefined &&
                                (typeof propData.splitLine === 'number' ||
                                 (typeof propData.splitLine === 'object' && Object.keys(propData.splitLine).length > 0));

                            entities.push({
                                type: hasSplit ? 'animTrunk' : 'animTile',
                                cell, x, y, layer: li,
                                sortY: baseSortY
                            });
                        }
                    }
                }
            }

            // Sort by Y, then layer
            entities.sort((a, b) => a.sortY - b.sortY);

            // Draw in sorted order
            let count = 0;
            for (const e of entities) {
                if (e.type === 'player') {
                    drawPlayer();
                } else if (e.type === 'npc') {
                    drawNPC(e.npcIndex, camX, camY, tileSize);
                } else if (e.type === 'trunk') {
                    drawTileTrunk(e.cell, e.x, e.y, camX, camY, tileSize);
                    count++;
                } else if (e.type === 'animTrunk') {
                    drawAnimTileTrunk(e.cell, e.x, e.y, e.layer, camX, camY, tileSize);
                    count++;
                } else if (e.type === 'animTile') {
                    drawAnimTile(e.cell, e.x, e.y, e.layer, camX, camY, tileSize);
                    count++;
                } else {
                    drawTileFull(e.cell, e.x, e.y, camX, camY, tileSize);
                    count++;
                }
            }

            return count;
        }

        // Redraw content from higher layers that overlaps with canopy from lower layers
        function redrawHigherLayerContent(camX, camY, tileSize) {
            // For each position that has canopy (split line), redraw any higher layer content
            for (let li = 1; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        // Check if this cell has canopy (split line)
                        let hasCanopy = false;
                        if (cell.type === 'tile') {
                            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
                            hasCanopy = tileSplitLines[key] !== undefined && tileSplitLines[key] !== null;
                        } else if (cell.type === 'animTile') {
                            const propData = animatedPropsData[cell.propIndex];
                            hasCanopy = propData && propData.splitLine !== null && propData.splitLine !== undefined;
                        }

                        if (!hasCanopy) continue;

                        // This cell has canopy - redraw any higher layer content at this position
                        for (let hi = li + 1; hi < layers.length; hi++) {
                            if (!layerVisibility[hi]) continue;
                            const higherLayer = layers[hi];
                            if (!higherLayer || !higherLayer[y] || !higherLayer[y][x]) continue;

                            const higherCell = higherLayer[y][x];
                            if (higherCell.type === 'animTile') {
                                drawAnimTile(higherCell, x, y, hi, camX, camY, tileSize);
                            } else if (higherCell.type === 'tile') {
                                drawTileFull(higherCell, x, y, camX, camY, tileSize);
                            }
                        }
                    }
                }
            }
        }

        function drawAnimTile(cell, tx, ty, li, camX, camY, tileSize) {
            const propData = animatedPropsData[cell.propIndex];
            const propImg = animPropImages[cell.propIndex];

            if (!propData || !propImg || !propImg.complete || !propData.frames || propData.frames.length === 0) {
                return;
            }

            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const overlap = 1;

            // Use origin tile position for synced animation
            const originX = tx - (cell.offsetX || 0);
            const originY = ty - (cell.offsetY || 0);
            const key = originX + ',' + originY + ',' + li;
            const timer = animPropFrameTimers[key] || { frame: 0 };
            const frameIdx = timer.frame % propData.frames.length;
            const frame = propData.frames[frameIdx];

            // Draw only this tile's portion of the frame
            const offsetX = cell.offsetX || 0;
            const offsetY = cell.offsetY || 0;
            const srcX = frame.x + offsetX * gridSize;
            const srcY = frame.y + offsetY * gridSize;

            ctx.imageSmoothingEnabled = false;

            // Draw with rotation support
            const rot = cell.rotation || 0;
            if (rot === 0) {
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px - overlap, py - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
            } else {
                ctx.save();
                ctx.translate(px + tileSize / 2, py + tileSize / 2);
                ctx.rotate(rot * Math.PI / 180);
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, -tileSize / 2 - overlap, -tileSize / 2 - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
                ctx.restore();
            }
        }

        // Draw only the trunk (bottom) portion of an animated tile with split line
        function drawAnimTileTrunk(cell, tx, ty, li, camX, camY, tileSize) {
            const propData = animatedPropsData[cell.propIndex];
            const propImg = animPropImages[cell.propIndex];
            if (!propData || !propImg || !propImg.complete) return;
            if (!propData.frames || propData.frames.length === 0) return;
            if (!propData.splitLine) return;

            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const scale = tileSize / gridSize;

            // Use origin tile position for synced animation
            const originX = tx - (cell.offsetX || 0);
            const originY = ty - (cell.offsetY || 0);
            const key = originX + ',' + originY + ',' + li;
            const timer = animPropFrameTimers[key] || { frame: 0 };
            const frameIdx = timer.frame % propData.frames.length;
            const frame = propData.frames[frameIdx];

            // Calculate this tile's portion
            const offsetX = cell.offsetX || 0;
            const offsetY = cell.offsetY || 0;

            // Get split Y for this specific tile within the prop
            const tileKey = offsetX + ',' + offsetY;
            let splitY = null;

            if (typeof propData.splitLine === 'object' && !Array.isArray(propData.splitLine)) {
                // New format: object with "tileX,tileY" -> splitY
                splitY = propData.splitLine[tileKey];
            } else if (typeof propData.splitLine === 'number') {
                // Old format: single number (only applies to tile 0,0)
                if (offsetX === 0 && offsetY === 0) splitY = propData.splitLine;
            }

            // If no split for this tile, draw full tile
            if (splitY === null || splitY === undefined) {
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize;
                const overlap = 1;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px - overlap, py - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
                return;
            }

            // splitY is already local to this tile (0 to gridSize)
            const localSplitY = splitY;

            // Only draw if split is within this tile
            const overlap = 1;
            if (localSplitY <= 0) {
                // Split is above this tile - draw full tile
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px - overlap, py - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
            } else if (localSplitY < gridSize) {
                // Split is within this tile - draw only trunk (below split)
                const srcX = frame.x + offsetX * gridSize;
                const srcY = frame.y + offsetY * gridSize + localSplitY;
                const srcH = gridSize - localSplitY;
                const destY = py + localSplitY * scale;
                const destH = srcH * scale;

                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(propImg, srcX, srcY, gridSize, srcH, px - overlap, destY, tileSize + overlap * 2, destH + overlap);
            }
            // If localSplitY >= gridSize, split is below this tile - don't draw trunk here
        }

        function drawTileFull(cell, tx, ty, camX, camY, tileSize) {
            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
            // Overlap to prevent seams when zoomed
            const overlap = 1;

            if (cellTileset) {
                ctx.imageSmoothingEnabled = false;
                drawTileWithEffects(ctx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize + overlap, cell.rotation || 0, cell.flipped || false);
            }

            // Draw collision overlay if debug enabled
            if (showCollision) {
                const tilesetIdx = cell.tilesetIndex || 0;
                const key = tilesetIdx + ':' + cell.x + ',' + cell.y;
                const mask = collisionMasks[key];

                if (mask) {
                    const pixelSize = tileSize / gridSize;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    for (let my = 0; my < gridSize; my++) {
                        for (let mx = 0; mx < gridSize; mx++) {
                            if (mask[my] && mask[my][mx]) {
                                ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                            }
                        }
                    }
                } else if (tileCollisions[key]) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(px, py, tileSize, tileSize);
                }
            }
        }

        function drawTileTrunk(cell, tx, ty, camX, camY, tileSize) {
            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
            const splitData = tileSplitLines[key];
            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];

            if (!cellTileset || splitData === undefined) return;

            const px = Math.floor(tx * tileSize - camX);
            const py = Math.floor(ty * tileSize - camY);
            const scale = tileSize / gridSize;
            // Overlap to prevent seams when zoomed
            const overlap = 1;

            ctx.imageSmoothingEnabled = false;

            // Handle rotation or flip
            const rot = cell.rotation || 0;
            if (rot !== 0 || cell.flipped) {
                // For rotated/flipped tiles, just draw full tile (rotation + split is complex)
                drawTileWithEffects(ctx, cellTileset, cell.x, cell.y, gridSize, px, py, tileSize + overlap, rot, cell.flipped || false);
                return;
            }

            // Draw trunk using clipping path for freeform line
            ctx.save();
            ctx.beginPath();

            // Create clip path for trunk (below the split line)
            const splitYArray = Array.isArray(splitData) ? splitData : new Array(gridSize).fill(splitData);

            // Start at bottom-left, go up the left edge to first split point
            ctx.moveTo(px - overlap, py + tileSize + overlap);
            ctx.lineTo(px - overlap, py + splitYArray[0] * scale);

            // Draw along the split line (left to right)
            for (let col = 0; col < gridSize; col++) {
                const splitY = splitYArray[col];
                ctx.lineTo(px + col * scale, py + splitY * scale);
                ctx.lineTo(px + (col + 1) * scale, py + splitY * scale);
            }

            // Go down right edge and close
            ctx.lineTo(px + tileSize + overlap, py + tileSize + overlap);
            ctx.closePath();
            ctx.clip();

            // Draw the full tile, clipped to trunk region
            ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
            ctx.restore();

            // Draw collision overlay if debug enabled
            if (showCollision) {
                const mask = collisionMasks[key];
                if (mask) {
                    const pixelSize = tileSize / gridSize;
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    for (let my = 0; my < gridSize; my++) {
                        for (let mx = 0; mx < gridSize; mx++) {
                            if (mask[my] && mask[my][mx]) {
                                ctx.fillRect(px + mx * pixelSize, py + my * pixelSize, pixelSize, pixelSize);
                            }
                        }
                    }
                } else if (tileCollisions[key]) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(px, py, tileSize, tileSize);
                }
            }
        }

        function drawCanopyOverlay(camX, camY, tileSize) {
            // Draw canopy portions (above split line) for all split tiles
            for (let li = 1; li < layers.length; li++) {
                if (!layerVisibility[li]) continue;
                const layer = layers[li];
                if (!layer) continue;

                for (let y = 0; y < mapRows; y++) {
                    if (!layer[y]) continue;
                    for (let x = 0; x < mapCols; x++) {
                        const cell = layer[y][x];
                        if (!cell) continue;

                        const px = Math.floor(x * tileSize - camX);
                        const py = Math.floor(y * tileSize - camY);
                        const overlap = 1;
                        const scale = tileSize / gridSize;

                        // Skip off-screen
                        if (px < -tileSize || px > canvas.width / cameraZoom || py < -tileSize || py > canvas.height / cameraZoom) continue;

                        if (cell.type === 'tile') {
                            const key = (cell.tilesetIndex || 0) + ':' + cell.x + ',' + cell.y;
                            const splitData = tileSplitLines[key];
                            if (splitData === undefined || splitData === null) continue;

                            const cellTileset = tilesetImages[cell.tilesetIndex || 0] || tilesetImages[0];
                            if (!cellTileset) continue;

                            ctx.imageSmoothingEnabled = false;

                            // Handle rotation
                            const rot = cell.rotation || 0;
                            if (rot !== 0) continue; // Skip rotated tiles (already drawn full in trunk pass)

                            // Draw canopy using clipping path for freeform line
                            ctx.save();
                            ctx.beginPath();

                            // Create clip path for canopy (above the split line)
                            const splitYArray = Array.isArray(splitData) ? splitData : new Array(gridSize).fill(splitData);

                            // Start at top-left, go along top edge
                            ctx.moveTo(px - overlap, py - overlap);
                            ctx.lineTo(px + tileSize + overlap, py - overlap);

                            // Go down right edge to last split point
                            ctx.lineTo(px + tileSize + overlap, py + splitYArray[gridSize - 1] * scale);

                            // Draw along the split line (right to left)
                            for (let col = gridSize - 1; col >= 0; col--) {
                                const splitY = splitYArray[col];
                                ctx.lineTo(px + (col + 1) * scale, py + splitY * scale);
                                ctx.lineTo(px + col * scale, py + splitY * scale);
                            }

                            // Go up left edge and close
                            ctx.lineTo(px - overlap, py - overlap);
                            ctx.closePath();
                            ctx.clip();

                            // Draw the full tile, clipped to canopy region
                            ctx.drawImage(cellTileset, cell.x, cell.y, gridSize, gridSize, px, py, tileSize + overlap, tileSize + overlap);
                            ctx.restore();

                        } else if (cell.type === 'animTile') {
                            // Animated tile canopy
                            const propData = animatedPropsData[cell.propIndex];
                            const propImg = animPropImages[cell.propIndex];
                            if (!propData || !propImg || !propImg.complete) continue;
                            if (propData.splitLine === null || propData.splitLine === undefined) continue;
                            if (!propData.frames || propData.frames.length === 0) continue;

                            // Get current animation frame
                            const originX = x - (cell.offsetX || 0);
                            const originY = y - (cell.offsetY || 0);
                            const key = originX + ',' + originY + ',' + li;
                            const timer = animPropFrameTimers[key] || { frame: 0 };
                            const frameIdx = timer.frame % propData.frames.length;
                            const frame = propData.frames[frameIdx];

                            const offsetX = cell.offsetX || 0;
                            const offsetY = cell.offsetY || 0;

                            // Get split Y for this specific tile within the prop
                            const tileKey = offsetX + ',' + offsetY;
                            let splitY = null;

                            if (typeof propData.splitLine === 'object' && !Array.isArray(propData.splitLine)) {
                                // New format: object with "tileX,tileY" -> splitY
                                splitY = propData.splitLine[tileKey];
                            } else if (typeof propData.splitLine === 'number') {
                                // Old format: single number (only applies to tile 0,0)
                                if (offsetX === 0 && offsetY === 0) splitY = propData.splitLine;
                            }

                            // If no split for this tile, skip canopy
                            if (splitY === null || splitY === undefined) continue;

                            // splitY is already local to this tile (0 to gridSize)
                            const localSplitY = splitY;

                            // Only draw canopy if split is within this tile
                            if (localSplitY > 0 && localSplitY < gridSize) {
                                const srcX = frame.x + offsetX * gridSize;
                                const srcY = frame.y + offsetY * gridSize;
                                const srcH = localSplitY;
                                const destH = srcH * scale;

                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(propImg, srcX, srcY, gridSize, srcH, px - overlap, py - overlap, tileSize + overlap * 2, destH + overlap * 2);
                            } else if (localSplitY >= gridSize) {
                                // Full tile is canopy (split at bottom)
                                const srcX = frame.x + offsetX * gridSize;
                                const srcY = frame.y + offsetY * gridSize;

                                ctx.imageSmoothingEnabled = false;
                                ctx.drawImage(propImg, srcX, srcY, gridSize, gridSize, px - overlap, py - overlap, tileSize + overlap * 2, tileSize + overlap * 2);
                            }
                        }
                    }
                }
            }
        }

        function drawPlayer() {
            const camX = Math.round(camera.x);
            const camY = Math.round(camera.y);
            const sx = Math.round(player.x - camX);
            const sy = Math.round(player.y - camY);

            // Player sprite: 1024x512, 16 cols x 8 rows = 64x64 each
            const frameWidth = 64;
            const frameHeight = 64;
            // playerScale is now a global variable controlled by slider

            // Idle frames (Row 0)
            const idleFrames = {
                down: [0, 1, 2],
                up: [3, 4, 5],
                right: [6, 7, 8],
                left: [6, 7, 8]
            };

            // Walk frames
            const walkFrames = {
                down: { row: 0, cols: [9, 10, 11, 12] },
                up: { row: 0, cols: [13, 14, 15] },
                right: { row: 1, cols: [1, 2, 3, 4] },
                left: { row: 1, cols: [1, 2, 3, 4] }
            };

            let row = 0;
            let col = 0;
            let flipX = false;

            if (player.attacking) {
                row = walkFrames[player.direction].row;
                col = walkFrames[player.direction].cols[Math.min(player.frame, walkFrames[player.direction].cols.length - 1)];
                if (player.direction === 'left') flipX = true;
            } else if (player.moving) {
                const walk = walkFrames[player.direction];
                row = walk.row;
                col = walk.cols[player.frame % walk.cols.length];
                if (player.direction === 'left') flipX = true;
            } else {
                row = 0;
                col = idleFrames[player.direction][player.frame % idleFrames[player.direction].length];
                if (player.direction === 'left') flipX = true;
            }

            const drawW = Math.round(64 * playerScale);
            const drawH = Math.round(64 * playerScale);

            // Center sprite on collision box
            // Collision box should cover body from feet to near head
            // Sprite is drawn so collision box aligns with the character body
            const spriteX = sx + player.width / 2 - drawW / 2;
            const spriteY = sy - 15; // shift sprite up so collision box covers body properly

            // Simple ellipse shadow under hero
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(
                spriteX + drawW / 2,
                spriteY + drawH - shadowYOffset,
                drawW * (shadowWidth / 100),
                drawW * (shadowHeight / 100),
                0, 0, Math.PI * 2
            );
            ctx.fill();

            if (playerImg.complete) {
                if (flipX) {
                    ctx.save();
                    ctx.translate(spriteX + drawW, spriteY);
                    ctx.scale(-1, 1);
                    ctx.drawImage(playerImg, col * frameWidth, row * frameHeight, frameWidth, frameHeight, 0, 0, drawW, drawH);
                    ctx.restore();
                } else {
                    ctx.drawImage(playerImg, col * frameWidth, row * frameHeight, frameWidth, frameHeight, spriteX, spriteY, drawW, drawH);
                }
            } else {
                ctx.fillStyle = '#4a7';
                ctx.fillRect(sx, sy, player.width, player.height);
            }

            // Attack effect
            if (player.attacking) {
                ctx.save();
                ctx.strokeStyle = '#adf';
                ctx.lineWidth = 3;
                ctx.globalAlpha = player.attackTimer / 18;
                ctx.beginPath();
                const cx = sx + player.width / 2;
                const cy = sy + player.height / 2;
                switch (player.direction) {
                    case 'up': ctx.arc(cx, cy - 30, 30, Math.PI * 1.2, Math.PI * 1.8); break;
                    case 'down': ctx.arc(cx, cy + 30, 30, Math.PI * 0.2, Math.PI * 0.8); break;
                    case 'left': ctx.arc(cx - 30, cy, 30, Math.PI * 0.7, Math.PI * 1.3); break;
                    case 'right': ctx.arc(cx + 30, cy, 30, -Math.PI * 0.3, Math.PI * 0.3); break;
                }
                ctx.stroke();
                ctx.restore();
            }

            // DEBUG: Draw collision box (shows actual foot hitbox used for collision)
            if (showCollision) {
                // Always show the small foot hitbox (bottom 1/3)
                const collisionHeight = player.height / 3;
                const collisionOffsetY = player.height * 2/3;

                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 2;
                ctx.strokeRect(sx, sy + collisionOffsetY, player.width, collisionHeight);

                // Draw center point of collision box
                ctx.fillStyle = '#0f0';
                ctx.beginPath();
                ctx.arc(sx + player.width / 2, sy + collisionOffsetY + collisionHeight / 2, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw NPC with correct animation based on direction
        function drawNPC(npcIdx, camX, camY, tileSize) {
            const placed = placedNpcsData[npcIdx];
            const state = npcRuntimeState[npcIdx];
            const npc = npcsData[placed.npcIndex];
            const img = npcImages[placed.npcIndex];

            if (!placed || !state || !npc || !img || !img.complete) return;

            const sx = Math.round(state.x * TILE_SCALE - camX);
            const sy = Math.round(state.y * TILE_SCALE - camY);

            // Get correct animation based on direction
            const anims = npc.animations || {};
            const dirMap = {
                'down': 'walkDown',
                'up': 'walkUp',
                'left': 'walkLeft',
                'right': 'walkRight'
            };
            const animKey = state.moving ? dirMap[state.direction] : 'idle';
            let anim = anims[animKey];

            // Fallback to any available animation
            if (!anim || anim.length === 0) {
                anim = anims.walkDown || anims.idle || Object.values(anims).find(a => a && a.length > 0);
            }
            if (!anim || anim.length === 0) return;

            // Get current frame
            const frameIdx = state.frame % anim.length;
            const frame = anim[frameIdx];
            if (!frame) return;

            const drawW = tileSize;
            const drawH = tileSize;

            // Draw shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(
                sx + drawW / 2,
                sy + drawH - 4,
                drawW * 0.35,
                drawW * 0.12,
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // Handle horizontal flip for left direction
            const flipX = state.direction === 'left' && !anims.walkLeft?.length;

            if (flipX) {
                ctx.save();
                ctx.translate(sx + drawW, sy);
                ctx.scale(-1, 1);
                ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, 0, 0, drawW, drawH);
                ctx.restore();
            } else {
                ctx.drawImage(img, frame.x, frame.y, frame.w, frame.h, sx, sy, drawW, drawH);
            }
        }

        function gameLoop() {
            updateDayCycle();
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Game loop is started when all tilesets load (see tileset loading code above)
    <\/script>
</body>
</html>
            `);
            testWindow.document.close();
        }
    </script>
</body>
</html>
